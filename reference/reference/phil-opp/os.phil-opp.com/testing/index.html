<!doctype html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="This post explores unit and integration testing in no_std executables. We will use Rust’s support for custom test frameworks to execute test functions…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../js/edition-2/main.js"></script>

    <title>Testing | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="../index.html" title="All Posts">« All Posts</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="">
        <h2>Table of Contents</h2>
    <ol>
        <li>
            <a href="index.html#requirements">Requirements</a>
            
        </li><li>
            <a href="index.html#testing-in-rust">Testing in Rust</a>
            <ol>
                <li>
                    <a href="index.html#custom-test-frameworks">Custom Test Frameworks</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#exiting-qemu">Exiting QEMU</a>
            <ol>
                <li>
                    <a href="index.html#i-o-ports">I/O Ports</a>
                </li><li>
                    <a href="index.html#using-the-exit-device">Using the Exit Device</a>
                </li><li>
                    <a href="index.html#success-exit-code">Success Exit Code</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#printing-to-the-console">Printing to the Console</a>
            <ol>
                <li>
                    <a href="index.html#serial-port">Serial Port</a>
                </li><li>
                    <a href="index.html#qemu-arguments">QEMU Arguments</a>
                </li><li>
                    <a href="index.html#print-an-error-message-on-panic">Print an Error Message on Panic</a>
                </li><li>
                    <a href="index.html#hiding-qemu">Hiding QEMU</a>
                </li><li>
                    <a href="index.html#timeouts">Timeouts</a>
                </li><li>
                    <a href="index.html#insert-printing-automatically">Insert Printing Automatically</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#testing-the-vga-buffer">Testing the VGA Buffer</a>
            
        </li><li>
            <a href="index.html#integration-tests">Integration Tests</a>
            <ol>
                <li>
                    <a href="index.html#create-a-library">Create a Library</a>
                </li><li>
                    <a href="index.html#completing-the-integration-test">Completing the Integration Test</a>
                </li><li>
                    <a href="index.html#future-tests">Future Tests</a>
                </li><li>
                    <a href="index.html#tests-that-should-panic">Tests that Should Panic</a>
                </li><li>
                    <a href="index.html#no-harness-tests">No Harness Tests</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#summary">Summary</a>
            
        </li><li>
            <a href="index.html#what-s-next">What’s next?</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">Comments</a></li>
    </ol>
</aside>

            <main>
    <div class="">
    <h1>Testing</h1>
    <time datetime="2019-04-27" class="post-date">
        Apr 27, 2019
        
    </time>
    </div>

    

    <div class="">
    <p>This post explores unit and integration testing in <code>no_std</code> executables. We will use Rust’s support for custom test frameworks to execute test functions inside our kernel. To report the results out of QEMU, we will use different features of QEMU and the <code>bootimage</code> tool.</p>
<span id="continue-reading"></span>
<p>This blog is openly developed on <a href="https://github.com/phil-opp/blog_os">GitHub</a>. If you have any problems or questions, please open an issue there. You can also leave comments <a href="index.html#comments">at the bottom</a>. The complete source code for this post can be found in the <a href="https://github.com/phil-opp/blog_os/tree/post-04"><code>post-04</code></a> branch.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>Table of Contents</b></summary>
        <ul>
            <li>
                <a href="index.html#requirements">Requirements</a>
                
            </li><li>
                <a href="index.html#testing-in-rust">Testing in Rust</a>
                <ul>
                    <li>
                        <a href="index.html#custom-test-frameworks">Custom Test Frameworks</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#exiting-qemu">Exiting QEMU</a>
                <ul>
                    <li>
                        <a href="index.html#i-o-ports">I/O Ports</a>
                    </li><li>
                        <a href="index.html#using-the-exit-device">Using the Exit Device</a>
                    </li><li>
                        <a href="index.html#success-exit-code">Success Exit Code</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#printing-to-the-console">Printing to the Console</a>
                <ul>
                    <li>
                        <a href="index.html#serial-port">Serial Port</a>
                    </li><li>
                        <a href="index.html#qemu-arguments">QEMU Arguments</a>
                    </li><li>
                        <a href="index.html#print-an-error-message-on-panic">Print an Error Message on Panic</a>
                    </li><li>
                        <a href="index.html#hiding-qemu">Hiding QEMU</a>
                    </li><li>
                        <a href="index.html#timeouts">Timeouts</a>
                    </li><li>
                        <a href="index.html#insert-printing-automatically">Insert Printing Automatically</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#testing-the-vga-buffer">Testing the VGA Buffer</a>
                
            </li><li>
                <a href="index.html#integration-tests">Integration Tests</a>
                <ul>
                    <li>
                        <a href="index.html#create-a-library">Create a Library</a>
                    </li><li>
                        <a href="index.html#completing-the-integration-test">Completing the Integration Test</a>
                    </li><li>
                        <a href="index.html#future-tests">Future Tests</a>
                    </li><li>
                        <a href="index.html#tests-that-should-panic">Tests that Should Panic</a>
                    </li><li>
                        <a href="index.html#no-harness-tests">No Harness Tests</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#summary">Summary</a>
                
            </li><li>
                <a href="index.html#what-s-next">What’s next?</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">Comments</a></li>
        </ul>
    </details>

<h2 id="requirements"><a class="zola-anchor" href="index.html#requirements" aria-label="Anchor link for: requirements">🔗</a>Requirements</h2>
<p>This post replaces the (now deprecated) <a href="../unit-testing/index.html"><em>Unit Testing</em></a> and <a href="../integration-tests/index.html"><em>Integration Tests</em></a> posts. It assumes that you have followed the <a href="../minimal-rust-kernel/index.html"><em>A Minimal Rust Kernel</em></a> post after 2019-04-27. Mainly, it requires that you have a <code>.cargo/config.toml</code> file that <a href="../minimal-rust-kernel/index.html#set-a-default-target">sets a default target</a> and <a href="../minimal-rust-kernel/index.html#using-cargo-run">defines a runner executable</a>.</p>
<h2 id="testing-in-rust"><a class="zola-anchor" href="index.html#testing-in-rust" aria-label="Anchor link for: testing-in-rust">🔗</a>Testing in Rust</h2>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">built-in test framework</a> that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the <code>#[test]</code> attribute to the function header. Then <code>cargo test</code> will automatically find and execute all test functions of your crate.</p>
<p>Unfortunately, it’s a bit more complicated for <code>no_std</code> applications such as our kernel. The problem is that Rust’s test framework implicitly uses the built-in <a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a> library, which depends on the standard library. This means that we can’t use the default test framework for our <code>#[no_std]</code> kernel.</p>
<p>We can see this when we try to run <code>cargo test</code> in our project:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>   Compiling blog_os v0.1.0 (/…/blog_os)
</span><span>error[E0463]: can&#39;t find crate for `test`
</span></code></pre>
<p>Since the <code>test</code> crate depends on the standard library, it is not available for our bare metal target. While porting the <code>test</code> crate to a <code>#[no_std]</code> context <a href="https://github.com/japaric/utest">is possible</a>, it is highly unstable and requires some hacks, such as redefining the <code>panic</code> macro.</p>
<h3 id="custom-test-frameworks"><a class="zola-anchor" href="index.html#custom-test-frameworks" aria-label="Anchor link for: custom-test-frameworks">🔗</a>Custom Test Frameworks</h3>
<p>Fortunately, Rust supports replacing the default test framework through the unstable <a href="https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html"><code>custom_test_frameworks</code></a> feature. This feature requires no external libraries and thus also works in <code>#[no_std]</code> environments. It works by collecting all functions annotated with a <code>#[test_case]</code> attribute and then invoking a user-specified runner function with the list of tests as an argument. Thus, it gives the implementation maximal control over the test process.</p>
<p>The disadvantage compared to the default test framework is that many advanced features, such as <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"><code>should_panic</code> tests</a>, are not available. Instead, it is up to the implementation to provide such features itself if needed. This is ideal for us since we have a very special execution environment where the default implementations of such advanced features probably wouldn’t work anyway. For example, the <code>#[should_panic]</code> attribute relies on stack unwinding to catch the panics, which we disabled for our kernel.</p>
<p>To implement a custom test framework for our kernel, we add the following to our <code>main.rs</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Running </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;"> tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>}
</span></code></pre>
<p>Our runner just prints a short debug message and then calls each test function in the list. The argument type <code>&amp;[&amp;dyn Fn()]</code> is a <a href="https://doc.rust-lang.org/std/primitive.slice.html"><em>slice</em></a> of <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/trait-objects.html"><em>trait object</em></a> references of the <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><em>Fn()</em></a> trait. It is basically a list of references to types that can be called like a function. Since the function is useless for non-test runs, we use the <code>#[cfg(test)]</code> attribute to include it only for tests.</p>
<p>When we run <code>cargo test</code> now, we see that it now succeeds (if it doesn’t, see the note below). However, we still see our “Hello World” instead of the message from our <code>test_runner</code>. The reason is that our <code>_start</code> function is still used as entry point. The custom test frameworks feature generates a <code>main</code> function that calls <code>test_runner</code>, but this function is ignored because we use the <code>#[no_main]</code> attribute and provide our own entry point.</p>
<div class = "warning">
<p><strong>Note:</strong> There is currently a bug in cargo that leads to “duplicate lang item” errors on <code>cargo test</code> in some cases. It occurs when you have set <code>panic = &quot;abort&quot;</code> for a profile in your <code>Cargo.toml</code>. Try removing it, then <code>cargo test</code> should work. See the <a href="https://github.com/rust-lang/cargo/issues/7359">cargo issue</a> for more information on this.</p>
</div>
<p>To fix this, we first need to change the name of the generated function to something different than <code>main</code> through the <code>reexport_test_harness_main</code> attribute. Then we can call the renamed function from our <code>_start</code> function:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>We set the name of the test framework entry function to <code>test_main</code> and call it from our <code>_start</code> entry point. We use <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">conditional compilation</a> to add the call to <code>test_main</code> only in test contexts because the function is not generated on a normal run.</p>
<p>When we now execute <code>cargo test</code>, we see the “Running 0 tests” message from our <code>test_runner</code> on the screen. We are now ready to create our first test function:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>When we run <code>cargo test</code> now, we see the following output:</p>
<p><img src="qemu-test-runner-output.png" alt="QEMU printing “Hello World!”, “Running 1 tests”, and “trivial assertion… [ok]”" /></p>
<p>The <code>tests</code> slice passed to our <code>test_runner</code> function now contains a reference to the <code>trivial_assertion</code> function. From the <code>trivial assertion... [ok]</code> output on the screen, we see that the test was called and that it succeeded.</p>
<p>After executing the tests, our <code>test_runner</code> returns to the <code>test_main</code> function, which in turn returns to our <code>_start</code> entry point function. At the end of <code>_start</code>, we enter an endless loop because the entry point function is not allowed to return. This is a problem, because we want <code>cargo test</code> to exit after running all tests.</p>
<h2 id="exiting-qemu"><a class="zola-anchor" href="index.html#exiting-qemu" aria-label="Anchor link for: exiting-qemu">🔗</a>Exiting QEMU</h2>
<p>Right now, we have an endless loop at the end of our <code>_start</code> function and need to close QEMU manually on each execution of <code>cargo test</code>. This is unfortunate because we also want to run <code>cargo test</code> in scripts without user interaction. The clean solution to this would be to implement a proper way to shutdown our OS. Unfortunately, this is relatively complex because it requires implementing support for either the <a href="https://wiki.osdev.org/APM">APM</a> or <a href="https://wiki.osdev.org/ACPI">ACPI</a> power management standard.</p>
<p>Luckily, there is an escape hatch: QEMU supports a special <code>isa-debug-exit</code> device, which provides an easy way to exit QEMU from the guest system. To enable it, we need to pass a <code>-device</code> argument to QEMU. We can do so by adding a <code>package.metadata.bootimage.test-args</code> configuration key in our <code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [</span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>]
</span></code></pre>
<p>The <code>bootimage runner</code> appends the <code>test-args</code> to the default QEMU command for all test executables. For a normal <code>cargo run</code>, the arguments are ignored.</p>
<p>Together with the device name (<code>isa-debug-exit</code>), we pass the two parameters <code>iobase</code> and <code>iosize</code> that specify the <em>I/O port</em> through which the device can be reached from our kernel.</p>
<h3 id="i-o-ports"><a class="zola-anchor" href="index.html#i-o-ports" aria-label="Anchor link for: i-o-ports">🔗</a>I/O Ports</h3>
<p>There are two different approaches for communicating between the CPU and peripheral hardware on x86, <strong>memory-mapped I/O</strong> and <strong>port-mapped I/O</strong>. We already used memory-mapped I/O for accessing the <a href="../vga-text-mode/index.html">VGA text buffer</a> through the memory address <code>0xb8000</code>. This address is not mapped to RAM but to some memory on the VGA device.</p>
<p>In contrast, port-mapped I/O uses a separate I/O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I/O port, there are special CPU instructions called <code>in</code> and <code>out</code>, which take a port number and a data byte (there are also variations of these commands that allow sending a <code>u16</code> or <code>u32</code>).</p>
<p>The <code>isa-debug-exit</code> device uses port-mapped I/O. The <code>iobase</code> parameter specifies on which port address the device should live (<code>0xf4</code> is a <a href="https://wiki.osdev.org/I/O_Ports#The_list">generally unused</a> port on the x86’s IO bus) and the <code>iosize</code> specifies the port size (<code>0x04</code> means four bytes).</p>
<h3 id="using-the-exit-device"><a class="zola-anchor" href="index.html#using-the-exit-device" aria-label="Anchor link for: using-the-exit-device">🔗</a>Using the Exit Device</h3>
<p>The functionality of the <code>isa-debug-exit</code> device is very simple. When a <code>value</code> is written to the I/O port specified by <code>iobase</code>, it causes QEMU to exit with <a href="https://en.wikipedia.org/wiki/Exit_status">exit status</a> <code>(value &lt;&lt; 1) | 1</code>. So when we write <code>0</code> to the port, QEMU will exit with exit status <code>(0 &lt;&lt; 1) | 1 = 1</code>, and when we write <code>1</code> to the port, it will exit with exit status <code>(1 &lt;&lt; 1) | 1 = 3</code>.</p>
<p>Instead of manually invoking the <code>in</code> and <code>out</code> assembly instructions, we use the abstractions provided by the <a href="https://docs.rs/x86_64/0.14.2/x86_64/"><code>x86_64</code></a> crate. To add a dependency on that crate, we add it to the <code>dependencies</code> section in our <code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">x86_64 </span><span>= </span><span style="color:#d69d85;">&quot;0.14.2&quot;
</span></code></pre>
<p>Now we can use the <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a> type provided by the crate to create an <code>exit_qemu</code> function:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style="color:#569cd6;">pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style="color:#b5cea8;">0x10</span><span>,
</span><span>    Failed = </span><span style="color:#b5cea8;">0x11</span><span>,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style="color:#569cd6;">as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>The function creates a new <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a> at <code>0xf4</code>, which is the <code>iobase</code> of the <code>isa-debug-exit</code> device. Then it writes the passed exit code to the port. We use <code>u32</code> because we specified the <code>iosize</code> of the <code>isa-debug-exit</code> device as 4 bytes. Both operations are unsafe because writing to an I/O port can generally result in arbitrary behavior.</p>
<p>To specify the exit status, we create a <code>QemuExitCode</code> enum. The idea is to exit with the success exit code if all tests succeeded and with the failure exit code otherwise. The enum is marked as <code>#[repr(u32)]</code> to represent each variant by a <code>u32</code> integer. We use the exit code <code>0x10</code> for success and <code>0x11</code> for failure. The actual exit codes don’t matter much, as long as they don’t clash with the default exit codes of QEMU. For example, using exit code <code>0</code> for success is not a good idea because it becomes <code>(0 &lt;&lt; 1) | 1 = 1</code> after the transformation, which is the default exit code when QEMU fails to run. So we could not differentiate a QEMU error from a successful test run.</p>
<p>We can now update our <code>test_runner</code> to exit QEMU after all tests have run:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Running </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;"> tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>    </span><span style="color:#608b4e;">/// new
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>When we run <code>cargo test</code> now, we see that QEMU immediately closes after executing the tests. The problem is that <code>cargo test</code> interprets the test as failed even though we passed our <code>Success</code> exit code:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-5804fc7d2dd4c9be
</span><span>Building bootloader
</span><span>   Compiling bootloader v0.5.3 (/home/philipp/Documents/bootloader)
</span><span>    Finished release [optimized + debuginfo] target(s) in 1.07s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,
</span><span>    iosize=0x04`
</span><span>error: test failed, to rerun pass &#39;--bin blog_os&#39;
</span></code></pre>
<p>The problem is that <code>cargo test</code> considers all error codes other than <code>0</code> as failure.</p>
<h3 id="success-exit-code"><a class="zola-anchor" href="index.html#success-exit-code" aria-label="Anchor link for: success-exit-code">🔗</a>Success Exit Code</h3>
<p>To work around this, <code>bootimage</code> provides a <code>test-success-exit-code</code> configuration key that maps a specified exit code to the exit code <code>0</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [</span><span style="color:#ff3333;">…</span><span>]
</span><span style="color:#569cd6;">test-success-exit-code </span><span>= </span><span style="color:#b5cea8;">33         </span><span style="color:#608b4e;"># (0x10 &lt;&lt; 1) | 1
</span></code></pre>
<p>With this configuration, <code>bootimage</code> maps our success exit code to exit code 0, so that <code>cargo test</code> correctly recognizes the success case and does not count the test as failed.</p>
<p>Our test runner now automatically closes QEMU and correctly reports the test results. We still see the QEMU window open for a very short time, but it does not suffice to read the results. It would be nice if we could print the test results to the console instead, so we can still see them after QEMU exits.</p>
<h2 id="printing-to-the-console"><a class="zola-anchor" href="index.html#printing-to-the-console" aria-label="Anchor link for: printing-to-the-console">🔗</a>Printing to the Console</h2>
<p>To see the test output on the console, we need to send the data from our kernel to the host system somehow. There are various ways to achieve this, for example, by sending the data over a TCP network interface. However, setting up a networking stack is quite a complex task, so we will choose a simpler solution instead.</p>
<h3 id="serial-port"><a class="zola-anchor" href="index.html#serial-port" aria-label="Anchor link for: serial-port">🔗</a>Serial Port</h3>
<p>A simple way to send the data is to use the <a href="https://en.wikipedia.org/wiki/Serial_port">serial port</a>, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host’s standard output or a file.</p>
<p>The chips implementing a serial interface are called <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UARTs</a>. There are <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#UART_models">lots of UART models</a> on x86, but fortunately the only differences between them are some advanced features we don’t need. The common UARTs today are all compatible with the <a href="https://en.wikipedia.org/wiki/16550_UART">16550 UART</a>, so we will use that model for our testing framework.</p>
<p>We will use the <a href="https://docs.rs/uart_16550"><code>uart_16550</code></a> crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our <code>Cargo.toml</code> and <code>main.rs</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">uart_16550 </span><span>= </span><span style="color:#d69d85;">&quot;0.2.0&quot;
</span></code></pre>
<p>The <code>uart_16550</code> crate contains a <code>SerialPort</code> struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that, we create a new <code>serial</code> module with the following content:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">mod </span><span>serial;
</span></code></pre>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/serial.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>uart_16550::SerialPort;
</span><span style="color:#569cd6;">use </span><span>spin::Mutex;
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">pub static ref </span><span style="color:#b4cea8;">SERIAL1</span><span>: Mutex&lt;SerialPort&gt; = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> serial_port = </span><span style="color:#569cd6;">unsafe </span><span>{ SerialPort::new(</span><span style="color:#b5cea8;">0x3F8</span><span>) };
</span><span>        serial_port.init();
</span><span>        Mutex::new(serial_port)
</span><span>    };
</span><span>}
</span></code></pre>
<p>Like with the <a href="../vga-text-mode/index.html#lazy-statics">VGA text buffer</a>, we use <code>lazy_static</code> and a spinlock to create a <code>static</code> writer instance. By using <code>lazy_static</code> we can ensure that the <code>init</code> method is called exactly once on its first use.</p>
<p>Like the <code>isa-debug-exit</code> device, the UART is programmed using port I/O. Since the UART is more complex, it uses multiple I/O ports for programming different device registers. The unsafe <code>SerialPort::new</code> function expects the address of the first I/O port of the UART as an argument, from which it can calculate the addresses of all needed ports. We’re passing the port address <code>0x3F8</code>, which is the standard port number for the first serial interface.</p>
<p>To make the serial port easily usable, we add <code>serial_print!</code> and <code>serial_println!</code> macros:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/serial.rs
</span><span>
</span><span>#[doc(hidden)]
</span><span style="color:#569cd6;">pub fn </span><span>_print(args: ::core::fmt::Arguments) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#b4cea8;">SERIAL1</span><span>.lock().write_fmt(args).expect(</span><span style="color:#d69d85;">&quot;Printing to serial failed&quot;</span><span>);
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Prints to the host through the serial interface.
</span><span>#[macro_export]
</span><span>macro_rules! serial_print {
</span><span>    (</span><span style="color:#569cd6;">$</span><span>($arg:</span><span style="color:#569cd6;">tt</span><span>)</span><span style="color:#569cd6;">*</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>{
</span><span>        $crate::serial::_print(format_args!(</span><span style="color:#569cd6;">$</span><span>($arg)*));
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Prints to the host through the serial interface, appending a newline.
</span><span>#[macro_export]
</span><span>macro_rules! serial_println {
</span><span>    () </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(</span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>));
</span><span>    ($fmt:</span><span style="color:#569cd6;">expr</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(concat!($fmt, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>)));
</span><span>    ($fmt:</span><span style="color:#569cd6;">expr</span><span>, </span><span style="color:#569cd6;">$</span><span>($arg:</span><span style="color:#569cd6;">tt</span><span>)</span><span style="color:#569cd6;">*</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(
</span><span>        concat!($fmt, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>), </span><span style="color:#569cd6;">$</span><span>($arg)*));
</span><span>}
</span></code></pre>
<p>The implementation is very similar to the implementation of our <code>print</code> and <code>println</code> macros. Since the <code>SerialPort</code> type already implements the <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html"><code>fmt::Write</code></a> trait, we don’t need to provide our own implementation.</p>
<p>Now we can print to the serial interface instead of the VGA text buffer in our test code:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    […]
</span><span>}
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>Note that the <code>serial_println</code> macro lives directly under the root namespace because we used the <code>#[macro_export]</code> attribute, so importing it through <code>use crate::serial::serial_println</code> will not work.</p>
<h3 id="qemu-arguments"><a class="zola-anchor" href="index.html#qemu-arguments" aria-label="Anchor link for: qemu-arguments">🔗</a>QEMU Arguments</h3>
<p>To see the serial output from QEMU, we need to use the <code>-serial</code> argument to redirect the output to stdout:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [
</span><span>    </span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>, </span><span style="color:#d69d85;">&quot;-serial&quot;</span><span>, </span><span style="color:#d69d85;">&quot;stdio&quot;
</span><span>]
</span></code></pre>
<p>When we run <code>cargo test</code> now, we see the test output directly in the console:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [ok]
</span></code></pre>
<p>However, when a test fails, we still see the output inside QEMU because our panic handler still uses <code>println</code>. To simulate this, we can change the assertion in our <code>trivial_assertion</code> test to <code>assert_eq!(0, 1)</code>:</p>
<p><img src="qemu-failed-test.png" alt="QEMU printing “Hello World!” and “panicked at ‘assertion failed: (left == right) left: 0, right: 1’, src/main.rs:55:5" /></p>
<p>We see that the panic message is still printed to the VGA buffer, while the other test output is printed to the serial port. The panic message is quite useful, so it would be useful to see it in the console too.</p>
<h3 id="print-an-error-message-on-panic"><a class="zola-anchor" href="index.html#print-an-error-message-on-panic" aria-label="Anchor link for: print-an-error-message-on-panic">🔗</a>Print an Error Message on Panic</h3>
<p>To exit QEMU with an error message on a panic, we can use <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">conditional compilation</a> to use a different panic handler in testing mode:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#608b4e;">// our existing panic handler
</span><span>#[cfg(not(test))] </span><span style="color:#608b4e;">// new attribute
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// our panic handler in test mode
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[failed]</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Error: {}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>For our test panic handler, we use <code>serial_println</code> instead of <code>println</code> and then exit QEMU with a failure exit code. Note that we still need an endless <code>loop</code> after the <code>exit_qemu</code> call because the compiler does not know that the <code>isa-debug-exit</code> device causes a program exit.</p>
<p>Now QEMU also exits for failed tests and prints a useful error message on the console:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [failed]
</span><span>
</span><span>Error: panicked at &#39;assertion failed: `(left == right)`
</span><span>  left: `0`,
</span><span> right: `1`&#39;, src/main.rs:65:5
</span></code></pre>
<p>Since we see all test output on the console now, we no longer need the QEMU window that pops up for a short time. So we can hide it completely.</p>
<h3 id="hiding-qemu"><a class="zola-anchor" href="index.html#hiding-qemu" aria-label="Anchor link for: hiding-qemu">🔗</a>Hiding QEMU</h3>
<p>Since we report out the complete test results using the <code>isa-debug-exit</code> device and the serial port, we don’t need the QEMU window anymore. We can hide it by passing the <code>-display none</code> argument to QEMU:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [
</span><span>    </span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>, </span><span style="color:#d69d85;">&quot;-serial&quot;</span><span>, </span><span style="color:#d69d85;">&quot;stdio&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;-display&quot;</span><span>, </span><span style="color:#d69d85;">&quot;none&quot;
</span><span>]
</span></code></pre>
<p>Now QEMU runs completely in the background and no window gets opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as CI services or <a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a> connections.</p>
<h3 id="timeouts"><a class="zola-anchor" href="index.html#timeouts" aria-label="Anchor link for: timeouts">🔗</a>Timeouts</h3>
<p>Since <code>cargo test</code> waits until the test runner exits, a test that never returns can block the test runner forever. That’s unfortunate, but not a big problem in practice since it’s usually easy to avoid endless loops. In our case, however, endless loops can occur in various situations:</p>
<ul>
<li>The bootloader fails to load our kernel, which causes the system to reboot endlessly.</li>
<li>The BIOS/UEFI firmware fails to load the bootloader, which causes the same endless rebooting.</li>
<li>The CPU enters a <code>loop {}</code> statement at the end of some of our functions, for example because the QEMU exit device doesn’t work properly.</li>
<li>The hardware causes a system reset, for example when a CPU exception is not caught (explained in a future post).</li>
</ul>
<p>Since endless loops can occur in so many situations, the <code>bootimage</code> tool sets a timeout of 5 minutes for each test executable by default. If the test does not finish within this time, it is marked as failed and a “Timed Out” error is printed to the console. This feature ensures that tests that are stuck in an endless loop don’t block <code>cargo test</code> forever.</p>
<p>You can try it yourself by adding a <code>loop {}</code> statement in the <code>trivial_assertion</code> test. When you run <code>cargo test</code>, you see that the test is marked as timed out after 5 minutes. The timeout duration is <a href="https://github.com/rust-osdev/bootimage#configuration">configurable</a> through a <code>test-timeout</code> key in the Cargo.toml:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-timeout </span><span>= </span><span style="color:#b5cea8;">300          </span><span style="color:#608b4e;"># (in seconds)
</span></code></pre>
<p>If you don’t want to wait 5 minutes for the <code>trivial_assertion</code> test to time out, you can temporarily decrease the above value.</p>
<h3 id="insert-printing-automatically"><a class="zola-anchor" href="index.html#insert-printing-automatically" aria-label="Anchor link for: insert-printing-automatically">🔗</a>Insert Printing Automatically</h3>
<p>Our <code>trivial_assertion</code> test currently needs to print its own status information using <code>serial_print!</code>/<code>serial_println!</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>Manually adding these print statements for every test we write is cumbersome, so let’s update our <code>test_runner</code> to print these messages automatically. To do that, we need to create a new <code>Testable</code> trait:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">pub trait </span><span>Testable {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; ();
</span><span>}
</span></code></pre>
<p>The trick now is to implement this trait for all types <code>T</code> that implement the <a href="https://doc.rust-lang.org/stable/core/ops/trait.Fn.html"><code>Fn()</code> trait</a>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">impl</span><span>&lt;T&gt; Testable </span><span style="color:#569cd6;">for </span><span>T
</span><span style="color:#569cd6;">where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        serial_print!(</span><span style="color:#d69d85;">&quot;{}...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>, core::any::type_name::&lt;T&gt;());
</span><span>        self();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>We implement the <code>run</code> function by first printing the function name using the <a href="https://doc.rust-lang.org/stable/core/any/fn.type_name.html"><code>any::type_name</code></a> function. This function is implemented directly in the compiler and returns a string description of every type. For functions, the type is their name, so this is exactly what we want in this case. The <code>\t</code> character is the <a href="https://en.wikipedia.org/wiki/Tab_key#Tab_characters">tab character</a>, which adds some alignment to the <code>[ok]</code> messages.</p>
<p>After printing the function name, we invoke the test function through <code>self()</code>. This only works because we require that <code>self</code> implements the <code>Fn()</code> trait. After the test function returns, we print <code>[ok]</code> to indicate that the function did not panic.</p>
<p>The last step is to update our <code>test_runner</code> to use the new <code>Testable</code> trait:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Testable]) { </span><span style="color:#608b4e;">// new
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test.run(); </span><span style="color:#608b4e;">// new
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>The only two changes are the type of the <code>tests</code> argument from <code>&amp;[&amp;dyn Fn()]</code> to <code>&amp;[&amp;dyn Testable]</code> and the fact that we now call <code>test.run()</code> instead of <code>test()</code>.</p>
<p>We can now remove the print statements from our <code>trivial_assertion</code> test since they’re now printed automatically:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span></code></pre>
<p>The <code>cargo test</code> output now looks like this:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>Running 1 tests
</span><span>blog_os::trivial_assertion...	[ok]
</span></code></pre>
<p>The function name now includes the full path to the function, which is useful when test functions in different modules have the same name. Otherwise, the output looks the same as before, but we no longer need to add print statements to our tests manually.</p>
<h2 id="testing-the-vga-buffer"><a class="zola-anchor" href="index.html#testing-the-vga-buffer" aria-label="Anchor link for: testing-the-vga-buffer">🔗</a>Testing the VGA Buffer</h2>
<p>Now that we have a working test framework, we can create a few tests for our VGA buffer implementation. First, we create a very simple test to verify that <code>println</code> works without panicking:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_simple() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;test_println_simple output&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>The test just prints something to the VGA buffer. If it finishes without panicking, it means that the <code>println</code> invocation did not panic either.</p>
<p>To ensure that no panic occurs even if many lines are printed and lines are shifted off the screen, we can create another test:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_many() {
</span><span>    </span><span style="color:#569cd6;">for _ in </span><span style="color:#b5cea8;">0</span><span style="color:#569cd6;">..</span><span style="color:#b5cea8;">200 </span><span>{
</span><span>        println!(</span><span style="color:#d69d85;">&quot;test_println_many output&quot;</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>We can also create a test function to verify that the printed lines really appear on the screen:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_output() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> s = </span><span style="color:#d69d85;">&quot;Some test string that fits on a single line&quot;</span><span>;
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, s);
</span><span>    </span><span style="color:#569cd6;">for </span><span>(i, c) </span><span style="color:#569cd6;">in</span><span> s.chars().enumerate() {
</span><span>        </span><span style="color:#569cd6;">let</span><span> screen_char = </span><span style="color:#b4cea8;">WRITER</span><span>.lock().buffer.chars[</span><span style="color:#b4cea8;">BUFFER_HEIGHT </span><span>- </span><span style="color:#b5cea8;">2</span><span>][i].read();
</span><span>        assert_eq!(</span><span style="color:#569cd6;">char</span><span>::from(screen_char.ascii_character), c);
</span><span>    }
</span><span>}
</span></code></pre>
<p>The function defines a test string, prints it using <code>println</code>, and then iterates over the screen characters of the static <code>WRITER</code>, which represents the VGA text buffer. Since <code>println</code> prints to the last screen line and then immediately appends a newline, the string should appear on line <code>BUFFER_HEIGHT - 2</code>.</p>
<p>By using <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>, we count the number of iterations in the variable <code>i</code>, which we then use for loading the screen character corresponding to <code>c</code>. By comparing the <code>ascii_character</code> of the screen character with <code>c</code>, we ensure that each character of the string really appears in the VGA text buffer.</p>
<p>As you can imagine, we could create many more test functions. For example, a function that tests that no panic occurs when printing very long lines and that they’re wrapped correctly, or a function for testing that newlines, non-printable characters, and non-unicode characters are handled correctly.</p>
<p>For the rest of this post, however, we will explain how to create <em>integration tests</em> to test the interaction of different components together.</p>
<h2 id="integration-tests"><a class="zola-anchor" href="index.html#integration-tests" aria-label="Anchor link for: integration-tests">🔗</a>Integration Tests</h2>
<p>The convention for <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">integration tests</a> in Rust is to put them into a <code>tests</code> directory in the project root (i.e., next to the <code>src</code> directory). Both the default test framework and custom test frameworks will automatically pick up and execute all tests in that directory.</p>
<p>All integration tests are their own executables and completely separate from our <code>main.rs</code>. This means that each test needs to define its own entry point function. Let’s create an example integration test named <code>basic_boot</code> to see how it works in detail:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// don&#39;t mangle the name of this function
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    unimplemented!();
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>Since integration tests are separate executables, we need to provide all the crate attributes (<code>no_std</code>, <code>no_main</code>, <code>test_runner</code>, etc.) again. We also need to create a new entry point function <code>_start</code>, which calls the test entry point function <code>test_main</code>. We don’t need any <code>cfg(test)</code> attributes because integration test executables are never built in non-test mode.</p>
<p>We use the <a href="https://doc.rust-lang.org/core/macro.unimplemented.html"><code>unimplemented</code></a> macro that always panics as a placeholder for the <code>test_runner</code> function and just <code>loop</code> in the <code>panic</code> handler for now. Ideally, we want to implement these functions exactly as we did in our <code>main.rs</code> using the <code>serial_println</code> macro and the <code>exit_qemu</code> function. The problem is that we don’t have access to these functions since tests are built completely separately from our <code>main.rs</code> executable.</p>
<p>If you run <code>cargo test</code> at this stage, you will get an endless loop because the panic handler loops endlessly. You need to use the <code>ctrl+c</code> keyboard shortcut for exiting QEMU.</p>
<h3 id="create-a-library"><a class="zola-anchor" href="index.html#create-a-library" aria-label="Anchor link for: create-a-library">🔗</a>Create a Library</h3>
<p>To make the required functions available to our integration test, we need to split off a library from our <code>main.rs</code>, which can be included by other crates and integration test executables. To do this, we create a new <code>src/lib.rs</code> file:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// src/lib.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span></code></pre>
<p>Like the <code>main.rs</code>, the <code>lib.rs</code> is a special file that is automatically recognized by cargo. The library is a separate compilation unit, so we need to specify the <code>#![no_std]</code> attribute again.</p>
<p>To make our library work with <code>cargo test</code>, we need to also move the test functions and attributes from <code>main.rs</code>  to <code>lib.rs</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span>#![cfg_attr(test, no_main)]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#569cd6;">pub trait </span><span>Testable {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; ();
</span><span>}
</span><span>
</span><span style="color:#569cd6;">impl</span><span>&lt;T&gt; Testable </span><span style="color:#569cd6;">for </span><span>T
</span><span style="color:#569cd6;">where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        serial_print!(</span><span style="color:#d69d85;">&quot;{}...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>, core::any::type_name::&lt;T&gt;());
</span><span>        self();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Testable]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test.run();
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_panic_handler(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[failed]</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Error: {}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Entry point for `cargo test`
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>To make our <code>test_runner</code> available to executables and integration tests, we make it public and don’t apply the <code>cfg(test)</code> attribute to it. We also factor out the implementation of our panic handler into a public <code>test_panic_handler</code> function, so that it is available for executables too.</p>
<p>Since our <code>lib.rs</code> is tested independently of our <code>main.rs</code>, we need to add a <code>_start</code> entry point and a panic handler when the library is compiled in test mode. By using the <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> crate attribute, we conditionally enable the <code>no_main</code> attribute in this case.</p>
<p>We also move over the <code>QemuExitCode</code> enum and the <code>exit_qemu</code> function and make them public:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style="color:#569cd6;">pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style="color:#b5cea8;">0x10</span><span>,
</span><span>    Failed = </span><span style="color:#b5cea8;">0x11</span><span>,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style="color:#569cd6;">as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now executables and integration tests can import these functions from the library and don’t need to define their own implementations. To also make <code>println</code> and <code>serial_println</code> available, we move the module declarations too:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>serial;
</span><span style="color:#569cd6;">pub mod </span><span>vga_buffer;
</span></code></pre>
<p>We make the modules public to make them usable outside of our library. This is also required for making our <code>println</code> and <code>serial_println</code> macros usable since they use the <code>_print</code> functions of the modules.</p>
<p>Now we can update our <code>main.rs</code> to use the library:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::println;
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// This function is called on panic.
</span><span>#[cfg(not(test))]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>The library is usable like a normal external crate. It is called <code>blog_os</code>, like our crate. The above code uses the <code>blog_os::test_runner</code> function in the <code>test_runner</code> attribute and the <code>blog_os::test_panic_handler</code> function in our <code>cfg(test)</code> panic handler. It also imports the <code>println</code> macro to make it available to our <code>_start</code> and <code>panic</code> functions.</p>
<p>At this point, <code>cargo run</code> and <code>cargo test</code> should work again. Of course, <code>cargo test</code> still loops endlessly (you can exit with <code>ctrl+c</code>). Let’s fix this by using the required library functions in our integration test.</p>
<h3 id="completing-the-integration-test"><a class="zola-anchor" href="index.html#completing-the-integration-test" aria-label="Anchor link for: completing-the-integration-test">🔗</a>Completing the Integration Test</h3>
<p>Like our <code>src/main.rs</code>, our <code>tests/basic_boot.rs</code> executable can import types from our new library. This allows us to import the missing components to complete our test:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>Instead of reimplementing the test runner, we use the <code>test_runner</code> function from our library by changing the <code>#![test_runner(crate::test_runner)]</code> attribute to <code>#![test_runner(blog_os::test_runner)]</code>. We then don’t need the <code>test_runner</code> stub function in <code>basic_boot.rs</code> anymore, so we can remove it. For our <code>panic</code> handler, we call the <code>blog_os::test_panic_handler</code> function like we did in our <code>main.rs</code>.</p>
<p>Now <code>cargo test</code> exits normally again. When you run it, you will see that it builds and runs the tests for our <code>lib.rs</code>, <code>main.rs</code>, and <code>basic_boot.rs</code> separately after each other. For the <code>main.rs</code> and the <code>basic_boot</code> integration tests, it reports “Running 0 tests” since these files don’t have any functions annotated with <code>#[test_case]</code>.</p>
<p>We can now add tests to our <code>basic_boot.rs</code>. For example, we can test that <code>println</code> works without panicking, like we did in the VGA buffer tests:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::println;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;test_println output&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>When we run <code>cargo test</code> now, we see that it finds and executes the test function.</p>
<p>The test might seem a bit useless right now since it’s almost identical to one of the VGA buffer tests. However, in the future, the <code>_start</code> functions of our <code>main.rs</code> and <code>lib.rs</code> might grow and call various initialization routines before running the <code>test_main</code> function, so that the two tests are executed in very different environments.</p>
<p>By testing <code>println</code> in a <code>basic_boot</code> environment without calling any initialization routines in <code>_start</code>, we can ensure that <code>println</code> works right after booting. This is important because we rely on it, e.g., for printing panic messages.</p>
<h3 id="future-tests"><a class="zola-anchor" href="index.html#future-tests" aria-label="Anchor link for: future-tests">🔗</a>Future Tests</h3>
<p>The power of integration tests is that they’re treated as completely separate executables. This gives them complete control over the environment, which makes it possible to test that the code interacts correctly with the CPU or hardware devices.</p>
<p>Our <code>basic_boot</code> test is a very simple example of an integration test. In the future, our kernel will become much more featureful and interact with the hardware in various ways. By adding integration tests, we can ensure that these interactions work (and keep working) as expected. Some ideas for possible future tests are:</p>
<ul>
<li><strong>CPU Exceptions</strong>: When the code performs invalid operations (e.g., divides by zero), the CPU throws an exception. The kernel can register handler functions for such exceptions. An integration test could verify that the correct exception handler is called when a CPU exception occurs or that the execution continues correctly after a resolvable exception.</li>
<li><strong>Page Tables</strong>: Page tables define which memory regions are valid and accessible. By modifying the page tables, it is possible to allocate new memory regions, for example when launching programs. An integration test could modify the page tables in the <code>_start</code> function and verify that the modifications have the desired effects in <code>#[test_case]</code> functions.</li>
<li><strong>Userspace Programs</strong>: Userspace programs are programs with limited access to the system’s resources. For example, they don’t have access to kernel data structures or to the memory of other programs. An integration test could launch userspace programs that perform forbidden operations and verify that the kernel prevents them all.</li>
</ul>
<p>As you can imagine, many more tests are possible. By adding such tests, we can ensure that we don’t break them accidentally when we add new features to our kernel or refactor our code. This is especially important when our kernel becomes larger and more complex.</p>
<h3 id="tests-that-should-panic"><a class="zola-anchor" href="index.html#tests-that-should-panic" aria-label="Anchor link for: tests-that-should-panic">🔗</a>Tests that Should Panic</h3>
<p>The test framework of the standard library supports a <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics"><code>#[should_panic]</code> attribute</a> that allows constructing tests that should fail. This is useful, for example, to verify that a function fails when an invalid argument is passed. Unfortunately, this attribute isn’t supported in <code>#[no_std]</code> crates since it requires support from the standard library.</p>
<p>While we can’t use the <code>#[should_panic]</code> attribute in our kernel, we can get similar behavior by creating an integration test that exits with a success error code from the panic handler. Let’s start creating such a test with the name <code>should_panic</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::{QemuExitCode, exit_qemu, serial_println};
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>This test is still incomplete as it doesn’t define a <code>_start</code> function or any of the custom test runner attributes yet. Let’s add the missing parts:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[test did not panic]&quot;</span><span>);
</span><span>        exit_qemu(QemuExitCode::Failed);
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>Instead of reusing the <code>test_runner</code> from our <code>lib.rs</code>, the test defines its own <code>test_runner</code> function that exits with a failure exit code when a test returns without panicking (we want our tests to panic). If no test function is defined, the runner exits with a success error code. Since the runner always exits after running a single test, it does not make sense to define more than one <code>#[test_case]</code> function.</p>
<p>Now we can create a test that should fail:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::serial_print;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;should_panic::should_fail...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">0</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span></code></pre>
<p>The test uses <code>assert_eq</code> to assert that <code>0</code> and <code>1</code> are equal. Of course, this fails, so our test panics as desired. Note that we need to manually print the function name using <code>serial_print!</code> here because we don’t use the <code>Testable</code> trait.</p>
<p>When we run the test through <code>cargo test --test should_panic</code> we see that it is successful because the test panicked as expected. When we comment out the assertion and run the test again, we see that it indeed fails with the <em>“test did not panic”</em> message.</p>
<p>A significant drawback of this approach is that it only works for a single test function. With multiple <code>#[test_case]</code> functions, only the first function is executed because the execution cannot continue after the panic handler has been called. I currently don’t know of a good way to solve this problem, so let me know if you have an idea!</p>
<h3 id="no-harness-tests"><a class="zola-anchor" href="index.html#no-harness-tests" aria-label="Anchor link for: no-harness-tests">🔗</a>No Harness Tests</h3>
<p>For integration tests that only have a single test function (like our <code>should_panic</code> test), the test runner isn’t really needed. For cases like this, we can disable the test runner completely and run our test directly in the <code>_start</code> function.</p>
<p>The key to this is to disable the <code>harness</code> flag for the test in the <code>Cargo.toml</code>, which defines whether a test runner is used for an integration test. When it’s set to <code>false</code>, both the default test runner and the custom test runner feature are disabled, so that the test is treated like a normal executable.</p>
<p>Let’s disable the <code>harness</code> flag for our <code>should_panic</code> test:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[[</span><span style="color:#808080;">test</span><span>]]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;should_panic&quot;
</span><span style="color:#569cd6;">harness </span><span>= </span><span style="color:#569cd6;">false
</span></code></pre>
<p>Now we vastly simplify our <code>should_panic</code> test by removing the <code>test_runner</code>-related code. The result looks like this:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::{exit_qemu, serial_print, serial_println, QemuExitCode};
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    should_fail();
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[test did not panic]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop</span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;should_panic::should_fail...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">0</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>We now call the <code>should_fail</code> function directly from our <code>_start</code> function and exit with a failure exit code if it returns. When we run <code>cargo test --test should_panic</code> now, we see that the test behaves exactly as before.</p>
<p>Apart from creating <code>should_panic</code> tests, disabling the <code>harness</code> attribute can also be useful for complex integration tests, for example, when the individual test functions have side effects and need to be run in a specified order.</p>
<h2 id="summary"><a class="zola-anchor" href="index.html#summary" aria-label="Anchor link for: summary">🔗</a>Summary</h2>
<p>Testing is a very useful technique to ensure that certain components have the desired behavior. Even if they cannot show the absence of bugs, they’re still a useful tool for finding them and especially for avoiding regressions.</p>
<p>This post explained how to set up a test framework for our Rust kernel. We used Rust’s custom test frameworks feature to implement support for a simple <code>#[test_case]</code> attribute in our bare-metal environment. Using the <code>isa-debug-exit</code> device of QEMU, our test runner can exit QEMU after running the tests and report the test status. To print error messages to the console instead of the VGA buffer, we created a basic driver for the serial port.</p>
<p>After creating some tests for our <code>println</code> macro, we explored integration tests in the second half of the post. We learned that they live in the <code>tests</code> directory and are treated as completely separate executables. To give them access to the <code>exit_qemu</code> function and the <code>serial_println</code> macro, we moved most of our code into a library that can be imported by all executables and integration tests. Since integration tests run in their own separate environment, they make it possible to test interactions with the hardware or to create tests that should panic.</p>
<p>We now have a test framework that runs in a realistic environment inside QEMU. By creating more tests in future posts, we can keep our kernel maintainable when it becomes more complex.</p>
<h2 id="what-s-next"><a class="zola-anchor" href="index.html#what-s-next" aria-label="Anchor link for: what-s-next">🔗</a>What’s next?</h2>
<p>In the next post, we will explore <em>CPU exceptions</em>. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called “page fault”). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.</p>

    </div>

    <div class="post-footer-support">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../vga-text-mode/index.html">&laquo; VGA Text Mode</a>
        
        
            <a class="next" href="../cpu-exceptions/index.html">CPU Exceptions &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="">Comments</h2>

        
            
        
        
    
        
        
    

    
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/1009"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="number"
    
        data-term="1009"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/1009"><em>on GitHub</em></a>.
    </p>

    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="zh-CN" class=""><a href="../zh-CN/testing/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../ja/testing/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="fa" class=""><a href="../fa/testing/index.html">
                        Persian
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../ko/testing/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
