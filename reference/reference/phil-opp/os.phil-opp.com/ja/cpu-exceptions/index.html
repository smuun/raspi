<!doctype html>

<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="CPU例外は、例えば無効なメモリアドレスにアクセスしたときやゼロ除算したときなど、様々なミスによって発生します。それらに対処するために、ハンドラ関数を提供する 割り込み記述子表 (interrupt descriptor table)  を設定しなくてはなりません。この記事を読み終わる頃には、私達の…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>CPU例外 | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/ja" title="All Posts">« すべての記事へ</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="">
        <h2>目次</h2>
    <ol>
        <li>
            <a href="index.html#gai-yao">概要</a>
            <ol>
                <li>
                    <a href="index.html#ge-riip-miji-shu-zi-biao">割り込み記述子表</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#idtxing">IDT型</a>
            
        </li><li>
            <a href="index.html#li-wai-nohu-bichu-sigui-yue">例外の呼び出し規約</a>
            <ol>
                <li>
                    <a href="index.html#preservedrezisutatoscratchrezisuta">PreservedレジスタとScratchレジスタ</a>
                </li><li>
                    <a href="index.html#subetenorezisutawobao-cun-suru">すべてのレジスタを保存する</a>
                </li><li>
                    <a href="index.html#ge-riip-mishi-nosutatukuhuremu">割り込み時のスタックフレーム</a>
                </li><li>
                    <a href="index.html#wu-tai-li-dehahe-ga">舞台裏では何が</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#shi-zhuang">実装</a>
            <ol>
                <li>
                    <a href="index.html#idtwodu-miip-mu">IDTを読み込む</a>
                </li><li>
                    <a href="index.html#shi-xing-suru">実行する</a>
                </li><li>
                    <a href="index.html#tesutowozhui-jia-suru">テストを追加する</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#sasuganijian-dan-sugi">さすがに簡単すぎ？</a>
            
        </li><li>
            <a href="index.html#ci-ha">次は？</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">コメント</a></li>
    </ol>
</aside>

            <main>
    <div class="">
    <h1>CPU例外</h1>
    <time datetime="2018-06-17" class="post-date">
        Jun 17, 2018
        
    </time>
    </div>

    
        <div class="warning">
            
            
            <p>
            <b>この記事は翻訳されたものです：</b>
            この記事は<strong><a href="../../cpu-exceptions/index.html">CPU Exceptions</a></strong>をコミュニティの手により翻訳したものです。そのため、翻訳が完全・最新でなかったり、原文にない誤りを含んでいる可能性があります。問題があれば<a href="https://github.com/phil-opp/blog_os/issues/906">このissue</a>上で報告してください！
            </p>
            <p>
                翻訳者： <a href="https://github.com/woodyZootopia">@woodyZootopia</a>.</p>
            </div>
    

    <div class="">
    <p>CPU例外は、例えば無効なメモリアドレスにアクセスしたときやゼロ除算したときなど、様々なミスによって発生します。それらに対処するために、ハンドラ関数を提供する <strong><ruby>割り込み記述子表<rp> (</rp><rt>interrupt descriptor table</rt><rp>) </rp></ruby></strong> を設定しなくてはなりません。この記事を読み終わる頃には、私達のカーネルは<a href="https://wiki.osdev.org/Exceptions#Breakpoint">ブレークポイント例外</a>を捕捉し、その後通常の実行を継続できるようになっているでしょう。</p>
<span id="continue-reading"></span>
<p>このブログの内容は <a href="https://github.com/phil-opp/blog_os">GitHub</a> 上で公開・開発されています。何か問題や質問などがあれば issue をたててください (訳注: リンクは原文(英語)のものになります)。また<a href="index.html#comments">こちら</a>にコメントを残すこともできます。この記事の完全なソースコードは<a href="https://github.com/phil-opp/blog_os/tree/post-05"><code>post-05</code> ブランチ</a>にあります。</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>目次</b></summary>
        <ul>
            <li>
                <a href="index.html#gai-yao">概要</a>
                <ul>
                    <li>
                        <a href="index.html#ge-riip-miji-shu-zi-biao">割り込み記述子表</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#idtxing">IDT型</a>
                
            </li><li>
                <a href="index.html#li-wai-nohu-bichu-sigui-yue">例外の呼び出し規約</a>
                <ul>
                    <li>
                        <a href="index.html#preservedrezisutatoscratchrezisuta">PreservedレジスタとScratchレジスタ</a>
                    </li><li>
                        <a href="index.html#subetenorezisutawobao-cun-suru">すべてのレジスタを保存する</a>
                    </li><li>
                        <a href="index.html#ge-riip-mishi-nosutatukuhuremu">割り込み時のスタックフレーム</a>
                    </li><li>
                        <a href="index.html#wu-tai-li-dehahe-ga">舞台裏では何が</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#shi-zhuang">実装</a>
                <ul>
                    <li>
                        <a href="index.html#idtwodu-miip-mu">IDTを読み込む</a>
                    </li><li>
                        <a href="index.html#shi-xing-suru">実行する</a>
                    </li><li>
                        <a href="index.html#tesutowozhui-jia-suru">テストを追加する</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#sasuganijian-dan-sugi">さすがに簡単すぎ？</a>
                
            </li><li>
                <a href="index.html#ci-ha">次は？</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">コメント</a></li>
        </ul>
    </details>

<h2 id="gai-yao"><a class="zola-anchor" href="index.html#gai-yao" aria-label="Anchor link for: gai-yao">🔗</a>概要</h2>
<p>例外とは、今実行している命令はなにかおかしいぞ、ということを示すものです。例えば、現在の命令がゼロ除算を実行しようとしているとき、CPUは例外を発します。例外が起こると、CPUは現在行われている作業に割り込み、例外の種類に従って、即座に特定の例外ハンドラ関数を呼びます。</p>
<p>x86には20種類のCPU例外があります。中でも重要なものは：</p>
<ul>
<li><strong><ruby>ページフォルト<rp> (</rp><rt>Page Fault</rt><rp>) </rp></ruby></strong>: ページフォルトは不正なメモリアクセスの際に発生します。例えば、現在の命令がマップされていないページから読み込もうとしたり、読み込み専用のページに書き込もうとしたときに生じます。</li>
<li><strong><ruby>無効な<rp> (</rp><rt>Invalid</rt><rp>) </rp></ruby><ruby>命令コード<rp> (</rp><rt>Opcode</rt><rp>) </rp></ruby></strong>: この例外は現在の命令が無効であるときに発生します。例えば、<a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE命令</a>という新しい命令をサポートしていない旧式のCPU上でこれを実行しようとしたときに生じます。</li>
<li><strong><ruby>一般保護違反<rp> (</rp><rt>General Protection Fault</rt><rp>) </rp></ruby></strong>: これは、例外の中でも、最もいろいろな理由で発生しうるものです。ユーザーレベルのコードで<ruby>特権命令<rp> (</rp><rt>privileged instruction</rt><rp>) </rp></ruby>を実行しようとしたときや、設定レジスタの保護領域に書き込もうとしたときなど、様々な種類のアクセス違反によって生じます。</li>
<li><strong><ruby>ダブルフォルト<rp> (</rp><rt>Double Fault</rt><rp>) </rp></ruby></strong>: 何らかの例外が起こったとき、CPUは対応するハンドラ関数を呼び出そうとします。 この例外ハンドラを <strong>呼び出している間に</strong> 別の例外が起こった場合、CPUはダブルフォルト例外を出します。この例外はまた、ある例外に対してハンドラ関数が登録されていないときにも起こります。</li>
<li><strong><ruby>トリプルフォルト<rp> (</rp><rt>Triple Fault</rt><rp>) </rp></ruby></strong>: CPUがダブルフォルトのハンドラ関数を呼び出そうとしている間に例外が発生すると、CPUは <strong>トリプルフォルト</strong> という致命的な例外を発します。トリプルフォルトを捕捉したり処理したりすることはできません。これが起こると、多くのプロセッサは自らをリセットしてOSを再起動することで対応します。</li>
</ul>
<p>例外の完全な一覧を見たい場合は、<a href="https://wiki.osdev.org/Exceptions">OSDev wiki</a>を見てください。</p>
<h3 id="ge-riip-miji-shu-zi-biao"><a class="zola-anchor" href="index.html#ge-riip-miji-shu-zi-biao" aria-label="Anchor link for: ge-riip-miji-shu-zi-biao">🔗</a>割り込み記述子表</h3>
<p>例外を捕捉し処理するためには、いわゆる割り込み記述子表 (Interrupt Descriptor Table, IDT) を設定しないといけません。この表にそれぞれのCPU例外に対するハンドラ関数を指定することができます。ハードウェアはこの表を直接使うので、決められたフォーマットに従わないといけません。それぞれのエントリは以下の16バイトの構造を持たなければなりません：</p>
<table><thead><tr><th>型</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td>u16</td><td>関数ポインタ     [0:15]</td><td>ハンドラ関数へのポインタの下位ビット。</td></tr>
<tr><td>u16</td><td>GDTセレクタ</td><td><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">大域記述子表 (Global Descriptor Table)</a> におけるコードセグメントのセレクタ。</td></tr>
<tr><td>u16</td><td>オプション</td><td>（下を参照）</td></tr>
<tr><td>u16</td><td>関数ポインタ     [16:31]</td><td>ハンドラ関数へのポインタの中位ビット。</td></tr>
<tr><td>u32</td><td>関数ポインタ     [32:63]</td><td>ハンドラ関数へのポインタの上位ビット。</td></tr>
<tr><td>u32</td><td>予約済</td><td></td></tr>
</tbody></table>
<p>オプション部は以下のフォーマットになっています：</p>
<table><thead><tr><th>ビット</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td>0-2</td><td>割り込みスタックテーブルインデックス</td><td>0ならスタックを変えない。1から7なら、ハンドラが呼ばれたとき、割り込みスタック表のその数字のスタックに変える。</td></tr>
<tr><td>3-7</td><td>予約済</td><td></td></tr>
<tr><td>8</td><td>0: 割り込みゲート、1: トラップゲート</td><td>0なら、このハンドラが呼ばれたとき割り込みは無効化される。</td></tr>
<tr><td>9-11</td><td>1にしておかないといけない</td><td></td></tr>
<tr><td>12</td><td>0にしておかないといけない</td><td></td></tr>
<tr><td>13‑14</td><td><ruby>記述子の特権レベル<rp> (</rp><rt>Descriptor Privilege Level</rt><rp>) </rp></ruby> (DPL)</td><td>このハンドラを呼ぶ際に必要になる最低限の特権レベル。</td></tr>
<tr><td>15</td><td>Present</td><td></td></tr>
</tbody></table>
<p>それぞれの例外がIDTの何番目に対応するかは事前に定義されています。例えば、「無効な命令コード」の例外は6番目で、「ページフォルト」例外は14番目です。これにより、ハードウェアがそれぞれの例外に対応するIDTの設定を（特に設定の必要なく）自動的に読み出せるというわけです。OSDev wikiの<a href="https://wiki.osdev.org/Exceptions">「例外表」</a>の “Vector nr.” 列に、すべての例外についてIDTの何番目かが記されています。</p>
<p>例外が起こると、ざっくりCPUは以下のことを行います：</p>
<ol>
<li>命令ポインタと<a href="https://en.wikipedia.org/wiki/FLAGS_register">RFLAGS</a>レジスタ（これらの値は後で使います）を含むレジスタをスタックにプッシュする。</li>
<li>割り込み記述子表から対応するエントリを読む。例えば、ページフォルトが起こったときはCPUは14番目のエントリを読む。</li>
<li>エントリが存在しているのかチェックする。そうでなければダブルフォルトを起こす。</li>
<li>エントリが割り込みゲートなら（40番目のビットが0なら）ハードウェア割り込みを無効にする。</li>
<li>指定された<a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">GDT</a>セレクタをCSセグメントに読み込む。</li>
<li>指定されたハンドラ関数にジャンプする。</li>
</ol>
<p>ステップ4と5について今深く考える必要はありません。今後の記事で大域記述子表 (Global Descriptor Table, 略してGDT) とハードウェア割り込みについては学んでいきます。</p>
<h2 id="idtxing"><a class="zola-anchor" href="index.html#idtxing" aria-label="Anchor link for: idtxing">🔗</a>IDT型</h2>
<p>自前でIDTの型を作る代わりに、<code>x86_64</code>クレートの<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code>構造体</a>を使います。こんな見た目をしています：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[repr(C)]
</span><span style="color:#569cd6;">pub struct </span><span>InterruptDescriptorTable {
</span><span>    </span><span style="color:#569cd6;">pub </span><span>divide_by_zero: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>debug: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>non_maskable_interrupt: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>breakpoint: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>overflow: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>bound_range_exceeded: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>invalid_opcode: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>device_not_available: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>double_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>invalid_tss: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>segment_not_present: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>stack_segment_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>general_protection_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>page_fault: Entry&lt;PageFaultHandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>x87_floating_point: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>alignment_check: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>machine_check: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>simd_floating_point: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>virtualization: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>security_exception: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#608b4e;">// いくつかのフィールドは省略している
</span><span>}
</span></code></pre>
<p>この構造体のフィールドは<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.Entry.html"><code>idt::Entry&lt;F&gt;</code></a>という型を持っています。これはIDTのエントリのフィールド（上の表を見てください）を表す構造体です。型パラメータ<code>F</code>は、期待されるハンドラ関数の型を表します。エントリの中には、<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFunc.html"><code>HandlerFunc</code></a>型を要求するものや、<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html"><code>HandlerFuncWithErrCode</code></a>型を要求するものがあることがわかります。ページフォルトに至っては、<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.PageFaultHandlerFunc.html"><code>PageFaultHandlerFunc</code></a>という自分専用の型を要求していますね。</p>
<p>まず<code>HandlerFunc</code>型を見てみましょう：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">type </span><span style="color:#4ec9b0;">HandlerFunc </span><span>= </span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn</span><span>(</span><span style="color:#569cd6;">_</span><span>: InterruptStackFrame);
</span></code></pre>
<p>これは、<code>extern &quot;x86-interrupt&quot; fn</code>型への<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">型エイリアス</a>です。<code>extern</code>は<a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">外部呼び出し規約</a>に従う関数を定義するのに使われ、おもにC言語のコードと連携したいときに使われます (<code>extern &quot;C&quot; fn</code>) 。しかし、<code>x86-interrupt</code>呼び出し規約とは何なのでしょう？</p>
<h2 id="li-wai-nohu-bichu-sigui-yue"><a class="zola-anchor" href="index.html#li-wai-nohu-bichu-sigui-yue" aria-label="Anchor link for: li-wai-nohu-bichu-sigui-yue">🔗</a>例外の呼び出し規約</h2>
<p>例外は関数呼び出しと非常に似ています。CPUが呼び出された関数の最初の命令にジャンプし、それを実行します。その後、CPUはリターンアドレスにジャンプし、親関数の実行を続けます。</p>
<p>しかし、例外と関数呼び出しには大きな違いが一つあるのです：関数呼び出しはコンパイラによって挿入された<code>call</code>命令によって自発的に引き起こされますが、例外は <strong>どんな命令の実行中でも</strong> 起こる可能性があるのです。この違いの結果を理解するためには、関数呼び出しについてより詳しく見ていく必要があります。</p>
<p><a href="https://en.wikipedia.org/wiki/Calling_convention">呼び出し規約</a>は関数呼び出しについて事細かく指定しています。例えば、関数のパラメータがどこに置かれるべきか（例えば、レジスタなのかスタックなのか）や、結果がどのように返されるべきかを指定しています。x86_64上のLinuxでは、C言語の関数に関しては以下のルールが適用されます（これは<a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">System V ABI</a>で指定されています）：</p>
<ul>
<li>最初の6つの整数引数は、レジスタ<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>で渡される</li>
<li>追加の引数はスタックで渡される</li>
<li>結果は<code>rax</code>と<code>rdx</code>で返される</li>
</ul>
<p>注意してほしいのは、RustはC言語のABIに従っていない（実は、<a href="https://github.com/rust-lang/rfcs/issues/600">RustにはABIすらまだありません</a>）ので、このルールは<code>extern &quot;C&quot; fn</code>と宣言された関数にしか適用されないということです。</p>
<h3 id="preservedrezisutatoscratchrezisuta"><a class="zola-anchor" href="index.html#preservedrezisutatoscratchrezisuta" aria-label="Anchor link for: preservedrezisutatoscratchrezisuta">🔗</a>PreservedレジスタとScratchレジスタ</h3>
<p>呼び出し規約はレジスタを2種類に分けています：<ruby>preserved<rp> (</rp><rt>保存</rt><rp>) </rp></ruby>レジスタと<ruby>scratch<rp> (</rp><rt>下書き</rt><rp>) </rp></ruby>レジスタです。</p>
<p>preservedレジスタの値は関数呼び出しの前後で変化してはいけません。ですので、呼び出された関数（訳注：callの受け身で“callee“と呼ばれます）は、リターンする前にその値をもとに戻す場合に限り、その値を上書きできます。そのため、これらのレジスタは<ruby>callee-saved<rp> (</rp><rt>呼び出し先によって保存される</rt><rp>) </rp></ruby>と呼ばれます。よくとられる方法は、関数の最初でそのレジスタをスタックに保存し、リターンする直前にその値をもとに戻すことです。</p>
<p>それとは対照的に、呼び出された関数はscratchレジスタを何の制限もなく上書きすることができます。呼び出し元の関数がscratchレジスタの値を関数呼び出しの前後で保存したいなら、関数呼び出しの前に自分で（スタックにプッシュするなどして）バックアップしておいて、もとに戻す必要があります。なので、scratchレジスタは<ruby>caller-saved<rp> (</rp><rt>呼び出し元によって保存される</rt><rp>) </rp></ruby>です。</p>
<p>x86_64においては、C言語の呼び出し規約は以下のpreservedレジスタとscratchレジスタを指定します：</p>
<table><thead><tr><th>preservedレジスタ</th><th>scratchレジスタ</th></tr></thead><tbody>
<tr><td><code>rbp</code>, <code>rbx</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code></td><td><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code></td></tr>
<tr><td><em>callee-saved</em></td><td><em>caller-saved</em></td></tr>
</tbody></table>
<p>コンパイラはこれらのルールを知っているので、それにしたがってコードを生成します。例えば、ほとんどの関数は<code>push rbp</code>から始まるのですが、これは<code>rbp</code>をスタックにバックアップしているのです（<code>rbp</code>はcallee-savedなレジスタであるため）。</p>
<h3 id="subetenorezisutawobao-cun-suru"><a class="zola-anchor" href="index.html#subetenorezisutawobao-cun-suru" aria-label="Anchor link for: subetenorezisutawobao-cun-suru">🔗</a>すべてのレジスタを保存する</h3>
<p>関数呼び出しとは対象的に、例外は <strong>どんな命令の最中にも</strong> 起きる可能性があります。多くの場合、生成されたコードが例外を引き起こすのかどうかは、コンパイル時には見当も付きません。例えば、コンパイラはある命令がスタックオーバーフローやページフォルトを起こすのか知ることができません。</p>
<p>いつ例外が起きるのかわからない以上、レジスタを事前にバックアップしておくことは不可能です。つまり、caller-savedレジスタを利用する呼び出し規約は、例外ハンドラには使えないということです。代わりに、 <strong>すべてのレジスタを</strong> 保存する規約を使わないといけません。<code>x86-interrupt</code>呼び出し規約はそのような呼び出し規約なので、関数が戻るときにすべてのレジスタが元の値に戻されることを保証してくれるというわけです。</p>
<p>これは、関数の初めにすべてのレジスタがスタックに保存されるということを意味しないことに注意してください。その代わりに、コンパイラは関数によって上書きされてしまうレジスタのみをバックアップします。こうすれば、数個のレジスタしか使わない短い関数に対して、とても効率的なコードが生成できるでしょう。</p>
<h3 id="ge-riip-mishi-nosutatukuhuremu"><a class="zola-anchor" href="index.html#ge-riip-mishi-nosutatukuhuremu" aria-label="Anchor link for: ge-riip-mishi-nosutatukuhuremu">🔗</a>割り込み時のスタックフレーム</h3>
<p>通常の関数呼び出し（<code>call</code>命令を使います）においては、CPUは対象の関数にジャンプする前にリターンアドレスをプッシュします。関数がリターンするとき（<code>ret</code>命令を使います）、CPUはこのリターンアドレスをポップし、そこにジャンプします。そのため、通常の関数呼び出しの際のスタックフレームは以下のようになっています：</p>
<p><img src="function-stack-frame.svg" alt="function stack frame" /></p>
<p>しかし、例外と割り込みハンドラについては、リターンアドレスをプッシュするだけではだめです。なぜなら、割り込みハンドラはしばしば（スタックポインタや、CPUフラグなどが）異なる状況で実行されるからです。ですので、代わりに、CPUは割り込みが起こると以下の手順を実行します。</p>
<ol>
<li><strong>スタックポインタをアラインする</strong>: 割り込みはあらゆる命令において発生しうるので、スタックポインタもあらゆる値を取る可能性があります。しかし、CPU命令のうちいくつか（例えばSSE命令の一部など）はスタックポインタが16バイトの倍数になっていることを要求するので、そうなるようにCPUは割り込みの直後にスタックポインタを<ruby>揃え<rp> (</rp><rt>アラインし</rt><rp>) </rp></ruby>ます。</li>
<li>（場合によっては）<strong>スタックを変更する</strong>: スタックの変更は、例えばCPU例外がユーザーモードのプログラムで起こった場合のような、CPUの特権レベルを変更するときに起こります。いわゆる<ruby>割り込みスタック表<rp> (</rp><rt>Interrupt Stack Table</rt><rp>) </rp></ruby>を使うことで、特定の割り込みに対しスタックを変更するよう設定することも可能です。割り込みスタック表については次の記事で説明します。</li>
<li><strong>古いスタックポインタをプッシュする</strong>: CPUは、割り込みが発生した際の（アラインされる前の）スタックポインタレジスタ（<code>rsp</code>）とスタックセグメントレジスタ（<code>ss</code>）の値をプッシュします。これにより、割り込みハンドラからリターンしてきたときにもとのスタックポインタを復元することが可能になります。</li>
<li><strong><code>RFLAGS</code>レジスタをプッシュして更新する</strong>: <a href="https://en.wikipedia.org/wiki/FLAGS_register"><code>RFLAGS</code></a>レジスタは状態や制御のための様々なビットを保持しています。割り込みに入るとき、CPUはビットのうちいくつかを変更し古い値をプッシュしておきます。</li>
<li><strong>命令ポインタをプッシュする</strong>: 割り込みハンドラ関数にジャンプする前に、CPUは命令ポインタ（<code>rip</code>）とコードセグメント（<code>cs</code>）をプッシュします。これは通常の関数呼び出しにおける戻り値のプッシュに対応します。</li>
<li>（例外によっては）<strong>エラーコードをプッシュする</strong>: ページフォルトのような特定の例外の場合、CPUはエラーコードをプッシュします。これは、例外の原因を説明するものです。</li>
<li><strong>割り込みハンドラを呼び出す</strong>: CPUは割り込みハンドラ関数のアドレスと<ruby>セグメント記述子<rp> (</rp><rt>segment descriptor</rt><rp>) </rp></ruby>をIDTの対応するフィールドから読み出します。そして、この値を<code>rip</code>と<code>cs</code>レジスタに書き出してから、ハンドラを呼び出します。</li>
</ol>
<p>ですので、割り込み時のスタックフレーム (interrupt stack frame) は以下のようになります：</p>
<p><img src="exception-stack-frame.svg" alt="interrupt stack frame" /></p>
<p><code>x86_64</code>クレートにおいては、割り込み時のスタックフレームは<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptStackFrame.html"><code>InterruptStackFrame</code></a>構造体によって表現されます。これは割り込みハンドラに<code>&amp;mut</code>として渡されるため、これを使うことで例外の原因に関して追加で情報を手に入れることができます。例外のすべてがエラーコードをプッシュするわけではないので、この構造体にはエラーコードのためのフィールドはありません。これらの例外は<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html"><code>HandlerFuncWithErrCode</code></a>という別の関数型を使いますが、これらは追加で<code>error_code</code>引数を持ちます。</p>
<h3 id="wu-tai-li-dehahe-ga"><a class="zola-anchor" href="index.html#wu-tai-li-dehahe-ga" aria-label="Anchor link for: wu-tai-li-dehahe-ga">🔗</a>舞台裏では何が</h3>
<p><code>x86-interrupt</code>呼び出し規約は、この例外<ruby>処理<rp> (</rp><rt>ハンドル</rt><rp>) </rp></ruby>プロセスのややこしいところをほぼ全て隠蔽してくれる、強力な抽象化です。しかし、その後ろで何が起こっているのかを知っておいたほうが良いこともあるでしょう。以下に、<code>x86-interrupt</code>呼び出し規約がやってくれることを簡単なリストにして示しました。</p>
<ul>
<li><strong>引数を取得する</strong>: 多くの呼び出し規約においては、引数はレジスタを使って渡されることを想定しています。例外ハンドラにおいては、スタックにバックアップする前にレジスタの値を上書きしてはいけないので、これは不可能です。その代わり、<code>x86-interrupt</code>呼び出し規約は、引数が既に特定のオフセットでスタック上にあることを認識しています。</li>
<li><strong><code>iretq</code>を使ってリターンする</strong>: 割り込み時のスタックフレームは通常の関数呼び出しのスタックフレームとは全く異なるため、通常の <code>ret</code> 命令を使ってハンドラ関数から戻ることはできません。その代わりに、<code>iretq</code> 命令を使う必要があります。</li>
<li><strong>エラーコードを処理する</strong>: いくつかの例外の場合、エラーコードがプッシュされるのですが、これが状況をより複雑にします。エラーコードはスタックのアラインメントを変更し（次の箇条を参照）、リターンする前にスタックからポップされる必要があるのです。<code>x86-interrupt</code>呼び出し規約は、このややこしい仕組みをすべて処理してくれます。しかし、どのハンドラ関数がどの例外に使われているかは呼び出し規約側にはわからないので、関数の引数の数からその情報を推測する必要があります。つまり、プログラマはやはりそれぞれの例外に対して正しい関数型を使う責任があるということです。幸いにも、<code>x86_64</code>クレートで定義されている<code>InterruptDescriptorTable</code>型が、正しい関数型が確実に使われるようにしてくれます。</li>
<li><strong>スタックをアラインする</strong>: 一部の命令（特にSSE命令）には、16バイトのスタックアラインメントを必要とするものがあります。CPUは例外が発生したときには必ずこのようにスタックが<ruby>整列<rp> (</rp><rt>アライン</rt><rp>) </rp></ruby>されることを保証しますが、例外の中には、エラーコードをプッシュして再びスタックの整列を壊してしまうものもあります。この場合、<code>x86-interrupt</code>の呼び出し規約は、スタックを再整列させることでこの問題を解決します。</li>
</ul>
<p>もしより詳しく知りたい場合は、例外の処理について<a href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md">naked function</a>を使って説明する一連の記事があります。<a href="index.html#sasuganijian-dan-sugi">この記事の最下部</a>にそこへのリンクがあります。</p>
<h2 id="shi-zhuang"><a class="zola-anchor" href="index.html#shi-zhuang" aria-label="Anchor link for: shi-zhuang">🔗</a>実装</h2>
<p>理屈は理解したので、私達のカーネルでCPUの例外を実際に処理していきましょう。まず、<code>src/interrupts.rs</code>に割り込みのための新しいモジュールを作ります。このモジュールはまず、<code>init_idt</code>関数という、新しい<code>InterruptDescriptorTable</code>を作る関数を定義します。</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>interrupts;
</span><span>
</span><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::InterruptDescriptorTable;
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>}
</span></code></pre>
<p>これで、ハンドラ関数を追加していくことができます。まず、<a href="https://wiki.osdev.org/Exceptions#Breakpoint">ブレークポイント例外</a>のハンドラを追加するところから始めましょう。ブレークポイント例外は、例外処理のテストをするのにうってつけの例外なのです。この例外の唯一の目的は、ブレークポイント命令<code>int3</code>が実行された時、プログラムを一時停止させることです。</p>
<p>ブレークポイント例外はよくデバッガによって使われます。ユーザーがブレークポイントを設定すると、デバッガが対応する命令を<code>int3</code>命令で置き換え、その行に到達したときにCPUがブレークポイント例外を投げるようにするのです。ユーザがプログラムを続行したい場合は、デバッガは<code>int3</code>命令をもとの命令に戻してプログラムを再開します。より詳しく知るには、<a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">How debuggers work</a>というシリーズ記事を読んでください。</p>
<p>今回の場合、命令を上書きしたりする必要はありません。ブレークポイント命令が実行された時、メッセージを表示したうえで実行を継続したいだけです。ですので、単純な<code>breakpoint_handler</code>関数を作ってIDTに追加してみましょう。</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::{InterruptDescriptorTable, InterruptStackFrame};
</span><span style="color:#569cd6;">use crate</span><span>::println;
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>    idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>}
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>breakpoint_handler(
</span><span>    stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;EXCEPTION: BREAKPOINT</span><span style="color:#e3bbab;">\n</span><span style="color:#b4cea8;">{:#?}</span><span style="color:#d69d85;">&quot;</span><span>, stack_frame);
</span><span>}
</span></code></pre>
<p>私達のハンドラは、ただメッセージを出力し、割り込みスタックフレームを整形して出力するだけです。</p>
<p>これをコンパイルしようとすると、以下のエラーが起こります：</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error[E0658]: x86-interrupt ABI is experimental and subject to change (see issue #40180)
</span><span>  --&gt; src/main.rs:53:1
</span><span>   |
</span><span>53 | / extern &quot;x86-interrupt&quot; fn breakpoint_handler(stack_frame: InterruptStackFrame) {
</span><span>54 | |     println!(&quot;EXCEPTION: BREAKPOINT\n{:#?}&quot;, stack_frame);
</span><span>55 | | }
</span><span>   | |_^
</span><span>   |
</span><span>   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
</span></code></pre>
<p>このエラーは、<code>x86-interrupt</code>呼び出し規約がまだ不安定なために発生します。これを強制的に使うためには、<code>lib.rs</code>の最初に<code>#![feature(abi_x86_interrupt)]</code>を追記して、この機能を明示的に有効化してやる必要があります。</p>
<h3 id="idtwodu-miip-mu"><a class="zola-anchor" href="index.html#idtwodu-miip-mu" aria-label="Anchor link for: idtwodu-miip-mu">🔗</a>IDTを読み込む</h3>
<p>CPUがこの割り込みディスクリプタテーブル(IDT)を使用するためには、<a href="https://www.felixcloutier.com/x86/lgdt:lidt"><code>lidt</code></a>命令を使ってこれを読み込む必要があります。<code>x86_64</code>の<code>InterruptDescriptorTable</code>構造体には、そのための<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html#method.load"><code>load</code></a>というメソッド関数が用意されています。それを使ってみましょう：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>    idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>    idt.load();
</span><span>}
</span></code></pre>
<p>これをコンパイルしようとすると、以下のエラーが発生します：</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: `idt` does not live long enough
</span><span>  --&gt; src/interrupts/mod.rs:43:5
</span><span>   |
</span><span>43 |     idt.load();
</span><span>   |     ^^^ does not live long enough
</span><span>44 | }
</span><span>   | - borrowed value only lives until here
</span><span>   |
</span><span>   = note: borrowed value must be valid for the static lifetime...
</span></code></pre>
<p><code>load</code>メソッドは（<code>idt</code>に）<code>&amp;'static self</code>、つまりプログラムの実行されている間ずっと有効な参照を期待しています。これは、私達が別のIDTを読み込まない限り、CPUは割り込みのたびにこの表にアクセスするからです。そのため、<code>'static</code>より短いライフタイムの場合、<ruby>use-after-free<rp> (</rp><rt>メモリ解放後にアクセス</rt><rp>) </rp></ruby>バグが発生する可能性があります。</p>
<p>実際、これはまさにここで起こっていることです。私達の<code>idt</code>はスタック上に生成されるので、<code>init</code>関数の中でしか有効ではないのです。この関数が終わると、このスタックメモリは他の関数に使い回されるので、CPUはどこかもわからないスタックメモリをIDTとして解釈してしまうのです。幸運にも、<code>InterruptDescriptorTable::load</code>メソッドは関数定義にこのライフタイムの要件を組み込んでいるので、Rustコンパイラはこのバグをコンパイル時に未然に防ぐことができたというわけです。</p>
<p>この問題を解決するには、<code>idt</code>を<code>'static</code>なライフタイムの場所に格納する必要があります。これを達成するには、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>を使ってIDTをヒープに割当て、続いてそれを<code>'static</code>な参照に変換すればよいです。しかし、私達はOSのカーネルを書いている途中であり、（まだ）ヒープを持っていません。</p>
<p>別の方法として、IDTを<code>static</code>として保存してみましょう：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">static </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = InterruptDescriptorTable::new();
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>}
</span></code></pre>
<p>しかし、問題が発生します：staticは<ruby>不変<rp> (</rp><rt>イミュータブル</rt><rp>) </rp></ruby>なので、<code>init</code>関数でエントリを変更することができません。これは<a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a>を使って解決できそうです：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">static mut </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = InterruptDescriptorTable::new();
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">IDT</span><span>.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>    }
</span><span>}
</span></code></pre>
<p>このように変更するとエラーなくコンパイルできますが、このような書き方は全く慣用的ではありません。<code>static mut</code>はデータ競合を非常に起こしやすいので、アクセスするたびに<a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers">unsafeブロック</a>が必要になります。</p>
<h4 id="lazy-staticsniomakase"><a class="zola-anchor" href="index.html#lazy-staticsniomakase" aria-label="Anchor link for: lazy-staticsniomakase">🔗</a>Lazy Staticsにおまかせ</h4>
<p>幸いにも、例の<code>lazy_static</code>マクロが存在します。このマクロは<code>static</code>をコンパイル時に評価する代わりに、最初に参照されたときに初期化を行います。このため、初期化時にはほとんどすべてのことができ、実行時にのみ決定する値を読み込むこともできます。</p>
<p><a href="../vga-text-mode/index.html#dai-keta-lazy-jing-de-bian-shu">VGAテキストバッファの抽象化をした</a>ときに、すでに<code>lazy_static</code>クレートはインポートしました。そのため、すぐに<code>lazy_static!</code>マクロを使って静的なIDTを作ることができます。</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>}
</span></code></pre>
<p>この方法では<code>unsafe</code>ブロックが必要ないことに注目してください。<code>lazy_static!</code>マクロはその内部で<code>unsafe</code>を使ってはいるのですが、これは安全なインターフェースの中に抽象化されているのです。</p>
<h3 id="shi-xing-suru"><a class="zola-anchor" href="index.html#shi-xing-suru" aria-label="Anchor link for: shi-xing-suru">🔗</a>実行する</h3>
<p>カーネルで例外を動作させるための最後のステップは、<code>main.rs</code>から<code>init_idt</code>関数を呼び出すことです。直接呼び出す代わりに、より一般的な<code>init</code>関数を<code>lib.rs</code>に導入します：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    interrupts::init_idt();
</span><span>}
</span></code></pre>
<p>この関数により、<code>main.rs</code>、<code>lib.rs</code>および結合テストにおける、異なる<code>_start</code>関数で共有される、初期化ルーチンの「中央広場」ができました。</p>
<p><code>main.rs</code>内の<code>_start</code>関数を更新して、<code>init</code>を呼び出し、そのあとブレークポイント例外を発生させるようにしてみましょう：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    blog_os::init(); </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    </span><span style="color:#608b4e;">// invoke a breakpoint exception
</span><span>    x86_64::instructions::interrupts::int3(); </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    </span><span style="color:#608b4e;">// as before
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>（<code>cargo run</code>を使って）QEMU内でこれを実行すると、以下のようになります</p>
<p><img src="qemu-breakpoint-exception.png" alt="QEMU printing EXCEPTION: BREAKPOINT and the interrupt stack frame" /></p>
<p>うまくいきました！CPUは私達のブレークポイントハンドラを呼び出すのに成功し、これがメッセージを出力し、そのあと<code>_start</code>関数に戻って、<code>It did not crash!</code>のメッセージを出力しました。</p>
<p>割り込みスタックフレームは、例外が発生した時の命令とスタックポインタを教えてくれることがわかります。これは、予期せぬ例外をデバッグする際に非常に便利です。</p>
<h3 id="tesutowozhui-jia-suru"><a class="zola-anchor" href="index.html#tesutowozhui-jia-suru" aria-label="Anchor link for: tesutowozhui-jia-suru">🔗</a>テストを追加する</h3>
<p>上記の動作が継続することを確認するテストを作成してみましょう。まず、<code>_start</code> 関数を更新して <code>init</code> を呼び出すようにします。</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#608b4e;">/// Entry point for `cargo test`
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    init();      </span><span style="color:#608b4e;">// new
</span><span>    test_main();
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>Rustのテストでは、<code>main.rs</code>とは全く無関係に<code>lib.rs</code>をテストするので、この<code>_start</code>関数は<code>cargo test --lib</code>を実行する際に使用されることを思い出してください。テストを実行する前にIDTを設定するために、ここで<code>init</code>を呼び出す必要があります。</p>
<p>では、<code>test_breakpoint_exception</code>テストを作ってみましょう：</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_breakpoint_exception() {
</span><span>    </span><span style="color:#608b4e;">// invoke a breakpoint exception
</span><span>    x86_64::instructions::interrupts::int3();
</span><span>}
</span></code></pre>
<p>このテストでは、<code>int3</code>関数を呼び出してブレークポイント例外を発生させます。その後も実行が続くことを確認することで、ブレークポイントハンドラが正しく動作していることを保証します。</p>
<p>この新しいテストを試すには、<code>cargo test</code>（すべてのテストを試したい場合）または<code>cargo test --lib</code>（<code>lib.rs</code>とそのモジュールのテストのみの場合）を実行すればよいです。出力は以下のようになるはずです：</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>blog_os::interrupts::test_breakpoint_exception...	[ok]
</span></code></pre>
<h2 id="sasuganijian-dan-sugi"><a class="zola-anchor" href="index.html#sasuganijian-dan-sugi" aria-label="Anchor link for: sasuganijian-dan-sugi">🔗</a>さすがに簡単すぎ？</h2>
<p><code>x86-interrupt</code>呼び出し規約と<a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code></a>型のおかげで、例外処理のプロセスは比較的わかりやすく、面倒なところはありませんでした。「これではさすがに簡単すぎる、例外処理の闇をすべて学び尽くしたい」というあなた向けの記事もあります：私達の<a href="https://os.phil-opp.com/edition-1/extra/naked-exceptions/">Handling Exceptions with Naked Functions</a>シリーズ（未訳）では、<code>x86-interrupt</code>呼び出し規約を使わずに例外を処理する方法を学び、さらには独自のIDT型を定義します。<code>x86-interrupt</code>呼び出し規約や、<code>x86_64</code>クレートが存在する前は、これらの記事が主な例外処理に関する記事でした。なお、これらの記事はこのブログの<a href="../../edition-1">第1版</a>をもとにしているので、内容が古くなっている可能性があることに注意してください。</p>
<h2 id="ci-ha"><a class="zola-anchor" href="index.html#ci-ha" aria-label="Anchor link for: ci-ha">🔗</a>次は？</h2>
<p>例外を捕捉し、そこから戻ってくることに成功しました！次のステップは、すべての例外を捕捉できるようにすることです。なぜなら、補足されなかった例外は致命的な<a href="https://wiki.osdev.org/Triple_Fault">トリプルフォルト</a>を引き起こし、これはシステムリセットにつながってしまうからです。次の記事では、<a href="https://wiki.osdev.org/Double_Fault#Double_Fault">ダブルフォルト</a>を正しく捕捉することで、これを回避できることを説明します。</p>

    </div>

    <div class="post-footer-support">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../testing/index.html">&laquo; テスト</a>
        
        
            <a class="next" href="../double-fault-exceptions/index.html">Double Faults &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="">コメント</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22CPU%20Exceptions%20%28ja%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="CPU Exceptions (ja)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="ja"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22CPU%20Exceptions%20%28ja%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="">
            可能な限りコメントは英語で残すようにしてください。
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../cpu-exceptions/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/cpu-exceptions/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="fa" class=""><a href="../../fa/cpu-exceptions/index.html">
                        Persian
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/cpu-exceptions/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
