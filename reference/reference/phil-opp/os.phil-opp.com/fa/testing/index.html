<!doctype html>

<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="این پست به بررسی تست‌های واحد (ترجمه: unit) و یکپارچه (ترجمه: integration) در فایل‌های اجرایی ‌no_std می‌پردازد. ما از پشتیبانی Rust برای فریم‌ورک تست‌های س…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>تست کردن | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fa" title="All Posts">« همه پست‌ها</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="right-to-left">
        <h2>فهرست مطالب</h2>
    <ol>
        <li>
            <a href="index.html#nyzmndyh">نیازمندی‌ها</a>
            
        </li><li>
            <a href="index.html#tst-khrdn-dr-rust">تست کردن در Rust</a>
            <ol>
                <li>
                    <a href="index.html#frymwrkh-tst-sfrshy">فریم‌ورک تست سفارشی</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khrwj-z-qemu">خروج از QEMU</a>
            <ol>
                <li>
                    <a href="index.html#pwrthy-i-o">پورت‌های I/O</a>
                </li><li>
                    <a href="index.html#stfdh-z-dstgh-khrwj">استفاده از دستگاه خروج</a>
                </li><li>
                    <a href="index.html#khd-khrwj-mwfqyt">کد خروج موفقیت</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#chp-khrdn-dr-khnswl">چاپ کردن در کنسول</a>
            <ol>
                <li>
                    <a href="index.html#pwrt-sryl">پورت سریال</a>
                </li><li>
                    <a href="index.html#argwmnhy-qemu">آرگومان‌‌های QEMU</a>
                </li><li>
                    <a href="index.html#chp-khrdn-pym-kht-hngm-pnykh-khrdn">چاپ کردن پیام خطا هنگام پنیک کردن</a>
                </li><li>
                    <a href="index.html#pnhn-khrdn-qemu">پنهان کردن QEMU</a>
                </li><li>
                    <a href="index.html#timeouts">Timeouts</a>
                </li><li>
                    <a href="index.html#dfh-khrdn-chp-khwdkhr">اضافه کردن چاپ خودکار</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#tst-khrdn-bfr-vga">تست کردن بافر VGA</a>
            
        </li><li>
            <a href="index.html#tsthy-ykhprchh">تست‌های یکپارچه</a>
            <ol>
                <li>
                    <a href="index.html#skht-ykh-khtbkhnh">ساخت یک کتابخانه</a>
                </li><li>
                    <a href="index.html#tmm-khrdn-tst-ykhprchh">تمام کردن تست یکپارچه</a>
                </li><li>
                    <a href="index.html#tsthy-ayndh">تست‌های آینده</a>
                </li><li>
                    <a href="index.html#tsthyy-khh-byd-pnykh-khnnd">تست‌هایی که باید پنیک کنند</a>
                </li><li>
                    <a href="index.html#tst-hy-bdwn-mhr">تست های بدون مهار</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khlsh">خلاصه</a>
            
        </li><li>
            <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
    </ol>
</aside>

            <main>
    <div class="right-to-left">
    <h1>تست کردن</h1>
    <time datetime="2019-04-27" class="post-date">
        Apr 27, 2019
        
    </time>
    </div>

    
        <div class="warning right-to-left">
            
            
            <p>
            <b>محتوای ترجمه شده:</b>
            این یک ترجمه از جامعه کاربران برای پست <strong><a href="../../testing/index.html">Testing</a></strong> است. ممکن است ناقص، منسوخ شده یا دارای خطا باشد. لطفا هر گونه مشکل را در <a href="https://github.com/phil-opp/blog_os/issues/908">این ایشو</a> گزارش دهید!
            </p>
            <p>
                ترجمه توسط <a href="https://github.com/hamidrezakp">@hamidrezakp</a> و <a href="https://github.com/MHBahrampour">@MHBahrampour</a>.</p>
            </div>
    

    <div class="right-to-left">
    <p>این پست به بررسی تست‌های واحد (ترجمه: unit) و یکپارچه (ترجمه: integration) در فایل‌های اجرایی ‌<code>no_std</code> می‌پردازد. ما از پشتیبانی Rust برای فریم‌ورک تست‌های سفارشی استفاده می‌کنیم تا توابع تست را درون کرنل‌مان اجرا کنیم. برای گزارش کردن نتایج خارج از QEMU، از ویژگی‌های مختلف QEMU و ابزار <code>bootimage</code> استفاده می‌کنیم.</p>
<span id="continue-reading"></span>
<p>این بلاگ بصورت آزاد روی <a href="https://github.com/phil-opp/blog_os">گیت‌هاب</a> توسعه داده شده است. اگر شما مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. شما همچنین می‌توانید <a href="index.html#comments">در زیر</a> این پست کامنت بگذارید. منبع کد کامل این پست را می‌توانید در بِرَنچ <a href="https://github.com/phil-opp/blog_os/tree/post-04"><code>post-04</code></a> پیدا کنید.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>فهرست مطالب</b></summary>
        <ul>
            <li>
                <a href="index.html#nyzmndyh">نیازمندی‌ها</a>
                
            </li><li>
                <a href="index.html#tst-khrdn-dr-rust">تست کردن در Rust</a>
                <ul>
                    <li>
                        <a href="index.html#frymwrkh-tst-sfrshy">فریم‌ورک تست سفارشی</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khrwj-z-qemu">خروج از QEMU</a>
                <ul>
                    <li>
                        <a href="index.html#pwrthy-i-o">پورت‌های I/O</a>
                    </li><li>
                        <a href="index.html#stfdh-z-dstgh-khrwj">استفاده از دستگاه خروج</a>
                    </li><li>
                        <a href="index.html#khd-khrwj-mwfqyt">کد خروج موفقیت</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#chp-khrdn-dr-khnswl">چاپ کردن در کنسول</a>
                <ul>
                    <li>
                        <a href="index.html#pwrt-sryl">پورت سریال</a>
                    </li><li>
                        <a href="index.html#argwmnhy-qemu">آرگومان‌‌های QEMU</a>
                    </li><li>
                        <a href="index.html#chp-khrdn-pym-kht-hngm-pnykh-khrdn">چاپ کردن پیام خطا هنگام پنیک کردن</a>
                    </li><li>
                        <a href="index.html#pnhn-khrdn-qemu">پنهان کردن QEMU</a>
                    </li><li>
                        <a href="index.html#timeouts">Timeouts</a>
                    </li><li>
                        <a href="index.html#dfh-khrdn-chp-khwdkhr">اضافه کردن چاپ خودکار</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#tst-khrdn-bfr-vga">تست کردن بافر VGA</a>
                
            </li><li>
                <a href="index.html#tsthy-ykhprchh">تست‌های یکپارچه</a>
                <ul>
                    <li>
                        <a href="index.html#skht-ykh-khtbkhnh">ساخت یک کتابخانه</a>
                    </li><li>
                        <a href="index.html#tmm-khrdn-tst-ykhprchh">تمام کردن تست یکپارچه</a>
                    </li><li>
                        <a href="index.html#tsthy-ayndh">تست‌های آینده</a>
                    </li><li>
                        <a href="index.html#tsthyy-khh-byd-pnykh-khnnd">تست‌هایی که باید پنیک کنند</a>
                    </li><li>
                        <a href="index.html#tst-hy-bdwn-mhr">تست های بدون مهار</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khlsh">خلاصه</a>
                
            </li><li>
                <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
        </ul>
    </details>

<h2 id="nyzmndyh"><a class="zola-anchor" href="index.html#nyzmndyh" aria-label="Anchor link for: nyzmndyh">🔗</a>نیازمندی‌ها</h2>
<p>این پست جایگزین (حالا منسوخ شده) پست‌های <a href="../../unit-testing/index.html"><em>Unit Testing</em></a> و <a href="../../integration-tests/index.html"><em>Integration Tests</em></a> می‌شود. فرض بر این است که شما پست <a href="../../minimal-rust-kernel/index.html"><em>یک کرنل مینیمال با Rust</em></a> را پس از 27-09-2019 دنبال کرده‌اید. اساساً نیاز است که شما یک فایل <code>.cargo/config.toml</code> داشته باشید که <a href="../../minimal-rust-kernel/index.html#set-a-default-target">یک هدف پیشفرض مشخص می‌کند</a> و <a href="../../minimal-rust-kernel/index.html#using-cargo-run">یک اجرا کننده قابل اجرا تعریف می‌کند</a>.</p>
<h2 id="tst-khrdn-dr-rust"><a class="zola-anchor" href="index.html#tst-khrdn-dr-rust" aria-label="Anchor link for: tst-khrdn-dr-rust">🔗</a>تست کردن در Rust</h2>
<p>زبان Rust یک <a href="https://doc.rust-lang.org/book/second-edition/ch11-00-testing.html">فریم‌ورک تست توکار</a> دارد که قادر به اجرای تست‌های واحد بدون نیاز به تنظیم هر چیزی است. فقط کافی است تابعی ایجاد کنید که برخی نتایج را از طریق اَسرشن‌ها (کلمه: assertions) بررسی کند و صفت <code>#[test]</code> را به هدر تابع (ترجمه: function header) اضافه کنید. سپس <code>cargo test</code> به طور خودکار تمام تابع‌های تست کریت شما را پیدا و اجرا می‌کند.</p>
<p>متأسفانه برای برنامه‌های <code>no_std</code> مانند هسته ما کمی پیچیده‌تر است. مسئله این است که فریم‌ورک تست Rust به طور ضمنی از کتابخانه <a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a> داخلی استفاده می‌کند که به کتابخانه استاندارد وابسته‌ است. این بدان معناست که ما نمی‌توانیم از فریم‌ورک تست پیشفرض برای هسته <code>#[no_std]</code> خود استفاده کنیم.</p>
<p>وقتی می‌خواهیم <code>cargo test</code> را در پروژه خود اجرا کنیم، چنین چیزی می‌بینیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>   Compiling blog_os v0.1.0 (/…/blog_os)
</span><span>error[E0463]: can&#39;t find crate for `test`
</span></code></pre>
<p>از آن‌جایی که کریت <code>test</code> به کتابخانه استاندارد وابسته است، برای هدف bare metal ما در دسترس نیست. در حالی که استفاده از کریت <code>test</code> در یک <code>#[no_std]</code> <a href="https://github.com/japaric/utest">امکان پذیر است</a>، اما بسیار ناپایدار بوده و به برخی هک‌ها مانند تعریف مجدد ماکرو <code>panic</code> نیاز دارد.</p>
<h3 id="frymwrkh-tst-sfrshy"><a class="zola-anchor" href="index.html#frymwrkh-tst-sfrshy" aria-label="Anchor link for: frymwrkh-tst-sfrshy">🔗</a>فریم‌ورک تست سفارشی</h3>
<p>خوشبختانه، Rust از جایگزین کردن فریم‌ورک تست پیشفرض از طریق ویژگی <a href="https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html"><code>custom_test_frameworks</code></a> ناپایدار پشتیبانی می‌کند. این ویژگی به کتابخانه خارجی احتیاج ندارد و بنابراین در محیط‌های <code>#[no_std]</code> نیز کار می‌کند. این کار با جمع آوری تمام توابع دارای صفت <code>#[test_case]</code> و سپس فراخوانی یک تابع اجرا کننده مشخص شده توسط کاربر و با لیست تست‌ها به عنوان آرگومان کار می‌کند. بنابراین حداکثر کنترل فرآیند تست را به ما می‌دهد.</p>
<p>نقطه ضعف آن در مقایسه با فریم‌ورک تست پیشفرض این است که بسیاری از ویژگی‌های پیشرفته مانند <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic">تست‌های <code>should_panic</code></a> در دسترس نیست. در عوض، تهیه این ویژگی‌ها در صورت نیاز به پیاده‌سازی ما بستگی دارد. این برای ما ایده آل است، زیرا ما یک محیط اجرای بسیار ویژه داریم که پیاده سازی پیشفرض چنین ویژگی‌های پیشرفته‌ای احتمالاً کارساز نخواهد بود. به عنوان مثال‌، صفت <code>#[should_panic]</code> متکی به stack unwinding برای گرفتن پنیک‌ها (کلمه: panics) است، که ما آن را برای هسته خود غیرفعال کردیم.</p>
<p>برای اجرای یک فریم‌ورک تست سفارشی برای هسته خود، موارد زیر را به <code>main.rs</code> اضافه می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Running </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;"> tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>}
</span></code></pre>
<p>اجرا کننده ما فقط یک پیام کوتاه اشکال زدایی را چاپ می‌کند و سپس هر تابع تست درون لیست را فراخوانی می‌کند. نوع آرگومان <code>&amp;[&amp;dyn Fn()]</code> یک <a href="https://doc.rust-lang.org/std/primitive.slice.html"><em>slice</em></a> از <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/trait-objects.html"><em>trait object</em></a> است که آن هم ارجاعی از تِرِیت (کلمه: trait) <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><em>Fn()</em></a> می‌باشد. در اصل لیستی از ارجاع به انواع است که می‌توان آن‌ها را مانند یک تابع صدا زد. از آن‌جایی که این تابع برای اجراهایی که تست نباشند بی فایده است، از ویژگی <code>#[cfg(test)]</code> استفاده می‌کنیم تا آن را فقط برای تست کردن در اضافه کنیم.</p>
<p>حال وقتی که <code>cargo test</code> را اجرا می‌کنیم، می‌بینیم که الان موفقیت آمیز است (اگر اینطور نیست یادداشت زیر را بخوانید). اگرچه، همچنان “Hello World” را به جای پیام <code>test_runner</code> می‌بینیم. دلیلش این است که تابع <code>_start</code> هنوز بعنوان نقطه شروع استفاده می‌شود. ویژگی فریم‌ورک تست سفارشی، یک تابع <code>main</code> ایجاد می‌کند که <code>test_runner</code> را صدا می‌زند، اما این تابع نادیده گرفته می‌شود چرا که ما از ویژگی <code>#[no_main]</code> استفاده می‌کنیم و نقطه شروع خودمان را ایجاد کردیم.</p>
<div class = "warning">
<p><strong>یادداشت:</strong> درحال حاضر یک باگ در کارگو وجود دارد که در برخی موارد وقتی از <code>cargo test</code> استفاده می‌کنیم ما را به سمت خطای “duplicate lang item” می‌برد. زمانی رخ می‌دهد که شما <code>panic = &quot;abort&quot;</code> را برای یک پروفایل در <code>Cargo.toml</code> تنظیم کرده‌اید. سعی کنید آن را حذف کنید، سپس <code>cargo test</code> باید به درستی کار کند. برای اطلاعات بیشتر <a href="https://github.com/rust-lang/cargo/issues/7359">ایشوی کارگو</a> را ببینید.</p>
</div>
<p>برای حل کردن این مشکل، ما ابتدا نیاز داریم که نام تابع تولید شده را از طریق صفت <code>reexport_test_harness_main</code> به چیزی غیر از <code>main</code> تغییر دهیم. سپس می‌توانیم تابع تغییر نام داده شده را از تابع <code>_start</code> صدا بزنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>ما نام فریم‌ورک تست تابع شروع را <code>test_main</code> گذاشتیم و آن را درون <code>_start</code> صدا زدیم. از <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">conditional compilation</a> برای اضافه کردن فراخوانی <code>test_main</code> فقط در زمینه‌های تست استفاده می‌کنیم زیرا تابع روی یک اجرای عادی تولید نشده است.</p>
<p>زمانی که <code>cargo test</code> را اجرا می‌کنیم، می‌بینیم که پیام “Running 0 tests” از <code>test_runner</code> روی صفحه نمایش داده می‌شود. حال ما آماده‌ایم تا اولین تابع تست را بسازیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>حال وقتی <code>cargo test</code> را اجرا می‌کنیم، خروجی زیر را می‌بینیم:</p>
<p><img src="qemu-test-runner-output.png" alt="QEMU printing “Hello World!”, “Running 1 tests”, and “trivial assertion… [ok]”" /></p>
<p>حالا بخش <code>tests</code> ارسال شده به تابع <code>test_runner</code> شامل یک ارجاع به تابع <code>trivial_assertion</code> است. از خروجی <code>trivial assertion... [ok]</code> روی صفحه می‌فهمیم که تست مورد نظر فراخوانی شده و موفقیت آمیز بوده است.</p>
<p>پس از اجرای تست‌ها، <code>test_runner</code> به تابع <code>test_main</code> برمی‌گردد، که به نوبه خود به تابع <code>_start</code> برمی‌گردد. در انتهای <code>_start</code>، یک حلقه بی‌پایان ایجاد می‌کنیم زیرا تابع شروع اجازه برگردادن چیزی را ندارد (یعنی بدون خروجی است). این یک مشکل است، زیرا می‌خواهیم <code>cargo test</code> پس از اجرای تمام تست‌ها به کار خود پایان دهد.</p>
<h2 id="khrwj-z-qemu"><a class="zola-anchor" href="index.html#khrwj-z-qemu" aria-label="Anchor link for: khrwj-z-qemu">🔗</a>خروج از QEMU</h2>
<p>در حال حاضر ما یک حلقه بی‌پایان در انتهای تابع <code>&quot;_start&quot;</code> داریم و باید QEMU را به صورت دستی در هر مرحله از <code>cargo test</code> ببندیم. این جای تأسف دارد زیرا ما همچنین می‌خواهیم <code>cargo test</code> را در اسکریپت‌ها بدون تعامل کاربر اجرا کنیم. یک راه حل خوب می‌تواند اجرای یک روش مناسب برای خاموش کردن سیستم عامل باشد. متأسفانه این کار نسبتاً پیچیده است، زیرا نیاز به پشتیبانی از استاندارد <a href="https://wiki.osdev.org/APM">APM</a> یا <a href="https://wiki.osdev.org/ACPI">ACPI</a> مدیریت توان دارد.</p>
<p>خوشبختانه، یک دریچه فرار وجود دارد: QEMU از یک دستگاه خاص <code>isa-debug-exit</code> پشتیبانی می‌کند، که راهی آسان برای خروج از سیستم QEMU از سیستم مهمان فراهم می‌کند. برای فعال کردن آن، باید یک آرگومان <code>-device</code> را به QEMU منتقل کنیم. ما می‌توانیم این کار را با اضافه کردن کلید پیکربندی <code>pack.metadata.bootimage.test-args</code> در<code> Cargo.toml</code> انجام دهیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [</span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>]
</span></code></pre>
<p><code>bootimage runner</code> برای کلیه تست‌های اجرایی <code> test-args</code> را به دستور پیش فرض QEMU اضافه می کند. برای یک <code>cargo run</code> عادی، آرگومان‌ها نادیده گرفته می‌شوند.</p>
<p>همراه با نام دستگاه (<code>isa-debug-exit</code>)، دو پارامتر <code>iobase</code> و <code>iosize</code> را عبور می‌دهیم که <em>پورت I/O</em> را مشخص می‌کند و هسته از طریق آن می‌تواند به دستگاه دسترسی داشته باشد.</p>
<h3 id="pwrthy-i-o"><a class="zola-anchor" href="index.html#pwrthy-i-o" aria-label="Anchor link for: pwrthy-i-o">🔗</a>پورت‌های I/O</h3>
<p>برای برقراری ارتباط بین پردازنده و سخت افزار جانبی در x86، دو رویکرد مختلف وجود دارد،<strong>memory-mapped I/O</strong> و <strong>port-mapped I/O</strong>. ما قبلاً برای دسترسی به <a href="../../vga-text-mode/index.html">بافر متن VGA</a> از طریق آدرس حافظه <code>0xb8000</code> از memory-mapped I/O استفاده کرده‌ایم. این آدرس به RAM مپ (ترسیم) نشده است، بلکه به برخی از حافظه‌های دستگاه VGA مپ شده است.</p>
<p>در مقابل، port-mapped I/O از یک گذرگاه I/O جداگانه برای ارتباط استفاده می‌کند. هر قسمت جانبی متصل دارای یک یا چند شماره پورت است. برای برقراری ارتباط با چنین پورت I/O، دستورالعمل‌های CPU خاصی وجود دارد که <code>in</code> و <code>out</code> نامیده می‌شوند، که یک عدد پورت و یک بایت داده را می‌گیرند (همچنین این دستورات تغییراتی دارند که اجازه می دهد یک <code>u16</code> یا <code>u32</code> ارسال کنید).</p>
<p>دستگاه‌های <code>isa-debug-exit</code> از port-mapped I/O استفاده می‌کنند. پارامتر <code>iobase</code> مشخص می‌کند که دستگاه باید در کدام آدرس پورت قرار بگیرد (<code>0xf4</code> یک پورت <a href="https://wiki.osdev.org/I/O_Ports#The_list">معمولاً استفاده نشده</a> در گذرگاه IO x86 است) و <code>iosize</code> اندازه پورت را مشخص می‌کند (<code>0x04</code> یعنی چهار بایت).</p>
<h3 id="stfdh-z-dstgh-khrwj"><a class="zola-anchor" href="index.html#stfdh-z-dstgh-khrwj" aria-label="Anchor link for: stfdh-z-dstgh-khrwj">🔗</a>استفاده از دستگاه خروج</h3>
<p>عملکرد دستگاه <code>isa-debug-exit</code> بسیار ساده است. وقتی یک مقدار به پورت I/O مشخص شده توسط <code>iobase</code> نوشته می‌شود، باعث می شود QEMU با <a href="https://en.wikipedia.org/wiki/Exit_status">exit status</a> خارج شود <code>(value &lt;&lt; 1) | 1</code>. بنابراین هنگامی که ما <code>0</code> را در پورت می‌نویسیم، QEMU با وضعیت خروج <code>(0 &lt;&lt; 1) | 1 = 1</code> خارج می‌شود و وقتی که ما <code>1</code> را در پورت می‌نویسیم با وضعیت خروج <code>(1 &lt;&lt; 1) | 1 = 3</code> از آن خارج می شود.</p>
<p>به جای فراخوانی دستی دستورالعمل های اسمبلی <code>in</code> و <code>out</code>، ما از انتزاعات ارائه شده توسط کریت <a href="https://docs.rs/x86_64/0.14.2/x86_64/"><code>x86_64</code></a> استفاده می‌کنیم. برای افزودن یک وابستگی به آن کریت، آن را به بخش <code>dependencies</code> در <code>Cargo.toml</code> اضافه می‌کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">x86_64 </span><span>= </span><span style="color:#d69d85;">&quot;0.14.2&quot;
</span></code></pre>
<p>اکنون می‌توانیم از نوع <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a> ارائه شده توسط کریت برای ایجاد عملکرد <code>exit_qemu</code> استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style="color:#569cd6;">pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style="color:#b5cea8;">0x10</span><span>,
</span><span>    Failed = </span><span style="color:#b5cea8;">0x11</span><span>,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style="color:#569cd6;">as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>این تابع یک <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a> جدید در <code>0xf4</code> ایجاد می‌کند، که <code>iobase</code> دستگاه <code>isa-debug-exit</code> است. سپس کد خروجی عبور داده شده را در پورت می‌نویسد. ما از <code>u32</code> استفاده می‌کنیم زیرا <code>iosize</code> دستگاه <code>isa-debug-exit</code> را به عنوان 4 بایت مشخص کردیم. هر دو عملیات ایمن نیستند، زیرا نوشتن در یک پورت I/O می‌تواند منجر به رفتار خودسرانه شود.</p>
<p>برای تعیین وضعیت خروج، یک ای‌نام (کلمه: enum) <code>QemuExitCode</code> ایجاد می کنیم. ایده این است که اگر همه تست‌ها موفقیت آمیز بود، با کد خروج موفقیت (ترجمه: success exit code) خارج شود و در غیر این صورت با کد خروج شکست (ترجمه: failure exit code) خارج شود. enum به عنوان <code>#[repr(u32)]</code> علامت گذاری شده است تا هر نوع را با یک عدد صحیح <code>u32</code> نشان دهد. برای موفقیت از کد خروجی <code>0x10</code> و برای شکست از <code>0x11</code> استفاده می‌کنیم. کدهای خروجی واقعی چندان هم مهم نیستند، به شرطی که با کدهای خروجی پیش فرض QEMU مغایرت نداشته باشند. به عنوان مثال، استفاده از کد خروجی <code>0</code> برای موفقیت ایده خوبی نیست زیرا پس از تغییر شکل تبدیل به <code>(0 &lt;&lt; 1) | 1 = 1</code> می‌شود، که کد خروجی پیش فرض است برای زمانی که QEMU نمی‌تواند اجرا شود. بنابراین ما نمی‌توانیم خطای QEMU را از یک تست موفقیت آمیز تشخیص دهیم.</p>
<p>اکنون می توانیم <code>test_runner</code> خود را به روز کنیم تا پس از اتمام تست‌ها از QEMU خارج شویم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Running </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;"> tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>    </span><span style="color:#608b4e;">/// new
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>حال وقتی <code>cargo test</code> را اجرا می‌کنیم، می‌بینیم که QEMU پس از اجرای تست‌ها بلافاصله بسته می‌شود. مشکل این است که <code>cargo test</code> تست را به عنوان شکست تفسیر می‌کند حتی اگر کد خروج <code>Success</code> را عبور دهیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-5804fc7d2dd4c9be
</span><span>Building bootloader
</span><span>   Compiling bootloader v0.5.3 (/home/philipp/Documents/bootloader)
</span><span>    Finished release [optimized + debuginfo] target(s) in 1.07s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,
</span><span>    iosize=0x04`
</span><span>error: test failed, to rerun pass &#39;--bin blog_os&#39;
</span></code></pre>
<p>مسئله این است که <code>cargo test</code> همه کدهای خطا به غیر از <code>0</code> را به عنوان شکست در نظر می‌گیرد.</p>
<h3 id="khd-khrwj-mwfqyt"><a class="zola-anchor" href="index.html#khd-khrwj-mwfqyt" aria-label="Anchor link for: khd-khrwj-mwfqyt">🔗</a>کد خروج موفقیت</h3>
<p>برای کار در این مورد، <code>bootimage</code> یک کلید پیکربندی <code>test-success-exit-code</code> ارائه می‌دهد که یک کد خروجی مشخص را به کد خروجی <code>0</code> مپ می‌کند:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [</span><span style="color:#ff3333;">…</span><span>]
</span><span style="color:#569cd6;">test-success-exit-code </span><span>= </span><span style="color:#b5cea8;">33         </span><span style="color:#608b4e;"># (0x10 &lt;&lt; 1) | 1
</span></code></pre>
<p>با استفاده از این پیکربندی، <code>bootimage</code> کد خروج موفقیت ما را به کد خروج 0 مپ می‌کند، به طوری که <code>cargo test</code> به درستی مورد موفقیت را تشخیص می‌دهد و تست را شکست خورده به حساب نمی‌آورد.</p>
<p>اجرا کننده تست ما اکنون به طور خودکار QEMU را می‌بندد و نتایج تست را به درستی گزارش می‌کند. ما همچنان می‌بینیم که پنجره QEMU برای مدت بسیار کوتاهی باز است، اما این مدت بسیار کوتاه برای خواندن نتایج کافی نیست. جالب می‌شود اگر بتوانیم نتایج تست را به جای QEMU در کنسول چاپ کنیم، بنابراین پس از خروج از QEMU هنوز می‌توانیم آنها را ببینیم.</p>
<h2 id="chp-khrdn-dr-khnswl"><a class="zola-anchor" href="index.html#chp-khrdn-dr-khnswl" aria-label="Anchor link for: chp-khrdn-dr-khnswl">🔗</a>چاپ کردن در کنسول</h2>
<p>برای دیدن خروجی تست روی کنسول، باید داده‌ها را از هسته خود به نحوی به سیستم میزبان ارسال کنیم. روش‌های مختلفی برای دستیابی به این هدف وجود دارد، به عنوان مثال با ارسال داده‌ها از طریق رابط شبکه TCP. با این حال، تنظیم پشته شبکه یک کار کاملا پیچیده است، بنابراین ما به جای آن راه حل ساده‌تری را انتخاب خواهیم کرد.</p>
<h3 id="pwrt-sryl"><a class="zola-anchor" href="index.html#pwrt-sryl" aria-label="Anchor link for: pwrt-sryl">🔗</a>پورت سریال</h3>
<p>یک راه ساده برای ارسال داده‌ها استفاده از <a href="https://en.wikipedia.org/wiki/Serial_port">پورت سریال</a> است، یک استاندارد رابط قدیمی که دیگر در رایانه‌های مدرن یافت نمی‌شود. پیاده‌سازی آن آسان است و QEMU می‌تواند بایت‌های ارسالی از طریق سریال را به خروجی استاندارد میزبان یا یک فایل هدایت کند.</p>
<p>تراشه‌های پیاده سازی یک رابط سریال [UART] نامیده می‌شوند. در x86 <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#UART_models">مدلهای UART زیادی</a> وجود دارد، اما خوشبختانه تنها تفاوت آنها ویژگی‌های پیشرفته‌ای است که نیازی به آن‌ها نداریم. UART هایِ رایج امروزه همه با <a href="https://en.wikipedia.org/wiki/16550_UART">16550 UART</a> سازگار هستند، بنابراین ما از آن مدل برای فریم‌ورک تست خود استفاده خواهیم کرد.</p>
<p>ما از کریت <a href="https://docs.rs/uart_16550"><code>uart_16550</code></a> برای شروع اولیه UART و ارسال داده‌ها از طریق پورت سریال استفاده خواهیم کرد. برای افزودن آن به عنوان یک وابستگی، ما <code>Cargo.toml</code> و <code>main.rs</code> خود را به روز می‌کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">uart_16550 </span><span>= </span><span style="color:#d69d85;">&quot;0.2.0&quot;
</span></code></pre>
<p>کریت <code>uart_16550</code> حاوی ساختار <code>SerialPort</code> است که نمایانگر ثبات‌های UART است، اما ما هنوز هم باید نمونه‌ای از آن را خودمان بسازیم. برای آن ما یک ماژول <code>‌serial</code> جدید با محتوای زیر ایجاد می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">mod </span><span>serial;
</span></code></pre>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/serial.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>uart_16550::SerialPort;
</span><span style="color:#569cd6;">use </span><span>spin::Mutex;
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">pub static ref </span><span style="color:#b4cea8;">SERIAL1</span><span>: Mutex&lt;SerialPort&gt; = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> serial_port = </span><span style="color:#569cd6;">unsafe </span><span>{ SerialPort::new(</span><span style="color:#b5cea8;">0x3F8</span><span>) };
</span><span>        serial_port.init();
</span><span>        Mutex::new(serial_port)
</span><span>    };
</span><span>}
</span></code></pre>
<p>مانند <a href="../../vga-text-mode/index.html">بافر متن VGA</a> <a href="../../vga-text-mode/index.html#lazy-statics">vga lazy-static</a>، ما از <code>lazy_static</code> و یک spinlock برای ایجاد یک نمونه نویسنده <code>static</code> استفاده می‌کنیم. با استفاده از <code>lazy_static</code> می‌توان اطمینان حاصل کرد که متد <code>init</code> در اولین استفاده دقیقاً یک بار فراخوانی می‌شود.</p>
<p>مانند دستگاه <code>isa-debug-exit</code>، UART با استفاده از پورت I/O برنامه نویسی می‌شود. از آنجا که UART پیچیده‌تر است، از چندین پورت I/O برای برنامه نویسی رجیسترهای مختلف دستگاه استفاده می‌کند. تابع ناامن <code>SerialPort::new</code> انتظار دارد که آدرس اولین پورت I/O از UART به عنوان آرگومان باشد، که از آن می‌تواند آدرس تمام پورت‌های مورد نیاز را محاسبه کند. ما در حال عبور دادنِ آدرس پورت <code>0x3F8</code> هستیم که شماره پورت استاندارد برای اولین رابط سریال است.</p>
<p>برای اینکه پورت سریال به راحتی قابل استفاده باشد، ماکروهای <code>serial_print!</code> و <code>serial_println!</code> را اضافه می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[doc(hidden)]
</span><span style="color:#569cd6;">pub fn </span><span>_print(args: ::core::fmt::Arguments) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#b4cea8;">SERIAL1</span><span>.lock().write_fmt(args).expect(</span><span style="color:#d69d85;">&quot;Printing to serial failed&quot;</span><span>);
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Prints to the host through the serial interface.
</span><span>#[macro_export]
</span><span>macro_rules! serial_print {
</span><span>    (</span><span style="color:#569cd6;">$</span><span>($arg:</span><span style="color:#569cd6;">tt</span><span>)</span><span style="color:#569cd6;">*</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>{
</span><span>        $crate::serial::_print(format_args!(</span><span style="color:#569cd6;">$</span><span>($arg)*));
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Prints to the host through the serial interface, appending a newline.
</span><span>#[macro_export]
</span><span>macro_rules! serial_println {
</span><span>    () </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(</span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>));
</span><span>    ($fmt:</span><span style="color:#569cd6;">expr</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(concat!($fmt, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>)));
</span><span>    ($fmt:</span><span style="color:#569cd6;">expr</span><span>, </span><span style="color:#569cd6;">$</span><span>($arg:</span><span style="color:#569cd6;">tt</span><span>)</span><span style="color:#569cd6;">*</span><span>) </span><span style="color:#569cd6;">=&gt; </span><span>($crate::serial_print</span><span style="color:#569cd6;">!</span><span>(
</span><span>        concat!($fmt, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>), </span><span style="color:#569cd6;">$</span><span>($arg)*));
</span><span>}
</span></code></pre>
<p>پیاده سازی بسیار شبیه به پیاده سازی ماکروهای <code>print</code> و<code> println</code> است. از آنجا که نوع <code>SerialPort</code> تِرِیت <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html"><code>fmt::Write</code></a> را پیاده سازی می‌کند، نیازی نیست این پیاده سازی را خودمان انجام دهیم.</p>
<p>اکنون می‌توانیم به جای بافر متن VGA در کد تست خود، روی رابط سریال چاپ کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    […]
</span><span>}
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>توجه داشته باشید که ماکرو <code>serial_println</code> مستقیماً در زیر فضای نام (ترجمه: namespace) ریشه قرار می‌گیرد زیرا ما از صفت <code>#[macro_export]</code> استفاده کردیم، بنابراین وارد کردن آن از طریق <code>use crate::serial::serial_println</code> کار نمی کند.</p>
<h3 id="argwmnhy-qemu"><a class="zola-anchor" href="index.html#argwmnhy-qemu" aria-label="Anchor link for: argwmnhy-qemu">🔗</a>آرگومان‌‌های QEMU</h3>
<p>برای دیدن خروجی سریال از QEMU، باید از آرگومان <code>-serial</code> برای هدایت خروجی به stdout (خروجی استاندارد) استفاده کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [
</span><span>    </span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>, </span><span style="color:#d69d85;">&quot;-serial&quot;</span><span>, </span><span style="color:#d69d85;">&quot;stdio&quot;
</span><span>]
</span></code></pre>
<p>حالا وقتی <code>cargo test</code> را اجرا می‌کنیم، خروجی تست را مستقیماً در کنسول مشاهده خواهیم گرد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [ok]
</span></code></pre>
<p>با این حال، هنگامی که یک تست ناموفق بود، ما همچنان خروجی را داخل QEMU مشاهده می‌کنیم، زیرا panic handler هنوز از <code>println</code> استفاده می‌کند. برای شبیه‌سازی این، می‌توانیم assertion درون تست <code>trivial_assertion</code> را به <code>assert_eq!(0, 1)</code> تغییر دهیم:</p>
<p><img src="qemu-failed-test.png" alt="QEMU printing “Hello World!” and “panicked at ‘assertion failed: (left == right) left: 0, right: 1’, src/main.rs:55:5" /></p>
<p>می‌بینیم که پیام panic (تلفظ: پَنیک) هنوز در بافر VGA چاپ می‌شود، در حالی که خروجی‌ تست دیگر (منظور تستی می‌باشد که پنیک نکند) در پورت سریال چاپ می‌شود. پیام پنیک کاملاً مفید است، بنابراین دیدن آن در کنسول نیز مفید خواهد بود.</p>
<h3 id="chp-khrdn-pym-kht-hngm-pnykh-khrdn"><a class="zola-anchor" href="index.html#chp-khrdn-pym-kht-hngm-pnykh-khrdn" aria-label="Anchor link for: chp-khrdn-pym-kht-hngm-pnykh-khrdn">🔗</a>چاپ کردن پیام خطا هنگام پنیک کردن</h3>
<p>برای خروج از QEMU با یک پیام خطا هنگامی که پنیک رخ می‌دهد، می‌توانیم از <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html">conditional compilation</a> برای استفاده از یک panic handler متفاوت در حالت تست استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// our existing panic handler
</span><span>#[cfg(not(test))] </span><span style="color:#608b4e;">// new attribute
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// our panic handler in test mode
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[failed]</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Error: {}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>برای panic handler تستِ خودمان، از <code>serial_println</code> به جای <code>println</code> استفاده می‌کنیم و سپس با کد خروج خطا از QEMU خارج می‌شویم. توجه داشته باشید که بعد از فراخوانی <code>exit_qemu</code> هنوز به یک حلقه بی‌پایان نیاز داریم زیرا کامپایلر نمی‌داند که دستگاه <code>isa-debug-exit</code> باعث خروج برنامه می‌شود.</p>
<p>اکنون QEMU برای تست‌های ناموفق نیز خارج شده و یک پیام خطای مفید روی کنسول چاپ می کند:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [failed]
</span><span>
</span><span>Error: panicked at &#39;assertion failed: `(left == right)`
</span><span>  left: `0`,
</span><span> right: `1`&#39;, src/main.rs:65:5
</span></code></pre>
<p>از آن‌جایی که اکنون همه خروجی‌های تست را در کنسول مشاهده می‌کنیم، دیگر نیازی به پنجره QEMU نداریم که برای مدت کوتاهی ظاهر می‌شود. بنابراین می‌توانیم آن را کاملا پنهان کنیم.</p>
<h3 id="pnhn-khrdn-qemu"><a class="zola-anchor" href="index.html#pnhn-khrdn-qemu" aria-label="Anchor link for: pnhn-khrdn-qemu">🔗</a>پنهان کردن QEMU</h3>
<p>از آنجا که ما نتایج کامل تست را با استفاده از دستگاه <code>isa-debug-exit</code> و پورت سریال گزارش می‌کنیم، دیگر نیازی به پنجره QEMU نداریم. ما می‌توانیم آن را با عبور دادن آرگومان <code>-display none</code> به QEMU پنهان کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-args </span><span>= [
</span><span>    </span><span style="color:#d69d85;">&quot;-device&quot;</span><span>, </span><span style="color:#d69d85;">&quot;isa-debug-exit,iobase=0xf4,iosize=0x04&quot;</span><span>, </span><span style="color:#d69d85;">&quot;-serial&quot;</span><span>, </span><span style="color:#d69d85;">&quot;stdio&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;-display&quot;</span><span>, </span><span style="color:#d69d85;">&quot;none&quot;
</span><span>]
</span></code></pre>
<p>اکنون QEMU کاملا در پس زمینه اجرا می‌شود و دیگر هیچ پنجره‌ای باز نمی‌شود. این نه تنها کمتر آزار دهنده است، بلکه به فریم‌ورک تست ما این امکان را می‌دهد که در محیط‌های بدون رابط کاربری گرافیکی مانند سرویس‌های CI یا کانکشن‌های <a href="https://en.wikipedia.org/wiki/Secure_Shell">SSH</a> اجرا شود.</p>
<h3 id="timeouts"><a class="zola-anchor" href="index.html#timeouts" aria-label="Anchor link for: timeouts">🔗</a>Timeouts</h3>
<p>از آنجا که <code>cargo test</code> منتظر می‌ماند تا test runner (ترجمه: اجرا کننده تست) پایان یابد، تستی که هرگز به اتمام نمی‌رسد (چه موفق، چه ناموفق) می‌تواند برای همیشه اجرا کننده تست را مسدود کند. این جای تأسف دارد، اما در عمل مشکل بزرگی نیست زیرا اجتناب از حلقه‌های بی‌پایان به طور معمول آسان است. با این حال، در مورد ما، حلقه‌های بی‌پایان می‌توانند در موقعیت‌های مختلف رخ دهند:</p>
<ul>
<li>بوت لودر موفق به بارگیری هسته نمی‌شود، در نتیجه سیستم به طور بی‌وقفه راه اندازی مجدد شود.</li>
<li>فریم‌ورک BIOS/UEFI قادر به بارگیری بوت لودر نمی‌شود، در نتیجه باز هم باعث راه‌اندازی مجدد بی‌پایان می‌شود.</li>
<li>وقتی که CPU در انتهای برخی از توابع ما وارد یک <code>loop {}</code> (حلقه بی‌پایان) می‌شود، به عنوان مثال به دلیل اینکه دستگاه خروج QEMU به درستی کار نمی‌کند.</li>
<li>یا وقتی که سخت افزار باعث ریست شدن سیستم می‌شود، به عنوان مثال وقتی یک استثنای پردازنده (ترجمه: CPU exception) گیر نمی‌افتد (در پست بعدی توضیح داده شده است).</li>
</ul>
<p>از آنجا که حلقه های بی‌پایان در بسیاری از شرایط ممکن است رخ دهد، به طور پیش فرض ابزار <code>bootimage</code> برای هر تست ۵ دقیقه زمان تعیین می‌کند. اگر تست در این زمان به پایان نرسد، به عنوان ناموفق علامت گذاری شده و خطای “Timed Out” در کنسول چاپ می شود. این ویژگی تضمین می‌کند که تست‌هایی که در یک حلقه بی‌پایان گیر کرده‌اند، <code>cargo test</code> را برای همیشه مسدود نمی‌کنند.</p>
<p>خودتان می‌توانید با افزودن عبارت <code>loop {}</code> در تست <code>trivial_assertion</code> آن را امتحان کنید. هنگامی که <code>cargo test</code> را اجرا می‌کنید، می‌بینید که این تست پس از ۵ دقیقه به پایان رسیده است. مدت زمان مهلت از طریق یک کلید <code>test-timeout</code> در Cargo.toml <a href="https://github.com/rust-osdev/bootimage#configuration">قابل پیکربندی</a> است:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">package.metadata.bootimage</span><span>]
</span><span style="color:#569cd6;">test-timeout </span><span>= </span><span style="color:#b5cea8;">300          </span><span style="color:#608b4e;"># (in seconds)
</span></code></pre>
<p>اگر نمی‌خواهید ۵ دقیقه منتظر بمانید تا تست <code>trivial_assertion</code> تمام شود، می‌توانید به طور موقت مقدار فوق را کاهش دهید.</p>
<h3 id="dfh-khrdn-chp-khwdkhr"><a class="zola-anchor" href="index.html#dfh-khrdn-chp-khwdkhr" aria-label="Anchor link for: dfh-khrdn-chp-khwdkhr">🔗</a>اضافه کردن چاپ خودکار</h3>
<p>تست <code>trivial_assertion</code> در حال حاضر باید اطلاعات وضعیت خود را با استفاده از <code>serial_print!</code>/<code>serial_println!</code> چاپ کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;trivial assertion... &quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>افزودن دستی این دستورات چاپی برای هر تستی که می‌نویسیم دست و پا گیر است، بنابراین بیایید <code>test_runner</code> خود را به روز کنیم تا به صورت خودکار این پیام‌ها را چاپ کنیم. برای انجام این کار، ما باید یک تریت جدید به نام <code>Testable</code> ایجاد کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">pub trait </span><span>Testable {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; ();
</span><span>}
</span></code></pre>
<p>این ترفند اکنون پیاده سازی این تریت برای همه انواع <code>T</code> است که <a href="https://doc.rust-lang.org/stable/core/ops/trait.Fn.html"><code>Fn()</code> trait</a> را پیاده سازی می‌کنند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">impl</span><span>&lt;T&gt; Testable </span><span style="color:#569cd6;">for </span><span>T
</span><span style="color:#569cd6;">where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        serial_print!(</span><span style="color:#d69d85;">&quot;{}...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>, core::any::type_name::&lt;T&gt;());
</span><span>        self();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>ما با اولین چاپِ نام تابع از طریق تابعِ <a href="https://doc.rust-lang.org/stable/core/any/fn.type_name.html"><code>any::type_name</code></a>، تابع <code>run</code> را پیاده سازی می کنیم. این تابع مستقیماً در کامپایلر پیاده سازی شده و یک رشته توضیح از هر نوع را برمی‌گرداند. برای توابع، نوع آنها نامشان است، بنابراین این دقیقاً همان چیزی است که ما در این مورد می‌خواهیم. کاراکتر <code>\t</code> <a href="https://en.wikipedia.org/wiki/Tab_key#Tab_characters">کاراکتر tab</a> است، که مقداری ترازبندی‌ به پیام‌های <code>[ok]</code> اضافه می‌کند.</p>
<p>پس از چاپ نام تابع، ما از طریق <code>self ()</code> تابع تست را فراخوانی می‌کنیم. این فقط به این دلیل کار می‌کند که ما نیاز داریم که <code>self</code> تریت <code>Fn()</code> را پیاده سازی کند. بعد از بازگشت تابع تست، ما <code>[ok]</code> را چاپ می‌کنیم تا نشان دهد که تابع پنیک نکرده است.</p>
<p>آخرین مرحله به روزرسانی <code>test_runner</code> برای استفاده از تریت جدید<code> Testable</code> است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Testable]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test.run(); </span><span style="color:#608b4e;">// new
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>تنها دو تغییر رخ داده، نوع آرگومان <code>tests</code> از <code>&amp;[&amp;dyn Fn()]</code> به <code>&amp;[&amp;dyn Testable]</code> است و ما اکنون <code>test.run()</code> را به جای <code>test()</code> فراخوانی می‌کنیم.</p>
<p>اکنون می‌توانیم عبارات چاپ را از تست <code>trivial_assertion</code> حذف کنیم، زیرا آن‌ها اکنون به طور خودکار چاپ می‌شوند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>trivial_assertion() {
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span></code></pre>
<p>خروجی <code>cargo test</code> اکنون به این شکل است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>Running 1 tests
</span><span>blog_os::trivial_assertion...	[ok]
</span></code></pre>
<p>نام تابع اکنون مسیر کامل به تابع را شامل می‌شود، که زمانی مفید است که توابع تست در ماژول‌های مختلف نام یکسانی دارند. در غیر اینصورت خروجی همانند قبل است، اما دیگر نیازی نیست که به صورت دستی دستورات چاپ را به تست‌های خود اضافه کنیم.</p>
<h2 id="tst-khrdn-bfr-vga"><a class="zola-anchor" href="index.html#tst-khrdn-bfr-vga" aria-label="Anchor link for: tst-khrdn-bfr-vga">🔗</a>تست کردن بافر VGA</h2>
<p>اکنون که یک فریم‌ورک تستِ کارا داریم، می‌توانیم چند تست برای اجرای بافر VGA خود ایجاد کنیم. ابتدا، ما یک تست بسیار ساده برای تأیید اینکه <code>println</code> بدون پنیک کردن کار می‌کند ایجاد می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_simple() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;test_println_simple output&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>این تست فقط چیزی را در بافر VGA چاپ می کند. اگر بدون پنیک تمام شود، به این معنی است که فراخوانی <code>println</code> نیز پنیک نکرده است.</p>
<p>برای اطمینان از این‌ که پنیک ایجاد نمی‌شود حتی اگر خطوط زیادی چاپ شده و خطوط از صفحه خارج شوند، می‌توانیم آزمایش دیگری ایجاد کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_many() {
</span><span>    </span><span style="color:#569cd6;">for _ in </span><span style="color:#b5cea8;">0</span><span style="color:#569cd6;">..</span><span style="color:#b5cea8;">200 </span><span>{
</span><span>        println!(</span><span style="color:#d69d85;">&quot;test_println_many output&quot;</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>همچنین می‌توانیم تابع تستی ایجاد کنیم تا تأیید کنیم که خطوط چاپ شده واقعاً روی صفحه ظاهر می شوند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_output() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> s = </span><span style="color:#d69d85;">&quot;Some test string that fits on a single line&quot;</span><span>;
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, s);
</span><span>    </span><span style="color:#569cd6;">for </span><span>(i, c) </span><span style="color:#569cd6;">in</span><span> s.chars().enumerate() {
</span><span>        </span><span style="color:#569cd6;">let</span><span> screen_char = </span><span style="color:#b4cea8;">WRITER</span><span>.lock().buffer.chars[</span><span style="color:#b4cea8;">BUFFER_HEIGHT </span><span>- </span><span style="color:#b5cea8;">2</span><span>][i].read();
</span><span>        assert_eq!(</span><span style="color:#569cd6;">char</span><span>::from(screen_char.ascii_character), c);
</span><span>    }
</span><span>}
</span></code></pre>
<p>این تابع یک رشته آزمایشی را تعریف می‌کند، آن را با استفاده از <code>println</code> چاپ می‌کند و سپس بر روی کاراکترهای صفحه از <code> WRITER</code> ثابت تکرار (iterate) می‌کند، که نشان دهنده بافر متن vga است. از آنجا که <code>println</code> در آخرین خط صفحه چاپ می‌شود و سپس بلافاصله یک خط جدید اضافه می‌کند، رشته باید در خط<code> BUFFER_HEIGHT - 2</code> ظاهر شود.</p>
<p>با استفاده از <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>، تعداد تکرارها را در متغیر <code>i</code> حساب می‌کنیم، سپس از آن‌ها برای بارگذاری کاراکتر صفحه مربوط به <code>c</code> استفاده می‌کنیم. با مقایسه <code>ascii_character</code> از کاراکتر صفحه با <code>c</code>، اطمینان حاصل می‌کنیم که هر کاراکتر از این رشته واقعاً در بافر متن vga ظاهر می‌شود.</p>
<p>همانطور که می‌توانید تصور کنید، ما می‌توانیم توابع تست بیشتری ایجاد کنیم، به عنوان مثال تابعی که تست می‌کند هنگام چاپ خطوط طولانی پنیک ایجاد نمی‌شود و به درستی بسته‌بندی می‌شوند. یا تابعی برای تست این که خطوط جدید، کاراکترهای غیرقابل چاپ (ترجمه: non-printable) و کاراکترهای non-unicode به درستی اداره می‌شوند.</p>
<p>برای بقیه این پست، ما نحوه ایجاد <em>integration tests</em> را برای تست تعامل اجزای مختلف با هم توضیح خواهیم داد.</p>
<h2 id="tsthy-ykhprchh"><a class="zola-anchor" href="index.html#tsthy-ykhprchh" aria-label="Anchor link for: tsthy-ykhprchh">🔗</a>تست‌های یکپارچه</h2>
<p>قرارداد <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">تست‌های یکپارچه</a> در Rust این است که آن‌ها را در یک دایرکتوری <code>tests</code> در ریشه پروژه قرار دهید (یعنی در کنار فهرست <code>src</code>).  فریم‌ورک تست پیش فرض و فریم‌ورک‌های تست سفارشی به طور خودکار تمام تست‌های موجود در آن فهرست را انتخاب و اجرا می‌کنند.</p>
<p>همه تست‌های یکپارچه، فایل اجرایی خاص خودشان هستند و کاملاً از <code>main.rs</code> جدا هستند. این بدان معناست که هر تست باید تابع نقطه شروع خود را مشخص کند. بیایید یک نمونه تست یکپارچه به نام <code>basic_boot</code> ایجاد کنیم تا با جزئیات ببینیم که چگونه کار می‌کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// don&#39;t mangle the name of this function
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    unimplemented!();
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>از آن‌جا که تست‌های یکپارچه فایل‌های اجرایی جداگانه‌ای هستند، ما باید تمام صفت‌های کریت (<code>no_std</code>، <code>no_main</code>، <code>test_runner</code> و غیره) را دوباره تهیه کنیم. ما همچنین باید یک تابع شروع جدید <code>_start</code> ایجاد کنیم که تابع نقطه شروع تست <code>test_main</code> را فراخوانی می‌کند. ما به هیچ یک از ویژگی‌های <code>cfg (test)</code> نیازی نداریم زیرا اجرایی‌های تست یکپارچه هرگز در حالت غیر تست ساخته نمی‌شوند.</p>
<p>ما از ماکرو [ʻunimplemented] استفاده می‌کنیم که همیشه به عنوان یک مکان نگهدار برای تابع <code>test_runner</code> پنیک می‌کند و فقط در حلقه رسیدگی کننده <code>panic</code> فعلاً <code>loop</code> می‌زند. در حالت ایده آل، ما می‌خواهیم این توابع را دقیقاً همانطور که در <code>main.rs</code> خود با استفاده از ماکرو<code> serial_println</code> و تابع <code>exit_qemu</code> پیاده سازی کردیم، پیاده سازی کنیم. مشکل این است که ما به این توابع دسترسی نداریم زیرا تست‌ها کاملاً جدا از اجرایی <code>main.rs</code> ساخته شده‌اند.</p>
<p>اگر در این مرحله <code>cargo test</code> را انجام دهید، یک حلقه بی‌پایان خواهید گرفت زیرا رسیدگی کننده پنیک دارای حلقه بی‌پایان است. برای خروج از QEMU باید از میانبر صفحه کلید <code>Ctrl + c</code> استفاده کنید.</p>
<h3 id="skht-ykh-khtbkhnh"><a class="zola-anchor" href="index.html#skht-ykh-khtbkhnh" aria-label="Anchor link for: skht-ykh-khtbkhnh">🔗</a>ساخت یک کتابخانه</h3>
<p>برای در دسترس قرار دادن توابع مورد نیاز در تست یکپارچه، باید یک کتابخانه را از <code>main.rs</code> جدا کنیم، کتابخانه‌ای که می‌تواند توسط کریت‌های دیگر و تست‌های یکپارچه مورد استفاده قرار بگیرد. برای این کار، یک فایل جدید <code>src/lib.rs</code> ایجاد می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// src/lib.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span></code></pre>
<p>مانند <code>main.rs</code> ،<code>lib.rs</code> یک فایل خاص است که به طور خودکار توسط کارگو شناسایی می‌شود. کتابخانه یک واحد تلفیقی جداگانه است، بنابراین باید ویژگی <code>#![no_std]</code> را دوباره مشخص کنیم.</p>
<p>برای اینکه کتابخانه‌مان با <code>cargo test</code> کار کند، باید توابع و صفت‌های تست را نیز اضافه کنیم:
To make our library work with <code>cargo test</code>, we need to also add the test functions and attributes:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span>#![cfg_attr(test, no_main)]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#569cd6;">pub trait </span><span>Testable {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) -&gt; ();
</span><span>}
</span><span>
</span><span style="color:#569cd6;">impl</span><span>&lt;T&gt; Testable </span><span style="color:#569cd6;">for </span><span>T
</span><span style="color:#569cd6;">where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style="color:#569cd6;">fn </span><span>run(</span><span style="color:#569cd6;">&amp;</span><span>self) {
</span><span>        serial_print!(</span><span style="color:#d69d85;">&quot;{}...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>, core::any::type_name::&lt;T&gt;());
</span><span>        self();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Testable]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test.run();
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_panic_handler(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[failed]</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Error: {}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Entry point for `cargo test`
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>برای اینکه <code>test_runner</code> را در دسترس ‌تست‌های یکپارچه و فایل‌های اجرایی قرار دهیم، صفت <code>cfg(test)</code> را روی آن اعمال نمی‌کنیم و عمومی نمی‌کنیم. ما همچنین پیاده سازی رسیدگی کننده پنیک خود را به یک تابع عمومی <code>test_panic_handler</code> تبدیل می‌کنیم، به طوری که برای اجرایی‌ها نیز در دسترس باشد.</p>
<p>از آن‌جا که <code>lib.rs</code> به طور مستقل از<code> main.rs</code> ما تست می‌شود، هنگام کامپایل کتابخانه در حالت تست، باید یک نقطه شروع <code>_start</code> و یک رسیدگی کننده پنیک اضافه کنیم. با استفاده از صفت کریت <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>، در این حالت ویژگی<code>no_main</code> را به طور مشروط فعال می‌کنیم.</p>
<p>ما همچنین ای‌نام <code>QemuExitCode</code> و تابع <code>exit_qemu</code> را عمومی می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style="color:#569cd6;">pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style="color:#b5cea8;">0x10</span><span>,
</span><span>    Failed = </span><span style="color:#b5cea8;">0x11</span><span>,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style="color:#569cd6;">as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>اکنون فایل‌های اجرایی و تست‌های یکپارچه می‌توانند این توابع را از کتابخانه وارد کنند و نیازی به تعریف پیاده سازی‌های خود ندارند. برای در دسترس قرار دادن <code>println</code> و <code>serial_println</code>، اعلان ماژول‌ها را نیز منتقل می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>serial;
</span><span style="color:#569cd6;">pub mod </span><span>vga_buffer;
</span></code></pre>
<p>ما ماژول‌ها را عمومی می‌کنیم تا از خارج از کتابخانه قابل استفاده باشند. این امر همچنین برای استفاده از ماکروهای <code>println</code> و <code>serial_println</code> مورد نیاز است، زیرا آنها از توابع <code>_print</code> ماژول‌ها استفاده می‌کنند.</p>
<p>اکنون می توانیم <code>main.rs</code> خود را برای استفاده از کتابخانه به روز کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// src/main.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::println;
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// This function is called on panic.
</span><span>#[cfg(not(test))]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>کتابخانه مانند یک کریت خارجی معمولی قابل استفاده است. و مانند کریت (که در مورد ما کریت <code>blog_os</code> است) فراخوانی می‌شود. کد فوق از تابع <code>blog_os :: test_runner</code> در صفت <code>test_runner</code> و تابع <code>blog_os :: test_panic_handler</code> در رسیدگی کننده پنیک <code>cfg(test)</code> استفاده می‌کند. همچنین ماکرو <code>println</code> را وارد می‌کند تا در اختیار توابع <code>_start</code> و <code>panic</code> قرار گیرد.</p>
<p>در این مرحله، <code>cargo run</code> و <code>cargo test</code> باید دوباره کار کنند. البته، <code>cargo test</code> هنوز هم در یک حلقه بی‌پایان گیر می‌کند (با <code>ctrl + c</code> می‌توانید خارج شوید). بیایید با استفاده از توابع مورد نیاز کتابخانه در تست یکپارچه این مشکل را برطرف کنیم.</p>
<h3 id="tmm-khrdn-tst-ykhprchh"><a class="zola-anchor" href="index.html#tmm-khrdn-tst-ykhprchh" aria-label="Anchor link for: tmm-khrdn-tst-ykhprchh">🔗</a>تمام کردن تست یکپارچه</h3>
<p>مانند <code>src/main.rs</code>، اجرایی<code> test/basic_boot.rs</code> می‌تواند انواع مختلفی را از کتابخانه جدید ما وارد کند. که این امکان را به ما می‌دهد تا اجزای گمشده را برای تکمیل آزمایش وارد کنیم.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>ما به جای پیاده سازی مجدد اجرا کننده تست، از تابع <code>test_runner</code> در کتابخانه خود استفاده می‌کنیم. برای رسیدگی کننده <code>panic</code>، ما تابع <code>blog_os::test_panic_handler</code> را مانند آن‌چه در <code>main.rs</code> انجام دادیم، فراخوانی می‌کنیم.</p>
<p>اکنون <code>cargo test</code> مجدداً به طور معمول وجود دارد. وقتی آن را اجرا می‌کنید ، می‌بینید که تست‌های <code>lib.rs</code>، <code>main.rs</code> و <code>basic_boot.rs</code> ما را به طور جداگانه و یکی پس از دیگری ایجاد و اجرا می‌کند. برای تست‌های یکپارچه <code>main.rs</code> و <code>basic_boot</code>، متن “Running 0 tests” را نشان می‌دهد زیرا این فایل‌ها هیچ تابعی با حاشیه نویسی <code>#[test_case]</code> ندارد.</p>
<p>اکنون می‌توانیم تست‌ها را به <code>basic_boot.rs</code> خود اضافه کنیم. به عنوان مثال، ما می‌توانیم آزمایش کنیم که <code>println</code> بدون پنیک کار می‌کند، مانند آنچه در تست‌های بافر vga انجام دادیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/basic_boot.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::println;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;test_println output&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>حال وقتی <code>cargo test</code> را اجرا می‌کنیم، می‌بینیم که این تابع تست را پیدا و اجرا می‌کند.</p>
<p>این تست ممکن است در حال حاضر کمی بی‌فایده به نظر برسد، زیرا تقریباً مشابه یکی از تست‌های بافر VGA است. با این حال، در آینده ممکن است توابع <code>_start</code> ما از <code>main.rs</code> و <code>lib.rs</code> رشد کرده و روال‌های اولیه مختلفی را قبل از اجرای تابع <code>test_main</code> فراخوانی کنند، به طوری که این دو تست در محیط‌های بسیار مختلف اجرا می‌شوند.</p>
<h3 id="tsthy-ayndh"><a class="zola-anchor" href="index.html#tsthy-ayndh" aria-label="Anchor link for: tsthy-ayndh">🔗</a>تست‌های آینده</h3>
<p>قدرت تست‌های یکپارچه این است که با آن‌ها به عنوان اجرایی کاملاً جداگانه برخورد می‌شود. این امر به آن‌ها اجازه کنترل کامل بر محیط را می‌دهد، و امکان تست کردن این که کد به درستی با CPU یا دستگاه‌های سخت‌افزاری ارتباط دارد را به ما می‌دهد.</p>
<p>تست <code>basic_boot</code> ما یک مثال بسیار ساده برای تست یکپارچه است. در آینده، هسته ما ویژگی‌های بسیار بیشتری پیدا می‌کند و از راه‌های مختلف با سخت افزار ارتباط برقرار می‌کند. با افزودن تست های یکپارچه، می‌توانیم اطمینان حاصل کنیم که این تعاملات مطابق انتظار کار می‌کنند (و به کار خود ادامه می‌دهند). برخی از ایده‌ها برای تست‌های احتمالی در آینده عبارتند از:</p>
<ul>
<li>
<p><strong>استثنائات CPU</strong>: هنگامی که این کد عملیات نامعتبری را انجام می‌دهد (به عنوان مثال تقسیم بر صفر)، CPU یک استثنا را ارائه می‌دهد. هسته می‌تواند توابع رسیدگی کننده را برای چنین مواردی ثبت کند. یک تست یکپارچه می‌تواند تأیید کند که در صورت بروز استثنا پردازنده ، رسیدگی کننده استثنای صحیح فراخوانی می‌شود یا اجرای آن پس از استثناهای قابل حل به درستی ادامه دارد.</p>
</li>
<li>
<p><strong>جدول‌های صفحه</strong>: جدول‌های صفحه مشخص می‌کند که کدام مناطق حافظه معتبر و قابل دسترسی هستند. با اصلاح جدول‌های صفحه، می‌توان مناطق حافظه جدیدی را اختصاص داد، به عنوان مثال هنگام راه‌اندازی برنامه‌ها. یک تست یکپارچه می‌تواند برخی از تغییرات جدول‌های صفحه را در تابع <code>_start</code> انجام دهد و سپس تأیید کند که این تغییرات در تابع‌های <code># [test_case]</code> اثرات مطلوبی دارند.</p>
</li>
<li>
<p><strong>برنامه‌های فضای کاربر</strong>: برنامه‌های فضای کاربر برنامه‌هایی با دسترسی محدود به منابع سیستم هستند. به عنوان مثال، آنها به ساختار داده‌های هسته یا حافظه برنامه‌های دیگر دسترسی ندارند. یک تست یکپارچه می‌تواند برنامه‌های فضای کاربر را که عملیات‌های ممنوعه را انجام می‌دهند راه‌اندازی کرده و بررسی کند هسته از همه آن‌ها جلوگیری می‌کند.</p>
</li>
</ul>
<p>همانطور که می‌توانید تصور کنید، تست‌های بیشتری امکان پذیر است. با افزودن چنین تست‌هایی، می‌توانیم اطمینان حاصل کنیم که وقتی ویژگی‌های جدیدی به هسته خود اضافه می‌کنیم یا کد خود را دوباره می‌سازیم، آن‌ها را به طور تصادفی خراب نمی‌کنیم. این امر به ویژه هنگامی مهم‌تر می‌شود که هسته ما بزرگتر و پیچیده‌تر شود.</p>
<h3 id="tsthyy-khh-byd-pnykh-khnnd"><a class="zola-anchor" href="index.html#tsthyy-khh-byd-pnykh-khnnd" aria-label="Anchor link for: tsthyy-khh-byd-pnykh-khnnd">🔗</a>تست‌هایی که باید پنیک کنند</h3>
<p>فریم‌ورک تست کتابخانه استاندارد از <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testing-panics">صفت <code>#[should_panic]</code></a> پشتیبانی می‌کند که اجازه می‌دهد تست‌هایی را بسازد که باید ناموفق شوند (باید پنیک کنند). این مفید است، به عنوان مثال برای تأیید پنیک کردن یک تابع هنگام عبور دادن یک آرگومان نامعتبر به آن. متأسفانه این ویژگی در کریت‌های <code>#[no_std]</code> پشتیبانی نمی‌شود زیرا به پشتیبانی از کتابخانه استاندارد نیاز دارد.</p>
<p>اگرچه نمی‌توانیم از صفت <code>#[should_panic]</code> در هسته خود استفاده کنیم، اما می‌توانیم با ایجاد یک تست یکپارچه که با کد خطای موفقیت آمیز از رسیدگی کننده پنیک خارج می‌شود، رفتار مشابهی داشته باشیم. بیایید شروع به ایجاد چنین تستی با نام <code>should_panic</code> کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::{QemuExitCode, exit_qemu, serial_println};
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>این تست هنوز ناقص است زیرا هنوز تابع <code>_start</code> یا هیچ یک از صفت‌های اجرا کننده تست سفارشی را مشخص نکرده. بیایید قسمت‌های گمشده را اضافه کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_runner(tests: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">&amp;</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Running {} tests&quot;</span><span>, tests.len());
</span><span>    </span><span style="color:#569cd6;">for</span><span> test </span><span style="color:#569cd6;">in</span><span> tests {
</span><span>        test();
</span><span>        serial_println!(</span><span style="color:#d69d85;">&quot;[test did not panic]&quot;</span><span>);
</span><span>        exit_qemu(QemuExitCode::Failed);
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre>
<p>به جای استفاده مجدد از <code>test_runner</code> از <code>lib.rs</code>، تست تابع <code>test_runner</code> خود را تعریف می‌کند که هنگام بازگشت یک تست بدون پنیک با یک کد خروج خطا خارج می‌شود (ما می‌خواهیم تست‌هایمان پنیک داشته باشند). اگر هیچ تابع تستی تعریف نشده باشد، اجرا کننده با کد خطای موفقیت خارج می‌شود. از آن‌جا که اجرا کننده همیشه پس از اجرای یک تست خارج می‌شود، منطقی نیست که بیش از یک تابع <code>#[test_case]</code> تعریف شود.</p>
<p>اکنون می‌توانیم یک تست ایجاد کنیم که باید شکست بخورد:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::serial_print;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;should_panic::should_fail...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">0</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span></code></pre>
<p>این تست با استفاده از <code>assert_eq</code> ادعا (ترجمه: assert) می‌کند که <code>0</code> و <code>1</code> برابر هستند. این البته ناموفق است، به طوری که تست ما مطابق دلخواه پنیک می‌کند. توجه داشته باشید که ما باید نام تابع را با استفاده از <code>serial_print!</code> در اینجا چاپ دستی کنیم زیرا از تریت <code>Testable</code> استفاده نمی‌کنیم.</p>
<p>هنگامی که ما تست را از طریق <code>cargo test --test should_panic</code> انجام دهیم، می‌بینیم که موفقیت آمیز است زیرا تست مطابق انتظار پنیک کرد. وقتی ادعا را کامنت کنیم و تست را دوباره اجرا کنیم، می‌بینیم که با پیام <em>“test did not panic”</em> با شکست مواجه می‌شود.</p>
<p>یک اشکال قابل توجه در این روش این است که این روش فقط برای یک تابع تست کار می‌کند. با چندین تابع <code>#[test_case]</code>، فقط اولین تابع اجرا می‌شود زیرا پس این‌که رسیدگی کننده پنیک فراخوانی شد، اجرا تمام می‌شود. من در حال حاضر راه خوبی برای حل این مشکل نمی‌دانم، بنابراین اگر ایده‌ای دارید به من اطلاع دهید!</p>
<h3 id="tst-hy-bdwn-mhr"><a class="zola-anchor" href="index.html#tst-hy-bdwn-mhr" aria-label="Anchor link for: tst-hy-bdwn-mhr">🔗</a>تست های بدون مهار</h3>
<p>برای تست‌های یکپارچه که فقط یک تابع تست دارند (مانند تست <code>should_panic</code> ما)، اجرا کننده تست مورد نیاز نیست. برای مواردی از این دست، ما می‌توانیم اجرا کننده تست را به طور کامل غیرفعال کنیم و تست خود را مستقیماً در تابع <code>_start</code> اجرا کنیم.</p>
<p>کلید این کار غیرفعال کردن پرچم <code>harness</code> برای تست در<code> Cargo.toml</code> است، که مشخص می‌کند آیا از یک اجرا کننده تست برای تست یکپارچه استفاده می‌شود. وقتی روی <code>false</code> تنظیم شود، هر دو اجرا ککنده تست پیش فرض و سفارشی غیرفعال می‌شوند، بنابراین با تست مانند یک اجرای معمولی رفتار می‌شود.</p>
<p>بیایید پرچم <code>harness</code> را برای تست <code>should_panic</code> خود غیرفعال کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[[</span><span style="color:#808080;">test</span><span>]]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;should_panic&quot;
</span><span style="color:#569cd6;">harness </span><span>= </span><span style="color:#569cd6;">false
</span></code></pre>
<p>اکنون ما با حذف کد مربوط به آاجرا کننده تست، تست <code>should_panic</code> خود را بسیار ساده کردیم. نتیجه به این شکل است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span style="color:#569cd6;">use </span><span>blog_os::{exit_qemu, serial_print, serial_println, QemuExitCode};
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    should_fail();
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[test did not panic]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style="color:#569cd6;">loop</span><span>{}
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;should_panic::should_fail...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    assert_eq!(</span><span style="color:#b5cea8;">0</span><span>, </span><span style="color:#b5cea8;">1</span><span>);
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>اکنون تابع <code>should_fail</code> را مستقیماً از تابع <code>_start</code> خود فراخوانی می‌کنیم و در صورت بازگشت با کد خروج شکست خارج می‌شویم. اکنون وقتی <code>cargo test --test should_panic</code> را اجرا می‌کنیم، می‌بینیم که تست دقیقاً مانند قبل عمل می‌کند.</p>
<p>غیر از ایجاد تست‌های <code>should_panic</code>، غیرفعال کردن صفت <code>harness</code> همچنین می‌تواند برای تست‌های یکپارچه پیچیده مفید باشد، به عنوان مثال هنگامی که تابع‌های منفرد دارای عوارض جانبی هستند و باید به ترتیب مشخصی اجرا شوند.</p>
<h2 id="khlsh"><a class="zola-anchor" href="index.html#khlsh" aria-label="Anchor link for: khlsh">🔗</a>خلاصه</h2>
<p>تست کردن یک تکنیک بسیار مفید است تا اطمینان حاصل شود که اجزای خاصی رفتار مطلوبی دارند. حتی اگر آن‌ها نتوانند فقدان اشکالات را نشان دهند، آن‌ها هنوز هم یک ابزار مفید برای یافتن آن‌ها و به ویژه برای جلوگیری از دوباره کاری و پسرفت هستند.</p>
<p>در این پست نحوه تنظیم فریم‌ورک تست برای هسته Rust ما توضیح داده شده است. ما از ویژگی فریم‌ورک تست سفارشی Rust برای پیاده سازی پشتیبانی از یک صفت ساده <code>#[test_case]</code> در محیط bare-metal خود استفاده کردیم. با استفاده از دستگاه <code>isa-debug-exit</code> شبیه‌ساز ماشین و مجازی‌ساز QEMU، اجرا کننده تست ما می‌تواند پس از اجرای تست‌ها از QEMU خارج شده و وضعیت تست را گزارش دهد. برای چاپ پیام‌های خطا به جای بافر VGA در کنسول، یک درایور اساسی برای پورت سریال ایجاد کردیم.</p>
<p>پس از ایجاد چند تست برای ماکرو <code>println</code>، در نیمه دوم پست به بررسی تست‌های یکپارچه پرداختیم. ما فهمیدیم که آن‌ها در دایرکتوری <code>tests</code> قرار می‌گیرند و به عنوان اجرایی کاملاً مستقل با آن‌ها رفتار می‌شود. برای دسترسی دادن به آن‌ها به تابع <code>exit_qemu</code> و ماکرو <code>serial_println</code>، بیشتر کدهای خود را به یک کتابخانه منتقل کردیم که می‌تواند توسط همه اجراها و تست‌های یکپارچه وارد (import) شود. از آن‌جا که تست‌های یکپارچه در محیط جداگانه خود اجرا می‌شوند، آن‌ها تست تعاملاتی با سخت‌افزار یا ایجاد تست‌هایی که باید پنیک کنند را امکان پذیر می کنند.</p>
<p>اکنون یک فریم‌ورک تست داریم که در یک محیط واقع گرایانه در داخل QEMU اجرا می‌شود. با ایجاد تست‌های بیشتر در پست‌های بعدی، می‌توانیم هسته خود را هنگامی که پیچیده‌تر شود، نگهداری کنیم.</p>
<h2 id="mrhlh-b-dy-chyst"><a class="zola-anchor" href="index.html#mrhlh-b-dy-chyst" aria-label="Anchor link for: mrhlh-b-dy-chyst">🔗</a>مرحله بعدی چیست؟</h2>
<p>در پست بعدی، ما <em>استثنائات CPU</em> را بررسی خواهیم کرد. این موارد استثنایی توسط CPU در صورت بروز هرگونه اتفاق غیرقانونی، مانند تقسیم بر صفر یا دسترسی به صفحه حافظه مپ نشده (اصطلاحاً “خطای صفحه”)، رخ می‌دهد. امکان کشف و بررسی این موارد استثنایی برای رفع اشکال در خطاهای آینده بسیار مهم است. رسیدگی به استثناها نیز بسیار شبیه رسیدگی به وقفه‌های سخت‌افزاری است، که برای پشتیبانی صفحه کلید مورد نیاز است.</p>

    </div>

    <div class="post-footer-support right-to-left">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../vga-text-mode/index.html">&laquo; حالت متن VGA</a>
        
        
            <a class="next" href="../cpu-exceptions/index.html">استثناهای پردازنده &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="right-to-left">نظرات</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Testing%20%28fa%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="Testing (fa)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fa"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Testing%20%28fa%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="right-to-left">
            لطفا نظرات خود را در صورت امکان به انگلیسی بنویسید.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../testing/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/testing/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/testing/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/testing/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
