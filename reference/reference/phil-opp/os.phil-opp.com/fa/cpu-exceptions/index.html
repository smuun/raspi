<!doctype html>

<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="استثناهای پردازنده در موقعیت های مختلف دارای خطا رخ می دهد ، به عنوان مثال هنگام دسترسی به آدرس حافظه نامعتبر یا تقسیم بر صفر. برای واکنش به آنها ، با…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>استثناهای پردازنده | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fa" title="All Posts">« همه پست‌ها</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="right-to-left">
        <h2>فهرست مطالب</h2>
    <ol>
        <li>
            <a href="index.html#brrsy-jmly">بررسی اجمالی</a>
            <ol>
                <li>
                    <a href="index.html#jdwl-twsyf-khnndh-wqfh">جدول توصیف کننده وقفه</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#ykh-nw-idt">یک نوع IDT</a>
            
        </li><li>
            <a href="index.html#qrrdd-frkhwny-wqfh">قرارداد فراخوانی وقفه</a>
            <ol>
                <li>
                    <a href="index.html#thbt-hy-hfz-shdh-w-tgyyrshwndh-scratch">ثبات های حفظ شده و تغییرشونده (Scratch)</a>
                </li><li>
                    <a href="index.html#hfz-khlyh-thbth">حفظ کلیه ثبات‌ها</a>
                </li><li>
                    <a href="index.html#qb-pshth-wqfh-the-interrupt-stack-frame">قاب پشته وقفه (The Interrupt Stack Frame)</a>
                </li><li>
                    <a href="index.html#psht-shnh">پشت صحنه</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#pydh-szy">پیاده سازی</a>
            <ol>
                <li>
                    <a href="index.html#brgyry-idt">بارگیری IDT</a>
                </li><li>
                    <a href="index.html#jry-an">اجرای آن</a>
                </li><li>
                    <a href="index.html#fzwdn-ykh-tst">افزودن یک تست</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khyly-jdwyy-bwd">خیلی جادویی بود؟</a>
            
        </li><li>
            <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
    </ol>
</aside>

            <main>
    <div class="right-to-left">
    <h1>استثناهای پردازنده</h1>
    <time datetime="2018-06-17" class="post-date">
        Jun 17, 2018
        
    </time>
    </div>

    
        <div class="warning right-to-left">
            
            
            <p>
            <b>محتوای ترجمه شده:</b>
            این یک ترجمه از جامعه کاربران برای پست <strong><a href="../../cpu-exceptions/index.html">CPU Exceptions</a></strong> است. ممکن است ناقص، منسوخ شده یا دارای خطا باشد. لطفا هر گونه مشکل را در <a href="https://github.com/phil-opp/blog_os/issues/908">این ایشو</a> گزارش دهید!
            </p>
            <p>
                ترجمه توسط <a href="https://github.com/hamidrezakp">@hamidrezakp</a> و <a href="https://github.com/MHBahrampour">@MHBahrampour</a>.</p>
            </div>
    

    <div class="right-to-left">
    <p>استثناهای پردازنده در موقعیت های مختلف دارای خطا رخ می دهد ، به عنوان مثال هنگام دسترسی به آدرس حافظه نامعتبر یا تقسیم بر صفر. برای واکنش به آنها ، باید یک <em>جدول توصیف کننده وقفه</em> تنظیم کنیم که توابع کنترل کننده را فراهم کند. در انتهای این پست ، هسته ما قادر به گرفتن <a href="https://wiki.osdev.org/Exceptions#Breakpoint">استثناهای breakpoint</a> و ادامه اجرای طبیعی پس از آن خواهد بود.</p>
<span id="continue-reading"></span>
<p>این بلاگ بصورت آزاد روی <a href="https://github.com/phil-opp/blog_os">گیت‌هاب</a> توسعه داده شده است. اگر مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. همچنین می‌توانید <a href="index.html#comments">در زیر</a> این پست کامنت بگذارید. سورس کد کامل این پست را می‌توانید در بِرَنچ <a href="https://github.com/phil-opp/blog_os/tree/post-05"><code>post-05</code></a> پیدا کنید.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>فهرست مطالب</b></summary>
        <ul>
            <li>
                <a href="index.html#brrsy-jmly">بررسی اجمالی</a>
                <ul>
                    <li>
                        <a href="index.html#jdwl-twsyf-khnndh-wqfh">جدول توصیف کننده وقفه</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#ykh-nw-idt">یک نوع IDT</a>
                
            </li><li>
                <a href="index.html#qrrdd-frkhwny-wqfh">قرارداد فراخوانی وقفه</a>
                <ul>
                    <li>
                        <a href="index.html#thbt-hy-hfz-shdh-w-tgyyrshwndh-scratch">ثبات های حفظ شده و تغییرشونده (Scratch)</a>
                    </li><li>
                        <a href="index.html#hfz-khlyh-thbth">حفظ کلیه ثبات‌ها</a>
                    </li><li>
                        <a href="index.html#qb-pshth-wqfh-the-interrupt-stack-frame">قاب پشته وقفه (The Interrupt Stack Frame)</a>
                    </li><li>
                        <a href="index.html#psht-shnh">پشت صحنه</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#pydh-szy">پیاده سازی</a>
                <ul>
                    <li>
                        <a href="index.html#brgyry-idt">بارگیری IDT</a>
                    </li><li>
                        <a href="index.html#jry-an">اجرای آن</a>
                    </li><li>
                        <a href="index.html#fzwdn-ykh-tst">افزودن یک تست</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khyly-jdwyy-bwd">خیلی جادویی بود؟</a>
                
            </li><li>
                <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
        </ul>
    </details>

<h2 id="brrsy-jmly"><a class="zola-anchor" href="index.html#brrsy-jmly" aria-label="Anchor link for: brrsy-jmly">🔗</a>بررسی اجمالی</h2>
<p>یک استثنا نشان می دهد که مشکلی در دستورالعمل فعلی وجود دارد. به عنوان مثال ، اگر دستورالعمل فعلی بخواهد تقسیم بر 0 کند ، پردازنده یک استثنا صادر می کند. وقتی یک استثنا اتفاق می افتد ، پردازنده کار فعلی خود را رها کرده و بسته به نوع استثنا ، بلافاصله یک تابع خاص کنترل کننده استثنا را فراخوانی می کند.</p>
<p>در x86 حدود 20 نوع مختلف استثنا پردازنده وجود دارد. مهمترین آنها در زیر آمده اند:</p>
<ul>
<li><strong>خطای صفحه</strong>: خطای صفحه در دسترسی غیرقانونی به حافظه رخ می دهد. به عنوان مثال ، اگر دستورالعمل فعلی بخواهد از یک صفحه نگاشت نشده بخواند یا بخواهد در یک صفحه فقط خواندنی بنویسد.</li>
<li><strong>کد نامعتبر</strong>: این استثنا وقتی رخ می دهد که دستورالعمل فعلی نامعتبر است ، به عنوان مثال وقتی می خواهیم از <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">دستورالعمل های SSE</a> جدیدتر بر روی یک پردازنده قدیمی استفاده کنیم که آنها را پشتیبانی نمی کند.</li>
<li><strong>خطای محافظت عمومی</strong>: این استثنا دارای بیشترین دامنه علل است. این مورد در انواع مختلف نقض دسترسی مانند تلاش برای اجرای یک دستورالعمل ممتاز در کد سطح کاربر یا نوشتن فیلدهای رزرو شده در ثبات های پیکربندی رخ می دهد.</li>
<li><strong>خطای دوگانه</strong>: هنگامی که یک استثنا رخ می دهد ، پردازنده سعی می کند تابع کنترل کننده مربوطه را اجرا کند. اگر یک استثنا دیگر رخ دهد <em>هنگام فراخوانی تابع کنترل کننده استثنا</em> ، پردازنده یک استثنای خطای دوگانه ایجاد می کند. این استثنا همچنین زمانی اتفاق می افتد که هیچ تابع کنترل کننده ای برای یک استثنا ثبت نشده باشد.</li>
<li><strong>خطای سه‌گانه</strong>: اگر در حالی که پردازنده سعی می کند تابع کنترل کننده خطای دوگانه را فراخوانی کند استثنایی رخ دهد ، این یک خطای سه‌گانه است. ما نمی توانیم یک خطای سه گانه را بگیریم یا آن را کنترل کنیم. بیشتر پردازنده ها ریست کردن خود و راه اندازی مجدد سیستم عامل واکنش نشان می دهند.</li>
</ul>
<p>برای مشاهده لیست کامل استثنا‌ها ، <a href="https://wiki.osdev.org/Exceptions">ویکی OSDev</a> را بررسی کنید.</p>
<h3 id="jdwl-twsyf-khnndh-wqfh"><a class="zola-anchor" href="index.html#jdwl-twsyf-khnndh-wqfh" aria-label="Anchor link for: jdwl-twsyf-khnndh-wqfh">🔗</a>جدول توصیف کننده وقفه</h3>
<p>برای گرفتن و رسیدگی به استثنا‌ها ، باید اصطلاحاً <em>جدول توصیفگر وقفه</em> (IDT) را تنظیم کنیم. در این جدول می توانیم برای هر استثنا پردازنده یک عملکرد تابع کننده مشخص کنیم. سخت افزار به طور مستقیم از این جدول استفاده می کند ، بنابراین باید از یک قالب از پیش تعریف شده پیروی کنیم. هر ورودی جدول باید ساختار 16 بایتی زیر را داشته باشد:</p>
<table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>u16</td><td>Function Pointer [0:15]</td><td>The lower bits of the pointer to the handler function.</td></tr>
<tr><td>u16</td><td>GDT selector</td><td>Selector of a code segment in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">global descriptor table</a>.</td></tr>
<tr><td>u16</td><td>Options</td><td>(see below)</td></tr>
<tr><td>u16</td><td>Function Pointer [16:31]</td><td>The middle bits of the pointer to the handler function.</td></tr>
<tr><td>u32</td><td>Function Pointer [32:63]</td><td>The remaining bits of the pointer to the handler function.</td></tr>
<tr><td>u32</td><td>Reserved</td><td></td></tr>
</tbody></table>
<p>قسمت گزینه ها (Options) دارای قالب زیر است:</p>
<table><thead><tr><th>Bits</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0-2</td><td>Interrupt Stack Table Index</td><td>0: Don’t switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.</td></tr>
<tr><td>3-7</td><td>Reserved</td><td></td></tr>
<tr><td>8</td><td>0: Interrupt Gate, 1: Trap Gate</td><td>If this bit is 0, interrupts are disabled when this handler is called.</td></tr>
<tr><td>9-11</td><td>must be one</td><td></td></tr>
<tr><td>12</td><td>must be zero</td><td></td></tr>
<tr><td>13‑14</td><td>Descriptor Privilege Level (DPL)</td><td>The minimal privilege level required for calling this handler.</td></tr>
<tr><td>15</td><td>Present</td><td></td></tr>
</tbody></table>
<p>هر استثنا دارای یک اندیس از پیش تعریف شده در IDT است. به عنوان مثال استثنا کد نامعتبر دارای اندیس 6 و استثنا خطای صفحه دارای اندیس 14 است. بنابراین ، سخت افزار می تواند به طور خودکار عنصر مربوطه را برای هر استثنا بارگذاری کند. <a href="https://wiki.osdev.org/Exceptions">جدول استثناها</a> در ویکی OSDev ، اندیس های IDT کلیه استثناها را در ستون “Vector nr.” نشان داده است.</p>
<p>هنگامی که یک استثنا رخ می دهد ، پردازنده تقریباً موارد زیر را انجام می دهد:</p>
<ol>
<li>برخی از ثبات‌ها را به پشته وارد می‌کند، از جمله اشاره گر دستورالعمل و ثبات <a href="https://en.wikipedia.org/wiki/FLAGS_register">RFLAGS</a>. (بعداً در این پست از این مقادیر استفاده خواهیم کرد.)</li>
<li>عنصر مربوط به آن (استثنا) را از جدول توصیف کننده وقفه (IDT) می‌خواند. به عنوان مثال ، پردازنده هنگام رخ دادن خطای صفحه ، عنصر چهاردهم را می خواند.</li>
<li>وجود عنصر را بررسی می‌کند. اگر اینگونه نباشد یک خطای دوگانه ایجاد می‌کند.</li>
<li>اگر عنصر یک گیت وقفه است (بیت 40 تنظیم نشده است) وقفه های سخت افزاری را غیرفعال می‌کند.</li>
<li>انتخابگر مشخص شده <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">GDT</a> را در سگمنت CS بارگذاری می‌کند.</li>
<li>به تابع کنترل کننده مشخص شده می‌رود.</li>
</ol>
<p>در حال حاضر نگران مراحل 4 و 5 نباشید ، ما در مورد جدول توصیف کننده گلوبال و وقفه های سخت افزاری در پست های بعدی خواهیم آموخت.</p>
<h2 id="ykh-nw-idt"><a class="zola-anchor" href="index.html#ykh-nw-idt" aria-label="Anchor link for: ykh-nw-idt">🔗</a>یک نوع IDT</h2>
<p>به جای ایجاد نوع IDT خود ، از <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html">ساختمان <code>InterruptDescriptorTable</code></a> کرت <code>x86_64</code> استفاده خواهیم کرد که به این شکل است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[repr(C)]
</span><span style="color:#569cd6;">pub struct </span><span>InterruptDescriptorTable {
</span><span>    </span><span style="color:#569cd6;">pub </span><span>divide_by_zero: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>debug: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>non_maskable_interrupt: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>breakpoint: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>overflow: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>bound_range_exceeded: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>invalid_opcode: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>device_not_available: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>double_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>invalid_tss: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>segment_not_present: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>stack_segment_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>general_protection_fault: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>page_fault: Entry&lt;PageFaultHandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>x87_floating_point: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>alignment_check: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>machine_check: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>simd_floating_point: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>virtualization: Entry&lt;HandlerFunc&gt;,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>security_exception: Entry&lt;HandlerFuncWithErrCode&gt;,
</span><span>    </span><span style="color:#608b4e;">// some fields omitted
</span><span>}
</span></code></pre>
<p>فیلدها از نوع <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.Entry.html"><code>&lt;idt::Entry&lt;F</code></a> هستند ، این ساختمانی است که فیلد های یک عنصر IDT را نشان می دهد (به جدول بالا مراجعه کنید). پارامتر نوع <code>F</code>، نوع تابع کنترل کننده مورد انتظار را تعریف می کند. می بینیم که برخی از عناصر به یک <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFunc.html"><code>HandlerFunc</code></a> و برخی دیگر به <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html"><code>HandlerFuncWithErrCode</code></a> نیاز دارند. خطای صفحه حتی نوع خاص خود را دارد: <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.PageFaultHandlerFunc.html"><code>PageFaultHandlerFunc</code></a>.</p>
<p>بیایید ابتدا به نوع <code>HandlerFunc</code> نگاه کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">type </span><span style="color:#4ec9b0;">HandlerFunc </span><span>= </span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn</span><span>(</span><span style="color:#569cd6;">_</span><span>: InterruptStackFrame);
</span></code></pre>
<p>این یک <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">نوع مستعار(type alias)</a> برای نوع “<code>extern &quot;x86-interrupt&quot; fn</code> است. کلمه کلیدی <code>extern</code> تابعی را با یک <a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">قرارداد فراخوانی خارجی</a> تعریف می کند و اغلب برای برقراری ارتباط با کد C استفاده می شود(<code>extern &quot;C&quot; fn</code>) . اما قرارداد فراخوانی <code>x86-interrupt</code> چیست؟</p>
<h2 id="qrrdd-frkhwny-wqfh"><a class="zola-anchor" href="index.html#qrrdd-frkhwny-wqfh" aria-label="Anchor link for: qrrdd-frkhwny-wqfh">🔗</a>قرارداد فراخوانی وقفه</h2>
<p>استثنا‌ها کاملاً شبیه فراخوانی توابع هستند: پردازنده به اولین دستورالعمل تابع فراخوانی شده می رود و آن را اجرا می کند. پس از آن پردازنده به آدرس بازگشت می پرد و اجرای تابع اصلی را ادامه می دهد.</p>
<p>با این وجود ، تفاوت عمده ای بین فراخوانی استثناها و توابع وجود دارد: یک فراخوانی تابع توسط یک کامپایلر که دستور “فراخوانی” در آن درج شده است ، انجام می شود ، در حالی که یک استثنا ممکن است در <em>هر</em> دستورالعملی رخ دهد. برای درک عواقب این تفاوت ، باید فراخوانی توابع را با جزئیات بیشتری بررسی کنیم.</p>
<p><a href="https://en.wikipedia.org/wiki/Calling_convention">قرارداد فراخوانی</a> جزئیات فراخوانی تابع را مشخص می کند. به عنوان مثال ، آنها مشخص می‌کنند که پارامترهای تابع کجا قرار می گیرند (به عنوان مثال در ثبات‌ها یا بر روی پشته) و نحوه بازگشت نتایج. در x86_64 لینوکس ، قوانین زیر برای توابع C اعمال می شود (مشخص شده در <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">System V ABI</a>):</p>
<ul>
<li>شش آرگومان اول با نوع عدد صحیح در ثبات‌های<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> منتقل می شوند</li>
<li>آرگومان های اضافی بر روی پشته منتقل می شوند</li>
<li>نتایج درون<code>rax</code> و <code>rdx</code> بر می گردند</li>
</ul>
<p>توجه داشته باشید که راست از C ABI پیروی نمی کند (در واقع ، <a href="https://github.com/rust-lang/rfcs/issues/600">هنوز حتی یک Rust ABI وجود ندارد</a>) ، بنابراین این قوانین فقط برای توابع اعلام شده به عنوان <code>extern &quot;C&quot; fn</code> اعمال می شود.</p>
<h3 id="thbt-hy-hfz-shdh-w-tgyyrshwndh-scratch"><a class="zola-anchor" href="index.html#thbt-hy-hfz-shdh-w-tgyyrshwndh-scratch" aria-label="Anchor link for: thbt-hy-hfz-shdh-w-tgyyrshwndh-scratch">🔗</a>ثبات های حفظ شده و تغییرشونده (Scratch)</h3>
<p>قرارداد فراخوانی، ثبات‌ها را به دو دسته ثبات های <em>محفوظ شده</em> و <em>تغییرشونده</em> تقسیم می کند.</p>
<p>مقادیر ثبات‌های <em>محفوظ شده</em>، در فراخوانی تابع باید بدون تغییر باقی بمانند. بنابراین یک تابع فراخوانی شده (<em>“callee”</em>) فقط در صورتی مجاز است این ثبات‌ها را تغییر دهد، که مقادیر اصلی آنها را قبل از بازگشت، برگرداند. بنابراین به این ثبات‌ها <em>“callee-saved”</em> گفته می شود. یک الگوی عمومی این است که ثبات‌ها در آغاز تابع بر روی پشته ذخیره شده و درست قبل از بازگشت از پشته برداشته شده و مقدار دهی شوند.</p>
<p>در مقابل، یک تابع فراخوانی شده مجاز است که بدون محدودیت ، ثبات‌های <em>تغییرشونده</em> را دوباره بنویسد. اگر فراخواننده (<em>“caller”</em>) بخواهد مقدار یک ثبات تغییرشونده را در یک فراخوانی تابع حفظ کند ، لازم است قبل از فراخوانی تابع (به عنوان مثال بوسیله اضافه و برداشتن از روی پشته) آن را پشتیبان گیری و بازیابی کند. بنابراین ثبات‌های تغییرشونده <em>caller-saved</em> هستند.</p>
<p>در x86_64 ، قرارداد فراخوانی C ثبات‌های محفوظ شده و تغییرشونده زیر را مشخص می کند:</p>
<table><thead><tr><th>preserved registers</th><th>scratch registers</th></tr></thead><tbody>
<tr><td><code>rbp</code>, <code>rbx</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code></td><td><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code></td></tr>
<tr><td><em>callee-saved</em></td><td><em>caller-saved</em></td></tr>
</tbody></table>
<p>کامپایلر این قوانین را می داند ، بنابراین کد را متناسب با آن تولید می کند. به عنوان مثال ، بیشتر توابع با <code>push rbp</code> شروع می شوند که پشتیبان گیری از<code>rbp</code> روی پشته است (زیرا این یک ثبات <em>caller-saved</em>).</p>
<h3 id="hfz-khlyh-thbth"><a class="zola-anchor" href="index.html#hfz-khlyh-thbth" aria-label="Anchor link for: hfz-khlyh-thbth">🔗</a>حفظ کلیه ثبات‌ها</h3>
<p>برخلاف فراخوانی تابع ، استثنا‌ها می توانند در <em>هر</em> دستورالعملی رخ دهند. در بیشتر موارد ، ما حتی در زمان کامپایل نمی دانیم که کد تولید شده استثنا ایجاد می کند یا نه. به عنوان مثال ، کامپایلر نمی تواند بداند که آیا یک دستورالعمل باعث سرریز شدن پشته یا خطای صفحه می شود.</p>
<p>از آنجا که نمی دانیم چه زمانی استثنا رخ می‌دهد ، نمی توانیم قبل از آن از هیچ ثباتی پشتیبان گیری کنیم. این بدان معناست که ما نمی توانیم از قرارداد فراخوانی‌ای استفاده کنیم که متکی به ثبات‌های caller-saved برای کنترل کننده های استثنا هست. در عوض ، به یک قرارداد فراخوانی نیاز داریم که <em>همه</em> ثبات‌ها را حفظ کند. قرارداد فراخوانی <code>x86-interrupt</code> چنین قرارداد فراخوانی است ، بنابراین تضمین می کند که تمام مقادیر ثبات‌ها در هنگام بازگشت تابع به مقادیر اصلی خود بازگردند.</p>
<p>توجه داشته باشید که این بدان معنا نیست که همه ثبات‌ها در ورود به تابع در پشته ذخیره می شوند. در عوض ، کامپایلر فقط از ثبات‌هایی که توسط تابع تغییر می‌کنند ، پشتیبان تهیه می کند. به این ترتیب ، کد بسیار کارآمدی برای توابع کوتاه که فقط از چند ثبات استفاده می کنند ، تولید می شود.</p>
<h3 id="qb-pshth-wqfh-the-interrupt-stack-frame"><a class="zola-anchor" href="index.html#qb-pshth-wqfh-the-interrupt-stack-frame" aria-label="Anchor link for: qb-pshth-wqfh-the-interrupt-stack-frame">🔗</a>قاب پشته وقفه (The Interrupt Stack Frame)</h3>
<p>در یک فراخوانی عادی تابع (با استفاده از دستورالعمل <code>call</code>) ، پردازنده قبل از پرش به تابع هدف ، آدرس بازگشت را در پشته ذخیره می‌کند. در هنگام بازگشت تابع (با استفاده از دستورالعمل <code>ret</code>) ، پردازنده این آدرس بازگشت را از پشته برمی‌دارد و به آن می پرد. بنابراین قاب پشته یک فراخوانی عادی تابع به این شکل است:</p>
<p><img src="function-stack-frame.svg" alt="function stack frame" /></p>
<p>با این وجود، برای کنترل کننده های استثنا و وقفه، ذخیره آدرس برگشت در پشته کافی نیست، زیرا کنترل کننده های وقفه غالباً در context دیگری اجرا می شوند (نشانگر پشته ، پرچم های پردازنده و غیره). در عوض، پردازنده در صورت وقفه مراحل زیر را انجام می دهد:</p>
<ol>
<li><strong>تراز کردن اشاره‌گر پشته</strong>: در هر دستورالعمل امکان رخ دادن وقفه وجود دارد، بنابراین اشاره‌گر پشته نیز می تواند هر مقداری داشته باشد. با این حال ، برخی از دستورالعمل های پردازنده (به عنوان مثال برخی از دستورالعمل های SSE) نیاز دارند که اشاره‌گر پشته در مرز 16 بایت تراز شود ، بنابراین پردازنده درست پس از وقفه چنین ترازی را انجام می دهد.</li>
<li><strong>تعویض پشته‌ها</strong> (در بعضی موارد): تعویض پشته زمانی اتفاق می افتد که سطح امتیاز پردازنده (CPU privilege level) تغییر می کند، به عنوان مثال وقتی یک استثنا در یک برنامه حالت کاربر رخ می دهد. همچنین می توان تعویض پشته را برای وقفه های خاص با استفاده از به اصطلاح <em>Interrupt Stack Table</em> پیکربندی کرد (در پست بعدی توضیح داده شده).</li>
<li><strong>پوش کردن اشاره‌گر قدیمی پشته</strong>: پردازنده مقادیر اشاره‌گر پشته (<code>rsp</code>) و سگمنت پشته (<code>ss</code>) را در زمان وقوع وقفه (قبل از تراز کردن) پوش می‌کند. این امکان را فراهم می کند تا هنگام بازگشت از کنترل کننده وقفه ، اشاره‌گر اصلی پشته بازیابی شود.</li>
<li><strong>پوش کردن و به‌روزرسانی ثبات <code>RFLAGS</code></strong>: ثبات <a href="https://en.wikipedia.org/wiki/FLAGS_register"><code>RFLAGS</code></a> شامل بیت های مختلف کنترل و وضعیت است. در هنگام وقوع وقفه ، پردازنده برخی از بیت‌ها را تغییر می‌دهد و مقدار قدیمی را پوش می‌کند.</li>
<li><strong>پوش کردن اشاره‌گر دستورالعمل</strong>: قبل از پرش به تابع کنترل کننده وقفه ، پردازنده اشاره‌گر دستورالعمل (<code>rip</code>) و سگمنت کد (<code>cs</code>) را پوش می‌کند. این مشابه با پوش کردن آدرس برگشت یک تابع عادی است.</li>
<li>** پوش کردن کد خطا** (برای برخی استثناها): برای برخی از استثنا های خاص مانند خطاهای صفحه ، پردازنده یک کد خطا را پوش می‌کند که علت استثنا را توصیف می کند.</li>
<li><strong>فراخوانی کنترل کننده وقفه</strong>: پردازنده آدرس و توصیف کننده سگمنت تابع کنترل کننده وقفه را از قسمت مربوطه در IDT می خواند. سپس با بارگذاری مقادیر در ثبات های <code>rip</code> و <code>cs</code> این کنترل کننده را فراخوانی می کند.</li>
</ol>
<p>بنابراین <em>interrupt stack frame</em> به این شکل است:</p>
<p><img src="exception-stack-frame.svg" alt="interrupt stack frame" /></p>
<p>در کرت <code>x86_64</code> ، فریم پشته وقفه توسط ساختمان <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptStackFrame.html"><code>InterruptStackFrame</code></a> نشان داده می شود. این ساختمان به عنوان <code>&amp;mut</code> به کنترل کننده وقفه منتقل می شود و می تواند برای دریافت اطلاعات بیشتر در مورد علت استثنا استفاده شود. ساختمان بدون فیلد کد خطا است ، زیرا فقط برخی از استثناها کد خطا را پوش می‌کنند. این استثناها از نوع تابع جداگانه <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/type.HandlerFuncWithErrCode.html"><code>HandlerFuncWithErrCode</code></a> استفاده می‌کنند ، که دارای یک آرگومان اضافی <code>error_code</code> است.</p>
<h3 id="psht-shnh"><a class="zola-anchor" href="index.html#psht-shnh" aria-label="Anchor link for: psht-shnh">🔗</a>پشت صحنه</h3>
<p>قرارداد فراخوانی <code>x86-interrupt</code> یک انتزاع قدرتمند است که تقریباً تمام جزئیات پیچیده فرآیند مدیریت استثناها را پنهان می کند. با این حال ، گاهی اوقات مفید است که بدانیم پشت پرده چه اتفاقی می افتد. در اینجا یک مرور کوتاه از مواردی که قرارداد فراخوانی <code>x86-interrupt</code> انجام می‌دهد را می‌بینید:</p>
<ul>
<li><strong>دریافت آرگومان ها</strong>: بیشتر قرارداد های فراخوانی انتظار دارند که آرگومان ها در ثبات‌ها منتقل شوند. این برای کنترل کننده های استثنا امکان پذیر نیست ، زیرا ما نباید قبل از تهیه نسخه پشتیبان از مقادیر ثبات‌ها ، آنها را بازنویسی کنیم. در عوض، قرارداد فراخوانی <code>x86-interrupt</code>  آگاه است که آرگومان ها از قبل در مکان خاصی بر روی پشته قرار دارند.</li>
<li><strong>بازگشت با استفاده از <code>iretq</code></strong>: از آنجا که قاب پشته وقفه با قاب پشته صدا زدن توابع معمولی کاملاً متفاوت است، نمی توانیم از طریق دستورالعمل<code> ret</code> از توابع کنترل کننده برگردیم. در عوض، باید از دستور <code>iretq</code> استفاده شود.</li>
<li><strong>مدیریت کد خطا</strong>: کد خطا که برای برخی  استثناها به پشته اضافه می شود ، کارها را بسیار پیچیده تر می کند. تراز بندی پشته را تغییر می دهد (به قسمت بعدی مراجعه کنید) و باید قبل از بازگشت، از پشته خارج شود. قرارداد فراخوانی <code>x86-interrupt</code> تمام پیچیدگی‌ها را برطرف می کند. با این حال، نمی داند کدام تابع کنترل کننده برای کدام استثنا استفاده می شود، بنابراین باید این اطلاعات را از تعداد آرگومان های تابع استخراج کند. این بدان معناست که برنامه نویس همچنان مسئول استفاده صحیح هر نوع تابع برای هر استثنا است. خوشبختانه نوع <code>InterruptDescriptorTable</code> که توسط کرت <code>x86_64</code> تعریف شده است، استفاده از انواع تابع صحیح را تضمین می کند.</li>
<li><strong>تراز کردن پشته</strong>: برخی دستورالعمل‌ها (به ویژه دستورالعمل های SSE) وجود دارند که به یک تراز پشته 16 بایتی نیاز دارند. پردازنده این تراز را هر زمان که یک استثنا اتفاق می افتد تضمین می کند ، اما برای برخی از استثناها بعداً هنگامی که یک کد خطا را به پشته اضافه می‌کند، دوباره آن را از بین می برد. قرارداد فراخوانی <code>x86-interrupt</code> با تنظیم مجدد پشته در این حالت این مشکل را برطرف می‌کند.</li>
</ul>
<p>اگر به جزئیات بیشتر علاقه مندید: ما همچنین یک سری پست داریم که مدیریت استثنا با استفاده از <a href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md">توابع برهنه</a> را توضیح می‌دهند. (<a href="index.html#khyly-jdwyy-bwd">در انتهای این پست</a>).</p>
<h2 id="pydh-szy"><a class="zola-anchor" href="index.html#pydh-szy" aria-label="Anchor link for: pydh-szy">🔗</a>پیاده سازی</h2>
<p>اکنون که تئوری را فهمیدیم ، وقت آن رسیده است که استثناهای پردازنده را در هسته خود کنترل کنیم. ما با ایجاد یک ماژول جدید وقفه‌ها در <code>src/interrupts.rs</code> شروع خواهیم کرد، که ابتدا یک تابع <code>init_idt</code> ایجاد می کند که یک <code>InterruptDescriptorTable</code> جدید ایجاد می کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>interrupts;
</span><span>
</span><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::InterruptDescriptorTable;
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>}
</span></code></pre>
<p>اکنون می توانیم توابع کنترل کننده را اضافه کنیم. با اضافه کردن یک کنترل کننده برای <a href="https://wiki.osdev.org/Exceptions#Breakpoint">استثنا بریک‌پوینت</a> شروع می کنیم. استثنای بریک‌پوینت، استثنای عالی برای آزمایش مدیریت استثنا است. تنها هدف آن مکث موقت برنامه هنگام اجرای دستورالعمل بریک‌پوینت <code>int3</code> است.</p>
<p>استثنا بریک‌پوینت معمولاً در دیباگرها به کار می رود: وقتی کاربر بریک‌پوینت را تعیین می کند ، دیباگر دستورالعمل مربوطه را با دستورالعمل <code>int3</code> بازنویسی می کند تا پردازنده هنگام رسیدن به آن خط، استثنای بریک‌پوینت را ایجاد کند. هنگامی که کاربر می خواهد برنامه را ادامه دهد، دیباگر دوباره دستورالعمل <code>int3</code> را با دستورالعمل اصلی جایگزین می کند و برنامه را ادامه می دهد. برای جزئیات بیشتر ، سری <a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">“<em>دیباگرها چطور کار می‌کنند</em>”</a> را ببینید.</p>
<p>برای موارد استفاده ما، نیازی به بازنویسی دستورالعمل نداریم. در عوض، فقط می‌خواهیم هنگام اجرای دستورالعمل بریک‌پوینت پیامی چاپ کنیم و سپس برنامه را ادامه دهیم. بنابراین بیایید یک تابع ساده <code>breakpoint_handler</code> ایجاد کنیم و آن را به IDT خود اضافه کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::{InterruptDescriptorTable, InterruptStackFrame};
</span><span style="color:#569cd6;">use crate</span><span>::println;
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>    idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>}
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>breakpoint_handler(
</span><span>    stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;EXCEPTION: BREAKPOINT</span><span style="color:#e3bbab;">\n</span><span style="color:#b4cea8;">{:#?}</span><span style="color:#d69d85;">&quot;</span><span>, stack_frame);
</span><span>}
</span></code></pre>
<p>کنترل کننده ما فقط یک پیام را خارج می کند و قاب پشته وقفه را زیبا چاپ می کند.</p>
<p>هنگامی که می خواهیم آن را کامپایل کنیم ، خطای زیر رخ می دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error[E0658]: x86-interrupt ABI is experimental and subject to change (see issue #40180)
</span><span>  --&gt; src/main.rs:53:1
</span><span>   |
</span><span>53 | / extern &quot;x86-interrupt&quot; fn breakpoint_handler(stack_frame: InterruptStackFrame) {
</span><span>54 | |     println!(&quot;EXCEPTION: BREAKPOINT\n{:#?}&quot;, stack_frame);
</span><span>55 | | }
</span><span>   | |_^
</span><span>   |
</span><span>   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
</span></code></pre>
<p>این خطا به این دلیل رخ می دهد که قرارداد فراخوانی <code>x86-interrupt</code> هنوز ناپایدار است. به هر حال برای استفاده از آن ، باید صریحاً آن را با اضافه کردن <code>#![feature(abi_x86_interrupt)]</code> در بالای <code>lib.rs</code> فعال کنیم.</p>
<h3 id="brgyry-idt"><a class="zola-anchor" href="index.html#brgyry-idt" aria-label="Anchor link for: brgyry-idt">🔗</a>بارگیری IDT</h3>
<p>برای اینکه پردازنده از جدول توصیف کننده وقفه جدید ما استفاده کند ، باید آن را با استفاده از دستورالعمل <a href="https://www.felixcloutier.com/x86/lgdt:lidt"><code>lidt</code></a> بارگیری کنیم. ساختمان <code>InterruptDescriptorTable</code> از کرت <code> x86_64</code> متد <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html#method.load"><code>load</code></a> را برای این کار فراهم می کند. بیایید سعی کنیم از آن استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>    idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>    idt.load();
</span><span>}
</span></code></pre>
<p>اکنون هنگامی که می خواهیم آن را کامپایل کنیم ، خطای زیر رخ می دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: `idt` does not live long enough
</span><span>  --&gt; src/interrupts/mod.rs:43:5
</span><span>   |
</span><span>43 |     idt.load();
</span><span>   |     ^^^ does not live long enough
</span><span>44 | }
</span><span>   | - borrowed value only lives until here
</span><span>   |
</span><span>   = note: borrowed value must be valid for the static lifetime...
</span></code></pre>
<p>پس متد <code>load</code> انتظار دریافت یک <code>static self'&amp;</code> را دارد، این مرجعی است که برای تمام مدت زمان اجرای برنامه معتبر است. دلیل این امر این است که پردازنده در هر وقفه به این جدول دسترسی پیدا می کند تا زمانی که IDT دیگری بارگیری کنیم. بنابراین استفاده از طول عمر کوتاه تر از <code>static'</code> می تواند منجر به باگ های استفاده-بعد-از-آزادسازی شود.</p>
<p>در واقع ، این دقیقاً همان چیزی است که در اینجا اتفاق می افتد. <code>idt</code> ما روی پشته ایجاد می شود ، بنابراین فقط در داخل تابع <code>init</code> معتبر است. پس از آن حافظه پشته برای توابع دیگر مورد استفاده مجدد قرار می گیرد ، بنابراین پردازنده حافظه پشته تصادفی را به عنوان IDT تفسیر می کند. خوشبختانه ، متد <code>InterruptDescriptorTable::load</code> این نیاز به طول عمر را در تعریف تابع خود اجباری می کند، بنابراین کامپایلر راست قادر است از این مشکل احتمالی در زمان کامپایل جلوگیری کند.</p>
<p>برای رفع این مشکل، باید <code>idt</code> را در مکانی ذخیره کنیم که طول عمر <code>static'</code> داشته باشد. برای رسیدن به این هدف می توانیم IDT را با استفاده از <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> بر روی حافظه Heap ایجاد کنیم و سپس آن را به یک مرجع <code>static'</code> تبدیل کنیم، اما ما در حال نوشتن هسته سیستم عامل هستیم و بنابراین هنوز Heap نداریم.</p>
<p>به عنوان یک گزینه دیگر، می توانیم IDT را به صورت <code>static</code> ذخیره کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">static </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = InterruptDescriptorTable::new();
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>}
</span></code></pre>
<p>با این وجود، یک مشکل وجود دارد: استاتیک‌ها تغییرناپذیر هستند، پس نمی توانیم ورودی بریک‌پوینت را از تابع <code>init</code> تغییر دهیم. می توانیم این مشکل را با استفاده از <a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a> حل کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">static mut </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = InterruptDescriptorTable::new();
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">IDT</span><span>.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>    }
</span><span>}
</span></code></pre>
<p>در این روش بدون خطا کامپایل می شود اما مشکلات دیگری به همراه دارد. <code>static mut</code> بسیار مستعد Data Race هستند، بنابراین در هر دسترسی به یک <a href="https://doc.rust-lang.org/1.30.0/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers">بلوک <code>unsafe</code></a> نیاز داریم.</p>
<h4 id="lazy-statics-bh-njt-m-myaynd"><a class="zola-anchor" href="index.html#lazy-statics-bh-njt-m-myaynd" aria-label="Anchor link for: lazy-statics-bh-njt-m-myaynd">🔗</a>Lazy Statics به نجات ما می‌آیند</h4>
<p>خوشبختانه ماکرو <code>lazy_static</code> وجود دارد. ماکرو به جای ارزیابی یک <code>static</code> در زمان کامپایل ، مقداردهی اولیه آن را هنگام اولین ارجاع به آن انجام می دهد. بنابراین، می توانیم تقریباً همه کاری را در بلوک مقداردهی اولیه انجام دهیم و حتی قادر به خواندن مقادیر زمان اجرا هستیم.</p>
<p>ما قبلاً کرت <code>lazy_static</code> را وارد کردیم وقتی <a href="../../vga-text-mode/index.html#lazy-statics">یک انتزاع برای بافر متن VGA ایجاد کردیم</a>. بنابراین می توانیم مستقیماً از ماکرو <code>!lazy_static</code> برای ایجاد IDT استاتیک استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_idt() {
</span><span>    </span><span style="color:#b4cea8;">IDT</span><span>.load();
</span><span>}
</span></code></pre>
<p>توجه داشته باشید که چگونه این راه حل به هیچ بلوک <code>unsafe</code> نیاز ندارد. ماکرو <code>!lazy_static</code> از <code>unsafe</code> در پشت صحنه استفاده می کند ، اما در یک رابط امن به ما داده می شود.</p>
<h3 id="jry-an"><a class="zola-anchor" href="index.html#jry-an" aria-label="Anchor link for: jry-an">🔗</a>اجرای آن</h3>
<p>آخرین مرحله برای کارکرد استثناها در هسته ما فراخوانی تابع <code>init_idt</code> از <code>main.rs</code> است. به جای فراخوانی مستقیم آن، یک تابع عمومی <code>init</code> را در <code>lib.rs</code> معرفی می کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    interrupts::init_idt();
</span><span>}
</span></code></pre>
<p>با استفاده از این تابع اکنون یک مکان اصلی برای روالهای اولیه داریم که می تواند بین توابع مختلف <code>start_</code> در <code>main.rs</code> ، <code>lib.rs</code> و  تست‌های یک‌پارچه به اشتراک گذاشته شود.</p>
<p>اکنون می توانیم تابع <code>start_</code> در <code>main.rs</code> را به روز کنیم تا <code>init</code> را فراخوانی کرده و سپس یک استثنا بریک‌پوینت ایجاد کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    blog_os::init(); </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    </span><span style="color:#608b4e;">// invoke a breakpoint exception
</span><span>    x86_64::instructions::interrupts::int3(); </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    </span><span style="color:#608b4e;">// as before
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>اکنون هنگامی که آن را در QEMU اجرا می کنیم (با استفاده از <code>cargo run</code>) ، موارد زیر را مشاهده می کنیم:</p>
<p><img src="qemu-breakpoint-exception.png" alt="QEMU printing EXCEPTION: BREAKPOINT and the interrupt stack frame" /></p>
<p>کار می کند! پردازنده با موفقیت تابع کنترل کننده بریک‌پوینت ما را فراخوانی می کند ، که پیام را چاپ می کند و سپس به تابع <code>start_</code> برمی گردد ، جایی که پیام <code>!It did not crash</code> چاپ شده است.</p>
<p>می بینیم که قاب پشته وقفه، دستورالعمل و نشانگرهای پشته را در زمان وقوع استثنا به ما می گوید. این اطلاعات هنگام رفع اشکال استثناهای غیر منتظره بسیار مفید است.</p>
<h3 id="fzwdn-ykh-tst"><a class="zola-anchor" href="index.html#fzwdn-ykh-tst" aria-label="Anchor link for: fzwdn-ykh-tst">🔗</a>افزودن یک تست</h3>
<p>بیایید یک تست ایجاد کنیم که از ادامه کار کد بالا اطمینان حاصل کند. ابتدا تابع <code>start_</code> را به روز می کنیم تا <code>init</code> را نیز فراخوانی کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#608b4e;">/// Entry point for `cargo test`
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    init();      </span><span style="color:#608b4e;">// new
</span><span>    test_main();
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>بخاطر داشته باشید، این تابع <code>start_</code> هنگام اجرای<code>cargo test --lib</code> استفاده می شود، زیرا راست <code>lib.rs</code> را کاملاً مستقل از<code>main.rs</code> تست می‌کند. قبل از اجرای تست‌ها باید برای راه اندازی IDT در اینجا <code>init</code> فراخوانی شود.</p>
<p>اکنون می توانیم یک تست <code>test_breakpoint_exception</code> ایجاد کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_breakpoint_exception() {
</span><span>    </span><span style="color:#608b4e;">// invoke a breakpoint exception
</span><span>    x86_64::instructions::interrupts::int3();
</span><span>}
</span></code></pre>
<p>این تست تابع <code>int3</code> را فراخوانی می کند تا یک استثنا بریک‌پوینت ایجاد کند. با بررسی اینکه اجرا پس از آن ادامه دارد ، تأیید می کنیم که کنترل کننده بریک‌پوینت ما به درستی کار می کند.</p>
<p>شما می توانید این تست جدید را با اجرای <code>cargo test</code> (همه تست‌ها) یا<code> cargo test --lib</code> (فقط تست های <code>lib.rs</code> و ماژول های آن) امتحان کنید. باید موارد زیر را در خروجی مشاهده کنید:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>blog_os::interrupts::test_breakpoint_exception...	[ok]
</span></code></pre>
<h2 id="khyly-jdwyy-bwd"><a class="zola-anchor" href="index.html#khyly-jdwyy-bwd" aria-label="Anchor link for: khyly-jdwyy-bwd">🔗</a>خیلی جادویی بود؟</h2>
<p>قرارداد فراخوانی <code>x86-interrupt</code> و نوع <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code></a> روند مدیریت استثناها را نسبتاً سر راست و بدون درد ساخته‌اند. اگر این برای شما بسیار جادویی بود و دوست دارید تمام جزئیات مهم مدیریت استثنا را بیاموزید، برای شما هم مطالبی داریم: مجموعه <a href="https://os.phil-opp.com/edition-1/extra/naked-exceptions/">“مدیریت استثناها با توابع برهنه”</a> ما، نحوه مدیریت استثنا‌ها بدون قرارداد فراخوانی<code>x86-interrupt</code> را نشان می دهد و همچنین نوع IDT خاص خود را ایجاد می کند. از نظر تاریخی، این پست‌ها مهمترین پست‌های مدیریت استثناها قبل از وجود قرارداد فراخوانی <code>x86-interrupt</code> و کرت <code>x86_64</code> بودند. توجه داشته باشید که این پست‌ها بر اساس <a href="../../edition-1">نسخه اول</a> این وبلاگ هستند و ممکن است قدیمی باشند.</p>
<h2 id="mrhlh-b-dy-chyst"><a class="zola-anchor" href="index.html#mrhlh-b-dy-chyst" aria-label="Anchor link for: mrhlh-b-dy-chyst">🔗</a>مرحله بعدی چیست؟</h2>
<p>ما اولین استثنای خود را با موفقیت گرفتیم و از آن بازگشتیم! گام بعدی اطمینان از این است که همه استثناها را می گیریم ، زیرا یک استثنا گرفته نشده باعث <a href="https://wiki.osdev.org/Triple_Fault">خطای سه‌گانه</a> می شود که منجر به شروع مجدد سیستم می شود. پست بعدی توضیح می دهد که چگونه می توان با گرفتن صحیح <a href="https://wiki.osdev.org/Double_Fault#Double_Fault">خطای دوگانه</a> از این امر جلوگیری کرد.</p>

    </div>

    <div class="post-footer-support right-to-left">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../testing/index.html">&laquo; تست کردن</a>
        
        
            <a class="next" href="../double-fault-exceptions/index.html">خطاهای دوگانه &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="right-to-left">نظرات</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22CPU%20Exceptions%20%28fa%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="CPU Exceptions (fa)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fa"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22CPU%20Exceptions%20%28fa%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="right-to-left">
            لطفا نظرات خود را در صورت امکان به انگلیسی بنویسید.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../cpu-exceptions/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/cpu-exceptions/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/cpu-exceptions/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/cpu-exceptions/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
