<!doctype html>

<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="این پست به طور دقیق جزئیات استثنای خطای دوگانه (ترجمه: double fault exception) را بررسی می‌کند، این استثنا هنگامی رخ می‌دهد که CPU نتواند یک کنترل کننده…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>خطاهای دوگانه | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fa" title="All Posts">« همه پست‌ها</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="right-to-left">
        <h2>فهرست مطالب</h2>
    <ol>
        <li>
            <a href="index.html#khty-dwgnh-chyst">خطای دوگانه چیست؟</a>
            <ol>
                <li>
                    <a href="index.html#rhndzy-ykh-khty-dwgnh">راه‌اندازی یک خطای دوگانه</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khntrl-khnndh-khty-dwgnh">کنترل کننده خطای دوگانه</a>
            
        </li><li>
            <a href="index.html#ll-rkh-dd-khty-dwgnh">علل رخ داد خطای دوگانه</a>
            <ol>
                <li>
                    <a href="index.html#srryzi-pshthy-hsth">سرریزِ پشته‌ی هسته</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#t-wyd-pshthh">تعویض پشته‌ها</a>
            <ol>
                <li>
                    <a href="index.html#ist-w-tss">IST و TSS</a>
                </li><li>
                    <a href="index.html#yjd-ykh-tss">ایجاد یک TSS</a>
                </li><li>
                    <a href="index.html#jdwl-twsyfgr-srsry">جدول توصیف‌گر سراسری</a>
                </li><li>
                    <a href="index.html#mrhl-pyny">مراحل پایانی</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#tst-srryz-pshth">تست سرریز پشته</a>
            <ol>
                <li>
                    <a href="index.html#pydhszy-start">پیاده‌سازی start_</a>
                </li><li>
                    <a href="index.html#tst-idt">تست IDT</a>
                </li><li>
                    <a href="index.html#mdyr-khty-dwgnh">مدیر خطای دوگانه</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khlsh">خلاصه</a>
            
        </li><li>
            <a href="index.html#b-dy-chyst">بعدی چیست؟</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
    </ol>
</aside>

            <main>
    <div class="right-to-left">
    <h1>خطاهای دوگانه</h1>
    <time datetime="2018-06-18" class="post-date">
        Jun 18, 2018
        
    </time>
    </div>

    
        <div class="warning right-to-left">
            
            
            <p>
            <b>محتوای ترجمه شده:</b>
            این یک ترجمه از جامعه کاربران برای پست <strong><a href="../../double-fault-exceptions/index.html">Double Faults</a></strong> است. ممکن است ناقص، منسوخ شده یا دارای خطا باشد. لطفا هر گونه مشکل را در <a href="https://github.com/phil-opp/blog_os/issues/908">این ایشو</a> گزارش دهید!
            </p>
            <p>
                ترجمه توسط <a href="https://github.com/hamidrezakp">@hamidrezakp</a> و <a href="https://github.com/MHBahrampour">@MHBahrampour</a>.</p>
            </div>
    

    <div class="right-to-left">
    <p>این پست به طور دقیق جزئیات استثنای خطای دوگانه (ترجمه: double fault exception) را بررسی می‌کند، این استثنا هنگامی رخ می‌دهد که CPU نتواند یک کنترل کننده استثنا را فراخوانی کند. با کنترل این استثنا، از بروز <em>خطاهای سه گانه</em> (ترجمه: triple faults) کشنده که باعث ریست (کلمه: reset) شدن سیستم می‌شوند، جلوگیری می‌کنیم. برای جلوگیری از خطاهای سه گانه در همه موارد، ما همچنین یک <em>Interrupt Stack Table</em> را تنظیم کرده‌ایم تا خطاهای دوگانه را روی یک پشته هسته جداگانه بگیرد.</p>
<span id="continue-reading"></span>
<p>این بلاگ بصورت آزاد روی <a href="https://github.com/phil-opp/blog_os">گیت‌هاب</a> توسعه داده شده است. اگر شما مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. شما همچنین می‌توانید <a href="index.html#comments">در زیر</a> این پست کامنت بگذارید. منبع کد کامل این پست را می‌توانید در بِرَنچ <a href="https://github.com/phil-opp/blog_os/tree/post-06"><code>post-06</code></a> پیدا کنید.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>فهرست مطالب</b></summary>
        <ul>
            <li>
                <a href="index.html#khty-dwgnh-chyst">خطای دوگانه چیست؟</a>
                <ul>
                    <li>
                        <a href="index.html#rhndzy-ykh-khty-dwgnh">راه‌اندازی یک خطای دوگانه</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khntrl-khnndh-khty-dwgnh">کنترل کننده خطای دوگانه</a>
                
            </li><li>
                <a href="index.html#ll-rkh-dd-khty-dwgnh">علل رخ داد خطای دوگانه</a>
                <ul>
                    <li>
                        <a href="index.html#srryzi-pshthy-hsth">سرریزِ پشته‌ی هسته</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#t-wyd-pshthh">تعویض پشته‌ها</a>
                <ul>
                    <li>
                        <a href="index.html#ist-w-tss">IST و TSS</a>
                    </li><li>
                        <a href="index.html#yjd-ykh-tss">ایجاد یک TSS</a>
                    </li><li>
                        <a href="index.html#jdwl-twsyfgr-srsry">جدول توصیف‌گر سراسری</a>
                    </li><li>
                        <a href="index.html#mrhl-pyny">مراحل پایانی</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#tst-srryz-pshth">تست سرریز پشته</a>
                <ul>
                    <li>
                        <a href="index.html#pydhszy-start">پیاده‌سازی start_</a>
                    </li><li>
                        <a href="index.html#tst-idt">تست IDT</a>
                    </li><li>
                        <a href="index.html#mdyr-khty-dwgnh">مدیر خطای دوگانه</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khlsh">خلاصه</a>
                
            </li><li>
                <a href="index.html#b-dy-chyst">بعدی چیست؟</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
        </ul>
    </details>

<h2 id="khty-dwgnh-chyst"><a class="zola-anchor" href="index.html#khty-dwgnh-chyst" aria-label="Anchor link for: khty-dwgnh-chyst">🔗</a>خطای دوگانه چیست؟</h2>
<p>به عبارت ساده، خطای دوگانه یک استثنای به خصوص است و هنگامی رخ می‌دهد که CPU نتواند یک کنترل کننده استثنا را فراخوانی کند. به عنوان مثال، این اتفاق هنگامی رخ می‌دهد که یک page fault (ترجمه: خطای صفحه) رخ دهد اما هیچ کنترل کننده خطایی در <a href="../../cpu-exceptions/index.html#the-interrupt-descriptor-table">جدول توصیف کننده وقفه</a> (ترجمه: Interrupt Descriptor Table) ثبت نشده باشد. بنابراین به نوعی شبیه بلاک‌های همه گیر در زبان‌های برنامه‌نویسی با استثناها می‌باشد، به عنوان مثال <code>catch(...)</code> در ++C یا <code>catch(Exception e)</code> در جاوا و #C.</p>
<p>خطای دوگانه مانند یک استثنای عادی رفتار می‌کند. دارای شماره وکتور (کلمه: vector) <code>8</code> است و ما می‌توانیم یک تابع طبیعی کنترل کننده برای آن در IDT تعریف کنیم. تهیه یک کنترل کننده خطای دوگانه بسیار مهم است، زیرا اگر یک خطای دوگانه کنترل نشود، یک خطای کشنده سه گانه رخ می‌دهد. خطاهای سه گانه قابل کشف نیستند و اکثر سخت افزارها با تنظیم مجدد سیستم واکنش نشان می‌دهند.</p>
<h3 id="rhndzy-ykh-khty-dwgnh"><a class="zola-anchor" href="index.html#rhndzy-ykh-khty-dwgnh" aria-label="Anchor link for: rhndzy-ykh-khty-dwgnh">🔗</a>راه‌اندازی یک خطای دوگانه</h3>
<p>بیایید یک خطای دوگانه را با راه‌اندازی (ترجمه: triggering) یک استثنا برای آن ایجاد کنیم، ما هنوز یک تابع کنترل کننده تعریف نکرده‌ایم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    blog_os::init();
</span><span>
</span><span>    </span><span style="color:#608b4e;">// trigger a page fault
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        *(</span><span style="color:#b5cea8;">0xdeadbeef </span><span style="color:#569cd6;">as *mut u64</span><span>) = </span><span style="color:#b5cea8;">42</span><span>;
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#608b4e;">// as before
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>برای نوشتن در آدرس نامعتبر <code>0xdeadbeef</code> از<code> unsafe</code> استفاده می‌کنیم. آدرس مجازی در جداول صفحه به آدرس فیزیکی مپ نمی‌شود، بنابراین خطای صفحه رخ می‌دهد. ما یک کنترل کننده خطای صفحه در <a href="../../cpu-exceptions/index.html#the-interrupt-descriptor-table">IDT</a> خود ثبت نکرده‌ایم، بنابراین یک خطای دوگانه رخ می‌دهد.</p>
<p>حال وقتی هسته را اجرا می‌کنیم، می‌بینیم که وارد یک حلقه بوت بی‌پایان می‌شود. دلایل حلقه بوت به شرح زیر است:</p>
<p>۱. سی‌پی‌یو سعی به نوشتن در <code>0xdeadbeef</code> دارد، که باعث خطای صفحه می‌شود.
۲. سی‌پی‌یو به ورودی مربوطه در IDT نگاه می‌کند و می‌بیند که هیچ تابع کنترل کننده‌ای مشخص نشده است. بنابراین، نمی‌تواند کنترل کننده خطای صفحه را فراخوانی کند و یک خطای دوگانه رخ می‌دهد.
۳. سی‌پی‌یو ورودی IDT کنترل کننده خطای دو گانه را بررسی می‌کند، اما این ورودی هم تابع کنترل کننده‌ای را  مشخص نمی‌کند. بنابراین، یک خطای <em>سه‌گانه</em> رخ می‌دهد.
۴. خطای سه گانه کشنده است. QEMU مانند اکثر سخت افزارهای واقعی به آن واکنش نشان داده دستور ریست شدن سیستم را صادر می‌کند.</p>
<p>بنابراین برای جلوگیری از این خطای سه‌گانه، باید یک تابع کنترل کننده برای خطاهای صفحه یا یک کنترل کننده خطای دوگانه ارائه دهیم. ما می‌خواهیم در همه موارد از خطاهای سه گانه جلوگیری کنیم، بنابراین بیایید با یک کنترل کننده خطای دوگانه شروع کنیم که برای همه انواع استثنا بدون کنترل فراخوانی می‌شود.</p>
<h2 id="khntrl-khnndh-khty-dwgnh"><a class="zola-anchor" href="index.html#khntrl-khnndh-khty-dwgnh" aria-label="Anchor link for: khntrl-khnndh-khty-dwgnh">🔗</a>کنترل کننده خطای دوگانه</h2>
<p>خطای دوگانه یک استثنا عادی با کد خطا است، بنابراین می‌توانیم یک تابع کنترل کننده مشابه کنترل کننده نقطه شکست (ترجمه: breakpoint) تعیین کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        idt.double_fault.set_handler_fn(double_fault_handler); </span><span style="color:#608b4e;">// new
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// new
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>double_fault_handler(
</span><span>    stack_frame: InterruptStackFrame, _error_code: </span><span style="color:#569cd6;">u64</span><span>) -&gt; </span><span style="color:#569cd6;">!
</span><span>{
</span><span>    panic!(</span><span style="color:#d69d85;">&quot;EXCEPTION: DOUBLE FAULT</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">{:#?}&quot;</span><span>, stack_frame);
</span><span>}
</span></code></pre>
<p>کنترل کننده ما یک پیام خطای کوتاه چاپ می‌کند و قاب پشته استثنا را تخلیه می‌کند. کد خطای کنترل کننده خطای دوگانه همیشه صفر است، بنابراین دلیلی برای چاپ آن وجود ندارد. یک تفاوت در کنترل کننده نقطه شکست این است که کنترل کننده خطای دوگانه <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/diverging.html"><em>diverging</em></a> (ترجمه: واگرا) است. چون معماری <code>x86_64</code> امکان بازگشت از یک استثنا خطای دوگانه را ندارد.</p>
<p>حال وقتی هسته را اجرا می‌کنیم، باید ببینیم که کنترل کننده خطای دوگانه فراخوانی می‌شود:</p>
<p><img src="qemu-catch-double-fault.png" alt="QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame" /></p>
<p>کار کرد! آن‌چه این بار اتفاق می‌افتد بصورت زیر است:</p>
<p>۱. سی‌پی‌یو سعی به نوشتن در <code>0xdeadbeef</code> دارد، که باعث خطای صفحه می‌شود.
۲. مانند قبل، سی‌پی‌یو به ورودی مربوطه در IDT نگاه می‌کند و می‌بیند که هیچ تابع کنترل کننده‌ای مشخص نشده است. بنابراین، یک خطای دوگانه رخ می‌دهد.
۳. سی‌پی‌یو به کنترل کننده خطای دوگانه - که اکنون وجود دارد - می‌رود.</p>
<p>خطای سه گانه (و حلقه بوت) دیگر رخ نمی‌دهد، زیرا اکنون CPU می‌تواند کنترل کننده خطای دوگانه را فراخوانی کند.</p>
<p>این کاملاً ساده بود! پس چرا ما برای این موضوع به یک پست کامل نیاز داریم؟ خب، ما اکنون قادر به ردیابی <em>اکثر</em> خطاهای دوگانه هستیم، اما مواردی وجود دارد که رویکرد فعلی ما کافی نیست.</p>
<h2 id="ll-rkh-dd-khty-dwgnh"><a class="zola-anchor" href="index.html#ll-rkh-dd-khty-dwgnh" aria-label="Anchor link for: ll-rkh-dd-khty-dwgnh">🔗</a>علل رخ داد خطای دوگانه</h2>
<p>قبل از بررسی موارد خاص، باید علل دقیق خطاهای دوگانه را بدانیم. در بالا، ما از یک تعریف کاملا مبهم استفاده کردیم:</p>
<blockquote>
<p>خطای دوگانه یک استثنای به خصوص است و هنگامی رخ می‌دهد که CPU نتواند یک کنترل کننده استثنا را فراخوانی کند.</p>
</blockquote>
<p>عبارت <em>“fails to invoke”</em> دقیقا چه معنایی دارد؟ کنترل کننده وجود ندارد؟ کنترل کننده <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf">خارج شده</a> (منظور این است که آیا صفحه مربوط به کنترل کننده از حافظه خارج شده)؟ و اگر کنترل کننده خودش باعث رخ دادن یک استثناها شود، چه اتفاقی رخ می‌دهد؟</p>
<p>به عنوان مثال، چه اتفاقی می‌افتد اگر:</p>
<p>۱. یک استثنای نقطه شکست رخ می‌دهد، آیا تابع کنترل کننده مربوطه خارج شده است؟
۲. یک خطای صفحه رخ می‌دهد، آیا کنترل کننده خطای صفحه خارج شده است؟
۳. کنترل کننده‌ی «تقسیم بر صفر» باعث رخ دادن یک استثنای نقطه شکست می‌شود، آیا کنترل کننده نقطه شکست خارج شده است؟
۴. هسته ما پشته خود را سرریز می‌کند و آیا <em>صفحه محافظ</em> (ترجمه: guard page) ضربه می‌خورد؟</p>
<p>خوشبختانه، کتابچه راهنمای AMD64 (<a href="https://www.amd.com/system/files/TechDocs/24593.pdf">PDF</a>) یک تعریف دقیق دارد (در بخش 8.2.9). مطابق آن، “یک استثنای خطای دوگانه <em>می‌تواند</em> زمانی اتفاق بیفتد که یک استثنا دوم هنگام کار با یک کنترل کننده استثنا قبلی (اول) رخ دهد”. <em>“می تواند”</em> مهم است: فقط ترکیبی بسیار خاص از استثناها منجر به خطای دوگانه می‌شود. این ترکیبات عبارتند از:</p>
<table><thead><tr><th>استثنای اول</th><th>استثنای دوم</th></tr></thead><tbody>
<tr><td><a href="https://wiki.osdev.org/Exceptions#Divide-by-zero_Error">Divide-by-zero</a>,<br><a href="https://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td><td><a href="https://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td></tr>
<tr><td><a href="https://wiki.osdev.org/Exceptions#Page_Fault">Page Fault</a></td><td><a href="https://wiki.osdev.org/Exceptions#Page_Fault">Page Fault</a>,<br><a href="https://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="https://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="https://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="https://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td></tr>
</tbody></table>
<p>بنابراین به عنوان مثال، یک خطای تقسیم بر صفر (ترجمه: Divide-by-zero) و به دنبال آن خطای صفحه (ترجمه: Page Fault)، خوب است (کنترل کننده خطای صفحه فراخوانی می‌شود)، اما خطای تقسیم بر صفر و به دنبال آن یک خطای محافظت عمومی (ترجمه: General Protection) منجر به خطای دوگانه می شود.</p>
<p>با کمک این جدول می‌توانیم به سه مورد اول از سوال‌های بالا پاسخ دهیم:</p>
<p>۱. اگر یک استثنای نقطه شکست اتفاق بیفتد و تابع مربوط به کنترل کننده آن خارج شده باشد، یک <em>خطای صفحه</em> رخ می‌دهد و <em>کنترل کننده خطای صفحه</em> فراخوانی می‌شود.
۲. اگر خطای صفحه رخ دهد و کنترل کننده خطای صفحه خارج شده باشد، یک <em>خطای دوگانه</em> رخ می‌دهد و <em>کنترل کننده خطای دوگانه</em> فراخوانی می‌شود.
۳. اگر یک کنترل کننده تقسیم بر صفر باعث استثنای نقطه شکست شود، CPU سعی می‌کند تا کنترل کننده نقطه شکست را فراخوانی کند. اگر کنترل کننده نقطه شکست خارج شده باشد، یک <em>خطای صفحه</em> رخ می‌دهد و <em>کنترل کننده خطای صفحه</em> فراخوانی می‌شود.</p>
<p>در حقیقت، حتی موارد استثنا بدون تابع کنترل کننده در IDT نیز از این طرح پیروی می‌کند: وقتی استثنا رخ می‌دهد، CPU سعی می‌کند ورودی IDT مربوطه را بخواند. از آن‌جا که ورودی 0 است، که یک ورودی IDT معتبر نیست، یک <em>خطای محافظت کلی</em> رخ می‌دهد. ما یک تابع کنترل کننده برای خطای محافظت عمومی نیز تعریف نکردیم، بنابراین یک خطای محافظت عمومی دیگر رخ می‌دهد. طبق جدول، این منجر به یک خطای دوگانه می‌شود.</p>
<h3 id="srryzi-pshthy-hsth"><a class="zola-anchor" href="index.html#srryzi-pshthy-hsth" aria-label="Anchor link for: srryzi-pshthy-hsth">🔗</a>سرریزِ پشته‌ی هسته</h3>
<p>بیایید به سوال چهارم نگاه کنیم:</p>
<blockquote>
<p>چه اتفاقی می‌افتد اگر هسته ما پشته خود را سرریز کند و صفحه محافظ ضربه بخورد؟</p>
</blockquote>
<p>یک صفحه محافظ یک صفحه حافظه ویژه در پایین پشته است که امکان تشخیصِ سرریز پشته را فراهم می‌کند. صفحه به هیچ قاب فیزیکی مپ نشده است، بنابراین دسترسی به آن باعث خطای صفحه می‌شود به جای اینکه بی صدا حافظه دیگر را خراب کند. بوت‌لودر یک صفحه محافظ برای پشته هسته ما تنظیم می‌کند، بنابراین سرریز پشته باعث <em>خطای صفحه</em> می‌شود.</p>
<p>هنگامی که خطای صفحه رخ می‌دهد، پردازنده به دنبال کنترل کننده خطای صفحه در IDT است و سعی می‌کند تا <a href="../../cpu-exceptions/index.html#the-interrupt-stack-frame">قاب پشته وقفه</a> را به پشته پوش می‌کند. با این حال، اشاره‌گر پشته فعلی هنوز به صفحه محافظی اشاره می‌کند که موجود نیست. بنابراین، خطای صفحه دوم رخ می‌دهد، که باعث خطای دوگانه می‌شود (مطابق جدول فوق).</p>
<p>بنابراین حالا پردازنده سعی می‌کند <em>کنترل کننده خطای دوگانه</em> را فراخوانی کند. با این حال، هنگام رخ دادن خطای دوگانه پردازنده سعی می‌کند تا قاب پشته استثنا را نیز پوش کند. اشاره‌گر پشته هنوز به سمت صفحه محافظ است، بنابراین یک خطای صفحه <em>سوم</em> رخ می‌هد که باعث یک <em>خطای سه‌گانه</em> و راه اندازی مجدد سیستم می‌شود. بنابراین کنترل کننده خطای دوگانه فعلی ما نمی‌تواند از خطای سه‌گانه در این مورد جلوگیری کند.</p>
<p>بیایید خودمان امتحان کنیم! ما می‌توانیم با فراخوانی تابعی که به طور بی‌وقفه بازگشت می‌یابد، به راحتی سرریز پشته هسته را تحریک کنیم (باعث رخ دادن یک سرریز پشته هسته شویم):</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// don&#39;t mangle the name of this function
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>
</span><span>    blog_os::init();
</span><span>
</span><span>    </span><span style="color:#569cd6;">fn </span><span>stack_overflow() {
</span><span>        stack_overflow(); </span><span style="color:#608b4e;">// for each recursion, the return address is pushed
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#608b4e;">// trigger a stack overflow
</span><span>    stack_overflow();
</span><span>
</span><span>    […] </span><span style="color:#608b4e;">// test_main(), println(…), and loop {}
</span><span>}
</span></code></pre>
<p>وقتی این کد را در QEMU امتحان می‌کنیم، می‌بینیم که سیستم دوباره وارد یک حلقه بوت می‌شود.</p>
<p>بنابراین چگونه می‌توانیم از بروز این مشکل جلوگیری کنیم؟ ما نمی‌توانیم پوش کردن قاب پشته استثنا را حذف کنیم، زیرا پردازنده خود این کار را انجام می‌دهد. بنابراین ما باید به نحوی اطمینان حاصل کنیم که وقتی یک استثنای خطای دوگانه رخ می‌دهد، پشته همیشه معتبر است. خوشبختانه، معماری x86_64 راه حلی برای این مشکل دارد.</p>
<h2 id="t-wyd-pshthh"><a class="zola-anchor" href="index.html#t-wyd-pshthh" aria-label="Anchor link for: t-wyd-pshthh">🔗</a>تعویض پشته‌ها</h2>
<p>معماری x86_64 قادر است در صورت وقوع یک استثنا به یک پشته از پیش تعریف شده و شناخته شده تعویض شود. این تعویض در سطح سخت افزاری اتفاق می‌افتد، بنابراین می‌توان آن را قبل از اینکه پردازنده قاب پشته استثنا را پوش کند، انجام داد.</p>
<p>مکانیزم تعویض به عنوان <em>Interrupt Stack Table</em> (IST) پیاده‌سازی می‌شود. IST جدولی است با 7 اشاره‌گر برای دسته های معروف. در شبه‌ کد شبیه Rust:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">struct </span><span>InterruptStackTable {
</span><span>    stack_pointers: [Option&lt;StackPointer&gt;; 7],
</span><span>}
</span></code></pre>
<p>برای هر کنترل کننده استثنا، می‌توانیم یک پشته از IST از طریق فیلد <code>stack_pointers</code> مربوط به <a href="../../cpu-exceptions/index.html#the-interrupt-descriptor-table">IDT entry</a> انتخاب کنیم. به عنوان مثال، ما می‌توانیم از اولین پشته در IST برای کنترل کننده خطای دوگانه استفاده کنیم. هرگاه خطای دوگانه رخ دهد، پردازنده به طور خودکار به این پشته تغییر می‌کند. این تعویض قبل از پوش کردن هر چیزی اتفاق می‌افتد، بنابراین از خطای سه‌گانه جلوگیری می‌کند.</p>
<h3 id="ist-w-tss"><a class="zola-anchor" href="index.html#ist-w-tss" aria-label="Anchor link for: ist-w-tss">🔗</a>IST و TSS</h3>
<p>جدول پشته وقفه (ترجمه: Interrupt Stack Table: IST) بخشی از یک ساختار قدیمی است که به آن <em><a href="https://en.wikipedia.org/wiki/Task_state_segment">سگمنت وضعیت پروسه</a></em> (Task State Segment: TSS) گفته می‌شود. TSS برای نگهداری اطلاعات مختلف (به عنوان مثال وضعیت ثبات پردازنده) در مورد یک پروسه در حالت 32 بیتی استفاده می‌شد و به عنوان مثال برای <a href="https://wiki.osdev.org/Context_Switching#Hardware_Context_Switching">تعویض سخت‌افزاری context</a> (ترجمه: hardware context switching) استفاده می‌شد. با این حال، تعویض سخت‌افزاری context دیگر در حالت 64 بیتی پشتیبانی نمی‌شود و قالب TSS کاملاً تغییر کرده است.</p>
<p>در x86_64، دیگر TSS هیچ اطلاعات خاصی برای پرسه‌ها ندارد. در عوض، دو جدول پشته را در خود جای داده است (IST یکی از آنهاست). تنها فیلد مشترک بین TSS 32-bit و TSS 64-bit اشاره‌گر به <a href="https://en.wikipedia.org/wiki/Task_state_segment#I.2FO_port_permissions">بیت‌مپ مجوزهای پورت I/O</a> است.</p>
<p>فرمت TSS 64-bit مانند زیر است:</p>
<table><thead><tr><th>فیلد</th><th>نوع</th></tr></thead><tbody>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u32</code></td></tr>
<tr><td>Privilege Stack Table</td><td><code>[u64; 3]</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u64</code></td></tr>
<tr><td>Interrupt Stack Table</td><td><code>[u64; 7]</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u64</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u16</code></td></tr>
<tr><td>I/O Map Base Address</td><td><code>u16</code></td></tr>
</tbody></table>
<p>وقتی سطح ممتاز تغییر می‌کند، پردازنده از <em>Privilege Stack Table</em> استفاده می‌کند. به عنوان مثال، اگر یک استثنا در حالی که CPU در حالت کاربر است (سطح ممتاز 3) رخ دهد، CPU معمولاً قبل از فراخوانی کنترل کننده استثنا، به حالت هسته تغییر می‌کند (سطح امتیاز 0). در این حالت، CPU به پشته صفرم در جدول پشته ممتاز تغییر وضعیت می دهد (از آنجا که 0، سطح ممتاز هدف است). ما هنوز هیچ برنامه حالت کاربر نداریم، بنابراین اکنون این جدول را نادیده می‌گیریم.</p>
<h3 id="yjd-ykh-tss"><a class="zola-anchor" href="index.html#yjd-ykh-tss" aria-label="Anchor link for: yjd-ykh-tss">🔗</a>ایجاد یک TSS</h3>
<p>بیایید یک TSS جدید ایجاد کنیم که شامل یک پشته خطای دوگانه جداگانه در جدول پشته وقفه خود باشد. برای این منظور ما به یک ساختار TSS نیاز داریم. خوشبختانه کریت <code>x86_64</code> از قبل حاوی <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/tss/struct.TaskStateSegment.html">ساختار <code>TaskStateSegment</code></a> است که می‌توانیم از آن استفاده کنیم.</p>
<p>ما TSS را در یک ماژول جدید به نام <code>gdt</code> ایجاد می‌کنیم (نام این ماژول بعداً برای‌تان معنا پیدا می‌کند):</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>gdt;
</span><span>
</span><span style="color:#608b4e;">// in src/gdt.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::VirtAddr;
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::tss::TaskStateSegment;
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span>
</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span>: </span><span style="color:#569cd6;">u16 </span><span>= </span><span style="color:#b5cea8;">0</span><span>;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">TSS</span><span>: TaskStateSegment = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> tss = TaskStateSegment::new();
</span><span>        tss.interrupt_stack_table[</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX </span><span style="color:#569cd6;">as usize</span><span>] = {
</span><span>            </span><span style="color:#569cd6;">const </span><span style="color:#b4cea8;">STACK_SIZE</span><span>: </span><span style="color:#569cd6;">usize </span><span>= </span><span style="color:#b5cea8;">4096 </span><span>* </span><span style="color:#b5cea8;">5</span><span>;
</span><span>            </span><span style="color:#569cd6;">static mut </span><span style="color:#b4cea8;">STACK</span><span>: [</span><span style="color:#569cd6;">u8</span><span>; </span><span style="color:#b4cea8;">STACK_SIZE</span><span>] = [</span><span style="color:#b5cea8;">0</span><span>; </span><span style="color:#b4cea8;">STACK_SIZE</span><span>];
</span><span>
</span><span>            </span><span style="color:#569cd6;">let</span><span> stack_start = VirtAddr::from_ptr(</span><span style="color:#569cd6;">unsafe </span><span>{ </span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">STACK </span><span>});
</span><span>            </span><span style="color:#569cd6;">let</span><span> stack_end = stack_start + </span><span style="color:#b4cea8;">STACK_SIZE</span><span>;
</span><span>            stack_end
</span><span>        };
</span><span>        tss
</span><span>    };
</span><span>}
</span></code></pre>
<p>ما از <code>lazy_static</code> استفاده می‌کنیم زیرا ارزیابی کننده ثابت راست هنوز آن‌قدر توانمند نیست که بتواند این مقداردهی اولیه را در زمان کامپایل انجام دهد. ما تعریف می‌کنیم که ورودی صفرم IST پشته خطای دوگانه است (هر اندیس دیگری از IST نیز قابل استفاده است). سپس آدرس بالای یک پشته خطای دوگانه را در ورودی صفرم می‌نویسیم. ما آدرس بالایی را می‌نویسیم زیرا پشته‌های x86 به سمت پایین رشد می‌کنند، یعنی از آدرس‌های بالا به آدرس‌های پایین می‌آیند.</p>
<p>ما هنوز مدیریت حافظه را پیاده سازی نکرده‌ایم، بنابراین روش مناسبی برای اختصاص پشته جدید نداریم. در عوض، فعلاً از یک آرایه <code>static mut</code> به عنوان حافظه پشته استفاده میکنیم. <code>unsafe</code> لازم است زیرا هنگام دسترسی به استاتیک‌های تغییرپذیر (ترجمه: mutable)، کامپایلر نمی‌تواند عدم وجود رقابت بین داده ها را تضمین کند. مهم است که یک <code>static mut</code> باشد و نه یک استاتیک‌ تغییرناپذیر (ترجمه: immutable)، زیرا در غیر این صورت bootloader آن را به یک صفحه فقط خواندنی نگاشت می‌کند. ما در پست بعدی این را با یک تخصیص پشته مناسب جایگزین خواهیم کرد، سپس <code>unsafe</code> دیگر در این‌جا مورد نیاز نخواهد بود.</p>
<p>توجه داشته باشید که این پشته خطای دوگانه فاقد صفحه محافظ در برابر سرریز پشته است. یعنی ما نباید هیچ کاری که اضافه شدن ایتمی در پشته شود را انجام دهیم زیرا سرریز پشته ممکن است حافظه زیر پشته را خراب کند.</p>
<h4 id="brgdhry-tss"><a class="zola-anchor" href="index.html#brgdhry-tss" aria-label="Anchor link for: brgdhry-tss">🔗</a>بارگذاری TSS</h4>
<p>اکنون که TSS جدیدی ایجاد کردیم، به روشی نیاز داریم که به CPU بگوییم باید از آن استفاده کند. متأسفانه این کمی دشوار است، زیرا TSS به دلایل تاریخی از سیستم سگمنت‌بندی (ترجمه: segmentation) استفاده می‌کند. به جای بارگذاری مستقیم جدول، باید توصیفگر سگمنت جدیدی را به <a href="https://web.archive.org/web/20190217233448/https://www.flingos.co.uk/docs/reference/Global-Descriptor-Table/">جدول توصیف‌گر سراسری</a> (Global Descriptor Table: GDT) اضافه کنیم. سپس می‌توانیم TSS خود را با فراخوانی <a href="https://www.felixcloutier.com/x86/ltr">دستور <code>ltr</code></a> با اندیس GDT مربوطه بارگذاری کنیم. (دلیل این‌که نام ماژول را <code>gdt</code> گذاشتیم نیز همین بود).</p>
<h3 id="jdwl-twsyfgr-srsry"><a class="zola-anchor" href="index.html#jdwl-twsyfgr-srsry" aria-label="Anchor link for: jdwl-twsyfgr-srsry">🔗</a>جدول توصیف‌گر سراسری</h3>
<p>جدول توصیف‌گر سراسری (GDT) یک یادگاری است که قبل از این‌که صفحه‌بندی به صورت استاندارد تبدیل شود، برای <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">تقسیم‌بندی حافظه</a> استفاده می‌شد. این مورد همچنان در حالت 64 بیتی برای موارد مختلف مانند پیکربندی هسته/کاربر یا بارگذاری TSS مورد نیاز است.</p>
<p>جدول توصیف‌گر سراسری، ساختاری است که شامل <em>بخشهای</em> برنامه است. قبل از اینکه صفحه‌بندی به استاندارد تبدیل شود، از آن در معماری‌های قدیمی استفاده می‌شد تا برنامه ها را از یکدیگر جدا کند. برای کسب اطلاعات بیشتر در مورد سگمنت‌بندی، فصل مربوط به این موضوع در <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">کتاب “Three Easy Pieces”</a> را مطالعه کنید. در حالی که سگمنت‌بندی در حالت 64 بیتی دیگر پشتیبانی نمی‌شود، GDT هنوز وجود دارد. بیشتر برای دو چیز استفاده می‌شود: جابجایی بین فضای هسته و فضای کاربر، و بارگذاری ساختار TSS.</p>
<h4 id="yjd-ykh-gdt"><a class="zola-anchor" href="index.html#yjd-ykh-gdt" aria-label="Anchor link for: yjd-ykh-gdt">🔗</a>ایجاد یک GDT</h4>
<p>بیایید یک <code>GDT</code> استاتیک ایجاد کنیم که شامل یک بخش برای TSS استاتیک ما باشد:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/gdt.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::gdt::{GlobalDescriptorTable, Descriptor};
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">GDT</span><span>: GlobalDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> gdt = GlobalDescriptorTable::new();
</span><span>        gdt.add_entry(Descriptor::kernel_code_segment());
</span><span>        gdt.add_entry(Descriptor::tss_segment(</span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">TSS</span><span>));
</span><span>        gdt
</span><span>    };
</span><span>}
</span></code></pre>
<p>ما دوباره از <code>lazy_static</code> استفاده می‌کنیم، زیرا ارزیابی کننده ثابت راست هنوز آن‌قدر توانمند نیست. ما یک GDT جدید با یک کد سگمنت و یک بخش TSS ایجاد می‌کنیم.</p>
<h4 id="brgdhry-gdt"><a class="zola-anchor" href="index.html#brgdhry-gdt" aria-label="Anchor link for: brgdhry-gdt">🔗</a>بارگذاری GDT</h4>
<p>برای بارگذاری GDT، یک تابع جدید <code>gdt::init</code> ایجاد می‌کنیم که آن را از تابع <code>init</code> فراخوانی می‌کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/gdt.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    </span><span style="color:#b4cea8;">GDT</span><span>.load();
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    gdt::init();
</span><span>    interrupts::init_idt();
</span><span>}
</span></code></pre>
<p>اکنون GDT ما بارگذاری شده است (از آن‌جا که تابع <code>start_</code>، تابع <code>init</code> را فراخوانی می‌کند)، اما هنوز حلقه بوت را هنگامِ سرریز پشته مشاهده می‌کنیم.</p>
<h3 id="mrhl-pyny"><a class="zola-anchor" href="index.html#mrhl-pyny" aria-label="Anchor link for: mrhl-pyny">🔗</a>مراحل پایانی</h3>
<p>مشکل این است که سگمنت‌های GDT هنوز فعال نیستند زیرا سگمنت و ثبات‌های TSS هنوز حاوی مقادیر GDT قدیمی هستند. ما همچنین باید ورودی خطای دوگانه IDT را اصلاح کنیم تا از پشته جدید استفاده کند.</p>
<p>به طور خلاصه، باید موارد زیر را انجام دهیم:</p>
<p>۱. <strong>بارگذاری مجدد ثبات کد سگمنت</strong>: ما GDT خود را تغییر دادیم، بنابراین باید <code>cs</code>، ثبات کد سگمنت را بارگذاری مجدد کنیم. این مورد الزامی است زیرا انتخاب‌گر سگمنت قدیمی می‌تواند اکنون توصیف‌گر دیگری از GDT را نشان دهد (به عنوان مثال توصیف کننده TSS).
۲. <strong>بارگذاری TSS</strong>: ما یک GDT بارگذاری کردیم که شامل یک انتخاب‌گر TSS است، اما هنوز باید به CPU بگوییم که باید از آن TSS استفاده کند.
۳. <strong>بروزرسانی ورودی IDT</strong>: به محض این‌که TSS بارگذاری شد، CPU به یک جدول پشته وقفه معتبر (IST) دسترسی دارد. سپس می‌توانیم به CPU بگوییم که باید با تغییر در ورودی IDT خطای دوگانه از پشته خطای دوگانه جدید استفاده کند.</p>
<p>برای دو مرحله اول، ما نیاز به دسترسی به متغیرهای<code> code_selector</code> و <code>tss_selector</code> در تابع <code>gdt::init</code> داریم. می‌توانیم با تبدیل آن‌ها به بخشی از استاتیک از طریق ساختار جدید <code>Selectors</code> به این هدف برسیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/gdt.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::gdt::SegmentSelector;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">GDT</span><span>: (GlobalDescriptorTable, Selectors) = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> gdt = GlobalDescriptorTable::new();
</span><span>        </span><span style="color:#569cd6;">let</span><span> code_selector = gdt.add_entry(Descriptor::kernel_code_segment());
</span><span>        </span><span style="color:#569cd6;">let</span><span> tss_selector = gdt.add_entry(Descriptor::tss_segment(</span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">TSS</span><span>));
</span><span>        (gdt, Selectors { code_selector, tss_selector })
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">struct </span><span>Selectors {
</span><span>    code_selector: SegmentSelector,
</span><span>    tss_selector: SegmentSelector,
</span><span>}
</span></code></pre>
<p>اکنون می‌توانیم با استفاده از انتخاب‌گرها، ثبات بخش <code>cs</code> را بارگذاری مجدد کرده و <code>TSS</code> را بارگذاری کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/gdt.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::segmentation::set_cs;
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::tables::load_tss;
</span><span>
</span><span>    </span><span style="color:#b4cea8;">GDT</span><span>.</span><span style="color:#b5cea8;">0.</span><span>load();
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        set_cs(</span><span style="color:#b4cea8;">GDT</span><span>.</span><span style="color:#b5cea8;">1.</span><span>code_selector);
</span><span>        load_tss(</span><span style="color:#b4cea8;">GDT</span><span>.</span><span style="color:#b5cea8;">1.</span><span>tss_selector);
</span><span>    }
</span><span>}
</span></code></pre>
<p>ما با استفاده از <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/segmentation/fn.set_cs.html"><code>set_cs</code></a> ثبات کد سگمنت را بارگذاری مجدد می‌کنیم و برای بارگذاری TSS با از <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/tables/fn.load_tss.html"><code>load_tss</code></a> استفاده می‌کنیم. توابع به عنوان <code>unsafe</code> علامت گذاری شده‌اند، بنابراین برای فراخوانی آن‌ها به یک بلوک <code>unsafe</code> نیاز داریم. چون ممکن است با بارگذاری انتخاب‌گرهای نامعتبر، ایمنی حافظه از بین برود.</p>
<p>اکنون که یک TSS معتبر و جدول پشته‌ وقفه را بارگذاری کردیم، می‌توانیم اندیس پشته را برای کنترل کننده خطای دوگانه در IDT تنظیم کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use crate</span><span>::gdt;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>            idt.double_fault.set_handler_fn(double_fault_handler)
</span><span>                .set_stack_index(gdt::</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span>); </span><span style="color:#608b4e;">// new
</span><span>        }
</span><span>
</span><span>        idt
</span><span>    };
</span><span>}
</span></code></pre>
<p>روش <code>set_stack_index</code> ایمن نیست زیرا فراخوان (ترجمه: caller) باید اطمینان حاصل کند که اندیس استفاده شده معتبر است و قبلاً برای استثنای دیگری استفاده نشده است.</p>
<p>همین! اکنون CPU باید هر زمان که خطای دوگانه رخ داد، به پشته خطای دوگانه برود. بنابراین، ما می‌توانیم <em>همه</em> خطاهای دوگانه، از جمله سرریزهای پشته هسته را بگیریم:</p>
<p><img src="qemu-double-fault-on-stack-overflow.png" alt="QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame" /></p>
<p>از این به بعد هرگز نباید شاهد خطای سه‌گانه باشیم! برای اطمینان از اینکه موارد بالا را به طور تصادفی نقض نمی‌کنیم، باید یک تست برای این کار اضافه کنیم.</p>
<h2 id="tst-srryz-pshth"><a class="zola-anchor" href="index.html#tst-srryz-pshth" aria-label="Anchor link for: tst-srryz-pshth">🔗</a>تست سرریز پشته</h2>
<p>برای آزمایش ماژول <code>gdt</code> جدید و اطمینان از اینکه مدیر خطای دوگانه به درستی هنگام سرریز پشته فراخوانی شده است، می‌توانیم یک تست یکپارچه اضافه کنیم. ایده این است که یک خطای دوگانه در تابع تست ایجاد کنید و تأیید کنید که مدیر خطای دوگانه فراخوانی می‌شود.</p>
<p>بیایید با یک طرح مینیمال شروع کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/stack_overflow.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    unimplemented!();
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>مانند تست <code>panic_handler</code>، تست <a href="../../testing/index.html#no-harness-tests">بدون یک test harness</a> اجرا خواهد شد. زیرا پس از یک خطای دوگانه نمی‌توانیم اجرا را ادامه دهیم، بنابراین بیش از یک تست منطقی نیست. برای غیرفعال کردن test harness برای این تست، موارد زیر را به <code>Cargo.toml</code> اضافه می‌کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[[</span><span style="color:#808080;">test</span><span>]]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;stack_overflow&quot;
</span><span style="color:#569cd6;">harness </span><span>= </span><span style="color:#569cd6;">false
</span></code></pre>
<p>حال باید <code>cargo test --test stack_overflow</code> بصورت موفقیت‌آمیز کامپایل شود. البته این تست با شکست مواجه می‌شود، زیرا ماکروی <code>unimplemented</code> پنیک می‌کند.</p>
<h3 id="pydhszy-start"><a class="zola-anchor" href="index.html#pydhszy-start" aria-label="Anchor link for: pydhszy-start">🔗</a>پیاده‌سازی <code>start_</code></h3>
<p>پیاده‌سازی تابع <code>start_</code> مانند این است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/stack_overflow.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::serial_print;
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_print!(</span><span style="color:#d69d85;">&quot;stack_overflow::stack_overflow...</span><span style="color:#e3bbab;">\t</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>
</span><span>    blog_os::gdt::init();
</span><span>    init_test_idt();
</span><span>
</span><span>    </span><span style="color:#608b4e;">// trigger a stack overflow
</span><span>    stack_overflow();
</span><span>
</span><span>    panic!(</span><span style="color:#d69d85;">&quot;Execution continued after stack overflow&quot;</span><span>);
</span><span>}
</span><span>
</span><span>#[allow(unconditional_recursion)]
</span><span style="color:#569cd6;">fn </span><span>stack_overflow() {
</span><span>    stack_overflow(); </span><span style="color:#608b4e;">// for each recursion, the return address is pushed
</span><span>    volatile::Volatile::new(</span><span style="color:#b5cea8;">0</span><span>).read(); </span><span style="color:#608b4e;">// prevent tail recursion optimizations
</span><span>}
</span></code></pre>
<p>برای راه‌اندازی یک GDT جدید، تابع <code>gdt::init</code> را فراخوانی می‌کنیم. به جای فراخوانی تابع <code>interrupts::init_idt</code>، تابع <code>init_test_idt</code> را فراخوانی می‌کنیم که بزودی توضیح داده می‌شود. زیرا ما می‌خواهیم یک مدیر خطای دوگانه سفارشی ثبت کنیم که به جای پنیک کردن، دستور <code>exit_qemu(QemuExitCode::Success)</code> را انجام می‌دهد.</p>
<p>تابع <code>stack_overflow</code> تقریباً مشابه تابع موجود در <code>main.rs</code> است. تنها تفاوت این است که برای جلوگیری از بهینه‌سازی کامپایلر موسوم به <a href="https://en.wikipedia.org/wiki/Tail_call"><em>tail call elimination</em></a>، در پایان تابع، یک خواندنِ [فرارِ] (ترجمه: volatile) اضافه به وسیله نوع <a href="https://docs.rs/volatile/0.2.6/volatile/struct.Volatile.html"><code>Volatile</code></a> انجام می‌دهیم. از جمله، این بهینه‌سازی به کامپایلر اجازه می‌دهد تابعی را که آخرین عبارت آن فراخوانی تابع بازگشتی است، به یک حلقه طبیعی تبدیل کند. بنابراین، هیچ قاب پشته اضافی برای فراخوانی تابع ایجاد نمی‌شود، پس استفاده از پشته ثابت می‌ماند.</p>
<p>با این حال، در مورد ما، ما می‌خواهیم که سرریز پشته اتفاق بیفتد، بنابراین در انتهای تابع یک دستور خواندن فرار ساختگی اضافه می‌کنیم، که کامپایلر مجاز به حذف آن نیست. بنابراین، تابع دیگر <em>tail recursive</em> نیست و از تبدیل به یک حلقه جلوگیری می‌شود. ما همچنین صفت <code>allow(unconditional_recursion)</code> را اضافه می‌کنیم تا اخطار کامپایلر را در مورد تکرار بی‌وقفه تابع خاموش نگه دارد.</p>
<h3 id="tst-idt"><a class="zola-anchor" href="index.html#tst-idt" aria-label="Anchor link for: tst-idt">🔗</a>تست IDT</h3>
<p>همانطور که در بالا ذکر شد، این تست به IDT مخصوص خود با یک مدیر خطای دوگانه سفارشی نیاز دارد. پیاده‌سازی به این شکل است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/stack_overflow.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>lazy_static::lazy_static;
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::InterruptDescriptorTable;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">TEST_IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>            idt.double_fault
</span><span>                .set_handler_fn(test_double_fault_handler)
</span><span>                .set_stack_index(blog_os::gdt::</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span>);
</span><span>        }
</span><span>
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_test_idt() {
</span><span>    </span><span style="color:#b4cea8;">TEST_IDT</span><span>.load();
</span><span>}
</span></code></pre>
<p>پیاده‌سازی بسیار شبیه IDT طبیعی ما در <code>interrupts.rs</code> است. مانند IDT عادی، برای مدیر خطای دوگانه به منظور جابجایی به پشته‌ای جداگانه، یک اندیس پشته را در IST تنظیم می‌کنیم. تابع <code>init_test_idt</code> با استفاده از روش <code>load</code>، آی‌دی‌تی را بر روی پردازنده بارگذاری می‌کند.</p>
<h3 id="mdyr-khty-dwgnh"><a class="zola-anchor" href="index.html#mdyr-khty-dwgnh" aria-label="Anchor link for: mdyr-khty-dwgnh">🔗</a>مدیر خطای دوگانه</h3>
<p>تنها قسمت جامانده، مدیر خطای دوگانه است که به این شکل پیاده‌سازی می‌شود:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/stack_overflow.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::{exit_qemu, QemuExitCode, serial_println};
</span><span style="color:#569cd6;">use </span><span>x86_64::structures::idt::InterruptStackFrame;
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>test_double_fault_handler(
</span><span>    _stack_frame: InterruptStackFrame,
</span><span>    _error_code: </span><span style="color:#569cd6;">u64</span><span>,
</span><span>) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>هنگامی که مدیر خطای دوگانه فراخوانی می‌شود، از QEMU با یک کد خروج موفقیت‌آمیز خارج می‌شویم، که تست را بعنوان «قبول شده» علامت‌گذاری می‌داند. از آن‌جا که تست‌های یکپارچه اجرایی‌های کاملاً مجزایی هستند، باید صفت <code>[feature(abi_x86_interrupt)]!#</code> را در بالای فایل تست تنظیم کنیم.</p>
<p>اکنون می‌توانیم تست را از طریق <code>cargo test --test stack_overflow</code> (یا <code>cargo test</code> برای اجرای همه تست‌ها) انجام دهیم. همانطور که انتظار می‌رفت، خروجی <code>stack_overflow... [ok ]</code> را در کنسول مشاهده می‌کنیم. خط <code>set_stack_index</code> را کامنت کنید: این امر باعث می‌شود تست از کار بیفتد.</p>
<h2 id="khlsh"><a class="zola-anchor" href="index.html#khlsh" aria-label="Anchor link for: khlsh">🔗</a>خلاصه</h2>
<p>در این پست یاد گرفتیم که خطای دوگانه چیست و در چه شرایطی رخ می‌دهد. ما یک مدیر خطای دوگانه پایه اضافه کردیم که پیام خطا را چاپ می‌کند و یک تست یکپارچه برای آن اضافه کردیم.</p>
<p>ما همچنین تعویض پشته پشتیبانی شده سخت‌افزاری را در استثناهای خطای دوگانه فعال کردیم تا در سرریز پشته نیز کار کند. در حین پیاده‌سازی آن، ما با سگمنت وضعیت پروسه (TSS)، جدول پشته وقفه (IST) و جدول توصیف کننده سراسری (GDT) آشنا شدیم، که برای سگمنت‌بندی در معماری‌های قدیمی استفاده می‌شد.</p>
<h2 id="b-dy-chyst"><a class="zola-anchor" href="index.html#b-dy-chyst" aria-label="Anchor link for: b-dy-chyst">🔗</a>بعدی چیست؟</h2>
<p>پست بعدی نحوه مدیریت وقفه‌های دستگاه‌های خارجی مانند تایمر، صفحه کلید یا کنترل کننده‌های شبکه را توضیح می‌دهد. این وقفه‌های سخت‌افزاری بسیار شبیه به استثناها هستند، به عنوان مثال آن‌ها هم از طریق IDT ارسال می‌شوند. با این حال، برخلاف استثناها، مستقیماً روی پردازنده رخ نمی‌دهند. در عوض، یک <em>interrupt controller</em> این وقفه‌ها را جمع کرده و بسته به اولویت، آن‌ها را به CPU می‌فرستد. در بخش بعدی، مدیر وقفه <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> (“PIC”) را بررسی خواهیم کرد و نحوه پیاده‌سازی پشتیبانی صفحه کلید را یاد خواهیم گرفت.</p>

    </div>

    <div class="post-footer-support right-to-left">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../cpu-exceptions/index.html">&laquo; استثناهای پردازنده</a>
        
        
            <a class="next" href="../hardware-interrupts/index.html">وقفه‌های سخت‌افزاری &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="right-to-left">نظرات</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Double%20Faults%20%28fa%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="Double Faults (fa)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fa"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Double%20Faults%20%28fa%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="right-to-left">
            لطفا نظرات خود را در صورت امکان به انگلیسی بنویسید.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../double-fault-exceptions/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/double-fault-exceptions/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/double-fault-exceptions/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/double-fault-exceptions/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
