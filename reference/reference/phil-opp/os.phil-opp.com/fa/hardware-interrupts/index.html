<!doctype html>

<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="در این پست ما کنترل کننده قابل برنامه ریزی وقفه را تنظیم می کنیم تا وقفه های سخت افزاری را به درستی به پردازنده منتقل کند. برای مدیریت این وقفه‌ها ، مو…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>وقفه‌های سخت‌افزاری | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fa" title="All Posts">« همه پست‌ها</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="right-to-left">
        <h2>فهرست مطالب</h2>
    <ol>
        <li>
            <a href="index.html#mqdmh">مقدمه</a>
            
        </li><li>
            <a href="index.html#the-8259-pic">The 8259 PIC</a>
            <ol>
                <li>
                    <a href="index.html#pydh-szy">پیاده سازی</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#f-lszy-wqfhh">فعال‌سازی وقفه‌ها</a>
            
        </li><li>
            <a href="index.html#mdyryt-wqfhhy-tymr">مدیریت وقفه‌های تایمر</a>
            <ol>
                <li>
                    <a href="index.html#pyn-wqfh">پایان وقفه</a>
                </li><li>
                    <a href="index.html#pykhrbndy-tymr">پیکربندی تایمر</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#bnbst-h">بن‌بست ها</a>
            <ol>
                <li>
                    <a href="index.html#yjd-bnbst">ایجاد بن‌بست</a>
                </li><li>
                    <a href="index.html#rf-bnbst">رفع بن‌بست</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#rf-wd-yt-rqbty">رفع وضعیت رقابتی</a>
            
        </li><li>
            <a href="index.html#dstwrl-ml-hlt">دستورالعمل hlt</a>
            
        </li><li>
            <a href="index.html#wrwdy-sfhh-khlyd">ورودی صفحه کلید</a>
            <ol>
                <li>
                    <a href="index.html#khwndn-skhnkhd-h">خواندن اسکن‌کد ها</a>
                </li><li>
                    <a href="index.html#tfsyr-skhnkhd-h">تفسیر اسکن‌کد ها</a>
                </li><li>
                    <a href="index.html#pykhrbndy-sfhh-khlyd">پیکربندی صفحه کلید</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khlsh">خلاصه</a>
            
        </li><li>
            <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
    </ol>
</aside>

            <main>
    <div class="right-to-left">
    <h1>وقفه‌های سخت‌افزاری</h1>
    <time datetime="2018-10-22" class="post-date">
        Oct 22, 2018
        
    </time>
    </div>

    
        <div class="warning right-to-left">
            
            
            <p>
            <b>محتوای ترجمه شده:</b>
            این یک ترجمه از جامعه کاربران برای پست <strong><a href="../../hardware-interrupts/index.html">Hardware Interrupts</a></strong> است. ممکن است ناقص، منسوخ شده یا دارای خطا باشد. لطفا هر گونه مشکل را در <a href="https://github.com/phil-opp/blog_os/issues/908">این ایشو</a> گزارش دهید!
            </p>
            <p>
                ترجمه توسط <a href="https://github.com/hamidrezakp">@hamidrezakp</a> و <a href="https://github.com/MHBahrampour">@MHBahrampour</a>.</p>
            </div>
    

    <div class="right-to-left">
    <p>در این پست ما کنترل کننده قابل برنامه ریزی وقفه را تنظیم می کنیم تا وقفه های سخت افزاری را به درستی به پردازنده منتقل کند. برای مدیریت این وقفه‌ها ، موارد جدیدی به جدول توصیف کننده وقفه اضافه می کنیم ، دقیقاً مانند کارهایی که برای کنترل کننده های استثنا انجام دادیم. ما یاد خواهیم گرفت که چگونه وقفه های متناوب تایمر را گرفته و چگونه از صفحه کلید ورودی بگیریم.</p>
<span id="continue-reading"></span>
<p>این بلاگ بصورت آزاد بر روی <a href="https://github.com/phil-opp/blog_os">گیت‌هاب</a> توسعه داده شده. اگر مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. همچنین می‌توانید <a href="index.html#comments">در زیر</a> این پست کامنت بگذارید. سورس کد کامل این پست را می‌توانید در بِرَنچ <a href="https://github.com/phil-opp/blog_os/tree/post-07"><code>post-07</code></a> پیدا کنید.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>فهرست مطالب</b></summary>
        <ul>
            <li>
                <a href="index.html#mqdmh">مقدمه</a>
                
            </li><li>
                <a href="index.html#the-8259-pic">The 8259 PIC</a>
                <ul>
                    <li>
                        <a href="index.html#pydh-szy">پیاده سازی</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#f-lszy-wqfhh">فعال‌سازی وقفه‌ها</a>
                
            </li><li>
                <a href="index.html#mdyryt-wqfhhy-tymr">مدیریت وقفه‌های تایمر</a>
                <ul>
                    <li>
                        <a href="index.html#pyn-wqfh">پایان وقفه</a>
                    </li><li>
                        <a href="index.html#pykhrbndy-tymr">پیکربندی تایمر</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#bnbst-h">بن‌بست ها</a>
                <ul>
                    <li>
                        <a href="index.html#yjd-bnbst">ایجاد بن‌بست</a>
                    </li><li>
                        <a href="index.html#rf-bnbst">رفع بن‌بست</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#rf-wd-yt-rqbty">رفع وضعیت رقابتی</a>
                
            </li><li>
                <a href="index.html#dstwrl-ml-hlt">دستورالعمل hlt</a>
                
            </li><li>
                <a href="index.html#wrwdy-sfhh-khlyd">ورودی صفحه کلید</a>
                <ul>
                    <li>
                        <a href="index.html#khwndn-skhnkhd-h">خواندن اسکن‌کد ها</a>
                    </li><li>
                        <a href="index.html#tfsyr-skhnkhd-h">تفسیر اسکن‌کد ها</a>
                    </li><li>
                        <a href="index.html#pykhrbndy-sfhh-khlyd">پیکربندی صفحه کلید</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khlsh">خلاصه</a>
                
            </li><li>
                <a href="index.html#mrhlh-b-dy-chyst">مرحله بعدی چیست؟</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
        </ul>
    </details>

<h2 id="mqdmh"><a class="zola-anchor" href="index.html#mqdmh" aria-label="Anchor link for: mqdmh">🔗</a>مقدمه</h2>
<p>وقفه‌ها راهی برای اطلاع به پردازنده از دستگاه های سخت افزاری متصل ارائه می دهند. بنابراین به جای اینکه پردازنده به طور دوره‌ای صفحه کلید را برای کاراکترهای جدید بررسی کند(فرآیندی به نام <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)"><em>polling</em></a>) ، صفحه کلید می‌تواند هسته را برای هر  فشردن کلید مطلع کند. این بسیار کارآمدتر است زیرا هسته فقط زمانی که اتفاقی افتاده است باید عمل کند. همچنین زمان واکنش سریع تری را فراهم می کند ، زیرا هسته می تواند بلافاصله و نه تنها در پول(کلمه: poll) بعدی واکنش نشان دهد.</p>
<p>اتصال مستقیم تمام دستگاه های سخت افزاری به پردازنده امکان پذیر نیست. در عوض ، یک <em>کنترل کننده وقفه</em> جداگانه ، وقفه‌ها را از همه دستگاه‌ها جمع کرده و سپس پردازنده را مطلع می کند:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>                                    ____________             _____
</span><span>               Timer ------------&gt; |            |           |     |
</span><span>               Keyboard ---------&gt; | Interrupt  |---------&gt; | CPU |
</span><span>               Other Hardware ---&gt; | Controller |           |_____|
</span><span>               Etc. -------------&gt; |____________|
</span><span>
</span></code></pre>
<p>بیشتر کنترل کننده های وقفه قابل برنامه ریزی هستند ، به این معنی که آنها از اولویت های مختلف برای وقفه‌ها پشتیبانی می کنند. به عنوان مثال ، این اجازه را می دهند تا به وقفه های تایمر اولویت بیشتری نسبت به وقفه های صفحه کلید داد تا از زمان بندی دقیق اطمینان حاصل شود.</p>
<p>بر خلاف استثناها ، وقفه های سخت افزاری <em>به صورت نا هم زمان</em> اتفاق می افتند. این بدان معنی است که آنها کاملاً از کد اجرا شده مستقل هستند و در هر زمان ممکن است رخ دهند. بنابراین ما ناگهان شکلی از همروندی در هسته خود با تمام اشکالات احتمالی مرتبط با همروندی داریم. مدل مالکیت دقیق راست در اینجا به ما کمک می کند زیرا مانع حالت تغییر پذیری گلوبال است(mutable global state). با این حال، همچنان احتمال بن بست وجود دارد، همانطور که بعداً در این پست خواهیم دید.</p>
<h2 id="the-8259-pic"><a class="zola-anchor" href="index.html#the-8259-pic" aria-label="Anchor link for: the-8259-pic">🔗</a>The 8259 PIC</h2>
<p><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> یک کنترل کننده وقفه قابل برنامه ریزی (PIC) است که در سال 1976 معرفی شد. مدت طولانی است که با <a href="https://en.wikipedia.org/wiki/Intel_APIC_Architecture">APIC</a> جدید جایگزین شده است ، اما رابط آن هنوز به دلایل سازگاری در سیستم های فعلی پشتیبانی می شود. 8259 PIC به طور قابل ملاحظه ای آسان تر از APIC است ، بنابراین ما قبل از مهاجرت و استفاده از APIC در آینده، از آن برای معرفی وقفه استفاده خواهیم کرد.</p>
<p>8259 دارای 8 خط وقفه و چندین خط برای برقراری ارتباط با پردازنده است. سیستم های معمولی در آن زمان به دو نمونه از 8259 PIC مجهز بودند ، یکی اصلی و دیگری PIC ثانویه که به یکی از خطوط وقفه اولیه متصل است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>                     ____________                          ____________
</span><span>Real Time Clock --&gt; |            |   Timer -------------&gt; |            |
</span><span>ACPI -------------&gt; |            |   Keyboard-----------&gt; |            |      _____
</span><span>Available --------&gt; | Secondary  |----------------------&gt; | Primary    |     |     |
</span><span>Available --------&gt; | Interrupt  |   Serial Port 2 -----&gt; | Interrupt  |---&gt; | CPU |
</span><span>Mouse ------------&gt; | Controller |   Serial Port 1 -----&gt; | Controller |     |_____|
</span><span>Co-Processor -----&gt; |            |   Parallel Port 2/3 -&gt; |            |
</span><span>Primary ATA ------&gt; |            |   Floppy disk -------&gt; |            |
</span><span>Secondary ATA ----&gt; |____________|   Parallel Port 1----&gt; |____________|
</span><span>
</span></code></pre>
<p>این نمودار نحوه اتصال معمول خطوط وقفه را نشان می دهد. می بینیم که بیشتر 15 خط دارای یک نگاشت ثابت هستند ، به عنوان مثال خط 4 PIC ثانویه به ماوس اختصاص داده شده است.</p>
<p>هر کنترل کننده را می توان از طریق دو <a href="../../testing/index.html#i-o-ports">پورت ورودی/خروجی</a> ، یک پورت “فرمان” و یک پورت “داده” پیکربندی کرد. برای کنترل کننده اصلی ، این پورت‌ها <code>0x20</code> (فرمان) و<code>0x21</code> (داده) هستند. برای کنترل کننده ثانویه آنها <code>0xa0</code> (فرمان) و <code>0xa1</code> (داده) هستند. برای اطلاعات بیشتر در مورد نحوه پیکربندی PIC ها ، به <a href="https://wiki.osdev.org/8259_PIC">مقاله‌ای در osdev.org</a> مراجعه کنید.</p>
<h3 id="pydh-szy"><a class="zola-anchor" href="index.html#pydh-szy" aria-label="Anchor link for: pydh-szy">🔗</a>پیاده سازی</h3>
<p>پیکربندی پیش فرض PIC ها قابل استفاده نیست، زیرا اعداد بردار وقفه را در محدوده 15-0 به پردازنده می فرستد. این اعداد در حال حاضر توسط استثناهای پردازنده اشغال شده‌اند ، به عنوان مثال شماره 8 مربوط به یک خطای دوگانه است. برای رفع این مشکل همپوشانی، باید وقفه های PIC را به اعداد دیگری تغییر دهیم. دامنه واقعی مهم نیست به شرطی که با استثناها همپوشانی نداشته باشد ، اما معمولاً محدوده 47-32 انتخاب می شود، زیرا اینها اولین شماره های آزاد پس از 32 اسلات استثنا هستند.</p>
<p>پیکربندی با نوشتن مقادیر ویژه در پورت های فرمان و داده PIC ها اتفاق می افتد. خوشبختانه قبلا کرت‌ای به نام <a href="https://docs.rs/pic8259/0.10.1/pic8259/"><code>pic8259</code></a> وجود دارد، بنابراین نیازی نیست که توالی راه اندازی اولیه را خودمان بنویسیم. در صورت علاقه‌مند بودن به چگونگی عملکرد آن، <a href="https://docs.rs/crate/pic8259/0.10.1/source/src/lib.rs">کد منبع آن</a> را بررسی کنید، نسبتاً کوچک و دارای مستند خوبی است.</p>
<p>برای افزودن کرت به عنوان وابستگی ، موارد زیر را به پروژه خود اضافه می کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">pic8259 </span><span>= </span><span style="color:#d69d85;">&quot;0.10.1&quot;
</span></code></pre>
<p>انتزاع اصلی ارائه شده توسط کرت، ساختمان <a href="https://docs.rs/pic8259/0.10.1/pic8259/struct.ChainedPics.html"><code>ChainedPics</code></a> است که نمایانگر طرح اولیه/ثانویه PIC است که در بالا دیدیم. برای استفاده به روش زیر طراحی شده است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>pic8259::ChainedPics;
</span><span style="color:#569cd6;">use</span><span> spin;
</span><span>
</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">PIC_1_OFFSET</span><span>: </span><span style="color:#569cd6;">u8 </span><span>= </span><span style="color:#b5cea8;">32</span><span>;
</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">PIC_2_OFFSET</span><span>: </span><span style="color:#569cd6;">u8 </span><span>= </span><span style="color:#b4cea8;">PIC_1_OFFSET </span><span>+ </span><span style="color:#b5cea8;">8</span><span>;
</span><span>
</span><span style="color:#569cd6;">pub static </span><span style="color:#b4cea8;">PICS</span><span>: spin::Mutex&lt;ChainedPics&gt; =
</span><span>    spin::Mutex::new(</span><span style="color:#569cd6;">unsafe </span><span>{ ChainedPics::new(</span><span style="color:#b4cea8;">PIC_1_OFFSET</span><span>, </span><span style="color:#b4cea8;">PIC_2_OFFSET</span><span>) });
</span></code></pre>
<p>همانطور که در بالا اشاره کردیم، افست PIC ها را در محدوده 47-32 تنظیم می کنیم. با بسته بندی ساختمان <code>ChainedPics</code> در <code>Mutex</code> می توانیم دسترسی قابل تغییر و ایمن (از طریق <a href="https://docs.rs/spin/0.5.2/spin/struct.Mutex.html#method.lock">متد lock</a>) به آن داشته باشیم، که در مرحله بعدی به آن نیاز داریم. تابع <code>ChainedPics::new</code> ناامن است زیرا افست اشتباه ممکن است باعث رفتار نامشخص شود.</p>
<p>اکنون می توانیم 8259 PIC را در تابع <code>init</code> خود مقدار دهی اولیه کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    gdt::init();
</span><span>    interrupts::init_idt();
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{ interrupts::</span><span style="color:#b4cea8;">PICS</span><span>.lock().initialize() }; </span><span style="color:#608b4e;">// new
</span><span>}
</span></code></pre>
<p>ما از تابع <a href="https://docs.rs/pic8259/0.10.1/pic8259/struct.ChainedPics.html#method.initialize"><code>initialize</code></a> برای انجام مقداردهی اولیه PIC استفاده می کنیم. مانند تابع <code>ChainedPics::new</code>، این تابع نیز ایمن نیست زیرا در صورت عدم پیکربندی صحیح PIC می تواند باعث رفتار نامشخص شود.</p>
<p>اگر همه چیز خوب پیش برود ، باید هنگام اجرای <code>cargo run</code> پیام “It did not crash” را ببینیم.</p>
<h2 id="f-lszy-wqfhh"><a class="zola-anchor" href="index.html#f-lszy-wqfhh" aria-label="Anchor link for: f-lszy-wqfhh">🔗</a>فعال‌سازی وقفه‌ها</h2>
<p>تاکنون هیچ اتفاقی نیفتاده است زیرا وقفه‌ها همچنان در تنظیمات پردازنده غیرفعال هستند. این بدان معناست که پردازنده به هیچ وجه به کنترل کننده وقفه گوش نمی دهد، بنابراین هیچ وقفه ای نمی تواند به پردازنده برسد. بیایید این را تغییر دهیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init() {
</span><span>    gdt::init();
</span><span>    interrupts::init_idt();
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{ interrupts::</span><span style="color:#b4cea8;">PICS</span><span>.lock().initialize() };
</span><span>    x86_64::instructions::interrupts::enable();     </span><span style="color:#608b4e;">// new
</span><span>}
</span></code></pre>
<p>تابع <code>interrupts::enable</code> از کرت <code>x86_64</code> دستورالعمل خاص <code>sti</code> را اجرا می کند (“set interrupts”) تا وقفه های خارجی را فعال کند. اکنون وقتی <code>cargo run</code> را امتحان می کنیم ، می بینیم که یک خطای دوگانه رخ می‌دهد:</p>
<p><img src="qemu-hardware-timer-double-fault.png" alt="QEMU printing EXCEPTION: DOUBLE FAULT because of hardware timer" /></p>
<p>دلیل این خطای دوگانه این است که تایمر سخت افزاری (به طور دقیق تر <a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a>) به طور پیش فرض فعال است، بنابراین به محض فعال کردن وقفه‌ها ، شروع به دریافت وقفه های تایمر می کنیم. از آنجا که هنوز یک تابع کنترل کننده برای آن تعریف نکرده‌ایم ، کنترل کننده خطای دوگانه فراخوانی می شود.</p>
<h2 id="mdyryt-wqfhhy-tymr"><a class="zola-anchor" href="index.html#mdyryt-wqfhhy-tymr" aria-label="Anchor link for: mdyryt-wqfhhy-tymr">🔗</a>مدیریت وقفه‌های تایمر</h2>
<p>همانطور که در شکل <a href="index.html#the-8259-pic">بالا</a> می بینیم، تایمر از خط 0 از PIC اصلی استفاده می کند. این به این معنی است که به صورت وقفه 32 (0 + افست 32) به پردازنده می رسد. به جای هارد-کد(Hardcode) کردن 32، آن را در یک اینام(enum) به نام <code>InterruptIndex</code> ذخیره می کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy)]
</span><span>#[repr(u8)]
</span><span style="color:#569cd6;">pub enum </span><span>InterruptIndex {
</span><span>    Timer = </span><span style="color:#b4cea8;">PIC_1_OFFSET</span><span>,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">impl </span><span>InterruptIndex {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>as_u8(self) -&gt; </span><span style="color:#569cd6;">u8 </span><span>{
</span><span>        self </span><span style="color:#569cd6;">as u8
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">fn </span><span>as_usize(self) -&gt; </span><span style="color:#569cd6;">usize </span><span>{
</span><span>        </span><span style="color:#569cd6;">usize</span><span>::from(self.as_u8())
</span><span>    }
</span><span>}
</span></code></pre>
<p>اینام یک <a href="https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">اینام C مانند</a> است بنابراین ما می توانیم ایندکس را برای هر نوع به طور مستقیم مشخص کنیم. ویژگی <code>repr(u8)</code> مشخص می کند که هر نوع به عنوان <code>u8</code> نشان داده می شود. در آینده انواع بیشتری برای وقفه های دیگر اضافه خواهیم کرد.</p>
<p>اکنون می توانیم یک تابع کنترل کننده برای وقفه تایمر اضافه کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">use crate</span><span>::print;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        […]
</span><span>        idt[InterruptIndex::Timer.as_usize()]
</span><span>            .set_handler_fn(timer_interrupt_handler); </span><span style="color:#608b4e;">// new
</span><span>
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>timer_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    print!(</span><span style="color:#d69d85;">&quot;.&quot;</span><span>);
</span><span>}
</span></code></pre>
<p><code>timer_interrupt_handler</code> ما دارای امضای مشابه کنترل کننده های استثنای ما است ، زیرا پردازنده به طور یکسان به استثناها و وقفه های خارجی واکنش نشان می دهد (تنها تفاوت این است که برخی از استثناها کد خطا را در پشته ذخیره می‌کنند). ساختمان <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.InterruptDescriptorTable.html"><code>InterruptDescriptorTable</code></a> تریت <a href="https://doc.rust-lang.org/core/ops/trait.IndexMut.html"><code>IndexMut</code></a> را پیاده سازی می کند، بنابراین می توانیم از طریق سینتکس ایندکس‌دهی آرایه، به ایتم های جداگانه دسترسی پیدا کنیم.</p>
<p>در کنترل کننده وقفه تایمر، یک نقطه را روی صفحه چاپ می کنیم. همانطور که وقفه تایمر به صورت دوره ای اتفاق می افتد ، انتظار داریم که در هر تیک تایمر یک نقطه ظاهر شود. با این حال، هنگامی که آن را اجرا می کنیم می بینیم که فقط یک نقطه چاپ می شود:</p>
<p><img src="qemu-single-dot-printed.png" alt="QEMU printing only a single dot for hardware timer" /></p>
<h3 id="pyn-wqfh"><a class="zola-anchor" href="index.html#pyn-wqfh" aria-label="Anchor link for: pyn-wqfh">🔗</a>پایان وقفه</h3>
<p>دلیل این امر این است که PIC انتظار دارد یک سیگنال صریح “پایان وقفه” (EOI) از کنترل کننده وقفه ما دریافت کند. این سیگنال به PIC می گوید که وقفه پردازش شده و سیستم آماده دریافت وقفه بعدی است. بنابراین PIC فکر می کند ما هنوز مشغول پردازش وقفه تایمر اول هستیم و قبل از ارسال سیگنال بعدی با صبر و حوصله منتظر سیگنال EOI از ما هست.</p>
<p>برای ارسال EOI ، ما دوباره از ساختمان ثابت <code>PICS</code> خود استفاده می کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>timer_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    print!(</span><span style="color:#d69d85;">&quot;.&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">PICS</span><span>.lock()
</span><span>            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
</span><span>    }
</span><span>}
</span></code></pre>
<p><code>notify_end_of_interrupt</code> تشخیص می‌دهد که PIC اصلی یا ثانویه وقفه را ارسال کرده است و سپس از پورت های <code>command</code> و <code>data</code> برای ارسال سیگنال EOI به PIC های مربوطه استفاده می کند. اگر PIC ثانویه وقفه را ارسال کرد ، هر دو PIC باید مطلع شوند زیرا PIC ثانویه به یک خط ورودی از PIC اصلی متصل است.</p>
<p>ما باید مراقب باشیم که از شماره بردار وقفه صحیح استفاده کنیم، در غیر این صورت می توانیم به طور تصادفی یک وقفه مهم ارسال نشده را حذف کنیم یا باعث هنگ سیستم خود شویم. این دلیل آن است که تابع ناامن است.</p>
<p>اکنون هنگامی که <code>cargo run</code> را اجرا می کنیم، نقاطی را می بینیم که به صورت دوره ای روی صفحه ظاهر می شوند:</p>
<p><img src="qemu-hardware-timer-dots.gif" alt="QEMU printing consecutive dots showing the hardware timer" /></p>
<h3 id="pykhrbndy-tymr"><a class="zola-anchor" href="index.html#pykhrbndy-tymr" aria-label="Anchor link for: pykhrbndy-tymr">🔗</a>پیکربندی تایمر</h3>
<p>تایمر سخت افزاری که ما از آن استفاده می کنیم ، <em>Programmable Interval Timer</em> یا به اختصار PIT نامیده می شود. همانطور که از نام آن مشخص است ، می توان فاصله بین دو وقفه را پیکربندی کرد. ما در اینجا به جزئیات نمی پردازیم زیرا به زودی به <a href="https://wiki.osdev.org/APIC_timer">تایمر APIC</a> سوییچ خواهیم کرد، اما ویکی OSDev مقاله مفصلی درباره <a href="https://wiki.osdev.org/Programmable_Interval_Timer">پیکربندی PIT</a> دارد.</p>
<h2 id="bnbst-h"><a class="zola-anchor" href="index.html#bnbst-h" aria-label="Anchor link for: bnbst-h">🔗</a>بن‌بست ها</h2>
<p>اکنون نوعی همروندی در هسته خود داریم: وقفه های تایمر به صورت ناهمزمان اتفاق می افتند ، بنابراین می توانند تابع <code>start_</code> را در هر زمان قطع کنند. خوشبختانه سیستم مالکیت راست از بسیاری از مشکلات مربوط به همروندی در زمان کامپایل جلوگیری می کند. یک استثنا قابل توجه بن‌بست است. درصورتی که نخ(Thread) بخواهد قفلی را بدست آورد که هرگز آزاد نخواهد شد، بن‌بست به وجود می آید. بنابراین نخ به طور نامحدود هنگ می‌کند.</p>
<p>ما می توانیم در هسته خود بن‌بست ایجاد کنیم. اگر به یاد داشته باشید، ماکرو <code>println</code> ما تابع <code>vga_buffer::_print</code> را فراخوانی می کند، که با استفاده از spinlock یک <a href="../../vga-text-mode/index.html#spinlocks"><code>WRITER</code> گلوبال را قفل میکند</a>.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>[…]
</span><span>
</span><span>#[doc(hidden)]
</span><span style="color:#569cd6;">pub fn </span><span>_print(args: fmt::Arguments) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#b4cea8;">WRITER</span><span>.lock().write_fmt(args).unwrap();
</span><span>}
</span></code></pre>
<p><code>WRITER</code> را قفل می کند، <code>write_fmt</code> را روی آن فراخوانی می کند و در انتهای تابع به طور ضمنی قفل آن را باز می کند. حال تصور کنید که در حالی که <code>WRITER</code> قفل شده است وقفه رخ دهد و کنترل کننده وقفه نیز سعی کند چیزی را چاپ کند:</p>
<table><thead><tr><th>Timestep</th><th>_start</th><th>interrupt_handler</th></tr></thead><tbody>
<tr><td>0</td><td>calls <code>println!</code></td><td> </td></tr>
<tr><td>1</td><td><code>print</code> locks <code>WRITER</code></td><td> </td></tr>
<tr><td>2</td><td></td><td><strong>interrupt occurs</strong>, handler begins to run</td></tr>
<tr><td>3</td><td></td><td>calls <code>println!</code></td></tr>
<tr><td>4</td><td></td><td><code>print</code> tries to lock <code>WRITER</code> (already locked)</td></tr>
<tr><td>5</td><td></td><td><code>print</code> tries to lock <code>WRITER</code> (already locked)</td></tr>
<tr><td>…</td><td></td><td>…</td></tr>
<tr><td><em>never</em></td><td><em>unlock <code>WRITER</code></em></td><td></td></tr>
</tbody></table>
<p><code>WRITER</code> قفل شده است ، بنابراین کنترل کننده وقفه منتظر می ماند تا آزاد شود. اما این هرگز اتفاق نمی افتد ، زیرا تابع <code>start_</code> فقط پس از بازگشت کنترل کننده وقفه ادامه می یابد. بنابراین کل سیستم هنگ است.</p>
<h3 id="yjd-bnbst"><a class="zola-anchor" href="index.html#yjd-bnbst" aria-label="Anchor link for: yjd-bnbst">🔗</a>ایجاد بن‌بست</h3>
<p>ما می توانیم با چاپ چیزی در حلقه در انتهای تابع <code>start_</code> خود ، به راحتی چنین بن‌بست‌ای در هسته خود ایجاد کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    […]
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{
</span><span>        </span><span style="color:#569cd6;">use </span><span>blog_os::print;
</span><span>        print!(</span><span style="color:#d69d85;">&quot;-&quot;</span><span>);        </span><span style="color:#608b4e;">// new
</span><span>    }
</span><span>}
</span></code></pre>
<p>وقتی آن را در QEMU اجرا می کنیم ، خروجی به حالت زیر دریافت می‌کنیم:</p>
<p><img src="qemu-deadlock.png" alt="QEMU output with many rows of hyphens and no dots" /></p>
<p>می بینیم که فقط تعداد محدودی خط فاصله ، تا زمانی که وقفه تایمر اول اتفاق بیفتد، چاپ می شود. سپس سیستم هنگ می‌کند زیرا تایمر هنگام تلاش برای چاپ یک نقطه باعث بن‌بست می‌شود. به همین دلیل است که در خروجی فوق هیچ نقطه‌ای مشاهده نمی‌کنیم.</p>
<p>تعداد واقعی خط فاصله بین هر اجرا متفاوت است زیرا وقفه تایمر به صورت غیر همزمان انجام می شود. این عدم قطعیت، اشکال زدایی اشکالات مربوط به همروندی را بسیار دشوار می کند.</p>
<h3 id="rf-bnbst"><a class="zola-anchor" href="index.html#rf-bnbst" aria-label="Anchor link for: rf-bnbst">🔗</a>رفع بن‌بست</h3>
<p>برای جلوگیری از این بن‌بست ، تا زمانی که <code>Mutex</code> قفل شده باشد، می توانیم وقفه‌ها را غیرفعال کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span style="color:#608b4e;">/// Prints the given formatted string to the VGA text buffer
</span><span style="color:#608b4e;">/// through the global `WRITER` instance.
</span><span>#[doc(hidden)]
</span><span style="color:#569cd6;">pub fn </span><span>_print(args: fmt::Arguments) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::interrupts;   </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    interrupts::without_interrupts(|| {     </span><span style="color:#608b4e;">// new
</span><span>        </span><span style="color:#b4cea8;">WRITER</span><span>.lock().write_fmt(args).unwrap();
</span><span>    });
</span><span>}
</span></code></pre>
<p>تابع <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/interrupts/fn.without_interrupts.html"><code>without_interrupts</code></a> یک <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">کلوژر</a> را گرفته و آن را در یک محیط بدون وقفه اجرا می کند. ما از آن استفاده می کنیم تا اطمینان حاصل کنیم که تا زمانی که <code>Mutex</code> قفل شده است ، هیچ وقفه ای رخ نمی دهد. اکنون هنگامی که هسته را اجرا می کنیم ، می بینیم که آن بدون هنگ کردن به کار خود ادامه می دهد. (ما هنوز هیچ نقطه ای را مشاهده نمی کنیم ، اما این به این دلیل است که سرعت حرکت آنها بسیار سریع است. سعی کنید سرعت چاپ را کم کنید، مثلاً با قرار دادن <code>for _ in 0..10000 {}</code> در داخل حلقه.)</p>
<p>ما می توانیم همین تغییر را در تابع چاپ سریال نیز اعمال کنیم تا اطمینان حاصل کنیم که هیچ بن‌بستی در آن رخ نمی دهد:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/serial.rs
</span><span>
</span><span>#[doc(hidden)]
</span><span style="color:#569cd6;">pub fn </span><span>_print(args: ::core::fmt::Arguments) {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::interrupts;       </span><span style="color:#608b4e;">// new
</span><span>
</span><span>    interrupts::without_interrupts(|| {         </span><span style="color:#608b4e;">// new
</span><span>        </span><span style="color:#b4cea8;">SERIAL1
</span><span>            .lock()
</span><span>            .write_fmt(args)
</span><span>            .expect(</span><span style="color:#d69d85;">&quot;Printing to serial failed&quot;</span><span>);
</span><span>    });
</span><span>}
</span></code></pre>
<p>توجه داشته باشید که غیرفعال کردن وقفه‌ها نباید یک راه حل کلی باشد. مشکل این است که بدترین حالت تأخیر در وقفه را افزایش می دهد ، یعنی زمانی که سیستم به وقفه واکنش نشان می دهد. بنابراین وقفه‌ها باید فقط برای مدت زمان کوتاه غیرفعال شوند.</p>
<h2 id="rf-wd-yt-rqbty"><a class="zola-anchor" href="index.html#rf-wd-yt-rqbty" aria-label="Anchor link for: rf-wd-yt-rqbty">🔗</a>رفع وضعیت رقابتی</h2>
<p>اگر <code>cargo test</code> را اجرا کنید ، ممکن است ببینید تست <code>test_println_output</code> با شکست مواجه می‌شود:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test --lib
</span><span>[…]
</span><span>Running 4 tests
</span><span>test_breakpoint_exception...[ok]
</span><span>test_println... [ok]
</span><span>test_println_many... [ok]
</span><span>test_println_output... [failed]
</span><span>
</span><span>Error: panicked at &#39;assertion failed: `(left == right)`
</span><span>  left: `&#39;.&#39;`,
</span><span> right: `&#39;S&#39;`&#39;, src/vga_buffer.rs:205:9
</span></code></pre>
<p>دلیل آن وجود یک <em>وضعیت رقابتی</em> بین تست و کنترل کننده تایمر ماست. اگر به یاد داشته باشید ، تست به این شکل است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_output() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> s = </span><span style="color:#d69d85;">&quot;Some test string that fits on a single line&quot;</span><span>;
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, s);
</span><span>    </span><span style="color:#569cd6;">for </span><span>(i, c) </span><span style="color:#569cd6;">in</span><span> s.chars().enumerate() {
</span><span>        </span><span style="color:#569cd6;">let</span><span> screen_char = </span><span style="color:#b4cea8;">WRITER</span><span>.lock().buffer.chars[</span><span style="color:#b4cea8;">BUFFER_HEIGHT </span><span>- </span><span style="color:#b5cea8;">2</span><span>][i].read();
</span><span>        assert_eq!(</span><span style="color:#569cd6;">char</span><span>::from(screen_char.ascii_character), c);
</span><span>    }
</span><span>}
</span></code></pre>
<p>این تست یک رشته را در بافر VGA چاپ می کند و سپس با پیمایش دستی روی آرایه <code>buffer_chars</code> خروجی را بررسی می کند. وضعیت رقابتی رخ می دهد زیرا ممکن است کنترل کننده وقفه تایمر بین <code>println</code> و خواندن کاراکتر های صفحه اجرا شود. توجه داشته باشید که این یک رقابت داده(Data race) خطرناک نیست، که Rust در زمان کامپایل کاملاً از آن جلوگیری کند. برای جزئیات به <a href="https://doc.rust-lang.org/nomicon/races.html"><em>Rustonomicon</em></a> مراجعه کنید.</p>
<p>برای رفع این مشکل ، باید <code>WRITER</code> را برای مدت زمان کامل تست قفل نگه داریم ، به این ترتیب که کنترل کننده تایمر نمی تواند <code>.</code> را روی صفحه نمایش در میان کار تست بنویسد. تست اصلاح شده به این شکل است:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>test_println_output() {
</span><span>    </span><span style="color:#569cd6;">use </span><span>core::fmt::Write;
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::interrupts;
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> s = </span><span style="color:#d69d85;">&quot;Some test string that fits on a single line&quot;</span><span>;
</span><span>    interrupts::without_interrupts(|| {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> writer = </span><span style="color:#b4cea8;">WRITER</span><span>.lock();
</span><span>        writeln!(writer, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\n</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, s).expect(</span><span style="color:#d69d85;">&quot;writeln failed&quot;</span><span>);
</span><span>        </span><span style="color:#569cd6;">for </span><span>(i, c) </span><span style="color:#569cd6;">in</span><span> s.chars().enumerate() {
</span><span>            </span><span style="color:#569cd6;">let</span><span> screen_char = writer.buffer.chars[</span><span style="color:#b4cea8;">BUFFER_HEIGHT </span><span>- </span><span style="color:#b5cea8;">2</span><span>][i].read();
</span><span>            assert_eq!(</span><span style="color:#569cd6;">char</span><span>::from(screen_char.ascii_character), c);
</span><span>        }
</span><span>    });
</span><span>}
</span></code></pre>
<p>ما تغییرات زیر را انجام دادیم:</p>
<ul>
<li>ما با استفاده صریح از متد <code>()lock</code> ، نویسنده را برای کل تست قفل می کنیم. به جای <code>println</code> ، از ماکرو <a href="https://doc.rust-lang.org/core/macro.writeln.html"><code>writeln</code></a> استفاده می کنیم که امکان چاپ بر روی نویسنده قبلاً قفل شده را فراهم می کند.</li>
<li>برای جلوگیری از یک بن‌بست دیگر ، وقفه‌ها را برای مدت زمان تست غیرفعال می کنیم. در غیر این صورت ممکن است تست در حالی که نویسنده هنوز قفل است قطع شود.</li>
<li>از آنجا که کنترل کننده وقفه تایمر هنوز می تواند قبل از تست اجرا شود ، قبل از چاپ رشته <code>s</code> یک خط جدید <code>n\</code> اضافی چاپ می کنیم. به این ترتیب ، اگر که کنترل کننده تایمر تعدادی کاراکتر <code>.</code> را در خط فعلی چاپ کرده باشد، از شکست تست جلوگیری می کنیم.</li>
</ul>
<p>اکنون با تغییرات فوق ، <code>cargo test</code> دوباره با قطعیت موفق می شود.</p>
<p>این یک وضعیت رقابتی بسیار بی خطر بود که فقط باعث شکست تست می‌شد. همانطور که می توانید تصور کنید، اشکال زدایی سایر وضعیت‌های رقابتی به دلیل ماهیت غیر قطعی بودن آنها بسیار دشوارتر است. خوشبختانه، راست مانع از رقابت داده‌ها می شود ، که جدی‌ترین نوع وضعیت رقابتی است ، زیرا می تواند باعث انواع رفتارهای تعریف نشده ، از جمله کرش کردن سیستم و خراب شدن آرام و بی صدای حافظه شود.</p>
<h2 id="dstwrl-ml-hlt"><a class="zola-anchor" href="index.html#dstwrl-ml-hlt" aria-label="Anchor link for: dstwrl-ml-hlt">🔗</a>دستورالعمل <code>hlt</code></h2>
<p>تاکنون از یک حلقه خالی ساده در پایان توابع <code>start_</code> و<code> panic</code> استفاده می کردیم. این باعث می شود پردازنده به طور بی وقفه بچرخد و بنابراین مطابق انتظار عمل می کند. اما بسیار ناکارآمد است، زیرا پردازنده همچنان با سرعت کامل کار می کند حتی اگر کاری برای انجام نداشته باشد. هنگامی که هسته را اجرا می کنید می توانید این مشکل را در مدیر وظیفه خود مشاهده کنید: فرایند QEMU در کل مدت زمان نیاز به تقریباً 100٪ پردازنده دارد.</p>
<p>کاری که واقعاً می خواهیم انجام دهیم این است که پردازنده را تا رسیدن وقفه بعدی متوقف کنیم. این اجازه می دهد پردازنده وارد حالت خواب شود که در آن انرژی بسیار کمتری مصرف می کند. <a href="https://en.wikipedia.org/wiki/HLT_(x86_instruction)">دستورالعمل <code>hlt</code></a> دقیقاً همین کار را می کند. بیایید از این دستورالعمل برای ایجاد یک حلقه بی پایان با مصرف انرژی پایین استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>hlt_loop() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{
</span><span>        x86_64::instructions::hlt();
</span><span>    }
</span><span>}
</span></code></pre>
<p>تابع <code>instructions::hlt</code> فقط یک <a href="https://github.com/rust-osdev/x86_64/blob/5e8e218381c5205f5777cb50da3ecac5d7e3b1ab/src/instructions/mod.rs#L16-L22">پوشش نازک</a> بر روی دستورالعمل اسمبلی است. این بی خطر است زیرا به هیچ وجه نمی تواند ایمنی حافظه را به خطر بیندازد.</p>
<p>اکنون می توانیم از این <code>hlt_loop</code> به جای حلقه های بی پایان در توابع<code> start_</code> و <code>panic</code> استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    […]
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    blog_os::hlt_loop();            </span><span style="color:#608b4e;">// new
</span><span>}
</span><span>
</span><span>
</span><span>#[cfg(not(test))]
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    blog_os::hlt_loop();            </span><span style="color:#608b4e;">// new
</span><span>}
</span><span>
</span></code></pre>
<p>بیایید <code>lib.rs</code> را نیز به روز کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#608b4e;">/// Entry point for `cargo test`
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    init();
</span><span>    test_main();
</span><span>    hlt_loop();         </span><span style="color:#608b4e;">// new
</span><span>}
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>test_panic_handler(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;[failed]</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>);
</span><span>    serial_println!(</span><span style="color:#d69d85;">&quot;Error: {}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">&quot;</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    hlt_loop();         </span><span style="color:#608b4e;">// new
</span><span>}
</span></code></pre>
<p>اکنون وقتی هسته خود را  در QEMU اجرا می کنیم ، شاهد استفاده بسیار کمتری از پردازنده هستیم.</p>
<h2 id="wrwdy-sfhh-khlyd"><a class="zola-anchor" href="index.html#wrwdy-sfhh-khlyd" aria-label="Anchor link for: wrwdy-sfhh-khlyd">🔗</a>ورودی صفحه کلید</h2>
<p>اکنون که قادر به مدیریت وقفه های دستگاه های خارجی هستیم ، سرانجام قادر به پشتیبانی از ورودی صفحه کلید هستیم. این به ما امکان می دهد برای اولین بار با هسته خود تعامل داشته باشیم.</p>
<aside class="post_aside">
<p>توجه داشته باشید که ما فقط نحوه مدیریت صفحه کلیدهای <a href="https://en.wikipedia.org/wiki/PS/2_port">PS/2</a> را توضیح می دهیم ، نه صفحه کلیدهای USB. هر چند که، مادربورد صفحه کلیدهای USB را به عنوان دستگاه های PS/2 برای پشتیبانی از نرم افزارهای قدیمی تقلید می‌کند ، بنابراین تا زمانی که هسته ما از USB پشتیبانی نمی‌کند می توانیم با اطمینان از صفحه کلیدهای USB چشم پوشی کنیم.</p>
</aside>
<p>مانند تایمر سخت افزاری ، کنترل کننده صفحه کلید نیز به طور پیش فرض از قبل فعال شده است. بنابراین با فشار دادن یک کلید ، کنترل کننده صفحه کلید وقفه را به PIC ارسال می کند و آن را به پردازنده منتقل می کند. پردازنده به دنبال یک تابع کنترل کننده در IDT می‌گردد ، اما ایتم مربوطه خالی است. بنابراین یک خطای دوگانه رخ می دهد.</p>
<p>پس بیایید یک تایع کنترل کننده برای وقفه صفحه کلید اضافه کنیم. این کاملاً مشابه نحوه تعریف کنترل کننده برای وقفه تایمر است ، فقط از یک شماره وقفه متفاوت استفاده می کند:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy)]
</span><span>#[repr(u8)]
</span><span style="color:#569cd6;">pub enum </span><span>InterruptIndex {
</span><span>    Timer = </span><span style="color:#b4cea8;">PIC_1_OFFSET</span><span>,
</span><span>    Keyboard, </span><span style="color:#608b4e;">// new
</span><span>}
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span>: InterruptDescriptorTable = {
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> idt = InterruptDescriptorTable::new();
</span><span>        idt.breakpoint.set_handler_fn(breakpoint_handler);
</span><span>        […]
</span><span>        </span><span style="color:#608b4e;">// new
</span><span>        idt[InterruptIndex::Keyboard.as_usize()]
</span><span>            .set_handler_fn(keyboard_interrupt_handler);
</span><span>
</span><span>        idt
</span><span>    };
</span><span>}
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>keyboard_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    print!(</span><span style="color:#d69d85;">&quot;k&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">PICS</span><span>.lock()
</span><span>            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
</span><span>    }
</span><span>}
</span></code></pre>
<p>همانطور که در شکل <a href="index.html#the-8259-pic">بالا</a> مشاهده می کنیم ، صفحه کلید از خط 1 در PIC اصلی استفاده می کند. این به این معنی است که به صورت وقفه 33 (1 + افست 32) به پردازنده می رسد. ما این ایندکس را به عنوان یک نوع جدید <code>Keyboard</code> به ای‌نام <code>InterruptIndex</code> اضافه می کنیم. نیازی نیست که مقدار را صریحاً مشخص کنیم ، زیرا این مقدار به طور پیش فرض برابر مقدار قبلی بعلاوه یک که 33 نیز می باشد ، هست. در کنترل کننده وقفه ، ما یک <code>k</code> چاپ می کنیم و سیگنال پایان وقفه را به کنترل کننده وقفه می فرستیم.</p>
<p>اکنون می بینیم که وقتی کلید را فشار می دهیم <code>k</code> بر روی صفحه ظاهر می شود. با این حال ، این فقط برای اولین کلیدی که فشار می دهیم کار می کند ، حتی اگر به فشار دادن کلیدها ادامه دهیم ، دیگر <code>k</code> بر روی صفحه نمایش ظاهر نمی شود. این امر به این دلیل است که کنترل کننده صفحه کلید تا زمانی که اصطلاحاً <em>scancode</em> را نخوانیم ، وقفه دیگری ارسال نمی کند.</p>
<h3 id="khwndn-skhnkhd-h"><a class="zola-anchor" href="index.html#khwndn-skhnkhd-h" aria-label="Anchor link for: khwndn-skhnkhd-h">🔗</a>خواندن اسکن‌کد ها</h3>
<p>برای اینکه بفهمیم <em>کدام</em> کلید فشار داده شده است ، باید کنترل کننده صفحه کلید را جستجو کنیم. ما این کار را با خواندن از پورت داده کنترل کننده PS/2 ، که <a href="../../testing/index.html#i-o-ports">پورت ورودی/خروجی</a> با شماره <code>0x60</code> است ، انجام می دهیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>keyboard_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0x60</span><span>);
</span><span>    </span><span style="color:#569cd6;">let</span><span> scancode: </span><span style="color:#569cd6;">u8 </span><span>= </span><span style="color:#569cd6;">unsafe </span><span>{ port.read() };
</span><span>    print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, scancode);
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">PICS</span><span>.lock()
</span><span>            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
</span><span>    }
</span><span>}
</span></code></pre>
<p>ما برای خواندن یک بایت از پورت داده صفحه کلید از نوع <a href="https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html"><code>Port</code></a> کرت <code>x86_64</code> استفاده می‌کنیم. این بایت <a href="https://en.wikipedia.org/wiki/Scancode"><em>اسکن کد</em></a> نامیده می شود و عددی است که کلید فشرده شده / رها شده را نشان می دهد. ما هنوز کاری با اسکن کد انجام نمی دهیم ، فقط آن را روی صفحه چاپ می کنیم:</p>
<p><img src="qemu-printing-scancodes.gif" alt="QEMU printing scancodes to the screen when keys are pressed" /></p>
<p>تصویر بالا نشان می دهد که من آرام آرام “123” را تایپ می کنم. می بینیم که کلیدهای مجاور دارای اسکن کد مجاور هستند و فشار دادن یک کلید دارای اسکن کد متفاوت با رها کردن آن است. اما چگونه اسکن‌کدها را دقیقاً به کار اصلی آن کلید ترجمه کنیم؟</p>
<h3 id="tfsyr-skhnkhd-h"><a class="zola-anchor" href="index.html#tfsyr-skhnkhd-h" aria-label="Anchor link for: tfsyr-skhnkhd-h">🔗</a>تفسیر اسکن‌کد ها</h3>
<p>سه استاندارد مختلف برای نگاشت بین اسکن کدها و کلیدها وجود دارد ، اصطلاحاً  <em>مجموعه های اسکن کد</em>. هر سه به صفحه کلید رایانه های اولیه IBM برمی گردند: <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer_XT">IBM XT</a> ، <a href="https://en.wikipedia.org/wiki/IBM_3270_PC">IBM 3270 PC</a> و <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer/AT">IBM AT</a>. خوشبختانه رایانه های بعدی روند تعریف مجموعه های جدید اسکن کد را ادامه ندادند ، بلکه مجموعه های موجود را تقلید و آنها را گسترش دادند. امروزه بیشتر صفحه کلیدها را می توان به گونه ای پیکربندی کرد که از هر کدام از سه مجموعه تقلید کند.</p>
<p>به طور پیش فرض ، صفحه کلیدهای PS/2 مجموعه شماره 1 (“XT”) را تقلید می کنند. در این مجموعه ، 7 بیت پایین بایت اسکن‌کد، کلید را تعریف می کند و مهمترین بیت فشردن (“0”) یا رها کردن (“1”) را مشخص می کند. کلیدهایی که در صفحه کلید اصلی <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer_XT">IBM XT</a> وجود نداشتند ، مانند کلید enter روی کی‌پد ، دو اسکن کد به طور متوالی ایجاد می کنند: یک بایت فرار(escape) <code>0xe0</code> و سپس یک بایت نمایانگر کلید. برای مشاهده لیست تمام اسکن‌کدهای مجموعه 1 و کلیدهای مربوط به آنها ، <a href="https://wiki.osdev.org/Keyboard#Scan_Code_Set_1">ویکی OSDev</a> را مشاهده کنید.</p>
<p>برای ترجمه اسکن کدها به کلیدها ، می توانیم از عبارت match استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>keyboard_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0x60</span><span>);
</span><span>    </span><span style="color:#569cd6;">let</span><span> scancode: </span><span style="color:#569cd6;">u8 </span><span>= </span><span style="color:#569cd6;">unsafe </span><span>{ port.read() };
</span><span>
</span><span>    </span><span style="color:#608b4e;">// new
</span><span>    </span><span style="color:#569cd6;">let</span><span> key = </span><span style="color:#569cd6;">match</span><span> scancode {
</span><span>        </span><span style="color:#b5cea8;">0x02 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;1&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x03 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;2&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x04 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;3&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x05 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;4&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x06 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;5&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x07 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;6&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x08 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;7&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x09 </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;8&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x0a </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;9&#39;</span><span>),
</span><span>        </span><span style="color:#b5cea8;">0x0b </span><span style="color:#569cd6;">=&gt; </span><span>Some(</span><span style="color:#d69d85;">&#39;0&#39;</span><span>),
</span><span>        </span><span style="color:#569cd6;">_ =&gt; </span><span>None,
</span><span>    };
</span><span>    </span><span style="color:#569cd6;">if let </span><span>Some(key) = key {
</span><span>        print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, key);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">PICS</span><span>.lock()
</span><span>            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
</span><span>    }
</span><span>}
</span></code></pre>
<p>کد بالا فشردن کلیدهای عددی 9-0 را ترجمه کرده و کلیه کلیدهای دیگر را نادیده می گیرد. از عبارت <a href="https://doc.rust-lang.org/book/ch06-02-match.html">match</a> برای اختصاص یک کاراکتر یا <code>None</code> به هر اسکن کد استفاده می کند. سپس با استفاده از <a href="https://doc.rust-lang.org/book/ch18-01-all-the-places-for-patterns.html#conditional-if-let-expressions"><code>if let</code></a> اپشن <code>key</code> را از بین می برد. با استفاده از همان نام متغیر <code>key</code> در الگو که یک روش معمول برای از بین بردن انواع<code>Option</code> در راست است تعریف قبلی را  <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">سایه می زنیم</a>.</p>
<p>اکنون می توانیم اعداد را بنویسیم:</p>
<p><img src="qemu-printing-numbers.gif" alt="QEMU printing numbers to the screen" /></p>
<p>ترجمه کلیدهای دیگر نیز به همین روش کار می کند. خوشبختانه کرت ای با نام <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/"><code>pc-keyboard</code></a> برای ترجمه اسکن‌کد مجموعه های اسکن‌کد 1 و 2 وجود دارد ، بنابراین لازم نیست که خودمان این را پیاده سازی کنیم. برای استفاده از کرت ، آن را به <code>Cargo.toml</code> اضافه کرده و در<code>lib.rs</code> خود وارد می کنیم:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">pc-keyboard </span><span>= </span><span style="color:#d69d85;">&quot;0.5.0&quot;
</span></code></pre>
<p>اکنون میتوانیم از این کرت برای باز نویسی <code>keyboard_interrupt_handler</code> استفاده کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in/src/interrupts.rs
</span><span>
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span>keyboard_interrupt_handler(
</span><span>    _stack_frame: InterruptStackFrame)
</span><span>{
</span><span>    </span><span style="color:#569cd6;">use </span><span>pc_keyboard::{layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1};
</span><span>    </span><span style="color:#569cd6;">use </span><span>spin::Mutex;
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    lazy_static! {
</span><span>        </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">KEYBOARD</span><span>: Mutex&lt;Keyboard&lt;layouts::Us104Key, ScancodeSet1&gt;&gt; =
</span><span>            Mutex::new(Keyboard::new(layouts::Us104Key, ScancodeSet1,
</span><span>                HandleControl::Ignore)
</span><span>            );
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> keyboard = </span><span style="color:#b4cea8;">KEYBOARD</span><span>.lock();
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> port = Port::new(</span><span style="color:#b5cea8;">0x60</span><span>);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> scancode: </span><span style="color:#569cd6;">u8 </span><span>= </span><span style="color:#569cd6;">unsafe </span><span>{ port.read() };
</span><span>    </span><span style="color:#569cd6;">if let </span><span>Ok(Some(key_event)) = keyboard.add_byte(scancode) {
</span><span>        </span><span style="color:#569cd6;">if let </span><span>Some(key) = keyboard.process_keyevent(key_event) {
</span><span>            </span><span style="color:#569cd6;">match</span><span> key {
</span><span>                DecodedKey::Unicode(character) </span><span style="color:#569cd6;">=&gt; </span><span>print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, character),
</span><span>                DecodedKey::RawKey(key) </span><span style="color:#569cd6;">=&gt; </span><span>print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, key),
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">PICS</span><span>.lock()
</span><span>            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
</span><span>    }
</span><span>}
</span></code></pre>
<p>ما از ماکرو <code>lazy_static</code> برای ایجاد یک شی ثابت <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html"><code>Keyboard</code></a> محافظت شده توسط Mutex استفاده می کنیم. <code>Keyboard</code> را با طرح صفحه کلید ایالات متحده و مجموعه اسکن کد 1 مقداردهی می کنیم. پارامتر <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/enum.HandleControl.html"><code>HandleControl</code></a> اجازه می دهد تا <code>ctrl+[a-z]</code> را به کاراکتر های <code>U+0001</code> تا <code>U+001A</code> نگاشت کنیم. ما نمی خواهیم چنین کاری انجام دهیم ، بنابراین از گزینه <code>Ignore</code> برای برخورد با <code>ctrl</code> مانند کلیدهای عادی استفاده می کنیم.</p>
<p>در هر وقفه ، Mutex را قفل می کنیم ، اسکن کد را از کنترل کننده صفحه کلید می خوانیم و آن را به متد <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html#method.add_byte"><code>add_byte</code></a> منتقل می کنیم ، که اسکن کد را به یک <code>&lt;Option&lt;KeyEvent</code> ترجمه می کند. <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.KeyEvent.html"><code>KeyEvent</code></a> حاوی كلیدی است كه باعث رویداد شده و آیا این یک رویداد فشردن یا رها کردن بوده است.</p>
<p>برای تفسیر این رویداد کلید ، آن را به متد <a href="https://docs.rs/pc-keyboard/0.5.0/pc_keyboard/struct.Keyboard.html#method.process_keyevent"><code>process_keyevent</code></a> منتقل می کنیم ، که در صورت امکان رویداد کلید را به یک کاراکتر ترجمه می کند. به عنوان مثال ، بسته به فشردن کلید shift ، یک رویداد فشردن کلید <code>A</code> را به یک حرف کوچک <code>a</code> یا یک حرف بزرگ <code>A</code> ترجمه می کند.</p>
<p>با استفاده از این کنترل کننده وقفه اصلاح شده اکنون می توانیم متن بنویسیم:</p>
<p><img src="qemu-typing.gif" alt="Typing “Hello World” in QEMU" /></p>
<h3 id="pykhrbndy-sfhh-khlyd"><a class="zola-anchor" href="index.html#pykhrbndy-sfhh-khlyd" aria-label="Anchor link for: pykhrbndy-sfhh-khlyd">🔗</a>پیکربندی صفحه کلید</h3>
<p>امکان پیکربندی برخی از جنبه های صفحه کلید PS/2 وجود دارد، به عنوان مثال از کدام اسکن کد استفاده کند. ما در اینجا به آن نمی پردازیم زیرا این پست به اندازه کافی طولانی شده است ، اما ویکی OSDev دارای نمای کلی <a href="https://wiki.osdev.org/PS/2_Keyboard#Commands">دستورات پیکربندی</a> ممکن است.</p>
<h2 id="khlsh"><a class="zola-anchor" href="index.html#khlsh" aria-label="Anchor link for: khlsh">🔗</a>خلاصه</h2>
<p>در این پست نحوه فعال سازی و مدیریت وقفه های خارجی توضیح داده شد. ما در مورد 8259 PIC و طرح اولیه/ثانویه آن ، نگاشت دوباره اعداد وقفه و سیگنال “پایان وقفه” اطلاعات کسب کردیم. ما کنترل کننده‌هایی را برای تایمر سخت افزاری و صفحه کلید پیاده سازی کردیم و درباره دستورات <code>hlt</code> اطلاعاتی کسب کردیم که پردازنده را تا وقفه بعدی متوقف می کند.</p>
<p>اکنون ما قادر به تعامل با هسته خود هستیم و برخی از عناصر اساسی برای ایجاد یک پوسته(Shell) کوچک یا بازی های ساده را داریم.</p>
<h2 id="mrhlh-b-dy-chyst"><a class="zola-anchor" href="index.html#mrhlh-b-dy-chyst" aria-label="Anchor link for: mrhlh-b-dy-chyst">🔗</a>مرحله بعدی چیست؟</h2>
<p>وقفه های تایمر برای یک سیستم عامل ضروری است، زیرا راهی برای قطع دوره ای روند اجرا و کنترل مجدد هسته فراهم می کند. سپس هسته می تواند به فرایند دیگری سوییچ کند و این توهم را ایجاد کند که چندین فرآیند به طور موازی اجرا می شوند.</p>
<p>اما قبل از اینکه بتوانیم فرایندها یا نخ‌ها را ایجاد کنیم ، به روشی برای اختصاص حافظه برای آنها نیاز داریم. در پست های بعدی، مدیریت حافظه مورد بررسی قرار می گیرد تا این عنصر اساسی ایجاد شود.</p>

    </div>

    <div class="post-footer-support right-to-left">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../double-fault-exceptions/index.html">&laquo; خطاهای دوگانه</a>
        
        
            <a class="next" href="../paging-introduction/index.html">مقدمه‌ای بر صفحه‌بندی &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="right-to-left">نظرات</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Hardware%20Interrupts%20%28fa%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="Hardware Interrupts (fa)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fa"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22Hardware%20Interrupts%20%28fa%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="right-to-left">
            لطفا نظرات خود را در صورت امکان به انگلیسی بنویسید.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../hardware-interrupts/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/hardware-interrupts/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/hardware-interrupts/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/hardware-interrupts/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
