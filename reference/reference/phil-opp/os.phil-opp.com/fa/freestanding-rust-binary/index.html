<!doctype html>

<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="اولین قدم برای نوشتن سیستم‌عامل، ساخت یک باینری راست (کلمه: Rust) هست که به کتابخانه استاندارد نیازمند نباشد. این باعث می‌شود تا بتوانیم کد راست را بدون…">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title> یک باینری مستقل Rust | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fa" title="All Posts">« همه پست‌ها</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="right-to-left">
        <h2>فهرست مطالب</h2>
    <ol>
        <li>
            <a href="index.html#mqdmh">مقدمه</a>
            
        </li><li>
            <a href="index.html#gyr-f-l-khrdn-khtbkhnh-stndrd">غیر فعال کردن کتابخانه استاندارد</a>
            <ol>
                <li>
                    <a href="index.html#khsyt-no-std">خاصیت no_std</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#pydhszy-pnykh-khlmh-panic">پیاده‌سازی پنیک (کلمه: Panic)</a>
            
        </li><li>
            <a href="index.html#aytm-zbn-eh-personality">آیتم زبان eh_personality</a>
            <ol>
                <li>
                    <a href="index.html#gyrf-l-khrdn-unwinding">غیرفعال کردن Unwinding</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khsyt-start">خاصیت start</a>
            <ol>
                <li>
                    <a href="index.html#bznwysy-nqth-wrwd">بازنویسی نقطه ورود</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#khthy-lynkhr-linker">خطا‌های لینکر (Linker)</a>
            <ol>
                <li>
                    <a href="index.html#byld-khrdn-bry-ykh-hdf-bare-metal">بیلد کردن برای یک هدف bare metal</a>
                </li><li>
                    <a href="index.html#argwmnhy-lynkhr">آرگومان‌های لینکر</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#summary">خلاصه</a>
            
        </li><li>
            <a href="index.html#b-dy-chyst">بعدی چیست؟</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
    </ol>
</aside>

            <main>
    <div class="right-to-left">
    <h1> یک باینری مستقل Rust</h1>
    <time datetime="2018-02-10" class="post-date">
        Feb 10, 2018
        
    </time>
    </div>

    
        <div class="warning right-to-left">
            
            
            <p>
            <b>محتوای ترجمه شده:</b>
            این یک ترجمه از جامعه کاربران برای پست <strong><a href="../../freestanding-rust-binary/index.html">A Freestanding Rust Binary</a></strong> است. ممکن است ناقص، منسوخ شده یا دارای خطا باشد. لطفا هر گونه مشکل را در <a href="https://github.com/phil-opp/blog_os/issues/908">این ایشو</a> گزارش دهید!
            </p>
            <p>
                ترجمه توسط <a href="https://github.com/hamidrezakp">@hamidrezakp</a> و <a href="https://github.com/MHBahrampour">@MHBahrampour</a>.</p>
            </div>
    

    <div class="right-to-left">
    <p>اولین قدم برای نوشتن سیستم‌عامل، ساخت یک باینری راست (کلمه: Rust) هست که به کتابخانه استاندارد نیازمند نباشد. این باعث می‌شود تا بتوانیم کد راست را بدون سیستم‌عامل زیرین، بر روی سخت افزار <a href="https://en.wikipedia.org/wiki/Bare_machine">bare metal</a> اجرا کنیم.</p>
<span id="continue-reading"></span>
<p>این بلاگ بصورت آزاد بر روی <a href="https://github.com/phil-opp/blog_os">گیت‌هاب</a> توسعه داده شده. اگر مشکل یا سوالی دارید، لطفاً آن‌جا یک ایشو باز کنید. همچنین می‌توانید <a href="index.html#comments">در زیر</a> این پست کامنت بگذارید. سورس کد کامل این پست را می‌توانید در بِرَنچ <a href="https://github.com/phil-opp/blog_os/tree/post-01"><code>post-01</code></a> پیدا کنید.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>فهرست مطالب</b></summary>
        <ul>
            <li>
                <a href="index.html#mqdmh">مقدمه</a>
                
            </li><li>
                <a href="index.html#gyr-f-l-khrdn-khtbkhnh-stndrd">غیر فعال کردن کتابخانه استاندارد</a>
                <ul>
                    <li>
                        <a href="index.html#khsyt-no-std">خاصیت no_std</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#pydhszy-pnykh-khlmh-panic">پیاده‌سازی پنیک (کلمه: Panic)</a>
                
            </li><li>
                <a href="index.html#aytm-zbn-eh-personality">آیتم زبان eh_personality</a>
                <ul>
                    <li>
                        <a href="index.html#gyrf-l-khrdn-unwinding">غیرفعال کردن Unwinding</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khsyt-start">خاصیت start</a>
                <ul>
                    <li>
                        <a href="index.html#bznwysy-nqth-wrwd">بازنویسی نقطه ورود</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#khthy-lynkhr-linker">خطا‌های لینکر (Linker)</a>
                <ul>
                    <li>
                        <a href="index.html#byld-khrdn-bry-ykh-hdf-bare-metal">بیلد کردن برای یک هدف bare metal</a>
                    </li><li>
                        <a href="index.html#argwmnhy-lynkhr">آرگومان‌های لینکر</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#summary">خلاصه</a>
                
            </li><li>
                <a href="index.html#b-dy-chyst">بعدی چیست؟</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">نظرات</a></li>
        </ul>
    </details>

<h2 id="mqdmh"><a class="zola-anchor" href="index.html#mqdmh" aria-label="Anchor link for: mqdmh">🔗</a>مقدمه</h2>
<p>برای نوشتن هسته سیستم‌عامل، ما به کدی نیاز داریم که به هیچ یک از ویژگی‌های سیستم‌عامل نیازی نداشته باشد. یعنی نمی‌توانیم از نخ‌ها (ترجمه: Threads)، فایل‌ها، حافظه هیپ (کلمه: Heap)، شبکه، اعداد تصادفی، ورودی استاندارد، یا هر ویژگی دیگری که نیاز به انتزاعات سیستم‌عامل یا سخت‌افزار خاصی داشته، استفاده کنیم. منطقی هم به نظر می‌رسد، چون ما سعی داریم سیستم‌عامل و درایور‌های خودمان را بنویسیم.</p>
<p>نداشتن انتزاعات سیستم‌عامل به این معنی هست که نمی‌توانیم از بخش زیادی از <a href="https://doc.rust-lang.org/std/">کتابخانه استاندارد راست</a> استفاده کنیم، اما هنوز بسیاری از ویژگی‌های راست هستند که می‌توانیم از آن‌ها استفاده کنیم. به عنوان مثال، می‌توانیم از [iterator] ها، [closure] ها، <a href="https://doc.rust-lang.org/book/ch06-00-enums.html">pattern matching</a>، <a href="https://doc.rust-lang.org/core/option/">option</a>، <a href="https://doc.rust-lang.org/core/result/">result</a>، <a href="https://doc.rust-lang.org/core/macro.write.html">string formatting</a> و البته <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">سیستم ownership</a> استفاده کنیم. این ویژگی‌ها به ما امکان نوشتن هسته به طور رسا، سطح بالا و بدون نگرانی درباره <a href="https://www.nayuki.io/page/undefined-behavior-in-c-and-cplusplus-programs">رفتار تعریف نشده</a> و <a href="https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention">امنیت حافظه</a> را میدهند.</p>
<p>برای ساختن یک هسته سیستم‌عامل به زبان راست، باید فایل اجرایی‌ای بسازیم که بتواند بدون سیستم‌عامل زیرین اجرا بشود. چنین فایل اجرایی، فایل اجرایی مستقل (ترجمه: freestanding) یا فایل اجرایی “bare-metal” نامیده می‌شود.</p>
<p>این پست قدم‌های لازم برای ساخت یک باینری مستقل راست و اینکه چرا این قدم‌ها نیاز هستند را توضیح می‌دهد. اگر علاقه‌ایی به خواندن کل توضیحات ندارید، می‌توانید <strong><a href="index.html#summary">به قسمت خلاصه مراجعه کنید</a></strong>.</p>
<h2 id="gyr-f-l-khrdn-khtbkhnh-stndrd"><a class="zola-anchor" href="index.html#gyr-f-l-khrdn-khtbkhnh-stndrd" aria-label="Anchor link for: gyr-f-l-khrdn-khtbkhnh-stndrd">🔗</a>غیر فعال کردن کتابخانه استاندارد</h2>
<p>به طور پیش‌فرض تمام کِرِیت‌های راست، از <a href="https://doc.rust-lang.org/std/">کتابخانه استاندارد</a> استفاده می‌کنند(لینک به آن دارند)، که به سیستم‌عامل برای قابلیت‌هایی مثل نخ‌ها، فایل‌ها یا شبکه وابستگی دارد. همچنین به کتابخانه استاندارد زبان سی، <code>libc</code> هم وابسطه هست که با سرویس‌های سیستم‌عامل تعامل نزدیکی دارند. از آن‌جا که قصد داریم یک سیستم‌عامل بنویسیم، نمی‌توانیم از هیچ کتابخانه‌ایی که به سیستم‌عامل نیاز داشته باشد استفاده کنیم. بنابراین باید اضافه شدن خودکار کتابخانه استاندارد را از طریق <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html">خاصیت <code>no_std</code></a> غیر فعال کنیم.</p>
<p>با ساخت یک اپلیکیشن جدید کارگو شروع می‌کنیم. ساده‌ترین راه برای انجام این کار از طریق خط فرمان است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo new blog_os --bin --edition 2018
</span></code></pre>
<p>نام پروژه را <code>blog_os‍</code> گذاشتم، اما شما می‌توانید نام دلخواه خود را انتخاب کنید. پرچمِ (ترجمه: Flag) <code>bin--</code> مشخص می‌کند که ما می‌خواهیم یک فایل اجرایی ایجاد کنیم (به جای یک کتابخانه) و پرچمِ <code>edition 2018--</code> مشخص می‌کند که می‌خواهیم از <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/index.html">ویرایش 2018</a> زبان راست برای کریت خود استفاده کنیم. وقتی دستور را اجرا می‌کنیم، کارگو ساختار پوشه‌های زیر را برای ما ایجاد می‌کند:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>blog_os
</span><span>├── Cargo.toml
</span><span>└── src
</span><span>    └── main.rs
</span></code></pre>
<p>فایل <code>Cargo.toml</code> شامل تنظیمات کریت می‌باشد، به عنوان مثال نام کریت، نام نویسنده، شماره <a href="https://semver.org/">نسخه سمنتیک</a> و وابستگی‌ها. فایل <code>src/main.rs</code> شامل ماژول ریشه برای کریت ما و تابع <code>main</code> است. می‌توانید کریت خود را با دستور <code>cargo build‍</code> کامپایل کنید و سپس باینری کامپایل شده ‍‍<code>blog_os</code> را در زیرپوشه <code>target/debug</code> اجرا کنید.</p>
<h3 id="khsyt-no-std"><a class="zola-anchor" href="index.html#khsyt-no-std" aria-label="Anchor link for: khsyt-no-std">🔗</a>خاصیت <code>no_std</code></h3>
<p>در حال حاظر کریت ما بطور ضمنی به کتابخانه استاندارد لینک دارد. بیایید تا سعی کنیم آن را با اضافه کردن  <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html">خاصیت <code>no_std</code></a> غیر فعال کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// main.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello, world!&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>حالا وقتی سعی می‌کنیم تا بیلد کنیم (با اجرای دستور <code>cargo build</code>)، خطای زیر رخ می‌دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: cannot find macro `println!` in this scope
</span><span> --&gt; src/main.rs:4:5
</span><span>  |
</span><span>4 |     println!(&quot;Hello, world!&quot;);
</span><span>  |     ^^^^^^^
</span></code></pre>
<p>دلیل این خطا این هست که <a href="https://doc.rust-lang.org/std/macro.println.html">ماکروی <code>println</code></a>(ترجمه: macro) جزوی از کتابخانه استاندارد است، که ما دیگر آن را نداریم. بنابراین نمی‌توانیم چیزی را چاپ کنیم. منطقی هست زیرا <code>println</code> در <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29">خروجی استاندارد</a> می‌نویسد، که یک توصیف کننده فایل (ترجمه: File Descriptor) خاص است که توسط سیستم‌عامل ارائه می‌شود.</p>
<p>پس بیایید قسمت مروبط به چاپ را پاک کرده و این‌ بار با یک تابع main خالی امتحان کنیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// main.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {}
</span></code></pre>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build
</span><span>error: `#[panic_handler]` function required, but not found
</span><span>error: language item required, but not found: `eh_personality`
</span></code></pre>
<p>حالا کامپایلر با کمبود یک تابع <code>#[panic_handler]</code> و یک <em>language item</em> روبرو است.</p>
<h2 id="pydhszy-pnykh-khlmh-panic"><a class="zola-anchor" href="index.html#pydhszy-pnykh-khlmh-panic" aria-label="Anchor link for: pydhszy-pnykh-khlmh-panic">🔗</a>پیاده‌سازی پنیک (کلمه: Panic)</h2>
<p>خاصیت <code>panic_handler</code> تابعی را تعریف می‌کند که کامپایلر باید در هنگام رخ دادن یک <a href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">پنیک</a> اجرا کند. کتابخانه استاندارد تابع مدیریت پنیک خود را ارائه می‌دهد، اما در یک محیط <code>no_std</code> ما باید خودمان آن را تعریف کنیم.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in main.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#608b4e;">/// This function is called on panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p><a href="https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html">پارامتر <code>PanicInfo</code></a> شامل فایل و شماره خطی که پنیک رخ داده و پیام پنیکِ اختیاری می‌باشد. تابع هیچ وقت نباید چیزی را برگرداند به همین دلیل به عنوان یک <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions">تابع واگرا</a>(ترجمه: diverging function) بوسیله نوع برگشتی <code>!</code> <a href="https://doc.rust-lang.org/nightly/std/primitive.never.html">نوع ”هرگز“</a> علامت‌گذاری شده است. فعلا کار زیادی نیست که بتوانیم در این تابع انجام دهیم، بنابراین فقط یک حلقه بی‌نهایت می‌نویسیم.</p>
<h2 id="aytm-zbn-eh-personality"><a class="zola-anchor" href="index.html#aytm-zbn-eh-personality" aria-label="Anchor link for: aytm-zbn-eh-personality">🔗</a>آیتم زبان <code>eh_personality</code></h2>
<p>آیتم‌های زبان، توابع و انواع خاصی هستند که برای استفاده درون کامپایلر ضروری‌اند. به عنوان مثال، تِرِیت ‍‍<a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><code>Copy</code></a>(کلمه: Trait) یک آیتم زبان است که به کامپایلر می‌گوید کدام انواع دارای <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><em>مفهوم کپی</em></a> هستند. وقتی به <a href="https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299">پیاده‌سازی</a> آن نگاه می‌کنیم، می‌بینیم که یک خاصیت ویژه <code>#[lang = &quot;copy&quot;]</code> دارد که آن را به عنوان یک آیتم زبان تعریف می‌کند.</p>
<p>درحالی که می‌توان پیاده‌سازی خاص برای آیتم‌های زبان فراهم کرد، فقط باید به عنوان آخرین راه حل از آن استفاده کرد. زیرا آیتم‌های زبان بسیار در جزئیات پیاده‌سازی ناپایدار هستند و حتی انواع آن‌ها نیز چک نمی‌شود (بنابراین کامپایلر حتی چک نمی‌کند که آرگومان تابع نوع درست را دارد). خوشبختانه یک راه پایدارتر برای حل مشکل آیتم زبان بالا وجود دارد.</p>
<p><a href="https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45">آیتم زبان <code>eh_personality</code></a> یک تابع را به عنوان تابعی که برای پیاده‌سازی <a href="https://www.bogotobogo.com/cplusplus/stackunwinding.php">بازکردن پشته (Stack Unwinding)</a> استفاده شده، علامت‌گذاری می‌کند. راست بطور پیش‌فرض از <em>بازکردن</em> (ترجمه: unwinding) برای اجرای نابودگرهای (ترجمه: Destructors) تمام متغیرهای زنده درون استک در مواقع <a href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">پنیک</a> استفاده می‌کند. این تضمین می‌کند که تمام حافظه استفاده شده آزاد می‌شود و به نخ اصلی اجازه می‌دهد پنیک را دریافت کرده و اجرا را ادامه دهد. باز کردن، یک فرآیند پیچیده است و به برخی از کتابخانه‌های خاص سیستم‌عامل (به عنوان مثال <a href="https://www.nongnu.org/libunwind/">libunwind</a> در لینوکس یا <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">مدیریت اکسپشن ساخت یافته</a> در ویندوز) نیاز دارد، بنابراین ما نمی‌خواهیم از آن برای سیستم‌عامل خود استفاده کنیم.</p>
<h3 id="gyrf-l-khrdn-unwinding"><a class="zola-anchor" href="index.html#gyrf-l-khrdn-unwinding" aria-label="Anchor link for: gyrf-l-khrdn-unwinding">🔗</a>غیرفعال کردن Unwinding</h3>
<p>موارد استفاده دیگری نیز وجود دارد که باز کردن نامطلوب است، بنابراین راست به جای آن گزینه <a href="https://github.com/rust-lang/rust/pull/32900">قطع در پنیک</a> را فراهم می‌کند. این امر تولید اطلاعات نمادها (ترجمه: Symbol) را از بین می‌برد و بنابراین اندازه باینری را بطور قابل توجهی کاهش می‌دهد. چندین مکان وجود دارد که می توانیم باز کردن را غیرفعال کنیم. ساده‌ترین راه این است که خطوط زیر را به <code>Cargo.toml</code> اضافه کنید:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">profile.dev</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot;
</span><span>
</span><span>[</span><span style="color:#808080;">profile.release</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot;
</span></code></pre>
<p>این استراتژی پنیک را برای دو پروفایل <code>dev</code> (در <code>cargo build</code> استفاده می‌شود)  و پروفایل <code>release</code> (در <code> cargo build --release</code> استفاده می‌شود) تنظیم می‌کند. اکنون آیتم زبان <code>eh_personality</code> نباید دیگر لازم باشد.</p>
<p>اکنون هر دو خطای فوق را برطرف کردیم. با این حال‌، اگر اکنون بخواهیم آن را کامپایل کنیم، خطای دیگری رخ می‌دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build
</span><span>error: requires `start` lang_item
</span></code></pre>
<p>برنامه ما آیتم زبان <code>start</code> که نقطه ورود را مشخص می‌کند، را ندارد.</p>
<h2 id="khsyt-start"><a class="zola-anchor" href="index.html#khsyt-start" aria-label="Anchor link for: khsyt-start">🔗</a>خاصیت <code>start</code></h2>
<p>ممکن است تصور شود که تابع <code>main</code> اولین تابعی است که هنگام اجرای یک برنامه فراخوانی می‌شود. با این حال، بیشتر زبان‌ها دارای <a href="https://en.wikipedia.org/wiki/Runtime_system">سیستم رانتایم</a> هستند که مسئول مواردی مانند جمع آوری زباله (به عنوان مثال در جاوا) یا نخ‌های نرم‌افزار (به عنوان مثال goroutines در Go) است. این رانتایم باید قبل از <code>main</code> فراخوانی شود، زیرا باید خود را مقداردهی اولیه و آماده کند.</p>
<p>در یک باینری معمولی راست که از کتابخانه استاندارد استفاده می‌کند، اجرا در یک کتابخانه رانتایم C به نام <code>crt0</code> (“زمان اجرا صفر C”) شروع می‌شود، که محیط را برای یک برنامه C تنظیم می‌کند. این شامل ایجاد یک پشته و قرار دادن آرگومان‌ها در رجیسترهای مناسب است. سپس رانتایم C <a href="https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73">ورودی رانتایم راست</a> را فراخوانی می‌کند، که با آیتم زبان <code>start</code> مشخص شده است. راست فقط یک رانتایم بسیار کوچک دارد، که مواظب برخی از کارهای کوچک مانند راه‌اندازی محافظ‌های سرریز پشته یا چاپ backtrace با پنیک می‌باشد. رانتایم در نهایت تابع <code>main</code> را فراخوانی می‌کند.</p>
<p>برنامه اجرایی مستقل ما به رانتایم و <code>crt0</code> دسترسی ندارد، بنابراین باید نقطه ورود را مشخص کنیم. پیاده‌سازی آیتم زبان <code>start</code> کمکی نخواهد کرد، زیرا همچنان به <code>crt0</code> نیاز دارد. در عوض، باید نقطه ورود <code>crt0</code> را مستقیماً بازنویسی کنیم.</p>
<h3 id="bznwysy-nqth-wrwd"><a class="zola-anchor" href="index.html#bznwysy-nqth-wrwd" aria-label="Anchor link for: bznwysy-nqth-wrwd">🔗</a>بازنویسی نقطه ورود</h3>
<p>برای اینکه به کامپایلر راست بگوییم که نمی‌خواهیم از زنجیره نقطه ورودی عادی استفاده کنیم، ویژگی <code>#![no_main]</code> را اضافه می‌کنیم.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#608b4e;">/// This function is called on panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>ممکن است متوجه شده باشید که ما تابع <code>main</code> را حذف کردیم. دلیل این امر این است که <code>main</code> بدون یک رانتایم اساسی که آن را صدا کند معنی ندارد. در عوض، ما در حال بازنویسی نقطه ورود سیستم‌عامل با تابع <code>start_</code> خود هستیم:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>با استفاده از ویژگی <code>[no_mangle]#</code> ما <a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a> را غیرفعال می کنیم تا اطمینان حاصل کنیم که کامپایلر راست تابعی با نام <code>start_</code> را خروجی می‌دهد. بدون این ویژگی، کامپایلر برخی از نمادهای رمزنگاری شده <code>ZN3blog_os4_start7hb173fedf945531caE_</code> را تولید می‌کند تا به هر تابع یک نام منحصر به فرد بدهد. این ویژگی لازم است زیرا در مرحله بعدی باید نام تایع نقطه ورود را به لینکر (کلمه: linker) بگوییم.</p>
<p>ما همچنین باید تابع را به عنوان <code>&quot;extern &quot;C</code> علامت‌گذاری کنیم تا به کامپایلر بگوییم که باید از <a href="https://en.wikipedia.org/wiki/Calling_convention">قرارداد فراخوانی C</a> برای این تابع استفاده کند (به جای قرارداد مشخص نشده فراخوانی راست). دلیل نامگذاری تابع <code>start_</code> این است که این نام نقطه پیش‌فرض ورودی برای اکثر سیستم‌ها است.</p>
<p>نوع بازگشت <code>!</code> به این معنی است که تایع واگرا است، یعنی اجازه بازگشت ندارد. این مورد لازم است زیرا نقطه ورود توسط هیچ تابعی فراخوانی نمی‌شود، بلکه مستقیماً توسط سیستم‌عامل یا بوت‌لودر فراخوانی می‌شود. بنابراین به جای بازگشت، نقطه ورود باید به عنوان مثال <a href="https://en.wikipedia.org/wiki/Exit_(system_call)">فراخوان سیستمی <code>exit</code></a> از سیستم‌عامل را فراخوانی کند. در مورد ما، خاموش کردن دستگاه می‌تواند اقدامی منطقی باشد، زیرا در صورت بازگشت باینری مستقل دیگر کاری برای انجام دادن وجود ندارد. در حال حاضر، ما این نیاز را با حلقه‌های بی‌پایان انجام می‌دهیم.</p>
<p>حالا وقتی <code>cargo build</code> را اجرا می‌کنیم، با یک خطای <em>لینکر</em> زشت مواجه می‌شویم.</p>
<h2 id="khthy-lynkhr-linker"><a class="zola-anchor" href="index.html#khthy-lynkhr-linker" aria-label="Anchor link for: khthy-lynkhr-linker">🔗</a>خطا‌های لینکر (Linker)</h2>
<p>لینکر برنامه‌ای است که کد تولید شده را ترکیب کرده و یک فایل اجرایی می‌سازد. از آن‌جا که فرمت اجرایی بین لینوکس، ویندوز و macOS متفاوت است، هر سیستم لینکر خود را دارد که خطای متفاوتی ایجاد می‌کند. علت اصلی خطاها یکسان است: پیکربندی پیش‌فرض لینکر فرض می‌کند که برنامه ما به رانتایم C وابسته است، که این طور نیست.</p>
<p>برای حل خطاها، باید به لینکر بگوییم که نباید رانتایم C را اضافه کند. ما می‌توانیم این کار را با اضافه کردن مجموعه‌ای از آرگمان‌ها به لینکر یا با ساختن یک هدف (ترجمه: Target) bare metal انجام دهیم.</p>
<h3 id="byld-khrdn-bry-ykh-hdf-bare-metal"><a class="zola-anchor" href="index.html#byld-khrdn-bry-ykh-hdf-bare-metal" aria-label="Anchor link for: byld-khrdn-bry-ykh-hdf-bare-metal">🔗</a>بیلد کردن برای یک هدف bare metal</h3>
<p>راست به طور پیش‌فرض سعی در ایجاد یک اجرایی دارد که بتواند در محیط سیستم فعلی شما اجرا شود. به عنوان مثال، اگر از ویندوز در <code>x86_64</code> استفاده می‌کنید، راست سعی در ایجاد یک <code>exe.</code> اجرایی ویندوز دارد که از دستورالعمل‌های <code>x86_64</code> استفاده می‌کند. به این محیط سیستم “میزبان” شما گفته می‌شود.</p>
<p>راست برای توصیف محیط‌های مختلف، از رشته‌ای به نام <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple"><em>target triple</em></a>(سه‌گانه هدف) استفاده می‌کند. با اجرای <code>rustc --version --verbose</code> می‌توانید target triple را برای سیستم میزبان خود مشاهده کنید:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>rustc 1.35.0-nightly (474e7a648 2019-04-07)
</span><span>binary: rustc
</span><span>commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
</span><span>commit-date: 2019-04-07
</span><span>host: x86_64-unknown-linux-gnu
</span><span>release: 1.35.0-nightly
</span><span>LLVM version: 8.0
</span></code></pre>
<p>خروجی فوق از یک سیستم لینوکس <code>x86_64</code> است. می‌بینیم که سه‌گانه میزبان <code>x86_64-unknown-linux-gnu</code> است که شامل معماری پردازنده (<code>x86_64</code>)، فروشنده (<code>ناشناخته</code>)، سیستم‌عامل (<code> linux</code>) و <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> (<code>gnu</code>) است.</p>
<p>با کامپایل کردن برای سه‌گانه میزبان‌مان، کامپایلر راست و لینکر فرض می‌کنند که یک سیستم‌عامل زیرین مانند Linux یا Windows وجود دارد که به طور پیش‌فرض از رانتایم C استفاده می‌کند، که باعث خطاهای لینکر می‌شود. بنابراین برای جلوگیری از خطاهای لینکر، می‌توانیم برای محیطی متفاوت و بدون سیستم‌عامل زیرین کامپایل کنیم.</p>
<p>یک مثال برای چنین محیطِ bare metal ی، سه‌گانه هدف <code>thumbv7em-none-eabihf</code> است، که یک سیستم <a href="https://en.wikipedia.org/wiki/ARM_architecture">تعبیه شده</a> را توصیف می‌کند. جزئیات مهم نیستند، مهم این است که سه‌گانه هدف فاقد سیستم‌عامل زیرین باشد، که با <code>none</code> در سه‌گانه هدف نشان داده می‌شود. برای این که بتوانیم برای این هدف کامپایل کنیم، باید آن را به rustup اضافه کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>rustup target add thumbv7em-none-eabihf
</span></code></pre>
<p>با این کار نسخه‌ای از کتابخانه استاندارد (و core) برای سیستم بارگیری می‌شود. اکنون می‌توانیم برای این هدف اجرایی مستقل خود را بسازیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo build --target thumbv7em-none-eabihf
</span></code></pre>
<p>با استفاده از یک آرگومان <code>target--</code>، ما اجرایی خود را برای یک سیستم هدف bare metal <a href="https://en.wikipedia.org/wiki/Cross_compiler">کراس کامپایل</a> می‌کنیم. از آن‌جا که سیستم هدف فاقد سیستم‌عامل است، لینکر سعی نمی‌کند رانتایم C را به آن پیوند دهد و بیلد ما بدون هیچ گونه خطای لینکر با موفقیت انجام می‌شود.</p>
<p>این روشی است که ما برای ساخت هسته سیستم‌عامل خود استفاده خواهیم کرد. به جای <code>thumbv7em-none-eabihf</code>، ما از یک <a href="https://doc.rust-lang.org/rustc/targets/custom.html">هدف سفارشی</a> استفاده خواهیم کرد که یک محیط <code>x86_64</code> bare metal را توصیف می‌کند. جزئیات در پست بعدی توضیح داده خواهد شد.</p>
<h3 id="argwmnhy-lynkhr"><a class="zola-anchor" href="index.html#argwmnhy-lynkhr" aria-label="Anchor link for: argwmnhy-lynkhr">🔗</a>آرگومان‌های لینکر</h3>
<p>به جای کامپایل کردن برای یک سیستم bare metal، می‌توان خطاهای لینکر را با استفاده از مجموعه خاصی از آرگومان‌ها به لینکر حل کرد. این روشی نیست که ما برای هسته خود استفاده کنیم، بنابراین این بخش اختیاری است و فقط برای کامل بودن ارائه می‌شود. برای نشان دادن محتوای اختیاری، روی <em>“آرگومان‌های لینکر”</em> در زیر کلیک کنید.</p>
<details>
<summary>آرگومان‌های لینکر</summary>
<p>در این بخش، ما در مورد خطاهای لینکر که در لینوکس، ویندوز و macOS رخ می‌دهد بحث می‌کنیم و نحوه حل آن‌ها را با استفاده از آرگومان‌های اضافی به لینکر توضیح می‌دهیم. توجه داشته باشید که فرمت اجرایی و لینکر بین سیستم‌عامل‌ها متفاوت است، بنابراین برای هر سیستم مجموعه‌ای متفاوت از آرگومان‌ها مورد نیاز است.</p>
<h4 id="lynwkhs"><a class="zola-anchor" href="index.html#lynwkhs" aria-label="Anchor link for: lynwkhs">🔗</a>لینوکس</h4>
<p>در لینوکس خطای لینکر زیر رخ می‌دهد (کوتاه شده):</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; […]
</span><span>  = note: /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x12): undefined reference to `__libc_csu_fini&#39;
</span><span>          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x19): undefined reference to `__libc_csu_init&#39;
</span><span>          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x25): undefined reference to `__libc_start_main&#39;
</span><span>          collect2: error: ld returned 1 exit status
</span></code></pre>
<p>مشکل این است که لینکر به طور پیش‌فرض شامل روال راه‌اندازی رانتایم C است که به آن <code>start_</code> نیز گفته می‌شود. به برخی از نمادهای کتابخانه استاندارد C یعنی <code>libc</code> نیاز دارد که به دلیل ویژگی<code>no_std</code> آن‌ها را نداریم، بنابراین لینکر نمی‌تواند این مراجع را پیدا کند. برای حل این مسئله، با استفاده از پرچم <code>nostartfiles-</code> می‌توانیم به لینکر بگوییم که نباید روال راه‌اندازی C را لینک دهد.</p>
<p>یکی از راه‌های عبور صفات لینکر از طریق cargo، دستور <code>cargo rustc</code> است. این دستور دقیقاً مانند <code>cargo build</code> رفتار می‌کند، اما اجازه می‌دهد گزینه‌ها را به <code>rustc</code>، کامپایلر اصلی راست انتقال دهید. <code>rustc</code> دارای پرچم<code>C link-arg-</code> است که آرگومان را به لینکر منتقل می‌کند. با ترکیب همه این‌ها، دستور بیلد جدید ما به این شکل است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-arg=-nostartfiles
</span></code></pre>
<p>اکنون کریت ما بصورت اجرایی مستقل در لینوکس ساخته می‌شود!</p>
<p>لازم نیست که صریحاً نام تابع نقطه ورود را مشخص کنیم، زیرا لینکر به طور پیش‌فرض به دنبال تابعی با نام <code>start_</code> می‌گردد.</p>
<h4 id="wyndwz"><a class="zola-anchor" href="index.html#wyndwz" aria-label="Anchor link for: wyndwz">🔗</a>ویندوز</h4>
<p>در ویندوز، یک خطای لینکر متفاوت رخ می‌دهد (کوتاه شده):</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `link.exe` failed: exit code: 1561
</span><span>  |
</span><span>  = note: &quot;C:\\Program Files (x86)\\…\\link.exe&quot; […]
</span><span>  = note: LINK : fatal error LNK1561: entry point must be defined
</span></code></pre>
<p>خطای “entry point must be defined” به این معنی است که لینکر نمی‌تواند نقطه ورود را پیدا کند. در ویندوز، نام پیش‌فرض نقطه ورود  [بستگی به زیر سیستم استفاده شده دارد] [windows-subsystem]. برای زیر سیستم <code>CONSOLE</code> لینکر به دنبال تابعی به نام <code>mainCRTStartup</code> و برای زیر سیستم <code>WINDOWS</code> به دنبال تابعی به نام <code>WinMainCRTStartup</code> می‌گردد. برای بازنویسی این پیش‌فرض و به لینکر گفتن که در عوض به دنبال تابع <code>_start</code> ما باشد ، می توانیم یک آرگومان <code>ENTRY/</code> را به لینکر ارسال کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-arg=/ENTRY:_start
</span></code></pre>
<p>از متفاوت بودن فرمت آرگومان، به وضوح می‌فهمیم که لینکر ویندوز یک برنامه کاملاً متفاوت از لینکر Linux است.</p>
<p>اکنون یک خطای لینکر متفاوت رخ داده است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `link.exe` failed: exit code: 1221
</span><span>  |
</span><span>  = note: &quot;C:\\Program Files (x86)\\…\\link.exe&quot; […]
</span><span>  = note: LINK : fatal error LNK1221: a subsystem can&#39;t be inferred and must be
</span><span>          defined
</span></code></pre>
<p>این خطا به این دلیل رخ می‌دهد که برنامه‌های اجرایی ویندوز می‌توانند از <a href="https://docs.microsoft.com/en-us/cpp/build/reference/entry-entry-point-symbol">زیر سیستم های</a> مختلف استفاده کنند. برای برنامه‌های عادی، بسته به نام نقطه ورود استنباط می شوند: اگر نقطه ورود <code>main</code> نامگذاری شود، از زیر سیستم <code>CONSOLE</code> و اگر نقطه ورود <code>WinMain</code> نامگذاری شود، از زیر سیستم <code>WINDOWS</code> استفاده می‌شود. از آن‌جا که تابع <code>start_</code> ما نام دیگری دارد، باید زیر سیستم را صریحاً مشخص کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;/ENTRY:_start /SUBSYSTEM:console&quot;
</span></code></pre>
<p>ما در اینجا از زیر سیستم <code>CONSOLE</code> استفاده می‌کنیم، اما زیر سیستم <code>WINDOWS</code> نیز کار خواهد کرد. به جای اینکه چند بار از <code>C link-arg-</code> استفاده کنیم، از<code>C link-args-</code> استفاده می‌کنیم که لیستی از آرگومان‌ها به صورت جدا شده با فاصله را دریافت می‌کند.</p>
<p>با استفاده از این دستور، اجرایی ما باید با موفقیت بر روی ویندوز ساخته شود.</p>
<h4 id="macos"><a class="zola-anchor" href="index.html#macos" aria-label="Anchor link for: macos">🔗</a>macOS</h4>
<p>در macOS، خطای لینکر زیر رخ می‌دهد (کوتاه شده):</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; […]
</span><span>  = note: ld: entry point (_main) undefined. for architecture x86_64
</span><span>          clang: error: linker command failed with exit code 1 […]
</span></code></pre>
<p>این پیام خطا به ما می‌گوید که لینکر نمی‌تواند یک تابع نقطه ورود را با نام پیش‌فرض <code>main</code> پیدا کند (به دلایلی همه توابع در macOS دارای پیشوند <code>_</code> هستند). برای تنظیم نقطه ورود به تابع <code>start_</code> ، آرگومان لینکر <code>e-</code> را استفاده می‌کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start&quot;
</span></code></pre>
<p>پرچم <code>e‌-‌</code> نام تابع نقطه ورود را مشخص می‌کند. از آن‌جا که همه توابع در macOS دارای یک پیشوند اضافی <code>_</code> هستند، ما باید به جای <code>start_</code> نقطه ورود را روی <code>start__</code> تنظیم کنیم.</p>
<p>اکنون خطای لینکر زیر رخ می‌دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; […]
</span><span>  = note: ld: dynamic main executables must link with libSystem.dylib
</span><span>          for architecture x86_64
</span><span>          clang: error: linker command failed with exit code 1 […]
</span></code></pre>
<p>سیستم‌عامل مک‌ [رسماً باینری‌هایی را که بطور استاتیک با هم پیوند دارند پشتیبانی نمی‌کند] و بطور پیش‌فرض به برنامه‌هایی برای پیوند دادن کتابخانه <code>libSystem</code> نیاز دارد. برای تغییر این حالت و پیوند دادن یک باینری استاتیک، پرچم <code>static-</code> را به لینکر ارسال می‌کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start -static&quot;
</span></code></pre>
<p>این نیز کافی نیست، سومین خطای لینکر رخ می‌دهد:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; […]
</span><span>  = note: ld: library not found for -lcrt0.o
</span><span>          clang: error: linker command failed with exit code 1 […]
</span></code></pre>
<p>این خطا رخ می‌دهد زیرا برنامه های موجود در macOS به طور پیش‌فرض به <code>crt0</code> (“رانتایم صفر C”) پیوند دارند. این همان خطایی است که در لینوکس داشتیم و با افزودن آرگومان لینکر <code>nostartfiles-</code> نیز قابل حل است:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start -static -nostartfiles&quot;
</span></code></pre>
<p>اکنون برنامه ما باید با موفقیت بر روی macOS ساخته شود.</p>
<h4 id="mthd-khrdn-dstwrt-build"><a class="zola-anchor" href="index.html#mthd-khrdn-dstwrt-build" aria-label="Anchor link for: mthd-khrdn-dstwrt-build">🔗</a>متحد کردن دستورات Build</h4>
<p>در حال حاضر بسته به سیستم‌عامل میزبان، دستورات ساخت متفاوتی داریم که ایده آل نیست. برای جلوگیری از این، می‌توانیم فایلی با نام <code>cargo/config.toml.</code> ایجاد کنیم که حاوی آرگومان‌های خاص هر پلتفرم است:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;linux&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-arg=-nostartfiles&quot;</span><span>]
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;windows&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-args=/ENTRY:_start /SUBSYSTEM:console&quot;</span><span>]
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;macos&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-args=-e __start -static -nostartfiles&quot;</span><span>]
</span></code></pre>
<p>کلید <code>rustflags</code> شامل آرگومان‌هایی است که بطور خودکار به هر فراخوانی <code>rustc</code> اضافه می‌شوند. برای کسب اطلاعات بیشتر در مورد فایل <code>cargo/config.toml‌.‌</code> به <a href="https://doc.rust-lang.org/cargo/reference/config.html">اسناد رسمی</a> مراجعه کنید.</p>
<p>اکنون برنامه ما باید در هر سه سیستم‌عامل با یک <code>cargo build</code> ساده قابل بیلد باشد.</p>
<h4 id="ay-shm-byd-yn-khr-r-njm-dhyd"><a class="zola-anchor" href="index.html#ay-shm-byd-yn-khr-r-njm-dhyd" aria-label="Anchor link for: ay-shm-byd-yn-khr-r-njm-dhyd">🔗</a>آیا شما باید این کار را انجام دهید؟</h4>
<p>اگرچه ساخت یک اجرایی مستقل برای لینوکس، ویندوز و macOS امکان پذیر است، اما احتمالاً ایده خوبی نیست. چرا که اجرایی ما هنوز انتظار موارد مختلفی را دارد، به عنوان مثال با فراخوانی تابع <code>start_</code> یک پشته مقداردهی اولیه شده است. بدون رانتایم C، ممکن است برخی از این الزامات برآورده نشود، که ممکن است باعث شکست برنامه ما شود، به عنوان مثال از طریق <code>segmentation fault</code>.</p>
<p>اگر می خواهید یک باینری کوچک ایجاد کنید که بر روی سیستم‌عامل موجود اجرا شود، اضافه کردن <code>libc</code> و تنظیم ویژگی <code>[start]#</code> همان‌طور که <a href="https://doc.rust-lang.org/1.16.0/book/no-stdlib.html">اینجا</a> شرح داده شده است، احتمالاً ایده بهتری است.</p>
</details>
<h2 id="summary"><a class="zola-anchor" href="index.html#summary" aria-label="Anchor link for: summary">🔗</a>خلاصه</h2>
<p>یک باینری مستقل مینیمال راست مانند این است:</p>
<p><code>src/main.rs</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![no_std] </span><span style="color:#608b4e;">// don&#39;t link the Rust standard library
</span><span>#![no_main] </span><span style="color:#608b4e;">// disable all Rust-level entry points
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// don&#39;t mangle the name of this function
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#608b4e;">// this function is the entry point, since the linker looks for a function
</span><span>    </span><span style="color:#608b4e;">// named `_start` by default
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// This function is called on panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p><code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">package</span><span>]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;crate_name&quot;
</span><span style="color:#569cd6;">version </span><span>= </span><span style="color:#d69d85;">&quot;0.1.0&quot;
</span><span style="color:#569cd6;">authors </span><span>= [</span><span style="color:#d69d85;">&quot;Author Name &lt;author@example.com&gt;&quot;</span><span>]
</span><span>
</span><span style="color:#608b4e;"># the profile used for `cargo build`
</span><span>[</span><span style="color:#808080;">profile.dev</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot; </span><span style="color:#608b4e;"># disable stack unwinding on panic
</span><span>
</span><span style="color:#608b4e;"># the profile used for `cargo build --release`
</span><span>[</span><span style="color:#808080;">profile.release</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot; </span><span style="color:#608b4e;"># disable stack unwinding on panic
</span></code></pre>
<p>برای ساخت این باینری، ما باید برای یک هدف bare metal مانند <code>thumbv7em-none-eabihf</code> کامپایل کنیم:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo build --target thumbv7em-none-eabihf
</span></code></pre>
<p>یک راه دیگر این است که می‌توانیم آن را برای سیستم میزبان با استفاده از آرگومان‌های اضافی لینکر کامپایل کنیم:</p>
<pre data-lang="bash" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#608b4e;"># Linux
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-arg=-nostartfiles
</span><span style="color:#608b4e;"># Windows
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-args=</span><span style="color:#d69d85;">&quot;/ENTRY:_start /SUBSYSTEM:console&quot;
</span><span style="color:#608b4e;"># macOS
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-args=</span><span style="color:#d69d85;">&quot;-e __start -static -nostartfiles&quot;
</span></code></pre>
<p>توجه داشته باشید که این فقط یک نمونه حداقلی از باینری مستقل راست است. این باینری انتظار چیزهای مختلفی را دارد، به عنوان مثال با فراخوانی تابع <code>start_</code> یک پشته مقداردهی اولیه می‌شود. <strong>بنابراین برای هر گونه استفاده واقعی از چنین باینری، مراحل بیشتری لازم است</strong>.</p>
<h2 id="b-dy-chyst"><a class="zola-anchor" href="index.html#b-dy-chyst" aria-label="Anchor link for: b-dy-chyst">🔗</a>بعدی چیست؟</h2>
<p><a href="../minimal-rust-kernel/index.html">پست بعدی</a> مراحل مورد نیاز برای تبدیل باینری مستقل به حداقل هسته سیستم‌عامل را توضیح می‌دهد. که شامل ایجاد یک هدف سفارشی، ترکیب اجرایی ما با بوت‌لودر و یادگیری نحوه چاپ چیزی در صفحه است.</p>

    </div>

    <div class="post-footer-support right-to-left">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
        
            <a class="next" href="../minimal-rust-kernel/index.html">یک هسته مینیمال با Rust &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="right-to-left">نظرات</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Freestanding%20Rust%20Binary%20%28fa%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="A Freestanding Rust Binary (fa)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fa"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Freestanding%20Rust%20Binary%20%28fa%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="right-to-left">
            لطفا نظرات خود را در صورت امکان به انگلیسی بنویسید.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../freestanding-rust-binary/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/freestanding-rust-binary/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="zh-TW" class=""><a href="../../zh-TW/freestanding-rust-binary/index.html">
                        Chinese (traditional)
                    </a></li><li data-lang-switch-to="fr" class=""><a href="../../fr/freestanding-rust-binary/index.html">
                        French
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/freestanding-rust-binary/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="ru" class=""><a href="../../ru/freestanding-rust-binary/index.html">
                        Russian
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/freestanding-rust-binary/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
