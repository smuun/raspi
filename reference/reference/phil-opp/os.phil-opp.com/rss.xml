<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Writing an OS in Rust</title>
        <link>https://os.phil-opp.com</link>
        <description>This blog series creates a small operating system in the Rust programming language. Each post is a small tutorial and includes all needed code.</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://os.phil-opp.com/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 01 Apr 2020 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Updates in March 2020</title>
                <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2020-04-01/</link>
                <guid>https://os.phil-opp.com/status-update/2020-04-01/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I focused my time this month on finishing the long-planned post about &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;&quot;&gt;&lt;strong&gt;Async&#x2F;Await&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;. In addition to that, there were a few updates to the crates behind the scenes, including some great contributions and a new &lt;code&gt;vga&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned in the &lt;em&gt;Async&#x2F;Await&lt;&#x2F;em&gt; post, I‚Äôm currently looking for job in Karlsruhe (Germany) or remote, so please let me know if you‚Äôre interested.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;763&quot;&gt;Update linked_list_allocator to v0.8.0&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;764&quot;&gt;Update x86_64 dependency to version 0.9.6&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;767&quot;&gt;New post about Async&#x2F;Await&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;774&quot;&gt;Discuss the approach of storing offsets for self-referential structs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;782&quot;&gt;Use a static counter for assigning task IDs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In addition to the changes above, there were a lot of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pulls?q=is%3Apr+is%3Aclosed+created%3A2020-03-01..2020-04-02+-author%3Aphil-opp+&quot;&gt;typo fixes&lt;&#x2F;a&gt; by external contributors. Thanks a lot!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides support for CPU-specific instructions, registers, and data structures of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture. In March, there was only a single addition, which was required for the &lt;em&gt;Async&#x2F;Await&lt;&#x2F;em&gt; post:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;138&quot;&gt;Add an enable_interrupts_and_hlt function that executes &lt;code&gt;sti; hlt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.6)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;101&quot;&gt;Implement boot-info-address&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Darksecond&quot;&gt;@Darksecond&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.9)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;104&quot;&gt;Identity-map complete vga region (0xa0000 to 0xc0000)&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.0)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool builds the &lt;code&gt;bootloader&lt;&#x2F;code&gt; and creates a bootable disk image from a kernel. It received a RUSTFLAGS-related bugfix:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;51&quot;&gt;Set empty RUSTFLAGS to ensure that no .cargo&#x2F;config applies&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--

## `cargo-xbuild`

The `cargo-xbuild` crate provides support for cross-compiling `libcore` and `liballoc`. There were no updates to it this month.

## `uart_16550`

The `uart_16550` crate provides basic support for uart_16550 serial output. It received no updates this month.

## `multiboot2-elf64`

The `multiboot2-elf64` crate provides abstractions for reading the boot information of the multiboot 2 standard, which is implemented by bootloaders like GRUB. There were no updates to the crate in March.

--&gt;
&lt;h2 id=&quot;vga&quot;&gt;&lt;code&gt;vga&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There is a new crate under the &lt;code&gt;rust-osdev&lt;&#x2F;code&gt; organization: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;vga&quot;&gt;&lt;code&gt;vga&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; created by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt;. The purpose of the library is to provide abstractions for the VGA hardware. For example, the crate allows to switch the VGA hardware to graphics mode, which makes it possible to draw on a pixel-based framebuffer:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;status-update&#x2F;2020-04-01&#x2F;qemu-vga-crate.png&quot; alt=&quot;QEMU printing a box with ‚ÄúHello World‚Äù in it&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For more information about the crate, check out its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;vga&#x2F;0.2.2&#x2F;vga&#x2F;&quot;&gt;API documentation&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;vga&quot;&gt;GitHub repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Async&#x2F;Await</title>
                <pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/async-await/</link>
                <guid>https://os.phil-opp.com/async-await/</guid>
                <description>&lt;p&gt;In this post, we explore &lt;em&gt;cooperative multitasking&lt;&#x2F;em&gt; and the &lt;em&gt;async&#x2F;await&lt;&#x2F;em&gt; feature of Rust. We take a detailed look at how async&#x2F;await works in Rust, including the design of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait, the state machine transformation, and &lt;em&gt;pinning&lt;&#x2F;em&gt;. We then add basic support for async&#x2F;await to our kernel by creating an asynchronous keyboard task and a basic executor.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-12&quot;&gt;&lt;code&gt;post-12&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;multitasking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multitasking&quot; aria-label=&quot;Anchor link for: multitasking&quot;&gt;üîó&lt;&#x2F;a&gt;Multitasking&lt;&#x2F;h2&gt;
&lt;p&gt;One of the fundamental features of most operating systems is &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computer_multitasking&quot;&gt;&lt;em&gt;multitasking&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, which is the ability to execute multiple tasks concurrently. For example, you probably have other programs open while looking at this post, such as a text editor or a terminal window. Even if you have only a single browser window open, there are probably various background tasks for managing your desktop windows, checking for updates, or indexing files.&lt;&#x2F;p&gt;
&lt;p&gt;While it seems like all tasks run in parallel, only a single task can be executed on a CPU core at a time. To create the illusion that the tasks run in parallel, the operating system rapidly switches between active tasks so that each one can make a bit of progress. Since computers are fast, we don‚Äôt notice these switches most of the time.&lt;&#x2F;p&gt;
&lt;p&gt;While single-core CPUs can only execute a single task at a time, multi-core CPUs can run multiple tasks in a truly parallel way. For example, a CPU with 8 cores can run 8 tasks at the same time. We will explain how to setup multi-core CPUs in a future post. For this post, we will focus on single-core CPUs for simplicity. (It‚Äôs worth noting that all multi-core CPUs start with only a single active core, so we can treat them as single-core CPUs for now.)&lt;&#x2F;p&gt;
&lt;p&gt;There are two forms of multitasking: &lt;em&gt;Cooperative&lt;&#x2F;em&gt; multitasking requires tasks to regularly give up control of the CPU so that other tasks can make progress. &lt;em&gt;Preemptive&lt;&#x2F;em&gt; multitasking uses operating system functionality to switch threads at arbitrary points in time by forcibly pausing them. In the following we will explore the two forms of multitasking in more detail and discuss their respective advantages and drawbacks.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preemptive-multitasking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preemptive-multitasking&quot; aria-label=&quot;Anchor link for: preemptive-multitasking&quot;&gt;üîó&lt;&#x2F;a&gt;Preemptive Multitasking&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind preemptive multitasking is that the operating system controls when to switch tasks. For that, it utilizes the fact that it regains control of the CPU on each interrupt. This makes it possible to switch tasks whenever new input is available to the system. For example, it would be possible to switch tasks when the mouse is moved or a network packet arrives. The operating system can also determine the exact time that a task is allowed to run by configuring a hardware timer to send an interrupt after that time.&lt;&#x2F;p&gt;
&lt;p&gt;The following graphic illustrates the task switching process on a hardware interrupt:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;regain-control-on-interrupt.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the first row, the CPU is executing task &lt;code&gt;A1&lt;&#x2F;code&gt; of program &lt;code&gt;A&lt;&#x2F;code&gt;. All other tasks are paused. In the second row, a hardware interrupt arrives at the CPU. As described in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;&quot;&gt;&lt;em&gt;Hardware Interrupts&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, the CPU immediately stops the execution of task &lt;code&gt;A1&lt;&#x2F;code&gt; and jumps to the interrupt handler defined in the interrupt descriptor table (IDT). Through this interrupt handler, the operating system now has control of the CPU again, which allows it to switch to task &lt;code&gt;B1&lt;&#x2F;code&gt; instead of continuing task &lt;code&gt;A1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;saving-state&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#saving-state&quot; aria-label=&quot;Anchor link for: saving-state&quot;&gt;üîó&lt;&#x2F;a&gt;Saving State&lt;&#x2F;h4&gt;
&lt;p&gt;Since tasks are interrupted at arbitrary points in time, they might be in the middle of some calculations. In order to be able to resume them later, the operating system must backup the whole state of the task, including its &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Call_stack&quot;&gt;call stack&lt;&#x2F;a&gt; and the values of all CPU registers. This process is called a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Context_switch&quot;&gt;&lt;em&gt;context switch&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As the call stack can be very large, the operating system typically sets up a separate call stack for each task instead of backing up the call stack content on each task switch. Such a task with its own stack is called a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_(computing)&quot;&gt;&lt;em&gt;thread of execution&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; or &lt;em&gt;thread&lt;&#x2F;em&gt; for short. By using a separate stack for each task, only the register contents need to be saved on a context switch (including the program counter and stack pointer). This approach minimizes the performance overhead of a context switch, which is very important since context switches often occur up to 100 times per second.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;discussion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion&quot; aria-label=&quot;Anchor link for: discussion&quot;&gt;üîó&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h4&gt;
&lt;p&gt;The main advantage of preemptive multitasking is that the operating system can fully control the allowed execution time of a task. This way, it can guarantee that each task gets a fair share of the CPU time, without the need to trust the tasks to cooperate. This is especially important when running third-party tasks or when multiple users share a system.&lt;&#x2F;p&gt;
&lt;p&gt;The disadvantage of preemption is that each task requires its own stack. Compared to a shared stack, this results in higher memory usage per task and often limits the number of tasks in the system. Another disadvantage is that the operating system always has to save the complete CPU register state on each task switch, even if the task only used a small subset of the registers.&lt;&#x2F;p&gt;
&lt;p&gt;Preemptive multitasking and threads are fundamental components of an operating system because they make it possible to run untrusted userspace programs. We will discuss these concepts in full detail in future posts. For this post, however, we will focus on cooperative multitasking, which also provides useful capabilities for our kernel.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cooperative-multitasking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cooperative-multitasking&quot; aria-label=&quot;Anchor link for: cooperative-multitasking&quot;&gt;üîó&lt;&#x2F;a&gt;Cooperative Multitasking&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of forcibly pausing running tasks at arbitrary points in time, cooperative multitasking lets each task run until it voluntarily gives up control of the CPU. This allows tasks to pause themselves at convenient points in time, for example, when they need to wait for an I&#x2F;O operation anyway.&lt;&#x2F;p&gt;
&lt;p&gt;Cooperative multitasking is often used at the language level, like in the form of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coroutine&quot;&gt;coroutines&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;01_getting_started&#x2F;04_async_await_primer.html&quot;&gt;async&#x2F;await&lt;&#x2F;a&gt;. The idea is that either the programmer or the compiler inserts &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Yield_(multithreading)&quot;&gt;&lt;em&gt;yield&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; operations into the program, which give up control of the CPU and allow other tasks to run. For example, a yield could be inserted after each iteration of a complex loop.&lt;&#x2F;p&gt;
&lt;p&gt;It is common to combine cooperative multitasking with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Asynchronous_I&#x2F;O&quot;&gt;asynchronous operations&lt;&#x2F;a&gt;. Instead of waiting until an operation is finished and preventing other tasks from running during this time, asynchronous operations return a ‚Äúnot ready‚Äù status if the operation is not finished yet. In this case, the waiting task can execute a yield operation to let other tasks run.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;saving-state-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#saving-state-1&quot; aria-label=&quot;Anchor link for: saving-state-1&quot;&gt;üîó&lt;&#x2F;a&gt;Saving State&lt;&#x2F;h4&gt;
&lt;p&gt;Since tasks define their pause points themselves, they don‚Äôt need the operating system to save their state. Instead, they can save exactly the state they need for continuation before they pause themselves, which often results in better performance. For example, a task that just finished a complex computation might only need to backup the final result of the computation since it does not need the intermediate results anymore.&lt;&#x2F;p&gt;
&lt;p&gt;Language-supported implementations of cooperative tasks are often even able to backup the required parts of the call stack before pausing. As an example, Rust‚Äôs async&#x2F;await implementation stores all local variables that are still needed in an automatically generated struct (see below). By backing up the relevant parts of the call stack before pausing, all tasks can share a single call stack, which results in much lower memory consumption per task. This makes it possible to create an almost arbitrary number of cooperative tasks without running out of memory.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;discussion-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion-1&quot; aria-label=&quot;Anchor link for: discussion-1&quot;&gt;üîó&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h4&gt;
&lt;p&gt;The drawback of cooperative multitasking is that an uncooperative task can potentially run for an unlimited amount of time. Thus, a malicious or buggy task can prevent other tasks from running and slow down or even block the whole system. For this reason, cooperative multitasking should only be used when all tasks are known to cooperate. As a counterexample, it‚Äôs not a good idea to make the operating system rely on the cooperation of arbitrary user-level programs.&lt;&#x2F;p&gt;
&lt;p&gt;However, the strong performance and memory benefits of cooperative multitasking make it a good approach for usage &lt;em&gt;within&lt;&#x2F;em&gt; a program, especially in combination with asynchronous operations. Since an operating system kernel is a performance-critical program that interacts with asynchronous hardware, cooperative multitasking seems like a good approach for implementing concurrency.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;async-await-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#async-await-in-rust&quot; aria-label=&quot;Anchor link for: async-await-in-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Async&#x2F;Await in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;The Rust language provides first-class support for cooperative multitasking in the form of async&#x2F;await. Before we can explore what async&#x2F;await is and how it works, we need to understand how &lt;em&gt;futures&lt;&#x2F;em&gt; and asynchronous programming work in Rust.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;futures&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#futures&quot; aria-label=&quot;Anchor link for: futures&quot;&gt;üîó&lt;&#x2F;a&gt;Futures&lt;&#x2F;h3&gt;
&lt;p&gt;A &lt;em&gt;future&lt;&#x2F;em&gt; represents a value that might not be available yet. This could be, for example, an integer that is computed by another task or a file that is downloaded from the network. Instead of waiting until the value is available, futures make it possible to continue execution until the value is needed.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example&quot; aria-label=&quot;Anchor link for: example&quot;&gt;üîó&lt;&#x2F;a&gt;Example&lt;&#x2F;h4&gt;
&lt;p&gt;The concept of futures is best illustrated with a small example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;async-example.svg&quot; alt=&quot;Sequence diagram: main calls read_file and is blocked until it returns; then it calls foo() and is also blocked until it returns. The same process is repeated, but this time async_read_file is called, which directly returns a future; then foo() is called again, which now runs concurrently with the file load. The file is available before foo() returns.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This sequence diagram shows a &lt;code&gt;main&lt;&#x2F;code&gt; function that reads a file from the file system and then calls a function &lt;code&gt;foo&lt;&#x2F;code&gt;. This process is repeated two times: once with a synchronous &lt;code&gt;read_file&lt;&#x2F;code&gt; call and once with an asynchronous &lt;code&gt;async_read_file&lt;&#x2F;code&gt; call.&lt;&#x2F;p&gt;
&lt;p&gt;With the synchronous call, the &lt;code&gt;main&lt;&#x2F;code&gt; function needs to wait until the file is loaded from the file system. Only then can it call the &lt;code&gt;foo&lt;&#x2F;code&gt; function, which requires it to again wait for the result.&lt;&#x2F;p&gt;
&lt;p&gt;With the asynchronous &lt;code&gt;async_read_file&lt;&#x2F;code&gt; call, the file system directly returns a future and loads the file asynchronously in the background. This allows the &lt;code&gt;main&lt;&#x2F;code&gt; function to call &lt;code&gt;foo&lt;&#x2F;code&gt; much earlier, which then runs in parallel with the file load. In this example, the file load even finishes before &lt;code&gt;foo&lt;&#x2F;code&gt; returns, so &lt;code&gt;main&lt;&#x2F;code&gt; can directly work with the file without further waiting after &lt;code&gt;foo&lt;&#x2F;code&gt; returns.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;futures-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#futures-in-rust&quot; aria-label=&quot;Anchor link for: futures-in-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Futures in Rust&lt;&#x2F;h4&gt;
&lt;p&gt;In Rust, futures are represented by the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, which looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Future {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types&quot;&gt;associated type&lt;&#x2F;a&gt; &lt;code&gt;Output&lt;&#x2F;code&gt; specifies the type of the asynchronous value. For example, the &lt;code&gt;async_read_file&lt;&#x2F;code&gt; function in the diagram above would return a &lt;code&gt;Future&lt;&#x2F;code&gt; instance with &lt;code&gt;Output&lt;&#x2F;code&gt; set to &lt;code&gt;File&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method allows to check if the value is already available. It returns a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;Poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; enum, which looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Poll&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Ready(T),
&lt;&#x2F;span&gt;&lt;span&gt;    Pending,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the value is already available (e.g. the file was fully read from disk), it is returned wrapped in the &lt;code&gt;Ready&lt;&#x2F;code&gt; variant. Otherwise, the &lt;code&gt;Pending&lt;&#x2F;code&gt; variant is returned, which signals to the caller that the value is not yet available.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;poll&lt;&#x2F;code&gt; method takes two arguments: &lt;code&gt;self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;cx: &amp;amp;mut Context&lt;&#x2F;code&gt;. The former behaves similarly to a normal &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; reference, except that the &lt;code&gt;Self&lt;&#x2F;code&gt; value is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;index.html&quot;&gt;&lt;em&gt;pinned&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; to its memory location. Understanding &lt;code&gt;Pin&lt;&#x2F;code&gt; and why it is needed is difficult without understanding how async&#x2F;await works first. We will therefore explain it later in this post.&lt;&#x2F;p&gt;
&lt;p&gt;The purpose of the &lt;code&gt;cx: &amp;amp;mut Context&lt;&#x2F;code&gt; parameter is to pass a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance to the asynchronous task, e.g., the file system load. This &lt;code&gt;Waker&lt;&#x2F;code&gt; allows the asynchronous task to signal that it (or a part of it) is finished, e.g., that the file was loaded from disk. Since the main task knows that it will be notified when the &lt;code&gt;Future&lt;&#x2F;code&gt; is ready, it does not need to call &lt;code&gt;poll&lt;&#x2F;code&gt; over and over again. We will explain this process in more detail later in this post when we implement our own waker type.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;working-with-futures&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#working-with-futures&quot; aria-label=&quot;Anchor link for: working-with-futures&quot;&gt;üîó&lt;&#x2F;a&gt;Working with Futures&lt;&#x2F;h3&gt;
&lt;p&gt;We now know how futures are defined and understand the basic idea behind the &lt;code&gt;poll&lt;&#x2F;code&gt; method. However, we still don‚Äôt know how to effectively work with futures. The problem is that futures represent the results of asynchronous tasks, which might not be available yet. In practice, however, we often need these values directly for further calculations. So the question is: How can we efficiently retrieve the value of a future when we need it?&lt;&#x2F;p&gt;
&lt;h4 id=&quot;waiting-on-futures&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#waiting-on-futures&quot; aria-label=&quot;Anchor link for: waiting-on-futures&quot;&gt;üîó&lt;&#x2F;a&gt;Waiting on Futures&lt;&#x2F;h4&gt;
&lt;p&gt;One possible answer is to wait until a future becomes ready. This could look something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; future = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; file_content = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; future.poll(‚Ä¶) {
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Ready(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; break&lt;&#x2F;span&gt;&lt;span&gt; value,
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; do nothing
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we &lt;em&gt;actively&lt;&#x2F;em&gt; wait for the future by calling &lt;code&gt;poll&lt;&#x2F;code&gt; over and over again in a loop. The arguments to &lt;code&gt;poll&lt;&#x2F;code&gt; don‚Äôt matter here, so we omitted them. While this solution works, it is very inefficient because we keep the CPU busy until the value becomes available.&lt;&#x2F;p&gt;
&lt;p&gt;A more efficient approach could be to &lt;em&gt;block&lt;&#x2F;em&gt; the current thread until the future becomes available. This is, of course, only possible if you have threads, so this solution does not work for our kernel, at least not yet. Even on systems where blocking is supported, it is often not desired because it turns an asynchronous task into a synchronous task again, thereby inhibiting the potential performance benefits of parallel tasks.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;future-combinators&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-combinators&quot; aria-label=&quot;Anchor link for: future-combinators&quot;&gt;üîó&lt;&#x2F;a&gt;Future Combinators&lt;&#x2F;h4&gt;
&lt;p&gt;An alternative to waiting is to use future combinators. Future combinators are methods like &lt;code&gt;map&lt;&#x2F;code&gt; that allow chaining and combining futures together, similar to the methods of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait. Instead of waiting on the future, these combinators return a future themselves, which applies the mapping operation on &lt;code&gt;poll&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, a simple &lt;code&gt;string_len&lt;&#x2F;code&gt; combinator for converting a &lt;code&gt;Future&amp;lt;Output = String&amp;gt;&lt;&#x2F;code&gt; to a &lt;code&gt;Future&amp;lt;Output = usize&amp;gt;&lt;&#x2F;code&gt; could look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;StringLen&amp;lt;F&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    inner_future: F,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F&amp;gt; Future &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;StringLen&amp;lt;F&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; F: Future&amp;lt;Output = String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Context&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; Poll&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self.inner_future.poll(cx) {
&lt;&#x2F;span&gt;&lt;span&gt;            Poll::Ready(s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Poll::Ready(s.len()),
&lt;&#x2F;span&gt;&lt;span&gt;            Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Poll::Pending,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;string_len(string: impl Future&amp;lt;Output = String&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; impl Future&amp;lt;Output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    StringLen {
&lt;&#x2F;span&gt;&lt;span&gt;        inner_future: string,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Usage
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;file_len() -&amp;gt; impl Future&amp;lt;Output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; file_content_future = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    string_len(file_content_future)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code does not quite work because it does not handle &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;pin&#x2F;index.html&quot;&gt;&lt;em&gt;pinning&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, but it suffices as an example. The basic idea is that the &lt;code&gt;string_len&lt;&#x2F;code&gt; function wraps a given &lt;code&gt;Future&lt;&#x2F;code&gt; instance into a new &lt;code&gt;StringLen&lt;&#x2F;code&gt; struct, which also implements &lt;code&gt;Future&lt;&#x2F;code&gt;. When the wrapped future is polled, it polls the inner future. If the value is not ready yet, &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; is returned from the wrapped future too. If the value is ready, the string is extracted from the &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt; variant and its length is calculated. Afterwards, it is wrapped in &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt; again and returned.&lt;&#x2F;p&gt;
&lt;p&gt;With this &lt;code&gt;string_len&lt;&#x2F;code&gt; function, we can calculate the length of an asynchronous string without waiting for it. Since the function returns a &lt;code&gt;Future&lt;&#x2F;code&gt; again, the caller can‚Äôt work directly on the returned value, but needs to use combinator functions again. This way, the whole call graph becomes asynchronous and we can efficiently wait for multiple futures at once at some point, e.g., in the main function.&lt;&#x2F;p&gt;
&lt;p&gt;Because manually writing combinator functions is difficult, they are often provided by libraries. While the Rust standard library itself provides no combinator methods yet, the semi-official (and &lt;code&gt;no_std&lt;&#x2F;code&gt; compatible) &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;&quot;&gt;&lt;code&gt;futures&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate does. Its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html&quot;&gt;&lt;code&gt;FutureExt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait provides high-level combinator methods such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html#method.then&quot;&gt;&lt;code&gt;then&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which can be used to manipulate the result with arbitrary closures.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;advantages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#advantages&quot; aria-label=&quot;Anchor link for: advantages&quot;&gt;üîó&lt;&#x2F;a&gt;Advantages&lt;&#x2F;h5&gt;
&lt;p&gt;The big advantage of future combinators is that they keep the operations asynchronous. In combination with asynchronous I&#x2F;O interfaces, this approach can lead to very high performance. The fact that future combinators are implemented as normal structs with trait implementations allows the compiler to excessively optimize them. For more details, see the &lt;a href=&quot;https:&#x2F;&#x2F;aturon.github.io&#x2F;blog&#x2F;2016&#x2F;08&#x2F;11&#x2F;futures&#x2F;&quot;&gt;&lt;em&gt;Zero-cost futures in Rust&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, which announced the addition of futures to the Rust ecosystem.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;drawbacks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#drawbacks&quot; aria-label=&quot;Anchor link for: drawbacks&quot;&gt;üîó&lt;&#x2F;a&gt;Drawbacks&lt;&#x2F;h5&gt;
&lt;p&gt;While future combinators make it possible to write very efficient code, they can be difficult to use in some situations because of the type system and the closure-based interface. For example, consider code like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example(min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; impl Future&amp;lt;Output = String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).then(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;move |&lt;&#x2F;span&gt;&lt;span&gt;content&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; content.len() &amp;lt; min_len {
&lt;&#x2F;span&gt;&lt;span&gt;            Either::Left(async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bar.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).map(|s| content + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;s))
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Either::Right(future::ready(content))
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=91fc09024eecb2448a85a7ef6a97b8d8&quot;&gt;Try it on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;Here we read the file &lt;code&gt;foo.txt&lt;&#x2F;code&gt; and then use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html#method.then&quot;&gt;&lt;code&gt;then&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combinator to chain a second future based on the file content. If the content length is smaller than the given &lt;code&gt;min_len&lt;&#x2F;code&gt;, we read a different &lt;code&gt;bar.txt&lt;&#x2F;code&gt; file and append it to &lt;code&gt;content&lt;&#x2F;code&gt; using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;trait.FutureExt.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combinator. Otherwise, we return only the content of &lt;code&gt;foo.txt&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We need to use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;keyword.move.html&quot;&gt;&lt;code&gt;move&lt;&#x2F;code&gt; keyword&lt;&#x2F;a&gt; for the closure passed to &lt;code&gt;then&lt;&#x2F;code&gt; because otherwise there would be a lifetime error for &lt;code&gt;min_len&lt;&#x2F;code&gt;. The reason for the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;enum.Either.html&quot;&gt;&lt;code&gt;Either&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper is that &lt;code&gt;if&lt;&#x2F;code&gt; and &lt;code&gt;else&lt;&#x2F;code&gt; blocks must always have the same type. Since we return different future types in the blocks, we must use the wrapper type to unify them into a single type. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;future&#x2F;fn.ready.html&quot;&gt;&lt;code&gt;ready&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function wraps a value into a future, which is immediately ready. The function is required here because the &lt;code&gt;Either&lt;&#x2F;code&gt; wrapper expects that the wrapped value implements &lt;code&gt;Future&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As you can imagine, this can quickly lead to very complex code for larger projects. It gets especially complicated if borrowing and different lifetimes are involved. For this reason, a lot of work was invested in adding support for async&#x2F;await to Rust, with the goal of making asynchronous code radically simpler to write.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-async-await-pattern&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-async-await-pattern&quot; aria-label=&quot;Anchor link for: the-async-await-pattern&quot;&gt;üîó&lt;&#x2F;a&gt;The Async&#x2F;Await Pattern&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind async&#x2F;await is to let the programmer write code that &lt;em&gt;looks&lt;&#x2F;em&gt; like normal synchronous code, but is turned into asynchronous code by the compiler. It works based on the two keywords &lt;code&gt;async&lt;&#x2F;code&gt; and &lt;code&gt;await&lt;&#x2F;code&gt;. The &lt;code&gt;async&lt;&#x2F;code&gt; keyword can be used in a function signature to turn a synchronous function into an asynchronous function that returns a future:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the above is roughly translated by the compiler to:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo() -&amp;gt; impl Future&amp;lt;Output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    future::ready(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This keyword alone wouldn‚Äôt be that useful. However, inside &lt;code&gt;async&lt;&#x2F;code&gt; functions, the &lt;code&gt;await&lt;&#x2F;code&gt; keyword can be used to retrieve the asynchronous value of a future:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example(min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; content = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; content.len() &amp;lt; min_len {
&lt;&#x2F;span&gt;&lt;span&gt;        content + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bar.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        content
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=d93c28509a1c67661f31ff820281d434&quot;&gt;Try it on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;This function is a direct translation of the &lt;code&gt;example&lt;&#x2F;code&gt; function from &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;#drawbacks&quot;&gt;above&lt;&#x2F;a&gt; that used combinator functions. Using the &lt;code&gt;.await&lt;&#x2F;code&gt; operator, we can retrieve the value of a future without needing any closures or &lt;code&gt;Either&lt;&#x2F;code&gt; types. As a result, we can write our code like we write normal synchronous code, with the difference that &lt;em&gt;this is still asynchronous code&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;state-machine-transformation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#state-machine-transformation&quot; aria-label=&quot;Anchor link for: state-machine-transformation&quot;&gt;üîó&lt;&#x2F;a&gt;State Machine Transformation&lt;&#x2F;h4&gt;
&lt;p&gt;Behind the scenes, the compiler converts the body of the &lt;code&gt;async&lt;&#x2F;code&gt; function into a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Finite-state_machine&quot;&gt;&lt;em&gt;state machine&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, with each &lt;code&gt;.await&lt;&#x2F;code&gt; call representing a different state. For the above &lt;code&gt;example&lt;&#x2F;code&gt; function, the compiler creates a state machine with the following four states:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;async-state-machine-states.svg&quot; alt=&quot;Four states: start, waiting on foo.txt, waiting on bar.txt, end&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Each state represents a different pause point in the function. The &lt;em&gt;‚ÄúStart‚Äù&lt;&#x2F;em&gt; and &lt;em&gt;‚ÄúEnd‚Äù&lt;&#x2F;em&gt; states represent the function at the beginning and end of its execution. The &lt;em&gt;‚ÄúWaiting on foo.txt‚Äù&lt;&#x2F;em&gt; state represents that the function is currently waiting for the first &lt;code&gt;async_read_file&lt;&#x2F;code&gt; result. Similarly, the &lt;em&gt;‚ÄúWaiting on bar.txt‚Äù&lt;&#x2F;em&gt; state represents the pause point where the function is waiting on the second &lt;code&gt;async_read_file&lt;&#x2F;code&gt; result.&lt;&#x2F;p&gt;
&lt;p&gt;The state machine implements the &lt;code&gt;Future&lt;&#x2F;code&gt; trait by making each &lt;code&gt;poll&lt;&#x2F;code&gt; call a possible state transition:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;async-state-machine-basic.svg&quot; alt=&quot;Four states and their transitions: start, waiting on foo.txt, waiting on bar.txt, end&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The diagram uses arrows to represent state switches and diamond shapes to represent alternative ways. For example, if the &lt;code&gt;foo.txt&lt;&#x2F;code&gt; file is not ready, the path marked with &lt;em&gt;‚Äúno‚Äù&lt;&#x2F;em&gt; is taken and the &lt;em&gt;‚ÄúWaiting on foo.txt‚Äù&lt;&#x2F;em&gt; state is reached. Otherwise, the &lt;em&gt;‚Äúyes‚Äù&lt;&#x2F;em&gt; path is taken. The small red diamond without a caption represents the &lt;code&gt;if content.len() &amp;lt; 100&lt;&#x2F;code&gt; branch of the &lt;code&gt;example&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;We see that the first &lt;code&gt;poll&lt;&#x2F;code&gt; call starts the function and lets it run until it reaches a future that is not ready yet. If all futures on the path are ready, the function can run till the &lt;em&gt;‚ÄúEnd‚Äù&lt;&#x2F;em&gt; state, where it returns its result wrapped in &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. Otherwise, the state machine enters a waiting state and returns &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. On the next &lt;code&gt;poll&lt;&#x2F;code&gt; call, the state machine then starts from the last waiting state and retries the last operation.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;saving-state-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#saving-state-2&quot; aria-label=&quot;Anchor link for: saving-state-2&quot;&gt;üîó&lt;&#x2F;a&gt;Saving State&lt;&#x2F;h4&gt;
&lt;p&gt;In order to be able to continue from the last waiting state, the state machine must keep track of the current state internally. In addition, it must save all the variables that it needs to continue execution on the next &lt;code&gt;poll&lt;&#x2F;code&gt; call. This is where the compiler can really shine: Since it knows which variables are used when, it can automatically generate structs with exactly the variables that are needed.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, the compiler generates structs like the following for the above &lt;code&gt;example&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; The `example` function again so that you don&amp;#39;t have to scroll up
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example(min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; content = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; content.len() &amp;lt; min_len {
&lt;&#x2F;span&gt;&lt;span&gt;        content + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bar.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        content
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; The compiler-generated state structs:
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;StartState {
&lt;&#x2F;span&gt;&lt;span&gt;    min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;WaitingOnFooTxtState {
&lt;&#x2F;span&gt;&lt;span&gt;    min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    foo_txt_future: impl Future&amp;lt;Output = String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;WaitingOnBarTxtState {
&lt;&#x2F;span&gt;&lt;span&gt;    content: String,
&lt;&#x2F;span&gt;&lt;span&gt;    bar_txt_future: impl Future&amp;lt;Output = String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;EndState {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the ‚Äústart‚Äù and &lt;em&gt;‚ÄúWaiting on foo.txt‚Äù&lt;&#x2F;em&gt; states, the &lt;code&gt;min_len&lt;&#x2F;code&gt; parameter needs to be stored for the later comparison with &lt;code&gt;content.len()&lt;&#x2F;code&gt;. The &lt;em&gt;‚ÄúWaiting on foo.txt‚Äù&lt;&#x2F;em&gt; state additionally stores a &lt;code&gt;foo_txt_future&lt;&#x2F;code&gt;, which represents the future returned by the &lt;code&gt;async_read_file&lt;&#x2F;code&gt; call. This future needs to be polled again when the state machine continues, so it needs to be saved.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;‚ÄúWaiting on bar.txt‚Äù&lt;&#x2F;em&gt; state contains the &lt;code&gt;content&lt;&#x2F;code&gt; variable for the later string concatenation when &lt;code&gt;bar.txt&lt;&#x2F;code&gt; is ready. It also stores a &lt;code&gt;bar_txt_future&lt;&#x2F;code&gt; that represents the in-progress load of &lt;code&gt;bar.txt&lt;&#x2F;code&gt;. The struct does not contain the &lt;code&gt;min_len&lt;&#x2F;code&gt; variable because it is no longer needed after the &lt;code&gt;content.len()&lt;&#x2F;code&gt; comparison. In the &lt;em&gt;‚Äúend‚Äù&lt;&#x2F;em&gt; state, no variables are stored because the function has already run to completion.&lt;&#x2F;p&gt;
&lt;p&gt;Keep in mind that this is only an example of the code that the compiler could generate. The struct names and the field layout are implementation details and might be different.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-full-state-machine-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-full-state-machine-type&quot; aria-label=&quot;Anchor link for: the-full-state-machine-type&quot;&gt;üîó&lt;&#x2F;a&gt;The Full State Machine Type&lt;&#x2F;h4&gt;
&lt;p&gt;While the exact compiler-generated code is an implementation detail, it helps in understanding to imagine how the generated state machine &lt;em&gt;could&lt;&#x2F;em&gt; look for the &lt;code&gt;example&lt;&#x2F;code&gt; function. We already defined the structs representing the different states and containing the required variables. To create a state machine on top of them, we can combine them into an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch06-01-defining-an-enum.html&quot;&gt;&lt;code&gt;enum&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;ExampleStateMachine {
&lt;&#x2F;span&gt;&lt;span&gt;    Start(StartState),
&lt;&#x2F;span&gt;&lt;span&gt;    WaitingOnFooTxt(WaitingOnFooTxtState),
&lt;&#x2F;span&gt;&lt;span&gt;    WaitingOnBarTxt(WaitingOnBarTxtState),
&lt;&#x2F;span&gt;&lt;span&gt;    End(EndState),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define a separate enum variant for each state and add the corresponding state struct to each variant as a field. To implement the state transitions, the compiler generates an implementation of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait based on the &lt;code&gt;example&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Future &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ExampleStateMachine {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= String; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; return type of `example`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO: handle pinning
&lt;&#x2F;span&gt;&lt;span&gt;                ExampleStateMachine::Start(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{‚Ä¶}
&lt;&#x2F;span&gt;&lt;span&gt;                ExampleStateMachine::WaitingOnFooTxt(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{‚Ä¶}
&lt;&#x2F;span&gt;&lt;span&gt;                ExampleStateMachine::WaitingOnBarTxt(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{‚Ä¶}
&lt;&#x2F;span&gt;&lt;span&gt;                ExampleStateMachine::End(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{‚Ä¶}
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Output&lt;&#x2F;code&gt; type of the future is &lt;code&gt;String&lt;&#x2F;code&gt; because it‚Äôs the return type of the &lt;code&gt;example&lt;&#x2F;code&gt; function. To implement the &lt;code&gt;poll&lt;&#x2F;code&gt; function, we use a &lt;code&gt;match&lt;&#x2F;code&gt; statement on the current state inside a &lt;code&gt;loop&lt;&#x2F;code&gt;. The idea is that we switch to the next state as long as possible and use an explicit &lt;code&gt;return Poll::Pending&lt;&#x2F;code&gt; when we can‚Äôt continue.&lt;&#x2F;p&gt;
&lt;p&gt;For simplicity, we only show simplified code and don‚Äôt handle &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;pin&#x2F;index.html&quot;&gt;pinning&lt;&#x2F;a&gt;, ownership, lifetimes, etc. So this and the following code should be treated as pseudo-code and not used directly. Of course, the real compiler-generated code handles everything correctly, albeit possibly in a different way.&lt;&#x2F;p&gt;
&lt;p&gt;To keep the code excerpts small, we present the code for each &lt;code&gt;match&lt;&#x2F;code&gt; arm separately. Let‚Äôs begin with the &lt;code&gt;Start&lt;&#x2F;code&gt; state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ExampleStateMachine::Start(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; from body of `example`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; foo_txt_future = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `.await` operation
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; state = WaitingOnFooTxtState {
&lt;&#x2F;span&gt;&lt;span&gt;        min_len: state.min_len,
&lt;&#x2F;span&gt;&lt;span&gt;        foo_txt_future,
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    *self = ExampleStateMachine::WaitingOnFooTxt(state);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The state machine is in the &lt;code&gt;Start&lt;&#x2F;code&gt; state when it is right at the beginning of the function. In this case, we execute all the code from the body of the &lt;code&gt;example&lt;&#x2F;code&gt; function until the first &lt;code&gt;.await&lt;&#x2F;code&gt;. To handle the &lt;code&gt;.await&lt;&#x2F;code&gt; operation, we change the state of the &lt;code&gt;self&lt;&#x2F;code&gt; state machine to &lt;code&gt;WaitingOnFooTxt&lt;&#x2F;code&gt;, which includes the construction of the &lt;code&gt;WaitingOnFooTxtState&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;p&gt;Since the &lt;code&gt;match self {‚Ä¶}&lt;&#x2F;code&gt; statement is executed in a loop, the execution jumps to the &lt;code&gt;WaitingOnFooTxt&lt;&#x2F;code&gt; arm next:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ExampleStateMachine::WaitingOnFooTxt(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; state.foo_txt_future.poll(cx) {
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; return &lt;&#x2F;span&gt;&lt;span&gt;Poll::Pending,
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Ready(content) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; from body of `example`
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; content.len() &amp;lt; state.min_len {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bar_txt_future = async_read_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bar.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `.await` operation
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; state = WaitingOnBarTxtState {
&lt;&#x2F;span&gt;&lt;span&gt;                    content,
&lt;&#x2F;span&gt;&lt;span&gt;                    bar_txt_future,
&lt;&#x2F;span&gt;&lt;span&gt;                };
&lt;&#x2F;span&gt;&lt;span&gt;                *self = ExampleStateMachine::WaitingOnBarTxt(state);
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                *self = ExampleStateMachine::End(EndState);
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Poll::Ready(content);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this &lt;code&gt;match&lt;&#x2F;code&gt; arm, we first call the &lt;code&gt;poll&lt;&#x2F;code&gt; function of the &lt;code&gt;foo_txt_future&lt;&#x2F;code&gt;. If it is not ready, we exit the loop and return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. Since &lt;code&gt;self&lt;&#x2F;code&gt; stays in the &lt;code&gt;WaitingOnFooTxt&lt;&#x2F;code&gt; state in this case, the next &lt;code&gt;poll&lt;&#x2F;code&gt; call on the state machine will enter the same &lt;code&gt;match&lt;&#x2F;code&gt; arm and retry polling the &lt;code&gt;foo_txt_future&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When the &lt;code&gt;foo_txt_future&lt;&#x2F;code&gt; is ready, we assign the result to the &lt;code&gt;content&lt;&#x2F;code&gt; variable and continue to execute the code of the &lt;code&gt;example&lt;&#x2F;code&gt; function: If &lt;code&gt;content.len()&lt;&#x2F;code&gt; is smaller than the &lt;code&gt;min_len&lt;&#x2F;code&gt; saved in the state struct, the &lt;code&gt;bar.txt&lt;&#x2F;code&gt; file is read asynchronously. We again translate the &lt;code&gt;.await&lt;&#x2F;code&gt; operation into a state change, this time into the &lt;code&gt;WaitingOnBarTxt&lt;&#x2F;code&gt; state. Since we‚Äôre executing the &lt;code&gt;match&lt;&#x2F;code&gt; inside a loop, the execution directly jumps to the &lt;code&gt;match&lt;&#x2F;code&gt; arm for the new state afterward, where the &lt;code&gt;bar_txt_future&lt;&#x2F;code&gt; is polled.&lt;&#x2F;p&gt;
&lt;p&gt;In case we enter the &lt;code&gt;else&lt;&#x2F;code&gt; branch, no further &lt;code&gt;.await&lt;&#x2F;code&gt; operation occurs. We reach the end of the function and return &lt;code&gt;content&lt;&#x2F;code&gt; wrapped in &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. We also change the current state to the &lt;code&gt;End&lt;&#x2F;code&gt; state.&lt;&#x2F;p&gt;
&lt;p&gt;The code for the &lt;code&gt;WaitingOnBarTxt&lt;&#x2F;code&gt; state looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ExampleStateMachine::WaitingOnBarTxt(state) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; state.bar_txt_future.poll(cx) {
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; return &lt;&#x2F;span&gt;&lt;span&gt;Poll::Pending,
&lt;&#x2F;span&gt;&lt;span&gt;        Poll::Ready(bar_txt) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            *self = ExampleStateMachine::End(EndState);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; from body of `example`
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Poll::Ready(state.content + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;bar_txt);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Similar to the &lt;code&gt;WaitingOnFooTxt&lt;&#x2F;code&gt; state, we start by polling the &lt;code&gt;bar_txt_future&lt;&#x2F;code&gt;. If it is still pending, we exit the loop and return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. Otherwise, we can perform the last operation of the &lt;code&gt;example&lt;&#x2F;code&gt; function: concatenating the &lt;code&gt;content&lt;&#x2F;code&gt; variable with the result from the future. We update the state machine to the &lt;code&gt;End&lt;&#x2F;code&gt; state and then return the result wrapped in &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, the code for the &lt;code&gt;End&lt;&#x2F;code&gt; state looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;ExampleStateMachine::End(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;poll called after Poll::Ready was returned&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Futures should not be polled again after they returned &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;, so we panic if &lt;code&gt;poll&lt;&#x2F;code&gt; is called while we are already in the &lt;code&gt;End&lt;&#x2F;code&gt; state.&lt;&#x2F;p&gt;
&lt;p&gt;We now know what the compiler-generated state machine and its implementation of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait &lt;em&gt;could&lt;&#x2F;em&gt; look like. In practice, the compiler generates code in a different way. (In case you‚Äôre interested, the implementation is currently based on &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;unstable-book&#x2F;language-features&#x2F;generators.html&quot;&gt;&lt;em&gt;generators&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, but this is only an implementation detail.)&lt;&#x2F;p&gt;
&lt;p&gt;The last piece of the puzzle is the generated code for the &lt;code&gt;example&lt;&#x2F;code&gt; function itself. Remember, the function header was defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example(min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the complete function body is now implemented by the state machine, the only thing that the function needs to do is to initialize the state machine and return it. The generated code for this could look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example(min_len: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; ExampleStateMachine {
&lt;&#x2F;span&gt;&lt;span&gt;    ExampleStateMachine::Start(StartState {
&lt;&#x2F;span&gt;&lt;span&gt;        min_len,
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function no longer has an &lt;code&gt;async&lt;&#x2F;code&gt; modifier since it now explicitly returns an &lt;code&gt;ExampleStateMachine&lt;&#x2F;code&gt; type, which implements the &lt;code&gt;Future&lt;&#x2F;code&gt; trait. As expected, the state machine is constructed in the &lt;code&gt;Start&lt;&#x2F;code&gt; state and the corresponding state struct is initialized with the &lt;code&gt;min_len&lt;&#x2F;code&gt; parameter.&lt;&#x2F;p&gt;
&lt;p&gt;Note that this function does not start the execution of the state machine. This is a fundamental design decision of futures in Rust: they do nothing until they are polled for the first time.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pinning&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pinning&quot; aria-label=&quot;Anchor link for: pinning&quot;&gt;üîó&lt;&#x2F;a&gt;Pinning&lt;&#x2F;h3&gt;
&lt;p&gt;We already stumbled across &lt;em&gt;pinning&lt;&#x2F;em&gt; multiple times in this post. Now is finally the time to explore what pinning is and why it is needed.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;self-referential-structs&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#self-referential-structs&quot; aria-label=&quot;Anchor link for: self-referential-structs&quot;&gt;üîó&lt;&#x2F;a&gt;Self-Referential Structs&lt;&#x2F;h4&gt;
&lt;p&gt;As explained above, the state machine transformation stores the local variables of each pause point in a struct. For small examples like our &lt;code&gt;example&lt;&#x2F;code&gt; function, this was straightforward and did not lead to any problems. However, things become more difficult when variables reference each other. For example, consider this function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;pin_example() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; array = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; element = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;array[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    async_write_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, element.to_string()).await;
&lt;&#x2F;span&gt;&lt;span&gt;    *element
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function creates a small &lt;code&gt;array&lt;&#x2F;code&gt; with the contents &lt;code&gt;1&lt;&#x2F;code&gt;, &lt;code&gt;2&lt;&#x2F;code&gt;, and &lt;code&gt;3&lt;&#x2F;code&gt;. It then creates a reference to the last array element and stores it in an &lt;code&gt;element&lt;&#x2F;code&gt; variable. Next, it asynchronously writes the number converted to a string to a &lt;code&gt;foo.txt&lt;&#x2F;code&gt; file. Finally, it returns the number referenced by &lt;code&gt;element&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since the function uses a single &lt;code&gt;await&lt;&#x2F;code&gt; operation, the resulting state machine has three states: start, end, and ‚Äúwaiting on write‚Äù. The function takes no arguments, so the struct for the start state is empty. Like before, the struct for the end state is empty because the function is finished at this point. The struct for the ‚Äúwaiting on write‚Äù state is more interesting:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;WaitingOnWriteState {
&lt;&#x2F;span&gt;&lt;span&gt;    array: [1, 2, 3],
&lt;&#x2F;span&gt;&lt;span&gt;    element: 0x1001c, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; address of the last array element
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to store both the &lt;code&gt;array&lt;&#x2F;code&gt; and &lt;code&gt;element&lt;&#x2F;code&gt; variables because &lt;code&gt;element&lt;&#x2F;code&gt; is required for the return value and &lt;code&gt;array&lt;&#x2F;code&gt; is referenced by &lt;code&gt;element&lt;&#x2F;code&gt;. Since &lt;code&gt;element&lt;&#x2F;code&gt; is a reference, it stores a &lt;em&gt;pointer&lt;&#x2F;em&gt; (i.e., a memory address) to the referenced element. We used &lt;code&gt;0x1001c&lt;&#x2F;code&gt; as an example memory address here. In reality, it needs to be the address of the last element of the &lt;code&gt;array&lt;&#x2F;code&gt; field, so it depends on where the struct lives in memory. Structs with such internal pointers are called &lt;em&gt;self-referential&lt;&#x2F;em&gt; structs because they reference themselves from one of their fields.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-problem-with-self-referential-structs&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-problem-with-self-referential-structs&quot; aria-label=&quot;Anchor link for: the-problem-with-self-referential-structs&quot;&gt;üîó&lt;&#x2F;a&gt;The Problem with Self-Referential Structs&lt;&#x2F;h4&gt;
&lt;p&gt;The internal pointer of our self-referential struct leads to a fundamental problem, which becomes apparent when we look at its memory layout:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;self-referential-struct.svg&quot; alt=&quot;array at 0x10014 with fields 1, 2, and 3; element at address 0x10020, pointing to the last array element at 0x1001c&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;array&lt;&#x2F;code&gt; field starts at address 0x10014 and the &lt;code&gt;element&lt;&#x2F;code&gt; field at address 0x10020. It points to address 0x1001c because the last array element lives at this address. At this point, everything is still fine. However, an issue occurs when we move this struct to a different memory address:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;self-referential-struct-moved.svg&quot; alt=&quot;array at 0x10024 with fields 1, 2, and 3; element at address 0x10030, still pointing to 0x1001c, even though the last array element now lives at 0x1002c&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We moved the struct a bit so that it starts at address &lt;code&gt;0x10024&lt;&#x2F;code&gt; now. This could, for example, happen when we pass the struct as a function argument or assign it to a different stack variable. The problem is that the &lt;code&gt;element&lt;&#x2F;code&gt; field still points to address &lt;code&gt;0x1001c&lt;&#x2F;code&gt; even though the last &lt;code&gt;array&lt;&#x2F;code&gt; element now lives at address &lt;code&gt;0x1002c&lt;&#x2F;code&gt;. Thus, the pointer is dangling, with the result that undefined behavior occurs on the next &lt;code&gt;poll&lt;&#x2F;code&gt; call.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;possible-solutions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#possible-solutions&quot; aria-label=&quot;Anchor link for: possible-solutions&quot;&gt;üîó&lt;&#x2F;a&gt;Possible Solutions&lt;&#x2F;h4&gt;
&lt;p&gt;There are three fundamental approaches to solving the dangling pointer problem:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Update the pointer on move:&lt;&#x2F;strong&gt; The idea is to update the internal pointer whenever the struct is moved in memory so that it is still valid after the move. Unfortunately, this approach would require extensive changes to Rust that would result in potentially huge performance losses. The reason is that some kind of runtime would need to keep track of the type of all struct fields and check on every move operation whether a pointer update is required.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Store an offset instead of self-references:&lt;&#x2F;strong&gt;: To avoid the requirement for updating pointers, the compiler could try to store self-references as offsets from the struct‚Äôs beginning instead. For example, the &lt;code&gt;element&lt;&#x2F;code&gt; field of the above &lt;code&gt;WaitingOnWriteState&lt;&#x2F;code&gt; struct could be stored in the form of an &lt;code&gt;element_offset&lt;&#x2F;code&gt; field with a value of 8 because the array element that the reference points to starts 8 bytes after the struct‚Äôs beginning. Since the offset stays the same when the struct is moved, no field updates are required.&lt;&#x2F;p&gt;
&lt;p&gt;The problem with this approach is that it requires the compiler to detect all self-references. This is not possible at compile-time because the value of a reference might depend on user input, so we would need a runtime system again to analyze references and correctly create the state structs. This would not only result in runtime costs but also prevent certain compiler optimizations, so that it would cause large performance losses again.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Forbid moving the struct:&lt;&#x2F;strong&gt; As we saw above, the dangling pointer only occurs when we move the struct in memory. By completely forbidding move operations on self-referential structs, the problem can also be avoided. The big advantage of this approach is that it can be implemented at the type system level without additional runtime costs. The drawback is that it puts the burden of dealing with move operations on possibly self-referential structs on the programmer.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Rust chose the third solution because of its principle of providing &lt;em&gt;zero cost abstractions&lt;&#x2F;em&gt;, which means that abstractions should not impose additional runtime costs. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;pin&#x2F;index.html&quot;&gt;&lt;em&gt;pinning&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; API was proposed for this purpose in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;2349-pin.md&quot;&gt;RFC 2349&lt;&#x2F;a&gt;. In the following, we will give a short overview of this API and explain how it works with async&#x2F;await and futures.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;heap-values&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#heap-values&quot; aria-label=&quot;Anchor link for: heap-values&quot;&gt;üîó&lt;&#x2F;a&gt;Heap Values&lt;&#x2F;h4&gt;
&lt;p&gt;The first observation is that &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;&quot;&gt;heap-allocated&lt;&#x2F;a&gt; values already have a fixed memory address most of the time. They are created using a call to &lt;code&gt;allocate&lt;&#x2F;code&gt; and then referenced by a pointer type such as &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;. While moving the pointer type is possible, the heap value that the pointer points to stays at the same memory address until it is freed through a &lt;code&gt;deallocate&lt;&#x2F;code&gt; call again.&lt;&#x2F;p&gt;
&lt;p&gt;Using heap allocation, we can try to create a self-referential struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; heap_value = Box::new(SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;        self_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*heap_value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2F;span&gt;&lt;span&gt; SelfReferential;
&lt;&#x2F;span&gt;&lt;span&gt;    heap_value.self_ptr = ptr;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap value at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, heap_value);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;internal reference: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, heap_value.self_ptr);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;    self_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const Self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=ce1aff3a37fcc1c8188eeaf0f39c97e8&quot;&gt;Try it on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;We create a simple struct named &lt;code&gt;SelfReferential&lt;&#x2F;code&gt; that contains a single pointer field. First, we initialize this struct with a null pointer and then allocate it on the heap using &lt;code&gt;Box::new&lt;&#x2F;code&gt;. We then determine the memory address of the heap-allocated struct and store it in a &lt;code&gt;ptr&lt;&#x2F;code&gt; variable. Finally, we make the struct self-referential by assigning the &lt;code&gt;ptr&lt;&#x2F;code&gt; variable to the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;When we execute this code &lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=ce1aff3a37fcc1c8188eeaf0f39c97e8&quot;&gt;on the playground&lt;&#x2F;a&gt;, we see that the address of the heap value and its internal pointer are equal, which means that the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field is a valid self-reference. Since the &lt;code&gt;heap_value&lt;&#x2F;code&gt; variable is only a pointer, moving it (e.g., by passing it to a function) does not change the address of the struct itself, so the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; stays valid even if the pointer is moved.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is still a way to break this example: We can move out of a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; or replace its content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_value = mem::replace(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*heap_value, SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;    self_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;value at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;stack_value);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;internal reference: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_value.self_ptr);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=e160ee8a64cba4cebc1c0473dcecb7c8&quot;&gt;Try it on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;Here we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;mem&#x2F;fn.replace.html&quot;&gt;&lt;code&gt;mem::replace&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to replace the heap-allocated value with a new struct instance. This allows us to move the original &lt;code&gt;heap_value&lt;&#x2F;code&gt; to the stack, while the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field of the struct is now a dangling pointer that still points to the old heap address. When you try to run the example on the playground, you see that the printed &lt;em&gt;‚Äúvalue at:‚Äù&lt;&#x2F;em&gt; and &lt;em&gt;‚Äúinternal reference:‚Äù&lt;&#x2F;em&gt; lines indeed show different pointers. So heap allocating a value is not enough to make self-references safe.&lt;&#x2F;p&gt;
&lt;p&gt;The fundamental problem that allowed the above breakage is that &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; allows us to get a &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; reference to the heap-allocated value. This &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference makes it possible to use methods like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;mem&#x2F;fn.replace.html&quot;&gt;&lt;code&gt;mem::replace&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;mem&#x2F;fn.swap.html&quot;&gt;&lt;code&gt;mem::swap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to invalidate the heap-allocated value. To resolve this problem, we must prevent &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references to self-referential structs from being created.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pin-box-t-and-unpin&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pin-box-t-and-unpin&quot; aria-label=&quot;Anchor link for: pin-box-t-and-unpin&quot;&gt;üîó&lt;&#x2F;a&gt;&lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Unpin&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The pinning API provides a solution to the &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; problem in the form of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;pin&#x2F;struct.Pin.html&quot;&gt;&lt;code&gt;Pin&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper type and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;marker&#x2F;trait.Unpin.html&quot;&gt;&lt;code&gt;Unpin&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; marker trait. The idea behind these types is to gate all methods of &lt;code&gt;Pin&lt;&#x2F;code&gt; that can be used to get &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references to the wrapped value (e.g. &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.deref_mut&quot;&gt;&lt;code&gt;deref_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;) on the &lt;code&gt;Unpin&lt;&#x2F;code&gt; trait. The &lt;code&gt;Unpin&lt;&#x2F;code&gt; trait is an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;special-types-and-traits.html#auto-traits&quot;&gt;&lt;em&gt;auto trait&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, which is automatically implemented for all types except those that explicitly opt-out. By making self-referential structs opt-out of &lt;code&gt;Unpin&lt;&#x2F;code&gt;, there is no (safe) way to get a &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; from a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; type for them. As a result, their internal self-references are guaranteed to stay valid.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, let‚Äôs update the &lt;code&gt;SelfReferential&lt;&#x2F;code&gt; type from above to opt-out of &lt;code&gt;Unpin&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::marker::PhantomPinned;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;    self_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const Self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    _pin: PhantomPinned,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We opt-out by adding a second &lt;code&gt;_pin&lt;&#x2F;code&gt; field of type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;struct.PhantomPinned.html&quot;&gt;&lt;code&gt;PhantomPinned&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. This type is a zero-sized marker type whose only purpose is to &lt;em&gt;not&lt;&#x2F;em&gt; implement the &lt;code&gt;Unpin&lt;&#x2F;code&gt; trait. Because of the way &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;special-types-and-traits.html#auto-traits&quot;&gt;auto traits&lt;&#x2F;a&gt; work, a single field that is not &lt;code&gt;Unpin&lt;&#x2F;code&gt; suffices to make the complete struct opt-out of &lt;code&gt;Unpin&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The second step is to change the &lt;code&gt;Box&amp;lt;SelfReferential&amp;gt;&lt;&#x2F;code&gt; type in the example to a &lt;code&gt;Pin&amp;lt;Box&amp;lt;SelfReferential&amp;gt;&amp;gt;&lt;&#x2F;code&gt; type. The easiest way to do this is to use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.pin&quot;&gt;&lt;code&gt;Box::pin&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function instead of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for creating the heap-allocated value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; heap_value = Box::pin(SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;    self_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    _pin: PhantomPinned,
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In addition to changing &lt;code&gt;Box::new&lt;&#x2F;code&gt; to &lt;code&gt;Box::pin&lt;&#x2F;code&gt;, we also need to add the new &lt;code&gt;_pin&lt;&#x2F;code&gt; field in the struct initializer. Since &lt;code&gt;PhantomPinned&lt;&#x2F;code&gt; is a zero-sized type, we only need its type name to initialize it.&lt;&#x2F;p&gt;
&lt;p&gt;When we &lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=961b0db194bbe851ff4d0ed08d3bd98a&quot;&gt;try to run our adjusted example&lt;&#x2F;a&gt; now, we see that it no longer works:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0594]: cannot assign to data in a dereference of `std::pin::Pin&amp;lt;std::boxed::Box&amp;lt;SelfReferential&amp;gt;&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;main.rs:10:5
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;10 |     heap_value.self_ptr = ptr;
&lt;&#x2F;span&gt;&lt;span&gt;   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::pin::Pin&amp;lt;std::boxed::Box&amp;lt;SelfReferential&amp;gt;&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[E0596]: cannot borrow data in a dereference of `std::pin::Pin&amp;lt;std::boxed::Box&amp;lt;SelfReferential&amp;gt;&amp;gt;` as mutable
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;main.rs:16:36
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;16 |     let stack_value = mem::replace(&amp;amp;mut *heap_value, SelfReferential {
&lt;&#x2F;span&gt;&lt;span&gt;   |                                    ^^^^^^^^^^^^^^^^ cannot borrow as mutable
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `std::pin::Pin&amp;lt;std::boxed::Box&amp;lt;SelfReferential&amp;gt;&amp;gt;`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Both errors occur because the &lt;code&gt;Pin&amp;lt;Box&amp;lt;SelfReferential&amp;gt;&amp;gt;&lt;&#x2F;code&gt; type no longer implements the &lt;code&gt;DerefMut&lt;&#x2F;code&gt; trait. This is exactly what we wanted because the &lt;code&gt;DerefMut&lt;&#x2F;code&gt; trait would return a &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference, which we wanted to prevent. This only happens because we both opted-out of &lt;code&gt;Unpin&lt;&#x2F;code&gt; and changed &lt;code&gt;Box::new&lt;&#x2F;code&gt; to &lt;code&gt;Box::pin&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The problem now is that the compiler does not only prevent moving the type in line 16, but also forbids initializing the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field in line 10. This happens because the compiler can‚Äôt differentiate between valid and invalid uses of &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references. To get the initialization working again, we have to use the unsafe &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.get_unchecked_mut&quot;&gt;&lt;code&gt;get_unchecked_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; safe because modifying a field doesn&amp;#39;t move the whole struct
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mut_ref = Pin::as_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; heap_value);
&lt;&#x2F;span&gt;&lt;span&gt;    Pin::get_unchecked_mut(mut_ref).self_ptr = ptr;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=b9ebbb11429d9d79b3f9fffe819e2018&quot;&gt;Try it on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.get_unchecked_mut&quot;&gt;&lt;code&gt;get_unchecked_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function works on a &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt; instead of a &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;, so we have to use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.as_mut&quot;&gt;&lt;code&gt;Pin::as_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for converting the value. Then we can set the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field using the &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference returned by &lt;code&gt;get_unchecked_mut&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now the only error left is the desired error on &lt;code&gt;mem::replace&lt;&#x2F;code&gt;. Remember, this operation tries to move the heap-allocated value to the stack, which would break the self-reference stored in the &lt;code&gt;self_ptr&lt;&#x2F;code&gt; field. By opting out of &lt;code&gt;Unpin&lt;&#x2F;code&gt; and using &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;, we can prevent this operation at compile time and thus safely work with self-referential structs. As we saw, the compiler is not able to prove that the creation of the self-reference is safe (yet), so we need to use an unsafe block and verify the correctness ourselves.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;stack-pinning-and-pin-mut-t&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#stack-pinning-and-pin-mut-t&quot; aria-label=&quot;Anchor link for: stack-pinning-and-pin-mut-t&quot;&gt;üîó&lt;&#x2F;a&gt;Stack Pinning and &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;In the previous section, we learned how to use &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; to safely create a heap-allocated self-referential value. While this approach works fine and is relatively safe (apart from the unsafe construction), the required heap allocation comes with a performance cost. Since Rust strives to provide &lt;em&gt;zero-cost abstractions&lt;&#x2F;em&gt; whenever possible, the pinning API also allows to create &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt; instances that point to stack-allocated values.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; instances, which have &lt;em&gt;ownership&lt;&#x2F;em&gt; of the wrapped value, &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt; instances only temporarily borrow the wrapped value. This makes things more complicated, as it requires the programmer to ensure additional guarantees themselves. Most importantly, a &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt; must stay pinned for the whole lifetime of the referenced &lt;code&gt;T&lt;&#x2F;code&gt;, which can be difficult to verify for stack-based variables. To help with this, crates like &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pin-utils&#x2F;0.1.0-alpha.4&#x2F;pin_utils&#x2F;&quot;&gt;&lt;code&gt;pin-utils&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; exist, but I still wouldn‚Äôt recommend pinning to the stack unless you really know what you‚Äôre doing.&lt;&#x2F;p&gt;
&lt;p&gt;For further reading, check out the documentation of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;index.html&quot;&gt;&lt;code&gt;pin&lt;&#x2F;code&gt; module&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.new_unchecked&quot;&gt;&lt;code&gt;Pin::new_unchecked&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pinning-and-futures&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pinning-and-futures&quot; aria-label=&quot;Anchor link for: pinning-and-futures&quot;&gt;üîó&lt;&#x2F;a&gt;Pinning and Futures&lt;&#x2F;h4&gt;
&lt;p&gt;As we already saw in this post, the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method uses pinning in the form of a &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;&#x2F;code&gt; parameter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason that this method takes &lt;code&gt;self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;&#x2F;code&gt; instead of the normal &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; is that future instances created from async&#x2F;await are often self-referential, as we saw &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;#self-referential-structs&quot;&gt;above&lt;&#x2F;a&gt;. By wrapping &lt;code&gt;Self&lt;&#x2F;code&gt; into &lt;code&gt;Pin&lt;&#x2F;code&gt; and letting the compiler opt-out of &lt;code&gt;Unpin&lt;&#x2F;code&gt; for self-referential futures generated from async&#x2F;await, it is guaranteed that the futures are not moved in memory between &lt;code&gt;poll&lt;&#x2F;code&gt; calls. This ensures that all internal references are still valid.&lt;&#x2F;p&gt;
&lt;p&gt;It is worth noting that moving futures before the first &lt;code&gt;poll&lt;&#x2F;code&gt; call is fine. This is a result of the fact that futures are lazy and do nothing until they‚Äôre polled for the first time. The &lt;code&gt;start&lt;&#x2F;code&gt; state of the generated state machines therefore only contains the function arguments but no internal references. In order to call &lt;code&gt;poll&lt;&#x2F;code&gt;, the caller must wrap the future into &lt;code&gt;Pin&lt;&#x2F;code&gt; first, which ensures that the future cannot be moved in memory anymore. Since stack pinning is more difficult to get right, I recommend to always use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.pin&quot;&gt;&lt;code&gt;Box::pin&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combined with &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.as_mut&quot;&gt;&lt;code&gt;Pin::as_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for this.&lt;&#x2F;p&gt;
&lt;p&gt;In case you‚Äôre interested in understanding how to safely implement a future combinator function using stack pinning yourself, take a look at the relatively short &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;src&#x2F;futures_util&#x2F;future&#x2F;future&#x2F;map.rs.html&quot;&gt;source of the &lt;code&gt;map&lt;&#x2F;code&gt; combinator method&lt;&#x2F;a&gt; of the &lt;code&gt;futures&lt;&#x2F;code&gt; crate and the section about &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;std&#x2F;pin&#x2F;index.html#projections-and-structural-pinning&quot;&gt;projections and structural pinning&lt;&#x2F;a&gt; of the pin documentation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;executors-and-wakers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#executors-and-wakers&quot; aria-label=&quot;Anchor link for: executors-and-wakers&quot;&gt;üîó&lt;&#x2F;a&gt;Executors and Wakers&lt;&#x2F;h3&gt;
&lt;p&gt;Using async&#x2F;await, it is possible to ergonomically work with futures in a completely asynchronous way. However, as we learned above, futures do nothing until they are polled. This means we have to call &lt;code&gt;poll&lt;&#x2F;code&gt; on them at some point, otherwise the asynchronous code is never executed.&lt;&#x2F;p&gt;
&lt;p&gt;With a single future, we can always wait for each future manually using a loop &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;#waiting-on-futures&quot;&gt;as described above&lt;&#x2F;a&gt;. However, this approach is very inefficient and not practical for programs that create a large number of futures. The most common solution to this problem is to define a global &lt;em&gt;executor&lt;&#x2F;em&gt; that is responsible for polling all futures in the system until they are finished.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;executors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#executors&quot; aria-label=&quot;Anchor link for: executors&quot;&gt;üîó&lt;&#x2F;a&gt;Executors&lt;&#x2F;h4&gt;
&lt;p&gt;The purpose of an executor is to allow spawning futures as independent tasks, typically through some sort of &lt;code&gt;spawn&lt;&#x2F;code&gt; method. The executor is then responsible for polling all futures until they are completed. The big advantage of managing all futures in a central place is that the executor can switch to a different future whenever a future returns &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. Thus, asynchronous operations are run in parallel and the CPU is kept busy.&lt;&#x2F;p&gt;
&lt;p&gt;Many executor implementations can also take advantage of systems with multiple CPU cores. They create a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_pool&quot;&gt;thread pool&lt;&#x2F;a&gt; that is able to utilize all cores if there is enough work available and use techniques such as &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_stealing&quot;&gt;work stealing&lt;&#x2F;a&gt; to balance the load between cores. There are also special executor implementations for embedded systems that optimize for low latency and memory overhead.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid the overhead of polling futures repeatedly, executors typically take advantage of the &lt;em&gt;waker&lt;&#x2F;em&gt; API supported by Rust‚Äôs futures.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wakers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#wakers&quot; aria-label=&quot;Anchor link for: wakers&quot;&gt;üîó&lt;&#x2F;a&gt;Wakers&lt;&#x2F;h4&gt;
&lt;p&gt;The idea behind the waker API is that a special &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type is passed to each invocation of &lt;code&gt;poll&lt;&#x2F;code&gt;, wrapped in the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. This &lt;code&gt;Waker&lt;&#x2F;code&gt; type is created by the executor and can be used by the asynchronous task to signal its (partial) completion. As a result, the executor does not need to call &lt;code&gt;poll&lt;&#x2F;code&gt; on a future that previously returned &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; until it is notified by the corresponding waker.&lt;&#x2F;p&gt;
&lt;p&gt;This is best illustrated by a small example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;write_file() {
&lt;&#x2F;span&gt;&lt;span&gt;    async_write_file(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;foo.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function asynchronously writes the string ‚ÄúHello‚Äù to a &lt;code&gt;foo.txt&lt;&#x2F;code&gt; file. Since hard disk writes take some time, the first &lt;code&gt;poll&lt;&#x2F;code&gt; call on this future will likely return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. However, the hard disk driver will internally store the &lt;code&gt;Waker&lt;&#x2F;code&gt; passed to the &lt;code&gt;poll&lt;&#x2F;code&gt; call and use it to notify the executor when the file is written to disk. This way, the executor does not need to waste any time trying to &lt;code&gt;poll&lt;&#x2F;code&gt; the future again before it receives the waker notification.&lt;&#x2F;p&gt;
&lt;p&gt;We will see how the &lt;code&gt;Waker&lt;&#x2F;code&gt; type works in detail when we create our own executor with waker support in the implementation section of this post.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cooperative-multitasking-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cooperative-multitasking-1&quot; aria-label=&quot;Anchor link for: cooperative-multitasking-1&quot;&gt;üîó&lt;&#x2F;a&gt;Cooperative Multitasking?&lt;&#x2F;h3&gt;
&lt;p&gt;At the beginning of this post, we talked about preemptive and cooperative multitasking. While preemptive multitasking relies on the operating system to forcibly switch between running tasks, cooperative multitasking requires that the tasks voluntarily give up control of the CPU through a &lt;em&gt;yield&lt;&#x2F;em&gt; operation on a regular basis. The big advantage of the cooperative approach is that tasks can save their state themselves, which results in more efficient context switches and makes it possible to share the same call stack between tasks.&lt;&#x2F;p&gt;
&lt;p&gt;It might not be immediately apparent, but futures and async&#x2F;await are an implementation of the cooperative multitasking pattern:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Each future that is added to the executor is basically a cooperative task.&lt;&#x2F;li&gt;
&lt;li&gt;Instead of using an explicit yield operation, futures give up control of the CPU core by returning &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; (or &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt; at the end).
&lt;ul&gt;
&lt;li&gt;There is nothing that forces futures to give up the CPU. If they want, they can never return from &lt;code&gt;poll&lt;&#x2F;code&gt;, e.g., by spinning endlessly in a loop.&lt;&#x2F;li&gt;
&lt;li&gt;Since each future can block the execution of the other futures in the executor, we need to trust them to not be malicious.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Futures internally store all the state they need to continue execution on the next &lt;code&gt;poll&lt;&#x2F;code&gt; call. With async&#x2F;await, the compiler automatically detects all variables that are needed and stores them inside the generated state machine.
&lt;ul&gt;
&lt;li&gt;Only the minimum state required for continuation is saved.&lt;&#x2F;li&gt;
&lt;li&gt;Since the &lt;code&gt;poll&lt;&#x2F;code&gt; method gives up the call stack when it returns, the same stack can be used for polling other futures.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We see that futures and async&#x2F;await fit the cooperative multitasking pattern perfectly; they just use some different terminology. In the following, we will therefore use the terms ‚Äútask‚Äù and ‚Äúfuture‚Äù interchangeably.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we understand how cooperative multitasking based on futures and async&#x2F;await works in Rust, it‚Äôs time to add support for it to our kernel. Since the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait is part of the &lt;code&gt;core&lt;&#x2F;code&gt; library and async&#x2F;await is a feature of the language itself, there is nothing special we need to do to use it in our &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; kernel. The only requirement is that we use at least nightly &lt;code&gt;2020-03-25&lt;&#x2F;code&gt; of Rust because async&#x2F;await was not &lt;code&gt;no_std&lt;&#x2F;code&gt; compatible before.&lt;&#x2F;p&gt;
&lt;p&gt;With a recent-enough nightly, we can start using async&#x2F;await in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;async_number() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example_task() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; number = async_number().await;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;async number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, number);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;async_number&lt;&#x2F;code&gt; function is an &lt;code&gt;async fn&lt;&#x2F;code&gt;, so the compiler transforms it into a state machine that implements &lt;code&gt;Future&lt;&#x2F;code&gt;. Since the function only returns &lt;code&gt;42&lt;&#x2F;code&gt;, the resulting future will directly return &lt;code&gt;Poll::Ready(42)&lt;&#x2F;code&gt; on the first &lt;code&gt;poll&lt;&#x2F;code&gt; call. Like &lt;code&gt;async_number&lt;&#x2F;code&gt;, the &lt;code&gt;example_task&lt;&#x2F;code&gt; function is also an &lt;code&gt;async fn&lt;&#x2F;code&gt;. It awaits the number returned by &lt;code&gt;async_number&lt;&#x2F;code&gt; and then prints it using the &lt;code&gt;println&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;p&gt;To run the future returned by &lt;code&gt;example_task&lt;&#x2F;code&gt;, we need to call &lt;code&gt;poll&lt;&#x2F;code&gt; on it until it signals its completion by returning &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. To do this, we need to create a simple executor type.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;task&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#task&quot; aria-label=&quot;Anchor link for: task&quot;&gt;üîó&lt;&#x2F;a&gt;Task&lt;&#x2F;h3&gt;
&lt;p&gt;Before we start the executor implementation, we create a new &lt;code&gt;task&lt;&#x2F;code&gt; module with a &lt;code&gt;Task&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;task;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::{future::Future, pin::Pin};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Task {
&lt;&#x2F;span&gt;&lt;span&gt;    future: Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = ()&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Task&lt;&#x2F;code&gt; struct is a newtype wrapper around a pinned, heap-allocated, and dynamically dispatched future with the empty type &lt;code&gt;()&lt;&#x2F;code&gt; as output. Let‚Äôs go through it in detail:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We require that the future associated with a task returns &lt;code&gt;()&lt;&#x2F;code&gt;. This means that tasks don‚Äôt return any result, they are just executed for their side effects. For example, the &lt;code&gt;example_task&lt;&#x2F;code&gt; function we defined above has no return value, but it prints something to the screen as a side effect.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;dyn&lt;&#x2F;code&gt; keyword indicates that we store a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch17-02-trait-objects.html&quot;&gt;&lt;em&gt;trait object&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; in the &lt;code&gt;Box&lt;&#x2F;code&gt;. This means that the methods on the future are &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch&quot;&gt;&lt;em&gt;dynamically dispatched&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, allowing different types of futures to be stored in the &lt;code&gt;Task&lt;&#x2F;code&gt; type. This is important because each &lt;code&gt;async fn&lt;&#x2F;code&gt; has its own type and we want to be able to create multiple different tasks.&lt;&#x2F;li&gt;
&lt;li&gt;As we learned in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;#pinning&quot;&gt;section about pinning&lt;&#x2F;a&gt;, the &lt;code&gt;Pin&amp;lt;Box&amp;gt;&lt;&#x2F;code&gt; type ensures that a value cannot be moved in memory by placing it on the heap and preventing the creation of &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references to it. This is important because futures generated by async&#x2F;await might be self-referential, i.e., contain pointers to themselves that would be invalidated when the future is moved.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To allow the creation of new &lt;code&gt;Task&lt;&#x2F;code&gt; structs from futures, we create a &lt;code&gt;new&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Task {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(future: impl Future&amp;lt;Output = ()&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Task {
&lt;&#x2F;span&gt;&lt;span&gt;        Task {
&lt;&#x2F;span&gt;&lt;span&gt;            future: Box::pin(future),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function takes an arbitrary future with an output type of &lt;code&gt;()&lt;&#x2F;code&gt; and pins it in memory through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.pin&quot;&gt;&lt;code&gt;Box::pin&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function. Then it wraps the boxed future in the &lt;code&gt;Task&lt;&#x2F;code&gt; struct and returns it. The &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime is required here because the returned &lt;code&gt;Task&lt;&#x2F;code&gt; can live for an arbitrary time, so the future needs to be valid for that time too.&lt;&#x2F;p&gt;
&lt;p&gt;We also add a &lt;code&gt;poll&lt;&#x2F;code&gt; method to allow the executor to poll the stored future:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::{Context, Poll};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Task {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, context: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        self.future.as_mut().poll(context)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method of the &lt;code&gt;Future&lt;&#x2F;code&gt; trait expects to be called on a &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;&#x2F;code&gt; type, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;pin&#x2F;struct.Pin.html#method.as_mut&quot;&gt;&lt;code&gt;Pin::as_mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to convert the &lt;code&gt;self.future&lt;&#x2F;code&gt; field of type &lt;code&gt;Pin&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; first. Then we call &lt;code&gt;poll&lt;&#x2F;code&gt; on the converted &lt;code&gt;self.future&lt;&#x2F;code&gt; field and return the result. Since the &lt;code&gt;Task::poll&lt;&#x2F;code&gt; method should only be called by the executor that we‚Äôll create in a moment, we keep the function private to the &lt;code&gt;task&lt;&#x2F;code&gt; module.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simple-executor&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simple-executor&quot; aria-label=&quot;Anchor link for: simple-executor&quot;&gt;üîó&lt;&#x2F;a&gt;Simple Executor&lt;&#x2F;h3&gt;
&lt;p&gt;Since executors can be quite complex, we deliberately start by creating a very basic executor before implementing a more featureful executor later. For this, we first create a new &lt;code&gt;task::simple_executor&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;simple_executor;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;simple_executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::Task;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::collections::VecDeque;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;SimpleExecutor {
&lt;&#x2F;span&gt;&lt;span&gt;    task_queue: VecDeque&amp;lt;Task&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;SimpleExecutor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; SimpleExecutor {
&lt;&#x2F;span&gt;&lt;span&gt;        SimpleExecutor {
&lt;&#x2F;span&gt;&lt;span&gt;            task_queue: VecDeque::new(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;spawn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, task: Task) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.task_queue.push_back(task)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct contains a single &lt;code&gt;task_queue&lt;&#x2F;code&gt; field of type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which is basically a vector that allows for push and pop operations on both ends. The idea behind using this type is that we insert new tasks through the &lt;code&gt;spawn&lt;&#x2F;code&gt; method at the end and pop the next task for execution from the front. This way, we get a simple &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FIFO_(computing_and_electronics)&quot;&gt;FIFO queue&lt;&#x2F;a&gt; (&lt;em&gt;‚Äúfirst in, first out‚Äù&lt;&#x2F;em&gt;).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dummy-waker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dummy-waker&quot; aria-label=&quot;Anchor link for: dummy-waker&quot;&gt;üîó&lt;&#x2F;a&gt;Dummy Waker&lt;&#x2F;h4&gt;
&lt;p&gt;In order to call the &lt;code&gt;poll&lt;&#x2F;code&gt; method, we need to create a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type, which wraps a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. To start simple, we will first create a dummy waker that does nothing. For this, we create a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html&quot;&gt;&lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, which defines the implementation of the different &lt;code&gt;Waker&lt;&#x2F;code&gt; methods, and then use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.Waker.html#method.from_raw&quot;&gt;&lt;code&gt;Waker::from_raw&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to turn it into a &lt;code&gt;Waker&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;simple_executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::{Waker, RawWaker};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;dummy_raw_waker() -&amp;gt; RawWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    todo!();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;dummy_waker() -&amp;gt; Waker {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Waker::from_raw(dummy_raw_waker()) }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;from_raw&lt;&#x2F;code&gt; function is unsafe because undefined behavior can occur if the programmer does not uphold the documented requirements of &lt;code&gt;RawWaker&lt;&#x2F;code&gt;. Before we look at the implementation of the &lt;code&gt;dummy_raw_waker&lt;&#x2F;code&gt; function, we first try to understand how the &lt;code&gt;RawWaker&lt;&#x2F;code&gt; type works.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;rawwaker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rawwaker&quot; aria-label=&quot;Anchor link for: rawwaker&quot;&gt;üîó&lt;&#x2F;a&gt;&lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;h5&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html&quot;&gt;&lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type requires the programmer to explicitly define a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_method_table&quot;&gt;&lt;em&gt;virtual method table&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (&lt;em&gt;vtable&lt;&#x2F;em&gt;) that specifies the functions that should be called when the &lt;code&gt;RawWaker&lt;&#x2F;code&gt; is cloned, woken, or dropped. The layout of this vtable is defined by the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWakerVTable.html&quot;&gt;&lt;code&gt;RawWakerVTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. Each function receives a &lt;code&gt;*const ()&lt;&#x2F;code&gt; argument, which is a &lt;em&gt;type-erased&lt;&#x2F;em&gt; pointer to some value. The reason for using a &lt;code&gt;*const ()&lt;&#x2F;code&gt; pointer instead of a proper reference is that the &lt;code&gt;RawWaker&lt;&#x2F;code&gt; type should be non-generic but still support arbitrary types. The pointer is provided by putting it into the &lt;code&gt;data&lt;&#x2F;code&gt; argument of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html#method.new&quot;&gt;&lt;code&gt;RawWaker::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which just initializes a &lt;code&gt;RawWaker&lt;&#x2F;code&gt;. The &lt;code&gt;Waker&lt;&#x2F;code&gt; then uses this &lt;code&gt;RawWaker&lt;&#x2F;code&gt; to call the vtable functions with &lt;code&gt;data&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Typically, the &lt;code&gt;RawWaker&lt;&#x2F;code&gt; is created for some heap-allocated struct that is wrapped into the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. For such types, methods like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; can be used to convert the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; to a &lt;code&gt;*const T&lt;&#x2F;code&gt; pointer. This pointer can then be cast to an anonymous &lt;code&gt;*const ()&lt;&#x2F;code&gt; pointer and passed to &lt;code&gt;RawWaker::new&lt;&#x2F;code&gt;. Since each vtable function receives the same &lt;code&gt;*const ()&lt;&#x2F;code&gt; as an argument, the functions can safely cast the pointer back to a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; or a &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; to operate on it. As you can imagine, this process is highly dangerous and can easily lead to undefined behavior on mistakes. For this reason, manually creating a &lt;code&gt;RawWaker&lt;&#x2F;code&gt; is not recommended unless necessary.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;a-dummy-rawwaker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummy-rawwaker&quot; aria-label=&quot;Anchor link for: a-dummy-rawwaker&quot;&gt;üîó&lt;&#x2F;a&gt;A Dummy &lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;h5&gt;
&lt;p&gt;While manually creating a &lt;code&gt;RawWaker&lt;&#x2F;code&gt; is not recommended, there is currently no other way to create a dummy &lt;code&gt;Waker&lt;&#x2F;code&gt; that does nothing. Fortunately, the fact that we want to do nothing makes it relatively safe to implement the &lt;code&gt;dummy_raw_waker&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;simple_executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::RawWakerVTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;dummy_raw_waker() -&amp;gt; RawWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;no_op(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;()) {}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clone(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;()) -&amp;gt; RawWaker {
&lt;&#x2F;span&gt;&lt;span&gt;        dummy_raw_waker()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; vtable = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;RawWakerVTable::new(clone, no_op, no_op, no_op);
&lt;&#x2F;span&gt;&lt;span&gt;    RawWaker::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const &lt;&#x2F;span&gt;&lt;span&gt;(), vtable)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we define two inner functions named &lt;code&gt;no_op&lt;&#x2F;code&gt; and &lt;code&gt;clone&lt;&#x2F;code&gt;. The &lt;code&gt;no_op&lt;&#x2F;code&gt; function takes a &lt;code&gt;*const ()&lt;&#x2F;code&gt; pointer and does nothing. The &lt;code&gt;clone&lt;&#x2F;code&gt; function also takes a &lt;code&gt;*const ()&lt;&#x2F;code&gt; pointer and returns a new &lt;code&gt;RawWaker&lt;&#x2F;code&gt; by calling &lt;code&gt;dummy_raw_waker&lt;&#x2F;code&gt; again. We use these two functions to create a minimal &lt;code&gt;RawWakerVTable&lt;&#x2F;code&gt;: The &lt;code&gt;clone&lt;&#x2F;code&gt; function is used for the cloning operations, and the &lt;code&gt;no_op&lt;&#x2F;code&gt; function is used for all other operations. Since the &lt;code&gt;RawWaker&lt;&#x2F;code&gt; does nothing, it does not matter that we return a new &lt;code&gt;RawWaker&lt;&#x2F;code&gt; from &lt;code&gt;clone&lt;&#x2F;code&gt; instead of cloning it.&lt;&#x2F;p&gt;
&lt;p&gt;After creating the &lt;code&gt;vtable&lt;&#x2F;code&gt;, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html#method.new&quot;&gt;&lt;code&gt;RawWaker::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to create the &lt;code&gt;RawWaker&lt;&#x2F;code&gt;. The passed &lt;code&gt;*const ()&lt;&#x2F;code&gt; does not matter since none of the vtable functions use it. For this reason, we simply pass a null pointer.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-run-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-run-method&quot; aria-label=&quot;Anchor link for: a-run-method&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;run&lt;&#x2F;code&gt; Method&lt;&#x2F;h4&gt;
&lt;p&gt;Now we have a way to create a &lt;code&gt;Waker&lt;&#x2F;code&gt; instance, we can use it to implement a &lt;code&gt;run&lt;&#x2F;code&gt; method on our executor. The most simple &lt;code&gt;run&lt;&#x2F;code&gt; method is to repeatedly poll all queued tasks in a loop until all are done. This is not very efficient since it does not utilize the notifications of the &lt;code&gt;Waker&lt;&#x2F;code&gt; type, but it is an easy way to get things running:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;simple_executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::{Context, Poll};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;SimpleExecutor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; task) = self.task_queue.pop_front() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; waker = dummy_waker();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; context = Context::from_waker(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;waker);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; task.poll(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; context) {
&lt;&#x2F;span&gt;&lt;span&gt;                Poll::Ready(()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; task done
&lt;&#x2F;span&gt;&lt;span&gt;                Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.task_queue.push_back(task),
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function uses a &lt;code&gt;while let&lt;&#x2F;code&gt; loop to handle all tasks in the &lt;code&gt;task_queue&lt;&#x2F;code&gt;. For each task, it first creates a &lt;code&gt;Context&lt;&#x2F;code&gt; type by wrapping a &lt;code&gt;Waker&lt;&#x2F;code&gt; instance returned by our &lt;code&gt;dummy_waker&lt;&#x2F;code&gt; function. Then it invokes the &lt;code&gt;Task::poll&lt;&#x2F;code&gt; method with this &lt;code&gt;context&lt;&#x2F;code&gt;. If the &lt;code&gt;poll&lt;&#x2F;code&gt; method returns &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;, the task is finished and we can continue with the next task. If the task is still &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;, we add it to the back of the queue again so that it will be polled again in a subsequent loop iteration.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;trying-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#trying-it&quot; aria-label=&quot;Anchor link for: trying-it&quot;&gt;üîó&lt;&#x2F;a&gt;Trying It&lt;&#x2F;h4&gt;
&lt;p&gt;With our &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt; type, we can now try running the task returned by the &lt;code&gt;example_task&lt;&#x2F;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::task::{Task, simple_executor::SimpleExecutor};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] initialization routines, including `init_heap`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; executor = SimpleExecutor::new();
&lt;&#x2F;span&gt;&lt;span&gt;    executor.spawn(Task::new(example_task()));
&lt;&#x2F;span&gt;&lt;span&gt;    executor.run();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] test_main, &amp;quot;it did not crash&amp;quot; message, hlt_loop
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Below is the example_task function again so that you don&amp;#39;t have to scroll up
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;async_number() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;example_task() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; number = async_number().await;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;async number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, number);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, we see that the expected &lt;em&gt;‚Äúasync number: 42‚Äù&lt;&#x2F;em&gt; message is printed to the screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;qemu-simple-executor.png&quot; alt=&quot;QEMU printing ‚ÄúHello World‚Äù, ‚Äúasync number: 42‚Äù, and ‚ÄúIt did not crash!‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs summarize the various steps that happen in this example:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First, a new instance of our &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt; type is created with an empty &lt;code&gt;task_queue&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Next, we call the asynchronous &lt;code&gt;example_task&lt;&#x2F;code&gt; function, which returns a future. We wrap this future in the &lt;code&gt;Task&lt;&#x2F;code&gt; type, which moves it to the heap and pins it, and then add the task to the &lt;code&gt;task_queue&lt;&#x2F;code&gt; of the executor through the &lt;code&gt;spawn&lt;&#x2F;code&gt; method.&lt;&#x2F;li&gt;
&lt;li&gt;We then call the &lt;code&gt;run&lt;&#x2F;code&gt; method to start the execution of the single task in the queue. This involves:
&lt;ul&gt;
&lt;li&gt;Popping the task from the front of the &lt;code&gt;task_queue&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Creating a &lt;code&gt;RawWaker&lt;&#x2F;code&gt; for the task, converting it to a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, and then creating a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance from it.&lt;&#x2F;li&gt;
&lt;li&gt;Calling the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on the future of the task, using the &lt;code&gt;Context&lt;&#x2F;code&gt; we just created.&lt;&#x2F;li&gt;
&lt;li&gt;Since the &lt;code&gt;example_task&lt;&#x2F;code&gt; does not wait for anything, it can directly run till its end on the first &lt;code&gt;poll&lt;&#x2F;code&gt; call. This is where the &lt;em&gt;‚Äúasync number: 42‚Äù&lt;&#x2F;em&gt; line is printed.&lt;&#x2F;li&gt;
&lt;li&gt;Since the &lt;code&gt;example_task&lt;&#x2F;code&gt; directly returns &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;, it is not added back to the task queue.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;run&lt;&#x2F;code&gt; method returns after the &lt;code&gt;task_queue&lt;&#x2F;code&gt; becomes empty. The execution of our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function continues and the &lt;em&gt;‚ÄúIt did not crash!‚Äù&lt;&#x2F;em&gt; message is printed.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;async-keyboard-input&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#async-keyboard-input&quot; aria-label=&quot;Anchor link for: async-keyboard-input&quot;&gt;üîó&lt;&#x2F;a&gt;Async Keyboard Input&lt;&#x2F;h3&gt;
&lt;p&gt;Our simple executor does not utilize the &lt;code&gt;Waker&lt;&#x2F;code&gt; notifications and simply loops over all tasks until they are done. This wasn‚Äôt a problem for our example since our &lt;code&gt;example_task&lt;&#x2F;code&gt; can directly run to finish on the first &lt;code&gt;poll&lt;&#x2F;code&gt; call. To see the performance advantages of a proper &lt;code&gt;Waker&lt;&#x2F;code&gt; implementation, we first need to create a task that is truly asynchronous, i.e., a task that will probably return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; on the first &lt;code&gt;poll&lt;&#x2F;code&gt; call.&lt;&#x2F;p&gt;
&lt;p&gt;We already have some kind of asynchronicity in our system that we can use for this: hardware interrupts. As we learned in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;&quot;&gt;&lt;em&gt;Interrupts&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, hardware interrupts can occur at arbitrary points in time, determined by some external device. For example, a hardware timer sends an interrupt to the CPU after some predefined time has elapsed. When the CPU receives an interrupt, it immediately transfers control to the corresponding handler function defined in the interrupt descriptor table (IDT).&lt;&#x2F;p&gt;
&lt;p&gt;In the following, we will create an asynchronous task based on the keyboard interrupt. The keyboard interrupt is a good candidate for this because it is both non-deterministic and latency-critical. Non-deterministic means that there is no way to predict when the next key press will occur because it is entirely dependent on the user. Latency-critical means that we want to handle the keyboard input in a timely manner, otherwise the user will feel a lag. To support such a task in an efficient way, it will be essential that the executor has proper support for &lt;code&gt;Waker&lt;&#x2F;code&gt; notifications.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scancode-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#scancode-queue&quot; aria-label=&quot;Anchor link for: scancode-queue&quot;&gt;üîó&lt;&#x2F;a&gt;Scancode Queue&lt;&#x2F;h4&gt;
&lt;p&gt;Currently, we handle the keyboard input directly in the interrupt handler. This is not a good idea for the long term because interrupt handlers should stay as short as possible as they might interrupt important work. Instead, interrupt handlers should only perform the minimal amount of work necessary (e.g., reading the keyboard scancode) and leave the rest of the work (e.g., interpreting the scancode) to a background task.&lt;&#x2F;p&gt;
&lt;p&gt;A common pattern for delegating work to a background task is to create some sort of queue. The interrupt handler pushes units of work to the queue, and the background task handles the work in the queue. Applied to our keyboard interrupt, this means that the interrupt handler only reads the scancode from the keyboard, pushes it to the queue, and then returns. The keyboard task sits on the other end of the queue and interprets and handles each scancode that is pushed to it:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;scancode-queue.svg&quot; alt=&quot;Scancode queue with 8 slots on the top. Keyboard interrupt handler on the bottom left with a ‚Äúpush scancode‚Äù arrow to the left of the queue. Keyboard task on the bottom right with a ‚Äúpop scancode‚Äù arrow coming from the right side of the queue.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A simple implementation of that queue could be a mutex-protected &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. However, using mutexes in interrupt handlers is not a good idea since it can easily lead to deadlocks. For example, when the user presses a key while the keyboard task has locked the queue, the interrupt handler tries to acquire the lock again and hangs indefinitely. Another problem with this approach is that &lt;code&gt;VecDeque&lt;&#x2F;code&gt; automatically increases its capacity by performing a new heap allocation when it becomes full. This can lead to deadlocks again because our allocator also uses a mutex internally. Further problems are that heap allocations can fail or take a considerable amount of time when the heap is fragmented.&lt;&#x2F;p&gt;
&lt;p&gt;To prevent these problems, we need a queue implementation that does not require mutexes or allocations for its &lt;code&gt;push&lt;&#x2F;code&gt; operation. Such queues can be implemented by using lock-free &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;index.html&quot;&gt;atomic operations&lt;&#x2F;a&gt; for pushing and popping elements. This way, it is possible to create &lt;code&gt;push&lt;&#x2F;code&gt; and &lt;code&gt;pop&lt;&#x2F;code&gt; operations that only require a &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference and are thus usable without a mutex. To avoid allocations on &lt;code&gt;push&lt;&#x2F;code&gt;, the queue can be backed by a pre-allocated fixed-size buffer. While this makes the queue &lt;em&gt;bounded&lt;&#x2F;em&gt; (i.e., it has a maximum length), it is often possible to define reasonable upper bounds for the queue length in practice, so that this isn‚Äôt a big problem.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;the-crossbeam-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-crossbeam-crate&quot; aria-label=&quot;Anchor link for: the-crossbeam-crate&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;crossbeam&lt;&#x2F;code&gt; Crate&lt;&#x2F;h5&gt;
&lt;p&gt;Implementing such a queue in a correct and efficient way is very difficult, so I recommend sticking to existing, well-tested implementations. One popular Rust project that implements various mutex-free types for concurrent programming is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;crossbeam-rs&#x2F;crossbeam&quot;&gt;&lt;code&gt;crossbeam&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. It provides a type named &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html&quot;&gt;&lt;code&gt;ArrayQueue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; that is exactly what we need in this case. And we‚Äôre lucky: the type is fully compatible with &lt;code&gt;no_std&lt;&#x2F;code&gt; crates with allocation support.&lt;&#x2F;p&gt;
&lt;p&gt;To use the type, we need to add a dependency on the &lt;code&gt;crossbeam-queue&lt;&#x2F;code&gt; crate:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.crossbeam-queue&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.1&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;default-features &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;alloc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By default, the crate depends on the standard library. To make it &lt;code&gt;no_std&lt;&#x2F;code&gt; compatible, we need to disable its default features and instead enable the &lt;code&gt;alloc&lt;&#x2F;code&gt; feature. &lt;span class=&quot;gray&quot;&gt;(Note that we could also add a dependency on the main &lt;code&gt;crossbeam&lt;&#x2F;code&gt; crate, which re-exports the &lt;code&gt;crossbeam-queue&lt;&#x2F;code&gt; crate, but this would result in a larger number of dependencies and longer compile times.)&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;h5 id=&quot;queue-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#queue-implementation&quot; aria-label=&quot;Anchor link for: queue-implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Queue Implementation&lt;&#x2F;h5&gt;
&lt;p&gt;Using the &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type, we can now create a global scancode queue in a new &lt;code&gt;task::keyboard&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;keyboard;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;conquer_once::spin::OnceCell;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crossbeam_queue::ArrayQueue;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE&lt;&#x2F;span&gt;&lt;span&gt;: OnceCell&amp;lt;ArrayQueue&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; = OnceCell::uninit();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html#method.new&quot;&gt;&lt;code&gt;ArrayQueue::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; performs a heap allocation, which is not possible at compile time (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;const-eval&#x2F;issues&#x2F;20&quot;&gt;yet&lt;&#x2F;a&gt;), we can‚Äôt initialize the static variable directly. Instead, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;raw&#x2F;struct.OnceCell.html&quot;&gt;&lt;code&gt;OnceCell&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;index.html&quot;&gt;&lt;code&gt;conquer_once&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, which makes it possible to perform a safe one-time initialization of static values. To include the crate, we need to add it as a dependency in our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.conquer-once&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.0&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;default-features &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;raw&#x2F;struct.OnceCell.html&quot;&gt;&lt;code&gt;OnceCell&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; primitive, we could also use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lazy_static&#x2F;1.4.0&#x2F;lazy_static&#x2F;index.html&quot;&gt;&lt;code&gt;lazy_static&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro here. However, the &lt;code&gt;OnceCell&lt;&#x2F;code&gt; type has the advantage that we can ensure that the initialization does not happen in the interrupt handler, thus preventing the interrupt handler from performing a heap allocation.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;filling-the-queue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#filling-the-queue&quot; aria-label=&quot;Anchor link for: filling-the-queue&quot;&gt;üîó&lt;&#x2F;a&gt;Filling the Queue&lt;&#x2F;h4&gt;
&lt;p&gt;To fill the scancode queue, we create a new &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function that we will call from the interrupt handler:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::println;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Called by the keyboard interrupt handler
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Must not block or allocate.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;add_scancode(scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(queue) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE&lt;&#x2F;span&gt;&lt;span&gt;.try_get() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Err(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = queue.push(scancode) {
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WARNING: scancode queue full; dropping keyboard input&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WARNING: scancode queue uninitialized&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;raw&#x2F;struct.OnceCell.html#method.try_get&quot;&gt;&lt;code&gt;OnceCell::try_get&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to get a reference to the initialized queue. If the queue is not initialized yet, we ignore the keyboard scancode and print a warning. It‚Äôs important that we don‚Äôt try to initialize the queue in this function because it will be called by the interrupt handler, which should not perform heap allocations. Since this function should not be callable from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, we use the &lt;code&gt;pub(crate)&lt;&#x2F;code&gt; visibility to make it only available to our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The fact that the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html#method.push&quot;&gt;&lt;code&gt;ArrayQueue::push&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method requires only a &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference makes it very simple to call the method on the static queue. The &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type performs all the necessary synchronization itself, so we don‚Äôt need a mutex wrapper here. In case the queue is full, we print a warning too.&lt;&#x2F;p&gt;
&lt;p&gt;To call the &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function on keyboard interrupts, we update our &lt;code&gt;keyboard_interrupt_handler&lt;&#x2F;code&gt; function in the &lt;code&gt;interrupts&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;keyboard_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ port.read() };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::task::keyboard::add_scancode(scancode); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We removed all the keyboard handling code from this function and instead added a call to the &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function. The rest of the function stays the same as before.&lt;&#x2F;p&gt;
&lt;p&gt;As expected, keypresses are no longer printed to the screen when we run our project using &lt;code&gt;cargo run&lt;&#x2F;code&gt; now. Instead, we see the warning that the scancode queue is uninitialized for every keystroke.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scancode-stream&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#scancode-stream&quot; aria-label=&quot;Anchor link for: scancode-stream&quot;&gt;üîó&lt;&#x2F;a&gt;Scancode Stream&lt;&#x2F;h4&gt;
&lt;p&gt;To initialize the &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; and read the scancodes from the queue in an asynchronous way, we create a new &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ScancodeStream {
&lt;&#x2F;span&gt;&lt;span&gt;    _private: (),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ScancodeStream {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE&lt;&#x2F;span&gt;&lt;span&gt;.try_init_once(|| ArrayQueue::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;            .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ScancodeStream::new should only be called once&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        ScancodeStream { _private: () }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The purpose of the &lt;code&gt;_private&lt;&#x2F;code&gt; field is to prevent construction of the struct from outside of the module. This makes the &lt;code&gt;new&lt;&#x2F;code&gt; function the only way to construct the type. In the function, we first try to initialize the &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; static. We panic if it is already initialized to ensure that only a single &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; instance can be created.&lt;&#x2F;p&gt;
&lt;p&gt;To make the scancodes available to asynchronous tasks, the next step is to implement a &lt;code&gt;poll&lt;&#x2F;code&gt;-like method that tries to pop the next scancode off the queue. While this sounds like we should implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait for our type, this does not quite fit here. The problem is that the &lt;code&gt;Future&lt;&#x2F;code&gt; trait only abstracts over a single asynchronous value and expects that the &lt;code&gt;poll&lt;&#x2F;code&gt; method is not called again after it returns &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. Our scancode queue, however, contains multiple asynchronous values, so it is okay to keep polling it.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;the-stream-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-stream-trait&quot; aria-label=&quot;Anchor link for: the-stream-trait&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;Stream&lt;&#x2F;code&gt; Trait&lt;&#x2F;h5&gt;
&lt;p&gt;Since types that yield multiple asynchronous values are common, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;&quot;&gt;&lt;code&gt;futures&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate provides a useful abstraction for such types: the &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;05_streams&#x2F;01_chapter.html&quot;&gt;&lt;code&gt;Stream&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait. The trait is defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Stream {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll_next(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Poll&amp;lt;Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Item&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This definition is quite similar to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, with the following differences:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The associated type is named &lt;code&gt;Item&lt;&#x2F;code&gt; instead of &lt;code&gt;Output&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Instead of a &lt;code&gt;poll&lt;&#x2F;code&gt; method that returns &lt;code&gt;Poll&amp;lt;Self::Item&amp;gt;&lt;&#x2F;code&gt;, the &lt;code&gt;Stream&lt;&#x2F;code&gt; trait defines a &lt;code&gt;poll_next&lt;&#x2F;code&gt; method that returns a &lt;code&gt;Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt;&amp;gt;&lt;&#x2F;code&gt; (note the additional &lt;code&gt;Option&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There is also a semantic difference: The &lt;code&gt;poll_next&lt;&#x2F;code&gt; can be called repeatedly, until it returns &lt;code&gt;Poll::Ready(None)&lt;&#x2F;code&gt; to signal that the stream is finished. In this regard, the method is similar to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;Iterator::next&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method, which also returns &lt;code&gt;None&lt;&#x2F;code&gt; after the last value.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;implementing-stream&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-stream&quot; aria-label=&quot;Anchor link for: implementing-stream&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing &lt;code&gt;Stream&lt;&#x2F;code&gt;&lt;&#x2F;h5&gt;
&lt;p&gt;Let‚Äôs implement the &lt;code&gt;Stream&lt;&#x2F;code&gt; trait for our &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; to provide the values of the &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; in an asynchronous way. For this, we first need to add a dependency on the &lt;code&gt;futures-util&lt;&#x2F;code&gt; crate, which contains the &lt;code&gt;Stream&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.futures-util&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.3.4&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;default-features &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;alloc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We disable the default features to make the crate &lt;code&gt;no_std&lt;&#x2F;code&gt; compatible and enable the &lt;code&gt;alloc&lt;&#x2F;code&gt; feature to make its allocation-based types available (we will need this later). &lt;span class=&quot;gray&quot;&gt;(Note that we could also add a dependency on the main &lt;code&gt;futures&lt;&#x2F;code&gt; crate, which re-exports the &lt;code&gt;futures-util&lt;&#x2F;code&gt; crate, but this would result in a larger number of dependencies and longer compile times.)&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now we can import and implement the &lt;code&gt;Stream&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::{pin::Pin, task::{Poll, Context}};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;futures_util::stream::Stream;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Stream &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ScancodeStream {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll_next(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; queue = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE&lt;&#x2F;span&gt;&lt;span&gt;.try_get().expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;not initialized&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; queue.pop() {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(scancode) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Poll::Ready(Some(scancode)),
&lt;&#x2F;span&gt;&lt;span&gt;            Err(crossbeam_queue::PopError) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Poll::Pending,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;raw&#x2F;struct.OnceCell.html#method.try_get&quot;&gt;&lt;code&gt;OnceCell::try_get&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to get a reference to the initialized scancode queue. This should never fail since we initialize the queue in the &lt;code&gt;new&lt;&#x2F;code&gt; function, so we can safely use the &lt;code&gt;expect&lt;&#x2F;code&gt; method to panic if it‚Äôs not initialized. Next, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html#method.pop&quot;&gt;&lt;code&gt;ArrayQueue::pop&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;  method to try to get the next element from the queue. If it succeeds, we return the scancode wrapped in &lt;code&gt;Poll::Ready(Some(‚Ä¶))&lt;&#x2F;code&gt;. If it fails, it means that the queue is empty. In that case, we return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;waker-support&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#waker-support&quot; aria-label=&quot;Anchor link for: waker-support&quot;&gt;üîó&lt;&#x2F;a&gt;Waker Support&lt;&#x2F;h4&gt;
&lt;p&gt;Like the &lt;code&gt;Futures::poll&lt;&#x2F;code&gt; method, the &lt;code&gt;Stream::poll_next&lt;&#x2F;code&gt; method requires the asynchronous task to notify the executor when it becomes ready after &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; is returned. This way, the executor does not need to poll the same task again until it is notified, which greatly reduces the performance overhead of waiting tasks.&lt;&#x2F;p&gt;
&lt;p&gt;To send this notification, the task should extract the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; from the passed &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; reference and store it somewhere. When the task becomes ready, it should invoke the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.Waker.html#method.wake&quot;&gt;&lt;code&gt;wake&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on the stored &lt;code&gt;Waker&lt;&#x2F;code&gt; to notify the executor that the task should be polled again.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;atomicwaker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#atomicwaker&quot; aria-label=&quot;Anchor link for: atomicwaker&quot;&gt;üîó&lt;&#x2F;a&gt;AtomicWaker&lt;&#x2F;h5&gt;
&lt;p&gt;To implement the &lt;code&gt;Waker&lt;&#x2F;code&gt; notification for our &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt;, we need a place where we can store the &lt;code&gt;Waker&lt;&#x2F;code&gt; between poll calls. We can‚Äôt store it as a field in the &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; itself because it needs to be accessible from the &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function. The solution to this is to use a static variable of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;futures_util&#x2F;task&#x2F;struct.AtomicWaker.html&quot;&gt;&lt;code&gt;AtomicWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type provided by the &lt;code&gt;futures-util&lt;&#x2F;code&gt; crate. Like the &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type, this type is based on atomic instructions and can be safely stored in a &lt;code&gt;static&lt;&#x2F;code&gt; and modified concurrently.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;futures_util&#x2F;task&#x2F;struct.AtomicWaker.html&quot;&gt;&lt;code&gt;AtomicWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type to define a static &lt;code&gt;WAKER&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;futures_util::task::AtomicWaker;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WAKER&lt;&#x2F;span&gt;&lt;span&gt;: AtomicWaker = AtomicWaker::new();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The idea is that the &lt;code&gt;poll_next&lt;&#x2F;code&gt; implementation stores the current waker in this static, and the &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function calls the &lt;code&gt;wake&lt;&#x2F;code&gt; function on it when a new scancode is added to the queue.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;storing-a-waker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#storing-a-waker&quot; aria-label=&quot;Anchor link for: storing-a-waker&quot;&gt;üîó&lt;&#x2F;a&gt;Storing a Waker&lt;&#x2F;h5&gt;
&lt;p&gt;The contract defined by &lt;code&gt;poll&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;poll_next&lt;&#x2F;code&gt; requires  the task to register a wakeup for the passed &lt;code&gt;Waker&lt;&#x2F;code&gt; when it returns &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. Let‚Äôs modify our &lt;code&gt;poll_next&lt;&#x2F;code&gt; implementation to satisfy this requirement:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Stream &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ScancodeStream {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;poll_next(self: Pin&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, cx: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Context) -&amp;gt; Poll&amp;lt;Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; queue = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE
&lt;&#x2F;span&gt;&lt;span&gt;            .try_get()
&lt;&#x2F;span&gt;&lt;span&gt;            .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;scancode queue not initialized&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; fast path
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(scancode) = queue.pop() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Poll::Ready(Some(scancode));
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WAKER&lt;&#x2F;span&gt;&lt;span&gt;.register(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;cx.waker());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; queue.pop() {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(scancode) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WAKER&lt;&#x2F;span&gt;&lt;span&gt;.take();
&lt;&#x2F;span&gt;&lt;span&gt;                Poll::Ready(Some(scancode))
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            Err(crossbeam_queue::PopError) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Poll::Pending,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like before, we first use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;conquer-once&#x2F;0.2.0&#x2F;conquer_once&#x2F;raw&#x2F;struct.OnceCell.html#method.try_get&quot;&gt;&lt;code&gt;OnceCell::try_get&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to get a reference to the initialized scancode queue. We then optimistically try to &lt;code&gt;pop&lt;&#x2F;code&gt; from the queue and return &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt; when it succeeds. This way, we can avoid the performance overhead of registering a waker when the queue is not empty.&lt;&#x2F;p&gt;
&lt;p&gt;If the first call to &lt;code&gt;queue.pop()&lt;&#x2F;code&gt; does not succeed, the queue is potentially empty. Only potentially because the interrupt handler might have filled the queue asynchronously immediately after the check. Since this race condition can occur again for the next check, we need to register the &lt;code&gt;Waker&lt;&#x2F;code&gt; in the &lt;code&gt;WAKER&lt;&#x2F;code&gt; static before the second check. This way, a wakeup might happen before we return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;, but it is guaranteed that we get a wakeup for any scancodes pushed after the check.&lt;&#x2F;p&gt;
&lt;p&gt;After registering the &lt;code&gt;Waker&lt;&#x2F;code&gt; contained in the passed &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; through the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;futures_util&#x2F;task&#x2F;struct.AtomicWaker.html#method.register&quot;&gt;&lt;code&gt;AtomicWaker::register&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function, we try to pop from the queue a second time. If it now succeeds, we return &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. We also remove the registered waker again using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;0.3.4&#x2F;futures&#x2F;task&#x2F;struct.AtomicWaker.html#method.take&quot;&gt;&lt;code&gt;AtomicWaker::take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; because a waker notification is no longer needed. In case &lt;code&gt;queue.pop()&lt;&#x2F;code&gt; fails for a second time, we return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; like before, but this time with a registered wakeup.&lt;&#x2F;p&gt;
&lt;p&gt;Note that there are two ways that a wakeup can happen for a task that did not return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; (yet). One way is the mentioned race condition when the wakeup happens immediately before returning &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;. The other way is when the queue is no longer empty after registering the waker, so that &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt; is returned. Since these spurious wakeups are not preventable, the executor needs to be able to handle them correctly.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;waking-the-stored-waker&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#waking-the-stored-waker&quot; aria-label=&quot;Anchor link for: waking-the-stored-waker&quot;&gt;üîó&lt;&#x2F;a&gt;Waking the Stored Waker&lt;&#x2F;h5&gt;
&lt;p&gt;To wake the stored &lt;code&gt;Waker&lt;&#x2F;code&gt;, we add a call to &lt;code&gt;WAKER.wake()&lt;&#x2F;code&gt; in the &lt;code&gt;add_scancode&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;add_scancode(scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(queue) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SCANCODE_QUEUE&lt;&#x2F;span&gt;&lt;span&gt;.try_get() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Err(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = queue.push(scancode) {
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WARNING: scancode queue full; dropping keyboard input&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WAKER&lt;&#x2F;span&gt;&lt;span&gt;.wake(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WARNING: scancode queue uninitialized&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only change that we made is to add a call to &lt;code&gt;WAKER.wake()&lt;&#x2F;code&gt; if the push to the scancode queue succeeds. If a waker is registered in the &lt;code&gt;WAKER&lt;&#x2F;code&gt; static, this method will call the equally-named &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.Waker.html#method.wake&quot;&gt;&lt;code&gt;wake&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on it, which notifies the executor. Otherwise, the operation is a no-op, i.e., nothing happens.&lt;&#x2F;p&gt;
&lt;p&gt;It is important that we call &lt;code&gt;wake&lt;&#x2F;code&gt; only after pushing to the queue because otherwise the task might be woken too early while the queue is still empty. This can, for example, happen when using a multi-threaded executor that starts the woken task concurrently on a different CPU core. While we don‚Äôt have thread support yet, we will add it soon and don‚Äôt want things to break then.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;keyboard-task&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#keyboard-task&quot; aria-label=&quot;Anchor link for: keyboard-task&quot;&gt;üîó&lt;&#x2F;a&gt;Keyboard Task&lt;&#x2F;h4&gt;
&lt;p&gt;Now that we implemented the &lt;code&gt;Stream&lt;&#x2F;code&gt; trait for our &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt;, we can use it to create an asynchronous keyboard task:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;keyboard.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;futures_util::stream::StreamExt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;pc_keyboard::{layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::print;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;print_keypresses() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; scancodes = ScancodeStream::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; keyboard = Keyboard::new(layouts::Us104Key, ScancodeSet1,
&lt;&#x2F;span&gt;&lt;span&gt;        HandleControl::Ignore);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(scancode) = scancodes.next().await {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(Some(key_event)) = keyboard.add_byte(scancode) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(key) = keyboard.process_keyevent(key_event) {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; key {
&lt;&#x2F;span&gt;&lt;span&gt;                    DecodedKey::Unicode(character) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, character),
&lt;&#x2F;span&gt;&lt;span&gt;                    DecodedKey::RawKey(key) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, key),
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code is very similar to the code we had in our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;#interpreting-the-scancodes&quot;&gt;keyboard interrupt handler&lt;&#x2F;a&gt; before we modified it in this post. The only difference is that, instead of reading the scancode from an I&#x2F;O port, we take it from the &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt;. For this, we first create a new &lt;code&gt;Scancode&lt;&#x2F;code&gt; stream and then repeatedly use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;futures_util&#x2F;stream&#x2F;trait.StreamExt.html#method.next&quot;&gt;&lt;code&gt;next&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-util&#x2F;0.3.4&#x2F;futures_util&#x2F;stream&#x2F;trait.StreamExt.html&quot;&gt;&lt;code&gt;StreamExt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait to get a &lt;code&gt;Future&lt;&#x2F;code&gt; that resolves to the next element in the stream. By using the &lt;code&gt;await&lt;&#x2F;code&gt; operator on it, we asynchronously wait for the result of the future.&lt;&#x2F;p&gt;
&lt;p&gt;We use &lt;code&gt;while let&lt;&#x2F;code&gt; to loop until the stream returns &lt;code&gt;None&lt;&#x2F;code&gt; to signal its end. Since our &lt;code&gt;poll_next&lt;&#x2F;code&gt; method never returns &lt;code&gt;None&lt;&#x2F;code&gt;, this is effectively an endless loop, so the &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task never finishes.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add the &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task to our executor in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; to get working keyboard input again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::task::keyboard; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] initialization routines, including init_heap, test_main
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; executor = SimpleExecutor::new();
&lt;&#x2F;span&gt;&lt;span&gt;    executor.spawn(Task::new(example_task()));
&lt;&#x2F;span&gt;&lt;span&gt;    executor.spawn(Task::new(keyboard::print_keypresses())); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    executor.run();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] &amp;quot;it did not crash&amp;quot; message, hlt_loop
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we execute &lt;code&gt;cargo run&lt;&#x2F;code&gt; now, we see that keyboard input works again:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;qemu-keyboard-output.gif&quot; alt=&quot;QEMU printing ‚Äú‚Ä¶..H‚Ä¶e‚Ä¶l‚Ä¶l..o‚Ä¶.. ‚Ä¶W..o..r‚Ä¶.l‚Ä¶d‚Ä¶!‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you keep an eye on the CPU utilization of your computer, you will see that the &lt;code&gt;QEMU&lt;&#x2F;code&gt; process now continuously keeps the CPU busy. This happens because our &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt; polls tasks over and over again in a loop. So even if we don‚Äôt press any keys on the keyboard, the executor repeatedly calls &lt;code&gt;poll&lt;&#x2F;code&gt; on our &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task, even though the task cannot make any progress and will return &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt; each time.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;executor-with-waker-support&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#executor-with-waker-support&quot; aria-label=&quot;Anchor link for: executor-with-waker-support&quot;&gt;üîó&lt;&#x2F;a&gt;Executor with Waker Support&lt;&#x2F;h3&gt;
&lt;p&gt;To fix the performance problem, we need to create an executor that properly utilizes the &lt;code&gt;Waker&lt;&#x2F;code&gt; notifications. This way, the executor is notified when the next keyboard interrupt occurs, so it does not need to keep polling the &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task over and over again.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;task-id&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#task-id&quot; aria-label=&quot;Anchor link for: task-id&quot;&gt;üîó&lt;&#x2F;a&gt;Task Id&lt;&#x2F;h4&gt;
&lt;p&gt;The first step in creating an executor with proper support for waker notifications is to give each task a unique ID. This is required because we need a way to specify which task should be woken. We start by creating a new &lt;code&gt;TaskId&lt;&#x2F;code&gt; wrapper type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TaskId(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;TaskId&lt;&#x2F;code&gt; struct is a simple wrapper type around &lt;code&gt;u64&lt;&#x2F;code&gt;. We derive a number of traits for it to make it printable, copyable, comparable, and sortable. The latter is important because we want to use &lt;code&gt;TaskId&lt;&#x2F;code&gt; as the key type of a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; in a moment.&lt;&#x2F;p&gt;
&lt;p&gt;To create a new unique ID, we create a &lt;code&gt;TaskId::new&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::sync::atomic::{AtomicU64, Ordering};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TaskId {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;NEXT_ID&lt;&#x2F;span&gt;&lt;span&gt;: AtomicU64 = AtomicU64::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        TaskId(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;NEXT_ID&lt;&#x2F;span&gt;&lt;span&gt;.fetch_add(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, Ordering::Relaxed))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function uses a static &lt;code&gt;NEXT_ID&lt;&#x2F;code&gt; variable of type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;struct.AtomicU64.html&quot;&gt;&lt;code&gt;AtomicU64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to ensure that each ID is assigned only once. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;struct.AtomicU64.html#method.fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method atomically increases the value and returns the previous value in one atomic operation. This means that even when the &lt;code&gt;TaskId::new&lt;&#x2F;code&gt; method is called in parallel, every ID is returned exactly once. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;enum.Ordering.html&quot;&gt;&lt;code&gt;Ordering&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; parameter defines whether the compiler is allowed to reorder the &lt;code&gt;fetch_add&lt;&#x2F;code&gt; operation in the instructions stream. Since we only require that the ID be unique, the &lt;code&gt;Relaxed&lt;&#x2F;code&gt; ordering with the weakest requirements is enough in this case.&lt;&#x2F;p&gt;
&lt;p&gt;We can now extend our &lt;code&gt;Task&lt;&#x2F;code&gt; type with an additional &lt;code&gt;id&lt;&#x2F;code&gt; field:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Task {
&lt;&#x2F;span&gt;&lt;span&gt;    id: TaskId, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    future: Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = ()&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Task {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(future: impl Future&amp;lt;Output = ()&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Task {
&lt;&#x2F;span&gt;&lt;span&gt;        Task {
&lt;&#x2F;span&gt;&lt;span&gt;            id: TaskId::new(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;            future: Box::pin(future),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The new &lt;code&gt;id&lt;&#x2F;code&gt; field makes it possible to uniquely name a task, which is required for waking a specific task.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-executor-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-executor-type&quot; aria-label=&quot;Anchor link for: the-executor-type&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;Executor&lt;&#x2F;code&gt; Type&lt;&#x2F;h4&gt;
&lt;p&gt;We create our new &lt;code&gt;Executor&lt;&#x2F;code&gt; type in a &lt;code&gt;task::executor&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;executor;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::{Task, TaskId};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::{collections::BTreeMap, sync::Arc};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::Waker;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;crossbeam_queue::ArrayQueue;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    tasks: BTreeMap&amp;lt;TaskId, Task&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    waker_cache: BTreeMap&amp;lt;TaskId, Waker&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Executor {
&lt;&#x2F;span&gt;&lt;span&gt;            tasks: BTreeMap::new(),
&lt;&#x2F;span&gt;&lt;span&gt;            task_queue: Arc::new(ArrayQueue::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;            waker_cache: BTreeMap::new(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of storing tasks in a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; like we did for our &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt;, we use a &lt;code&gt;task_queue&lt;&#x2F;code&gt; of task IDs and a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; named &lt;code&gt;tasks&lt;&#x2F;code&gt; that contains the actual &lt;code&gt;Task&lt;&#x2F;code&gt; instances. The map is indexed by the &lt;code&gt;TaskId&lt;&#x2F;code&gt; to allow efficient continuation of a specific task.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;task_queue&lt;&#x2F;code&gt; field is an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html&quot;&gt;&lt;code&gt;ArrayQueue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; of task IDs, wrapped into the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type that implements &lt;em&gt;reference counting&lt;&#x2F;em&gt;. Reference counting makes it possible to share ownership of the value among multiple owners. It works by allocating the value on the heap and counting the number of active references to it. When the number of active references reaches zero, the value is no longer needed and can be deallocated.&lt;&#x2F;p&gt;
&lt;p&gt;We use this &lt;code&gt;Arc&amp;lt;ArrayQueue&amp;gt;&lt;&#x2F;code&gt; type for the &lt;code&gt;task_queue&lt;&#x2F;code&gt; because it will be shared between the executor and wakers. The idea is that the wakers push the ID of the woken task to the queue. The executor sits on the receiving end of the queue, retrieves the woken tasks by their ID from the &lt;code&gt;tasks&lt;&#x2F;code&gt; map, and then runs them. The reason for using a fixed-size queue instead of an unbounded queue such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam-queue&#x2F;0.2.1&#x2F;crossbeam_queue&#x2F;struct.SegQueue.html&quot;&gt;&lt;code&gt;SegQueue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is that interrupt handlers should not allocate on push to this queue.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to the &lt;code&gt;task_queue&lt;&#x2F;code&gt; and the &lt;code&gt;tasks&lt;&#x2F;code&gt; map, the &lt;code&gt;Executor&lt;&#x2F;code&gt; type has a &lt;code&gt;waker_cache&lt;&#x2F;code&gt; field that is also a map. This map caches the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; of a task after its creation. This has two reasons: First, it improves performance by reusing the same waker for multiple wake-ups of the same task instead of creating a new waker each time. Second, it ensures that reference-counted wakers are not deallocated inside interrupt handlers because it could lead to deadlocks (there are more details on this below).&lt;&#x2F;p&gt;
&lt;p&gt;To create an &lt;code&gt;Executor&lt;&#x2F;code&gt;, we provide a simple &lt;code&gt;new&lt;&#x2F;code&gt; function. We choose a capacity of 100 for the &lt;code&gt;task_queue&lt;&#x2F;code&gt;, which should be more than enough for the foreseeable future. In case our system will have more than 100 concurrent tasks at some point, we can easily increase this size.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;spawning-tasks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spawning-tasks&quot; aria-label=&quot;Anchor link for: spawning-tasks&quot;&gt;üîó&lt;&#x2F;a&gt;Spawning Tasks&lt;&#x2F;h4&gt;
&lt;p&gt;As for the &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt;, we provide a &lt;code&gt;spawn&lt;&#x2F;code&gt; method on our &lt;code&gt;Executor&lt;&#x2F;code&gt; type that adds a given task to the &lt;code&gt;tasks&lt;&#x2F;code&gt; map and immediately wakes it by pushing its ID to the &lt;code&gt;task_queue&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;spawn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, task: Task) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task_id = task.id;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.tasks.insert(task.id, task).is_some() {
&lt;&#x2F;span&gt;&lt;span&gt;            panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;task with same ID already in tasks&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        self.task_queue.push(task_id).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;queue full&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If there is already a task with the same ID in the map, the [&lt;code&gt;BTreeMap::insert&lt;&#x2F;code&gt;] method returns it. This should never happen since each task has a unique ID, so we panic in this case since it indicates a bug in our code. Similarly, we panic when the &lt;code&gt;task_queue&lt;&#x2F;code&gt; is full since this should never happen if we choose a large-enough queue size.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;running-tasks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-tasks&quot; aria-label=&quot;Anchor link for: running-tasks&quot;&gt;üîó&lt;&#x2F;a&gt;Running Tasks&lt;&#x2F;h4&gt;
&lt;p&gt;To execute all tasks in the &lt;code&gt;task_queue&lt;&#x2F;code&gt;, we create a private &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::task::{Context, Poll};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run_ready_tasks(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; destructure `self` to avoid borrow checker errors
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            tasks,
&lt;&#x2F;span&gt;&lt;span&gt;            task_queue,
&lt;&#x2F;span&gt;&lt;span&gt;            waker_cache,
&lt;&#x2F;span&gt;&lt;span&gt;        } = self;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Ok(task_id) = task_queue.pop() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; tasks.get_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;task_id) {
&lt;&#x2F;span&gt;&lt;span&gt;                Some(task) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; task,
&lt;&#x2F;span&gt;&lt;span&gt;                None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; continue&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; task no longer exists
&lt;&#x2F;span&gt;&lt;span&gt;            };
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; waker = waker_cache
&lt;&#x2F;span&gt;&lt;span&gt;                .entry(task_id)
&lt;&#x2F;span&gt;&lt;span&gt;                .or_insert_with(|| TaskWaker::new(task_id, task_queue.clone()));
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; context = Context::from_waker(waker);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; task.poll(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; context) {
&lt;&#x2F;span&gt;&lt;span&gt;                Poll::Ready(()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; task done -&amp;gt; remove it and its cached waker
&lt;&#x2F;span&gt;&lt;span&gt;                    tasks.remove(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;task_id);
&lt;&#x2F;span&gt;&lt;span&gt;                    waker_cache.remove(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;task_id);
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                Poll::Pending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The basic idea of this function is similar to our &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt;: Loop over all tasks in the &lt;code&gt;task_queue&lt;&#x2F;code&gt;, create a waker for each task, and then poll them. However, instead of adding pending tasks back to the end of the &lt;code&gt;task_queue&lt;&#x2F;code&gt;, we let our &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; implementation take care of adding woken tasks back to the queue. The implementation of this waker type will be shown in a moment.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs look into some of the implementation details of this &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-03-pattern-syntax.html#destructuring-to-break-apart-values&quot;&gt;&lt;em&gt;destructuring&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; to split &lt;code&gt;self&lt;&#x2F;code&gt; into its three fields to avoid some borrow checker errors. Namely, our implementation needs to access the &lt;code&gt;self.task_queue&lt;&#x2F;code&gt; from within a closure, which currently tries to borrow &lt;code&gt;self&lt;&#x2F;code&gt; completely. This is a fundamental borrow checker issue that will be resolved when &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2229&quot;&gt;RFC 2229&lt;&#x2F;a&gt; is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;53488&quot;&gt;implemented&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;For each popped task ID, we retrieve a mutable reference to the corresponding task from the &lt;code&gt;tasks&lt;&#x2F;code&gt; map. Since our &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; implementation registers wakers before checking whether a task needs to be put to sleep, it might happen that a wake-up occurs for a task that no longer exists. In this case, we simply ignore the wake-up and continue with the next ID from the queue.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;To avoid the performance overhead of creating a waker on each poll, we use the &lt;code&gt;waker_cache&lt;&#x2F;code&gt; map to store the waker for each task after it has been created. For this, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html#method.entry&quot;&gt;&lt;code&gt;BTreeMap::entry&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method in combination with &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;enum.Entry.html#method.or_insert_with&quot;&gt;&lt;code&gt;Entry::or_insert_with&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to create a new waker if it doesn‚Äôt exist yet and then get a mutable reference to it. For creating a new waker, we clone the &lt;code&gt;task_queue&lt;&#x2F;code&gt; and pass it together with the task ID to the &lt;code&gt;TaskWaker::new&lt;&#x2F;code&gt; function (implementation shown below). Since the &lt;code&gt;task_queue&lt;&#x2F;code&gt; is wrapped into an &lt;code&gt;Arc&lt;&#x2F;code&gt;, the &lt;code&gt;clone&lt;&#x2F;code&gt; only increases the reference count of the value, but still points to the same heap-allocated queue. Note that reusing wakers like this is not possible for all waker implementations, but our &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type will allow it.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;A task is finished when it returns &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;. In that case, we remove it from the &lt;code&gt;tasks&lt;&#x2F;code&gt; map using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html#method.remove&quot;&gt;&lt;code&gt;BTreeMap::remove&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. We also remove its cached waker, if it exists.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;waker-design&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#waker-design&quot; aria-label=&quot;Anchor link for: waker-design&quot;&gt;üîó&lt;&#x2F;a&gt;Waker Design&lt;&#x2F;h4&gt;
&lt;p&gt;The job of the waker is to push the ID of the woken task to the &lt;code&gt;task_queue&lt;&#x2F;code&gt; of the executor. We implement this by creating a new &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; struct that stores the task ID and a reference to the &lt;code&gt;task_queue&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TaskWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    task_id: TaskId,
&lt;&#x2F;span&gt;&lt;span&gt;    task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the ownership of the &lt;code&gt;task_queue&lt;&#x2F;code&gt; is shared between the executor and wakers, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper type to implement shared reference-counted ownership.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of the wake operation is quite simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TaskWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wake_task(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.task_queue.push(self.task_id).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;task_queue full&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We push the &lt;code&gt;task_id&lt;&#x2F;code&gt; to the referenced &lt;code&gt;task_queue&lt;&#x2F;code&gt;. Since modifications to the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crossbeam&#x2F;0.7.3&#x2F;crossbeam&#x2F;queue&#x2F;struct.ArrayQueue.html&quot;&gt;&lt;code&gt;ArrayQueue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type only require a shared reference, we can implement this method on &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; instead of &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;the-wake-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-wake-trait&quot; aria-label=&quot;Anchor link for: the-wake-trait&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;Wake&lt;&#x2F;code&gt; Trait&lt;&#x2F;h5&gt;
&lt;p&gt;In order to use our &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type for polling futures, we need to convert it to a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance first. This is required because the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;future&#x2F;trait.Future.html#tymethod.poll&quot;&gt;&lt;code&gt;Future::poll&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method takes a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Context.html&quot;&gt;&lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance as an argument, which can only be constructed from the &lt;code&gt;Waker&lt;&#x2F;code&gt; type. While we could do this by providing an implementation of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html&quot;&gt;&lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type, it‚Äôs both simpler and safer to instead implement the &lt;code&gt;Arc&lt;&#x2F;code&gt;-based &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;task&#x2F;trait.Wake.html&quot;&gt;&lt;code&gt;Wake&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait and then use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;convert&#x2F;trait.From.html&quot;&gt;&lt;code&gt;From&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; implementations provided by the standard library to construct the &lt;code&gt;Waker&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The trait implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::task::Wake;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Wake &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;TaskWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wake(self: Arc&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.wake_task();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wake_by_ref(self: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Arc&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.wake_task();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since wakers are commonly shared between the executor and the asynchronous tasks, the trait methods require that the &lt;code&gt;Self&lt;&#x2F;code&gt; instance is wrapped in the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type, which implements reference-counted ownership. This means that we have to move our &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; to an &lt;code&gt;Arc&lt;&#x2F;code&gt; in order to call them.&lt;&#x2F;p&gt;
&lt;p&gt;The difference between the &lt;code&gt;wake&lt;&#x2F;code&gt; and &lt;code&gt;wake_by_ref&lt;&#x2F;code&gt; methods is that the latter only requires a reference to the &lt;code&gt;Arc&lt;&#x2F;code&gt;, while the former takes ownership of the &lt;code&gt;Arc&lt;&#x2F;code&gt; and thus often requires an increase of the reference count. Not all types support waking by reference, so implementing the &lt;code&gt;wake_by_ref&lt;&#x2F;code&gt; method is optional. However, it can lead to better performance because it avoids unnecessary reference count modifications. In our case, we can simply forward both trait methods to our &lt;code&gt;wake_task&lt;&#x2F;code&gt; function, which requires only a shared &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;creating-wakers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-wakers&quot; aria-label=&quot;Anchor link for: creating-wakers&quot;&gt;üîó&lt;&#x2F;a&gt;Creating Wakers&lt;&#x2F;h5&gt;
&lt;p&gt;Since the &lt;code&gt;Waker&lt;&#x2F;code&gt; type supports &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;convert&#x2F;trait.From.html&quot;&gt;&lt;code&gt;From&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; conversions for all &lt;code&gt;Arc&lt;&#x2F;code&gt;-wrapped values that implement the &lt;code&gt;Wake&lt;&#x2F;code&gt; trait, we can now implement the &lt;code&gt;TaskWaker::new&lt;&#x2F;code&gt; function that is required by our &lt;code&gt;Executor::run_ready_tasks&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TaskWaker {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(task_id: TaskId, task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;) -&amp;gt; Waker {
&lt;&#x2F;span&gt;&lt;span&gt;        Waker::from(Arc::new(TaskWaker {
&lt;&#x2F;span&gt;&lt;span&gt;            task_id,
&lt;&#x2F;span&gt;&lt;span&gt;            task_queue,
&lt;&#x2F;span&gt;&lt;span&gt;        }))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We create the &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; using the passed &lt;code&gt;task_id&lt;&#x2F;code&gt; and &lt;code&gt;task_queue&lt;&#x2F;code&gt;. We then wrap the &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; in an &lt;code&gt;Arc&lt;&#x2F;code&gt; and use the &lt;code&gt;Waker::from&lt;&#x2F;code&gt; implementation to convert it to a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;task&#x2F;struct.Waker.html&quot;&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. This &lt;code&gt;from&lt;&#x2F;code&gt; method takes care of constructing a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWakerVTable.html&quot;&gt;&lt;code&gt;RawWakerVTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;task&#x2F;struct.RawWaker.html&quot;&gt;&lt;code&gt;RawWaker&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance for our &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type. In case you‚Äôre interested in how it works in detail, check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;cdb50c6f2507319f29104a25765bfb79ad53395c&#x2F;src&#x2F;liballoc&#x2F;task.rs#L58-L87&quot;&gt;implementation in the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-run-method-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-run-method-1&quot; aria-label=&quot;Anchor link for: a-run-method-1&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;run&lt;&#x2F;code&gt; Method&lt;&#x2F;h4&gt;
&lt;p&gt;With our waker implementation in place, we can finally construct a &lt;code&gt;run&lt;&#x2F;code&gt; method for our executor:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            self.run_ready_tasks();
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This method just calls the &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt; function in a loop. While we could theoretically return from the function when the &lt;code&gt;tasks&lt;&#x2F;code&gt; map becomes empty, this would never happen since our &lt;code&gt;keyboard_task&lt;&#x2F;code&gt; never finishes, so a simple &lt;code&gt;loop&lt;&#x2F;code&gt; should suffice. Since the function never returns, we use the &lt;code&gt;!&lt;&#x2F;code&gt; return type to mark the function as &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;rust-by-example&#x2F;fn&#x2F;diverging.html&quot;&gt;diverging&lt;&#x2F;a&gt; to the compiler.&lt;&#x2F;p&gt;
&lt;p&gt;We can now change our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; to use our new &lt;code&gt;Executor&lt;&#x2F;code&gt; instead of the &lt;code&gt;SimpleExecutor&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::task::executor::Executor; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] initialization routines, including init_heap, test_main
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; executor = Executor::new(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    executor.spawn(Task::new(example_task()));
&lt;&#x2F;span&gt;&lt;span&gt;    executor.spawn(Task::new(keyboard::print_keypresses()));
&lt;&#x2F;span&gt;&lt;span&gt;    executor.run();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We only need to change the import and the type name. Since our &lt;code&gt;run&lt;&#x2F;code&gt; function is marked as diverging, the compiler knows that it never returns, so we no longer need a call to &lt;code&gt;hlt_loop&lt;&#x2F;code&gt; at the end of our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;When we run our kernel using &lt;code&gt;cargo run&lt;&#x2F;code&gt; now, we see that keyboard input still works:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;async-await&#x2F;qemu-keyboard-output-again.gif&quot; alt=&quot;QEMU printing ‚Äú‚Ä¶..H‚Ä¶e‚Ä¶l‚Ä¶l..o‚Ä¶.. ‚Ä¶a..g..a‚Ä¶.i‚Ä¶n‚Ä¶!‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;However, the CPU utilization of QEMU did not get any better. The reason for this is that we still keep the CPU busy the whole time. We no longer poll tasks until they are woken again, but we still check the &lt;code&gt;task_queue&lt;&#x2F;code&gt; in a busy loop. To fix this, we need to put the CPU to sleep if there is no more work to do.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sleep-if-idle&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sleep-if-idle&quot; aria-label=&quot;Anchor link for: sleep-if-idle&quot;&gt;üîó&lt;&#x2F;a&gt;Sleep If Idle&lt;&#x2F;h4&gt;
&lt;p&gt;The basic idea is to execute the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HLT_(x86_instruction)&quot;&gt;&lt;code&gt;hlt&lt;&#x2F;code&gt; instruction&lt;&#x2F;a&gt; when the &lt;code&gt;task_queue&lt;&#x2F;code&gt; is empty. This instruction puts the CPU to sleep until the next interrupt arrives. The fact that the CPU immediately becomes active again on interrupts ensures that we can still directly react when an interrupt handler pushes to the &lt;code&gt;task_queue&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To implement this, we create a new &lt;code&gt;sleep_if_idle&lt;&#x2F;code&gt; method in our executor and call it from our &lt;code&gt;run&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            self.run_ready_tasks();
&lt;&#x2F;span&gt;&lt;span&gt;            self.sleep_if_idle();   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;sleep_if_idle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.task_queue.is_empty() {
&lt;&#x2F;span&gt;&lt;span&gt;            x86_64::instructions::hlt();
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we call &lt;code&gt;sleep_if_idle&lt;&#x2F;code&gt; directly after &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt;, which loops until the &lt;code&gt;task_queue&lt;&#x2F;code&gt; becomes empty, checking the queue again might seem unnecessary. However, a hardware interrupt might occur directly after &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt; returns, so there might be a new task in the queue at the time the &lt;code&gt;sleep_if_idle&lt;&#x2F;code&gt; function is called. Only if the queue is still empty, do we put the CPU to sleep by executing the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction through the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;fn.hlt.html&quot;&gt;&lt;code&gt;instructions::hlt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper function provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;index.html&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, there is still a subtle race condition in this implementation. Since interrupts are asynchronous and can happen at any time, it is possible that an interrupt happens right between the &lt;code&gt;is_empty&lt;&#x2F;code&gt; check and the call to &lt;code&gt;hlt&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.task_queue.is_empty() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; &amp;lt;--- interrupt can happen here
&lt;&#x2F;span&gt;&lt;span&gt;    x86_64::instructions::hlt();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In case this interrupt pushes to the &lt;code&gt;task_queue&lt;&#x2F;code&gt;, we put the CPU to sleep even though there is now a ready task. In the worst case, this could delay the handling of a keyboard interrupt until the next keypress or the next timer interrupt. So how do we prevent it?&lt;&#x2F;p&gt;
&lt;p&gt;The answer is to disable interrupts on the CPU before the check and atomically enable them again together with the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction. This way, all interrupts that happen in between are delayed after the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction so that no wake-ups are missed. To implement this approach, we can use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;interrupts&#x2F;fn.enable_and_hlt.html&quot;&gt;&lt;code&gt;interrupts::enable_and_hlt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;index.html&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;The updated implementation of our &lt;code&gt;sleep_if_idle&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;task&#x2F;executor.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Executor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;sleep_if_idle(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::interrupts::{self, enable_and_hlt};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        interrupts::disable();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.task_queue.is_empty() {
&lt;&#x2F;span&gt;&lt;span&gt;            enable_and_hlt();
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            interrupts::enable();
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To avoid race conditions, we disable interrupts before checking whether the &lt;code&gt;task_queue&lt;&#x2F;code&gt; is empty. If it is, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;interrupts&#x2F;fn.enable_and_hlt.html&quot;&gt;&lt;code&gt;enable_and_hlt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to enable interrupts and put the CPU to sleep as a single atomic operation. In case the queue is no longer empty, it means that an interrupt woke a task after &lt;code&gt;run_ready_tasks&lt;&#x2F;code&gt; returned. In that case, we enable interrupts again and directly continue execution without executing &lt;code&gt;hlt&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now our executor properly puts the CPU to sleep when there is nothing to do. We can see that the QEMU process has a much lower CPU utilization when we run our kernel using &lt;code&gt;cargo run&lt;&#x2F;code&gt; again.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;possible-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#possible-extensions&quot; aria-label=&quot;Anchor link for: possible-extensions&quot;&gt;üîó&lt;&#x2F;a&gt;Possible Extensions&lt;&#x2F;h4&gt;
&lt;p&gt;Our executor is now able to run tasks in an efficient way. It utilizes waker notifications to avoid polling waiting tasks and puts the CPU to sleep when there is currently no work to do. However, our executor is still quite basic, and there are many possible ways to extend its functionality:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scheduling&lt;&#x2F;strong&gt;: For our &lt;code&gt;task_queue&lt;&#x2F;code&gt;, we currently use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type to implement a &lt;em&gt;first in first out&lt;&#x2F;em&gt; (FIFO) strategy, which is often also called &lt;em&gt;round robin&lt;&#x2F;em&gt; scheduling. This strategy might not be the most efficient for all workloads. For example, it might make sense to prioritize latency-critical tasks or tasks that do a lot of I&#x2F;O. See the &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;cpu-sched.pdf&quot;&gt;scheduling chapter&lt;&#x2F;a&gt; of the &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;&quot;&gt;&lt;em&gt;Operating Systems: Three Easy Pieces&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; book or the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scheduling_(computing)&quot;&gt;Wikipedia article on scheduling&lt;&#x2F;a&gt; for more information.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Task Spawning&lt;&#x2F;strong&gt;: Our &lt;code&gt;Executor::spawn&lt;&#x2F;code&gt; method currently requires a &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; reference and is thus no longer available after invoking the &lt;code&gt;run&lt;&#x2F;code&gt; method. To fix this, we could create an additional &lt;code&gt;Spawner&lt;&#x2F;code&gt; type that shares some kind of queue with the executor and allows task creation from within tasks themselves. The queue could be the &lt;code&gt;task_queue&lt;&#x2F;code&gt; directly or a separate queue that the executor checks in its run loop.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Utilizing Threads&lt;&#x2F;strong&gt;: We don‚Äôt have support for threads yet, but we will add it in the next post. This will make it possible to launch multiple instances of the executor in different threads. The advantage of this approach is that the delay imposed by long-running tasks can be reduced because other tasks can run concurrently. This approach also allows it to utilize multiple CPU cores.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Load Balancing&lt;&#x2F;strong&gt;: When adding threading support, it becomes important to know how to distribute the tasks between the executors to ensure that all CPU cores are utilized. A common technique for this is &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Work_stealing&quot;&gt;&lt;em&gt;work stealing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;We started this post by introducing &lt;strong&gt;multitasking&lt;&#x2F;strong&gt; and differentiating between &lt;em&gt;preemptive&lt;&#x2F;em&gt; multitasking, which forcibly interrupts running tasks regularly, and &lt;em&gt;cooperative&lt;&#x2F;em&gt; multitasking, which lets tasks run until they voluntarily give up control of the CPU.&lt;&#x2F;p&gt;
&lt;p&gt;We then explored how Rust‚Äôs support of &lt;strong&gt;async&#x2F;await&lt;&#x2F;strong&gt; provides a language-level implementation of cooperative multitasking. Rust bases its implementation on top of the polling-based &lt;code&gt;Future&lt;&#x2F;code&gt; trait, which abstracts asynchronous tasks. Using async&#x2F;await, it is possible to work with futures almost like with normal synchronous code. The difference is that asynchronous functions return a &lt;code&gt;Future&lt;&#x2F;code&gt; again, which needs to be added to an executor at some point in order to run it.&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, the compiler transforms async&#x2F;await code to &lt;em&gt;state machines&lt;&#x2F;em&gt;, with each &lt;code&gt;.await&lt;&#x2F;code&gt; operation corresponding to a possible pause point. By utilizing its knowledge about the program, the compiler is able to save only the minimal state for each pause point, resulting in a very small memory consumption per task. One challenge is that the generated state machines might contain &lt;em&gt;self-referential&lt;&#x2F;em&gt; structs, for example when local variables of the asynchronous function reference each other. To prevent pointer invalidation, Rust uses the &lt;code&gt;Pin&lt;&#x2F;code&gt; type to ensure that futures cannot be moved in memory anymore after they have been polled for the first time.&lt;&#x2F;p&gt;
&lt;p&gt;For our &lt;strong&gt;implementation&lt;&#x2F;strong&gt;, we first created a very basic executor that polls all spawned tasks in a busy loop without using the &lt;code&gt;Waker&lt;&#x2F;code&gt; type at all. We then showed the advantage of waker notifications by implementing an asynchronous keyboard task. The task defines a static &lt;code&gt;SCANCODE_QUEUE&lt;&#x2F;code&gt; using the mutex-free &lt;code&gt;ArrayQueue&lt;&#x2F;code&gt; type provided by the &lt;code&gt;crossbeam&lt;&#x2F;code&gt; crate. Instead of handling keypresses directly, the keyboard interrupt handler now puts all received scancodes in the queue and then wakes the registered &lt;code&gt;Waker&lt;&#x2F;code&gt; to signal that new input is available. On the receiving end, we created a &lt;code&gt;ScancodeStream&lt;&#x2F;code&gt; type to provide a &lt;code&gt;Future&lt;&#x2F;code&gt; resolving to the next scancode in the queue. This made it possible to create an asynchronous &lt;code&gt;print_keypresses&lt;&#x2F;code&gt; task that uses async&#x2F;await to interpret and print the scancodes in the queue.&lt;&#x2F;p&gt;
&lt;p&gt;To utilize the waker notifications of the keyboard task, we created a new &lt;code&gt;Executor&lt;&#x2F;code&gt; type that uses an &lt;code&gt;Arc&lt;&#x2F;code&gt;-shared &lt;code&gt;task_queue&lt;&#x2F;code&gt; for ready tasks. We implemented a &lt;code&gt;TaskWaker&lt;&#x2F;code&gt; type that pushes the ID of woken tasks directly to this &lt;code&gt;task_queue&lt;&#x2F;code&gt;, which are then polled again by the executor. To save power when no tasks are runnable, we added support for putting the CPU to sleep using the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction. Finally, we discussed some potential extensions to our executor, for example, providing multi-core support.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs Next?&lt;&#x2F;h2&gt;
&lt;p&gt;Using async&#x2F;wait, we now have basic support for cooperative multitasking in our kernel. While cooperative multitasking is very efficient, it leads to latency problems when individual tasks keep running for too long, thus preventing other tasks from running. For this reason, it makes sense to also add support for preemptive multitasking to our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;In the next post, we will introduce &lt;em&gt;threads&lt;&#x2F;em&gt; as the most common form of preemptive multitasking. In addition to resolving the problem of long-running tasks, threads will also prepare us for utilizing multiple CPU cores and running untrusted user programs in the future.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in February 2020</title>
                <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2020-03-02/</link>
                <guid>https://os.phil-opp.com/status-update/2020-03-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;722&quot;&gt;Mention potential bump allocator extensions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;738&quot;&gt;Don‚Äôt panic on overflow in allocator; return null pointer instead&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;739&quot;&gt;Update Allocator Designs post to signal OOM instead of panicking on overflow&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;747&quot;&gt;Update to Zola 0.10&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;694&quot;&gt;Add translations from rustcc&#x2F;writing-an-os-in-rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;748&quot;&gt;Some fixes to generated translations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;749&quot;&gt;Add metadata to translations and list translators&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;752&quot;&gt;Add a language selector for browser-supported languages&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;751&quot;&gt;Use zola check to check for dead links; fix all dead links found&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;commit&#x2F;0619f3a9e766c575ba1a4f2c6825049c177f8c70&quot;&gt;Convert all external links to https (if supported)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;732&quot;&gt;Mention in ‚ÄúPaging Introduction‚Äù that a CPU with 5-level paging is available now&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;commit&#x2F;b532c052add9d3eac18663f1836bc9eee11007af&quot;&gt;Double Faults: A missing handler leads to a #GP exception (not a #NP)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;756&quot;&gt;Updated pc-keyboard to &lt;code&gt;0.5.0&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RKennedy9064&quot;&gt;@RKennedy9064&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides support for CPU-specific instructions, registers, and data structures of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture. There were lots of great contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;119&quot;&gt;Add User Mode registers&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released together with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;118&quot;&gt;#118&lt;&#x2F;a&gt; as v0.9.0)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;122&quot;&gt;Improve PageTableIndex and PageOffset&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.1)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;124&quot;&gt;Remove the &lt;code&gt;cast&lt;&#x2F;code&gt; dependency&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.2)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;126&quot;&gt;Fix GitHub actions to run latest available rustfmt&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;127&quot;&gt;Enable usage with non-nightly rust&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.3)&lt;&#x2F;span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;128&quot;&gt;asm: add target_env = ‚Äúmusl‚Äù to pickup the underscore asm names&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.4)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;129&quot;&gt;Add &lt;code&gt;#[inline]&lt;&#x2F;code&gt; attribute to small functions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;AntoineSebert&quot;&gt;@AntoineSebert&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.9.5)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;130&quot;&gt;Fix clippy warnings&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;AntoineSebert&quot;&gt;@AntoineSebert&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;132&quot;&gt;Resolve remaining clippy warnings and add clippy job to CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two small bugfixes and one new feature this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;94&quot;&gt;Objcopy replaces &lt;code&gt;.&lt;&#x2F;code&gt; chars with &lt;code&gt;_&lt;&#x2F;code&gt; chars&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.6)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;commit&#x2F;af4f1016aa19fec3271226f8bfc2145521cf0c98&quot;&gt;Fix docs.rs build by specifying an explicit target&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.7)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;96&quot;&gt;Add basic support for ELF thread local storage segments&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.8)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate provides support for cross-compiling &lt;code&gt;libcore&lt;&#x2F;code&gt; and &lt;code&gt;liballoc&lt;&#x2F;code&gt;. It received the following contributions this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;56&quot;&gt;Added new option to the configuration table&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;56&quot;&gt;@parraman&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released an v0.5.22)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;57&quot;&gt;Pick up xbuild config from workspace manifest&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.23)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;59&quot;&gt;Make &lt;code&gt;fn build&lt;&#x2F;code&gt; and &lt;code&gt;Args&lt;&#x2F;code&gt; public to enable use as lib&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.24)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;61&quot;&gt;Fix: Not all projects have a root package&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.25)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;62&quot;&gt;Improvements to args and config for lib usage&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ascjones&quot;&gt;@ascjones&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.26)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;64&quot;&gt;Add &lt;code&gt;cargo xfix&lt;&#x2F;code&gt; command&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tjhu&quot;&gt;@tjhu&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.27)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;65&quot;&gt;Update dependencies&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;parasyte&quot;&gt;@parasyte&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.5.28)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate, which provides basic support for uart_16550 serial output, received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;6&quot;&gt;Switch CI to GitHub Actions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;5&quot;&gt;Cargo.toml: update x86_64 dependency&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.2.3)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;7&quot;&gt;Enable usage with non-nightly rust&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.2.4)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;multiboot2-elf64&quot;&gt;&lt;code&gt;multiboot2-elf64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;multiboot2-elf64&lt;&#x2F;code&gt; crate provides abstractions for reading the boot information of the multiboot 2 standard, which is implemented by bootloaders like GRUB. There were two updates to the crate in February:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;61&quot;&gt;Add MemoryAreaType, to allow users to access memory area types in a type-safe way&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;CWood1&quot;&gt;@CWood1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;62&quot;&gt;Add some basic documentation&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;multiboot2-elf64&#x2F;pull&#x2F;62&quot;&gt;@mental32&lt;&#x2F;a&gt; &lt;span class=&quot;gray&quot;&gt;(released as v0.8.2)&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in January 2020</title>
                <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2020-02-01/</link>
                <guid>https://os.phil-opp.com/status-update/2020-02-01/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;714&quot;&gt;Move #[global_allocator] into allocator module&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;716&quot;&gt;Update many_boxes test to scale with heap size&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;719&quot;&gt;New post about allocator designs&lt;&#x2F;a&gt; üéâ&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;721&quot;&gt;Provide multiple implementations of align_up and mention performance&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;725&quot;&gt;Refactor Simplified Chinese translation of post 3&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rustin-Liu&quot;&gt;@Rustin-Liu&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;726&quot;&gt;Use checked addition for allocator implementations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;728&quot;&gt;Fix dummy allocator code example&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;729&quot;&gt;Some style updates to the front page&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;733&quot;&gt;Mark active item in table of contents&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;734&quot;&gt;Make active section link more discreet&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Menschenkindlein&quot;&gt;@Menschenkindlein&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I also started working on the upcoming post about threads.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The bootloader crate received two minor updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;91&quot;&gt;Move architecture checks from build script into lib.rs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;92&quot;&gt;Update x86_64 dependency to version 0.8.3&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Since I focused my time on the new &lt;em&gt;Allocator Designs&lt;&#x2F;em&gt; post, I did not have the time to make more progress on my plan to rewrite the 16-bit&#x2F;32-bit stages of the bootloader in Rust. I hope to get back to it soon.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The following changes were merged this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;115&quot;&gt;Allow immediate port version of in&#x2F;out instructions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;116&quot;&gt;Make more functions const&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;m-ou-se&quot;&gt;@m-ou-se&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Released as version 0.8.3&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;118&quot;&gt;Return the UnusedPhysFrame on MapToError::PageAlreadyMapped&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;This is a &lt;strong&gt;breaking change&lt;&#x2F;strong&gt; since it changes the signature of a type.&lt;&#x2F;li&gt;
&lt;li&gt;No new release was published yet to give us the option to bundle it with other breaking changes.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There are also some pull requests that have some open design questions and are still being discussed:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;114&quot;&gt;Add p23_insert_flag_mask argument to mapper.map_to()&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Related proposal: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;issues&#x2F;121&quot;&gt;Page Table Visitors&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mark-i-m&quot;&gt;@mark-i-m&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;119&quot;&gt;Add User Mode registers&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Please feel free to join these discussions if you have opinions on the matter.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate, which cross-compiles the sysroot, received the following updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;52&quot;&gt;Override target path for building sysroot&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;upsuper&quot;&gt;@upsuper&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Published as version 0.5.21&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate, which provides basic support for uart_16550 serial output, received a small dependency update:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;4&quot;&gt;Update dependency for x86_64&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haraldh&quot;&gt;@haraldh&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Published as version 0.2.2&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Allocator Designs</title>
                <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/allocator-designs/</link>
                <guid>https://os.phil-opp.com/allocator-designs/</guid>
                <description>&lt;p&gt;This post explains how to implement heap allocators from scratch. It presents and discusses different allocator designs, including bump allocation, linked list allocation, and fixed-size block allocation. For each of the three designs, we will create a basic implementation that can be used for our kernel.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-11&quot;&gt;&lt;code&gt;post-11&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt;, we added basic support for heap allocations to our kernel. For that, we &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#creating-a-kernel-heap&quot;&gt;created a new memory region&lt;&#x2F;a&gt; in the page tables and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#using-an-allocator-crate&quot;&gt;used the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate&lt;&#x2F;a&gt; to manage that memory. While we have a working heap now, we left most of the work to the allocator crate without trying to understand how it works.&lt;&#x2F;p&gt;
&lt;p&gt;In this post, we will show how to create our own heap allocator from scratch instead of relying on an existing allocator crate. We will discuss different allocator designs, including a simplistic &lt;em&gt;bump allocator&lt;&#x2F;em&gt; and a basic &lt;em&gt;fixed-size block allocator&lt;&#x2F;em&gt;, and use this knowledge to implement an allocator with improved performance (compared to the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;design-goals&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#design-goals&quot; aria-label=&quot;Anchor link for: design-goals&quot;&gt;üîó&lt;&#x2F;a&gt;Design Goals&lt;&#x2F;h3&gt;
&lt;p&gt;The responsibility of an allocator is to manage the available heap memory. It needs to return unused memory on &lt;code&gt;alloc&lt;&#x2F;code&gt; calls and keep track of memory freed by &lt;code&gt;dealloc&lt;&#x2F;code&gt; so that it can be reused again. Most importantly, it must never hand out memory that is already in use somewhere else because this would cause undefined behavior.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from correctness, there are many secondary design goals. For example, the allocator should effectively utilize the available memory and keep &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)&quot;&gt;&lt;em&gt;fragmentation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; low. Furthermore, it should work well for concurrent applications and scale to any number of processors. For maximal performance, it could even optimize the memory layout with respect to the CPU caches to improve &lt;a href=&quot;https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;locality-of-reference-and-cache-operation-in-cache-memory&#x2F;&quot;&gt;cache locality&lt;&#x2F;a&gt; and avoid &lt;a href=&quot;https:&#x2F;&#x2F;mechanical-sympathy.blogspot.de&#x2F;2011&#x2F;07&#x2F;false-sharing.html&quot;&gt;false sharing&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These requirements can make good allocators very complex. For example, &lt;a href=&quot;http:&#x2F;&#x2F;jemalloc.net&#x2F;&quot;&gt;jemalloc&lt;&#x2F;a&gt; has over 30.000 lines of code. This complexity is often undesired in kernel code, where a single bug can lead to severe security vulnerabilities. Fortunately, the allocation patterns of kernel code are often much simpler compared to userspace code, so that relatively simple allocator designs often suffice.&lt;&#x2F;p&gt;
&lt;p&gt;In the following, we present three possible kernel allocator designs and explain their advantages and drawbacks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bump-allocator&quot; aria-label=&quot;Anchor link for: bump-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Bump Allocator&lt;&#x2F;h2&gt;
&lt;p&gt;The most simple allocator design is a &lt;em&gt;bump allocator&lt;&#x2F;em&gt; (also known as &lt;em&gt;stack allocator&lt;&#x2F;em&gt;). It allocates memory linearly and only keeps track of the number of allocated bytes and the number of allocations. It is only useful in very specific use cases because it has a severe limitation: it can only free all memory at once.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;idea&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#idea&quot; aria-label=&quot;Anchor link for: idea&quot;&gt;üîó&lt;&#x2F;a&gt;Idea&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind a bump allocator is to linearly allocate memory by increasing (&lt;em&gt;‚Äúbumping‚Äù&lt;&#x2F;em&gt;) a &lt;code&gt;next&lt;&#x2F;code&gt; variable, which points to the start of the unused memory. At the beginning, &lt;code&gt;next&lt;&#x2F;code&gt; is equal to the start address of the heap. On each allocation, &lt;code&gt;next&lt;&#x2F;code&gt; is increased by the allocation size so that it always points to the boundary between used and unused memory:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;bump-allocation.svg&quot; alt=&quot;The heap memory area at three points in time: 1: A single allocation exists at the start of the heap; the next pointer points to its end. 2: A second allocation was added right after the first; the next pointer points to the end of the second allocation. 3: A third allocation was added right after the second one; the next pointer points to the end of the third allocation.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;next&lt;&#x2F;code&gt; pointer only moves in a single direction and thus never hands out the same memory region twice. When it reaches the end of the heap, no more memory can be allocated, resulting in an out-of-memory error on the next allocation.&lt;&#x2F;p&gt;
&lt;p&gt;A bump allocator is often implemented with an allocation counter, which is increased by 1 on each &lt;code&gt;alloc&lt;&#x2F;code&gt; call and decreased by 1 on each &lt;code&gt;dealloc&lt;&#x2F;code&gt; call. When the allocation counter reaches zero, it means that all allocations on the heap have been deallocated. In this case, the &lt;code&gt;next&lt;&#x2F;code&gt; pointer can be reset to the start address of the heap, so that the complete heap memory is available for allocations again.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;We start our implementation by declaring a new &lt;code&gt;allocator::bump&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;bump;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The content of the submodule lives in a new &lt;code&gt;src&#x2F;allocator&#x2F;bump.rs&lt;&#x2F;code&gt; file, which we create with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;bump.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    allocations: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates a new empty bump allocator.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;            heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            next: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            allocations: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Initializes the bump allocator with the given heap bounds.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This method is unsafe because the caller must ensure that the given
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; memory range is unused. Also, this method must be called only once.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, heap_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.heap_start = heap_start;
&lt;&#x2F;span&gt;&lt;span&gt;        self.heap_end = heap_start + heap_size;
&lt;&#x2F;span&gt;&lt;span&gt;        self.next = heap_start;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;heap_start&lt;&#x2F;code&gt; and &lt;code&gt;heap_end&lt;&#x2F;code&gt; fields keep track of the lower and upper bounds of the heap memory region. The caller needs to ensure that these addresses are valid, otherwise the allocator would return invalid memory. For this reason, the &lt;code&gt;init&lt;&#x2F;code&gt; function needs to be &lt;code&gt;unsafe&lt;&#x2F;code&gt; to call.&lt;&#x2F;p&gt;
&lt;p&gt;The purpose of the &lt;code&gt;next&lt;&#x2F;code&gt; field is to always point to the first unused byte of the heap, i.e., the start address of the next allocation. It is set to &lt;code&gt;heap_start&lt;&#x2F;code&gt; in the &lt;code&gt;init&lt;&#x2F;code&gt; function because at the beginning, the entire heap is unused. On each allocation, this field will be increased by the allocation size (&lt;em&gt;‚Äúbumped‚Äù&lt;&#x2F;em&gt;) to ensure that we don‚Äôt return the same memory region twice.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;allocations&lt;&#x2F;code&gt; field is a simple counter for the active allocations with the goal of resetting the allocator after the last allocation has been freed. It is initialized with 0.&lt;&#x2F;p&gt;
&lt;p&gt;We chose to create a separate &lt;code&gt;init&lt;&#x2F;code&gt; function instead of performing the initialization directly in &lt;code&gt;new&lt;&#x2F;code&gt; in order to keep the interface identical to the allocator provided by the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate. This way, the allocators can be switched without additional code changes.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementing-globalalloc&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-globalalloc&quot; aria-label=&quot;Anchor link for: implementing-globalalloc&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;As &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#the-allocator-interface&quot;&gt;explained in the previous post&lt;&#x2F;a&gt;, all heap allocators need to implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, which is defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_zeroed(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;realloc(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;        ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        layout: Layout,
&lt;&#x2F;span&gt;&lt;span&gt;        new_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Only the &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; methods are required; the other two methods have default implementations and can be omitted.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;first-implementation-attempt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#first-implementation-attempt&quot; aria-label=&quot;Anchor link for: first-implementation-attempt&quot;&gt;üîó&lt;&#x2F;a&gt;First Implementation Attempt&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs try to implement the &lt;code&gt;alloc&lt;&#x2F;code&gt; method for our &lt;code&gt;BumpAllocator&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;bump.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO alignment and bounds check
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_start = self.next;
&lt;&#x2F;span&gt;&lt;span&gt;        self.next = alloc_start + layout.size();
&lt;&#x2F;span&gt;&lt;span&gt;        self.allocations += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, _layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        todo!();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we use the &lt;code&gt;next&lt;&#x2F;code&gt; field as the start address for our allocation. Then we update the &lt;code&gt;next&lt;&#x2F;code&gt; field to point to the end address of the allocation, which is the next unused address on the heap. Before returning the start address of the allocation as a &lt;code&gt;*mut u8&lt;&#x2F;code&gt; pointer, we increase the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter by 1.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we don‚Äôt perform any bounds checks or alignment adjustments, so this implementation is not safe yet. This does not matter much because it fails to compile anyway with the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0594]: cannot assign to `self.next` which is behind a `&amp;amp;` reference
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;allocator&#x2F;bump.rs:29:9
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;29 |         self.next = alloc_start + layout.size();
&lt;&#x2F;span&gt;&lt;span&gt;   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;amp;` reference, so the data it refers to cannot be written
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(The same error also occurs for the &lt;code&gt;self.allocations += 1&lt;&#x2F;code&gt; line. We omitted it here for brevity.)&lt;&#x2F;p&gt;
&lt;p&gt;The error occurs because the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.alloc&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; methods of the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait only operate on an immutable &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference, so updating the &lt;code&gt;next&lt;&#x2F;code&gt; and &lt;code&gt;allocations&lt;&#x2F;code&gt; fields is not possible. This is problematic because updating &lt;code&gt;next&lt;&#x2F;code&gt; on every allocation is the essential principle of a bump allocator.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;globalalloc-and-mutability&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#globalalloc-and-mutability&quot; aria-label=&quot;Anchor link for: globalalloc-and-mutability&quot;&gt;üîó&lt;&#x2F;a&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; and Mutability&lt;&#x2F;h4&gt;
&lt;p&gt;Before we look at a possible solution to this mutability problem, let‚Äôs try to understand why the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait methods are defined with &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; arguments: As we saw &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#the-global-allocator-attribute&quot;&gt;in the previous post&lt;&#x2F;a&gt;, the global heap allocator is defined by adding the &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute to a &lt;code&gt;static&lt;&#x2F;code&gt; that implements the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait. Static variables are immutable in Rust, so there is no way to call a method that takes &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; on the static allocator. For this reason, all the methods of &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; only take an immutable &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, there is a way to get a &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; reference from a &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference: We can use synchronized &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html&quot;&gt;interior mutability&lt;&#x2F;a&gt; by wrapping the allocator in a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.0&#x2F;spin&#x2F;struct.Mutex.html&quot;&gt;&lt;code&gt;spin::Mutex&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; spinlock. This type provides a &lt;code&gt;lock&lt;&#x2F;code&gt; method that performs &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mutual_exclusion&quot;&gt;mutual exclusion&lt;&#x2F;a&gt; and thus safely turns a &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; reference to a &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; reference. We‚Äôve already used the wrapper type multiple times in our kernel, for example for the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#spinlocks&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-locked-wrapper-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-locked-wrapper-type&quot; aria-label=&quot;Anchor link for: a-locked-wrapper-type&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;Locked&lt;&#x2F;code&gt; Wrapper Type&lt;&#x2F;h4&gt;
&lt;p&gt;With the help of the &lt;code&gt;spin::Mutex&lt;&#x2F;code&gt; wrapper type, we can implement the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait for our bump allocator. The trick is to implement the trait not for the &lt;code&gt;BumpAllocator&lt;&#x2F;code&gt; directly, but for the wrapped &lt;code&gt;spin::Mutex&amp;lt;BumpAllocator&amp;gt;&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex&amp;lt;BumpAllocator&amp;gt; {‚Ä¶}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately, this still doesn‚Äôt work because the Rust compiler does not permit trait implementations for types defined in other crates:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;allocator&#x2F;bump.rs:28:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;28 | unsafe impl GlobalAlloc for spin::Mutex&amp;lt;BumpAllocator&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------------------------
&lt;&#x2F;span&gt;&lt;span&gt;   | |                           |
&lt;&#x2F;span&gt;&lt;span&gt;   | |                           `spin::mutex::Mutex` is not defined in the current crate
&lt;&#x2F;span&gt;&lt;span&gt;   | impl doesn&amp;#39;t use only types from inside the current crate
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = note: define and implement a trait or new type instead
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To fix this, we need to create our own wrapper type around &lt;code&gt;spin::Mutex&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A wrapper around spin::Mutex to permit trait implementations.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Locked&amp;lt;A&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    inner: spin::Mutex&amp;lt;A&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;A&amp;gt; Locked&amp;lt;A&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new(inner: A) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Locked {
&lt;&#x2F;span&gt;&lt;span&gt;            inner: spin::Mutex::new(inner),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;lock(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; spin::MutexGuard&amp;lt;A&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        self.inner.lock()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type is a generic wrapper around a &lt;code&gt;spin::Mutex&amp;lt;A&amp;gt;&lt;&#x2F;code&gt;. It imposes no restrictions on the wrapped type &lt;code&gt;A&lt;&#x2F;code&gt;, so it can be used to wrap all kinds of types, not just allocators. It provides a simple &lt;code&gt;new&lt;&#x2F;code&gt; constructor function that wraps a given value. For convenience, it also provides a &lt;code&gt;lock&lt;&#x2F;code&gt; function that calls &lt;code&gt;lock&lt;&#x2F;code&gt; on the wrapped &lt;code&gt;Mutex&lt;&#x2F;code&gt;. Since the &lt;code&gt;Locked&lt;&#x2F;code&gt; type is general enough to be useful for other allocator implementations too, we put it in the parent &lt;code&gt;allocator&lt;&#x2F;code&gt; module.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;implementation-for-locked-bumpallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-for-locked-bumpallocator&quot; aria-label=&quot;Anchor link for: implementation-for-locked-bumpallocator&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation for &lt;code&gt;Locked&amp;lt;BumpAllocator&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;Locked&lt;&#x2F;code&gt; type is defined in our own crate (in contrast to &lt;code&gt;spin::Mutex&lt;&#x2F;code&gt;), so we can use it to implement &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; for our bump allocator. The full implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;bump.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::{align_up, Locked};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Locked&amp;lt;BumpAllocator&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; bump = self.lock(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; get a mutable reference
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_start = align_up(bump.next, layout.align());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_end = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; alloc_start.checked_add(layout.size()) {
&lt;&#x2F;span&gt;&lt;span&gt;            Some(end) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; end,
&lt;&#x2F;span&gt;&lt;span&gt;            None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; return &lt;&#x2F;span&gt;&lt;span&gt;ptr::null_mut(),
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; alloc_end &amp;gt; bump.heap_end {
&lt;&#x2F;span&gt;&lt;span&gt;            ptr::null_mut() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; out of memory
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            bump.next = alloc_end;
&lt;&#x2F;span&gt;&lt;span&gt;            bump.allocations += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, _layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; bump = self.lock(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; get a mutable reference
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        bump.allocations -= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; bump.allocations == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            bump.next = bump.heap_start;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first step for both &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; is to call the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.0&#x2F;spin&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method through the &lt;code&gt;inner&lt;&#x2F;code&gt; field to get a mutable reference to the wrapped allocator type. The instance remains locked until the end of the method, so that no data race can occur in multithreaded contexts (we will add threading support soon).&lt;&#x2F;p&gt;
&lt;p&gt;Compared to the previous prototype, the &lt;code&gt;alloc&lt;&#x2F;code&gt; implementation now respects alignment requirements and performs a bounds check to ensure that the allocations stay inside the heap memory region. The first step is to round up the &lt;code&gt;next&lt;&#x2F;code&gt; address to the alignment specified by the &lt;code&gt;Layout&lt;&#x2F;code&gt; argument. The code for the &lt;code&gt;align_up&lt;&#x2F;code&gt; function is shown in a moment. We then add the requested allocation size to &lt;code&gt;alloc_start&lt;&#x2F;code&gt; to get the end address of the allocation. To prevent integer overflow on large allocations, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.usize.html#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. If an overflow occurs or if the resulting end address of the allocation is larger than the end address of the heap, we return a null pointer to signal an out-of-memory situation. Otherwise, we update the &lt;code&gt;next&lt;&#x2F;code&gt; address and increase the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter by 1 like before. Finally, we return the &lt;code&gt;alloc_start&lt;&#x2F;code&gt; address converted to a &lt;code&gt;*mut u8&lt;&#x2F;code&gt; pointer.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;dealloc&lt;&#x2F;code&gt; function ignores the given pointer and &lt;code&gt;Layout&lt;&#x2F;code&gt; arguments. Instead, it just decreases the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter. If the counter reaches &lt;code&gt;0&lt;&#x2F;code&gt; again, it means that all allocations were freed again. In this case, it resets the &lt;code&gt;next&lt;&#x2F;code&gt; address to the &lt;code&gt;heap_start&lt;&#x2F;code&gt; address to make the complete heap memory available again.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;address-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#address-alignment&quot; aria-label=&quot;Anchor link for: address-alignment&quot;&gt;üîó&lt;&#x2F;a&gt;Address Alignment&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;align_up&lt;&#x2F;code&gt; function is general enough that we can put it into the parent &lt;code&gt;allocator&lt;&#x2F;code&gt; module. A basic implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Align the given address `addr` upwards to alignment `align`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;align_up(addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remainder = addr % align;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; remainder == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; addr already aligned
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        addr - remainder + align
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function first computes the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Euclidean_division&quot;&gt;remainder&lt;&#x2F;a&gt; of the division of &lt;code&gt;addr&lt;&#x2F;code&gt; by &lt;code&gt;align&lt;&#x2F;code&gt;. If the remainder is &lt;code&gt;0&lt;&#x2F;code&gt;, the address is already aligned with the given alignment. Otherwise, we align the address by subtracting the remainder (so that the new remainder is 0) and then adding the alignment (so that the address does not become smaller than the original address).&lt;&#x2F;p&gt;
&lt;p&gt;Note that this isn‚Äôt the most efficient way to implement this function. A much faster implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Align the given address `addr` upwards to alignment `align`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Requires that `align` is a power of two.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;align_up(addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    (addr + align - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; !&lt;&#x2F;span&gt;&lt;span&gt;(align - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This method requires &lt;code&gt;align&lt;&#x2F;code&gt; to be a power of two, which can be guaranteed by utilizing the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait (and its &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; parameter). This makes it possible to create a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mask_(computing)&quot;&gt;bitmask&lt;&#x2F;a&gt; to align the address in a very efficient way. To understand how it works, let‚Äôs go through it step by step, starting on the right side:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Since &lt;code&gt;align&lt;&#x2F;code&gt; is a power of two, its &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_number#Representation&quot;&gt;binary representation&lt;&#x2F;a&gt; has only a single bit set (e.g. &lt;code&gt;0b000100000&lt;&#x2F;code&gt;). This means that &lt;code&gt;align - 1&lt;&#x2F;code&gt; has all the lower bits set (e.g. &lt;code&gt;0b00011111&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;By creating the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitwise_operation#NOT&quot;&gt;bitwise &lt;code&gt;NOT&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; through the &lt;code&gt;!&lt;&#x2F;code&gt; operator, we get a number that has all the bits set except for the bits lower than &lt;code&gt;align&lt;&#x2F;code&gt; (e.g. &lt;code&gt;0b‚Ä¶111111111100000&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;By performing a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bitwise_operation#AND&quot;&gt;bitwise &lt;code&gt;AND&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; on an address and &lt;code&gt;!(align - 1)&lt;&#x2F;code&gt;, we align the address &lt;em&gt;downwards&lt;&#x2F;em&gt;. This works by clearing all the bits that are lower than &lt;code&gt;align&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Since we want to align upwards instead of downwards, we increase the &lt;code&gt;addr&lt;&#x2F;code&gt; by &lt;code&gt;align - 1&lt;&#x2F;code&gt; before performing the bitwise &lt;code&gt;AND&lt;&#x2F;code&gt;. This way, already aligned addresses remain the same while non-aligned addresses are rounded to the next alignment boundary.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Which variant you choose is up to you. Both compute the same result, only using different methods.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-it&quot; aria-label=&quot;Anchor link for: using-it&quot;&gt;üîó&lt;&#x2F;a&gt;Using It&lt;&#x2F;h3&gt;
&lt;p&gt;To use the bump allocator instead of the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate, we need to update the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static in &lt;code&gt;allocator.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bump::BumpAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: Locked&amp;lt;BumpAllocator&amp;gt; = Locked::new(BumpAllocator::new());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here it becomes important that we declared &lt;code&gt;BumpAllocator::new&lt;&#x2F;code&gt; and &lt;code&gt;Locked::new&lt;&#x2F;code&gt; as &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;functions.html#const-functions&quot;&gt;&lt;code&gt;const&lt;&#x2F;code&gt; functions&lt;&#x2F;a&gt;. If they were normal functions, a compilation error would occur because the initialization expression of a &lt;code&gt;static&lt;&#x2F;code&gt; must be evaluable at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;We don‚Äôt need to change the  &lt;code&gt;ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE)&lt;&#x2F;code&gt; call in our &lt;code&gt;init_heap&lt;&#x2F;code&gt; function because the bump allocator provides the same interface as the allocator provided by the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now our kernel uses our bump allocator! Everything should still work, including the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#adding-a-test&quot;&gt;&lt;code&gt;heap_allocation&lt;&#x2F;code&gt; tests&lt;&#x2F;a&gt; that we created in the previous post:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --test heap_allocation
&lt;&#x2F;span&gt;&lt;span&gt;[‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;Running 3 tests
&lt;&#x2F;span&gt;&lt;span&gt;simple_allocation... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;large_vec... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;discussion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion&quot; aria-label=&quot;Anchor link for: discussion&quot;&gt;üîó&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h3&gt;
&lt;p&gt;The big advantage of bump allocation is that it‚Äôs very fast. Compared to other allocator designs (see below) that need to actively look for a fitting memory block and perform various bookkeeping tasks on &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt;, a bump allocator &lt;a href=&quot;https:&#x2F;&#x2F;fitzgeraldnick.com&#x2F;2019&#x2F;11&#x2F;01&#x2F;always-bump-downwards.html&quot;&gt;can be optimized&lt;&#x2F;a&gt; to just a few assembly instructions. This makes bump allocators useful for optimizing the allocation performance, for example when creating a &lt;a href=&quot;https:&#x2F;&#x2F;hacks.mozilla.org&#x2F;2019&#x2F;03&#x2F;fast-bump-allocated-virtual-doms-with-rust-and-wasm&#x2F;&quot;&gt;virtual DOM library&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;While a bump allocator is seldom used as the global allocator, the principle of bump allocation is often applied in the form of &lt;a href=&quot;https:&#x2F;&#x2F;mgravell.github.io&#x2F;Pipelines.Sockets.Unofficial&#x2F;docs&#x2F;arenas.html&quot;&gt;arena allocation&lt;&#x2F;a&gt;, which basically batches individual allocations together to improve performance. An example of an arena allocator for Rust is contained in the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;toolshed&#x2F;0.8.1&#x2F;toolshed&#x2F;index.html&quot;&gt;&lt;code&gt;toolshed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-drawback-of-a-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-drawback-of-a-bump-allocator&quot; aria-label=&quot;Anchor link for: the-drawback-of-a-bump-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;The Drawback of a Bump Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;The main limitation of a bump allocator is that it can only reuse deallocated memory after all allocations have been freed. This means that a single long-lived allocation suffices to prevent memory reuse. We can see this when we add a variation of the &lt;code&gt;many_boxes&lt;&#x2F;code&gt; test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;many_boxes_long_lived() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; long_lived = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = Box::new(i);
&lt;&#x2F;span&gt;&lt;span&gt;        assert_eq!(*x, i);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(*long_lived, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like the &lt;code&gt;many_boxes&lt;&#x2F;code&gt; test, this test creates a large number of allocations to provoke an out-of-memory failure if the allocator does not reuse freed memory. Additionally, the test creates a &lt;code&gt;long_lived&lt;&#x2F;code&gt; allocation, which lives for the whole loop execution.&lt;&#x2F;p&gt;
&lt;p&gt;When we try to run our new test, we see that it indeed fails:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --test heap_allocation
&lt;&#x2F;span&gt;&lt;span&gt;Running 4 tests
&lt;&#x2F;span&gt;&lt;span&gt;simple_allocation... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;large_vec... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes_long_lived... [failed]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Error: panicked at &amp;#39;allocation error: Layout { size_: 8, align_: 8 }&amp;#39;, src&#x2F;lib.rs:86:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs try to understand why this failure occurs in detail: First, the &lt;code&gt;long_lived&lt;&#x2F;code&gt; allocation is created at the start of the heap, thereby increasing the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter by 1. For each iteration of the loop, a short-lived allocation is created and directly freed again before the next iteration starts. This means that the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter is temporarily increased to 2 at the beginning of an iteration and decreased to 1 at the end of it. The problem now is that the bump allocator can only reuse memory after &lt;em&gt;all&lt;&#x2F;em&gt; allocations have been freed, i.e., when the &lt;code&gt;allocations&lt;&#x2F;code&gt; counter falls to 0. Since this doesn‚Äôt happen before the end of the loop, each loop iteration allocates a new region of memory, leading to an out-of-memory error after a number of iterations.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fixing-the-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-test&quot; aria-label=&quot;Anchor link for: fixing-the-test&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the Test?&lt;&#x2F;h4&gt;
&lt;p&gt;There are two potential tricks that we could utilize to fix the test for our bump allocator:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We could update &lt;code&gt;dealloc&lt;&#x2F;code&gt; to check whether the freed allocation was the last allocation returned by &lt;code&gt;alloc&lt;&#x2F;code&gt; by comparing its end address with the &lt;code&gt;next&lt;&#x2F;code&gt; pointer. In case they‚Äôre equal, we can safely reset &lt;code&gt;next&lt;&#x2F;code&gt; back to the start address of the freed allocation. This way, each loop iteration reuses the same memory block.&lt;&#x2F;li&gt;
&lt;li&gt;We could add an &lt;code&gt;alloc_back&lt;&#x2F;code&gt; method that allocates memory from the &lt;em&gt;end&lt;&#x2F;em&gt; of the heap using an additional &lt;code&gt;next_back&lt;&#x2F;code&gt; field. Then we could manually use this allocation method for all long-lived allocations, thereby separating short-lived and long-lived allocations on the heap. Note that this separation only works if it‚Äôs clear beforehand how long each allocation will live. Another drawback of this approach is that manually performing allocations is cumbersome and potentially unsafe.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While both of these approaches work to fix the test, they are not a general solution since they are only able to reuse memory in very specific cases. The question is: Is there a general solution that reuses &lt;em&gt;all&lt;&#x2F;em&gt; freed memory?&lt;&#x2F;p&gt;
&lt;h4 id=&quot;reusing-all-freed-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reusing-all-freed-memory&quot; aria-label=&quot;Anchor link for: reusing-all-freed-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Reusing All Freed Memory?&lt;&#x2F;h4&gt;
&lt;p&gt;As we learned &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#dynamic-memory&quot;&gt;in the previous post&lt;&#x2F;a&gt;, allocations can live arbitrarily long and can be freed in an arbitrary order. This means that we need to keep track of a potentially unbounded number of non-continuous, unused memory regions, as illustrated by the following example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;allocation-fragmentation.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The graphic shows the heap over the course of time. At the beginning, the complete heap is unused, and the &lt;code&gt;next&lt;&#x2F;code&gt; address is equal to &lt;code&gt;heap_start&lt;&#x2F;code&gt; (line 1). Then the first allocation occurs (line 2). In line 3, a second memory block is allocated and the first allocation is freed. Many more allocations are added in line 4. Half of them are very short-lived and already get freed in line 5, where another new allocation is also added.&lt;&#x2F;p&gt;
&lt;p&gt;Line 5 shows the fundamental problem: We have five unused memory regions with different sizes, but the &lt;code&gt;next&lt;&#x2F;code&gt; pointer can only point to the beginning of the last region. While we could store the start addresses and sizes of the other unused memory regions in an array of size 4 for this example, this isn‚Äôt a general solution since we could easily create an example with 8, 16, or 1000 unused memory regions.&lt;&#x2F;p&gt;
&lt;p&gt;Normally, when we have a potentially unbounded number of items, we can just use a heap-allocated collection. This isn‚Äôt really possible in our case, since the heap allocator can‚Äôt depend on itself (it would cause endless recursion or deadlocks). So we need to find a different solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;linked-list-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linked-list-allocator&quot; aria-label=&quot;Anchor link for: linked-list-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Linked List Allocator&lt;&#x2F;h2&gt;
&lt;p&gt;A common trick to keep track of an arbitrary number of free memory areas when implementing allocators is to use these areas themselves as backing storage. This utilizes the fact that the regions are still mapped to a virtual address and backed by a physical frame, but the stored information is not needed anymore. By storing the information about the freed region in the region itself, we can keep track of an unbounded number of freed regions without needing additional memory.&lt;&#x2F;p&gt;
&lt;p&gt;The most common implementation approach is to construct a single linked list in the freed memory, with each node being a freed memory region:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;linked-list-allocation.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Each list node contains two fields: the size of the memory region and a pointer to the next unused memory region. With this approach, we only need a pointer to the first unused region (called &lt;code&gt;head&lt;&#x2F;code&gt;) to keep track of all unused regions, regardless of their number. The resulting data structure is often called a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Free_list&quot;&gt;&lt;em&gt;free list&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As you might guess from the name, this is the technique that the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate uses. Allocators that use this technique are also often called &lt;em&gt;pool allocators&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-1&quot; aria-label=&quot;Anchor link for: implementation-1&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;In the following, we will create our own simple &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt; type that uses the above approach for keeping track of freed memory regions. This part of the post isn‚Äôt required for future posts, so you can skip the implementation details if you like.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-allocator-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-type&quot; aria-label=&quot;Anchor link for: the-allocator-type&quot;&gt;üîó&lt;&#x2F;a&gt;The Allocator Type&lt;&#x2F;h4&gt;
&lt;p&gt;We start by creating a private &lt;code&gt;ListNode&lt;&#x2F;code&gt; struct in a new &lt;code&gt;allocator::linked_list&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;linked_list;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ListNode {
&lt;&#x2F;span&gt;&lt;span&gt;    size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like in the graphic, a list node has a &lt;code&gt;size&lt;&#x2F;code&gt; field and an optional pointer to the next node, represented by the &lt;code&gt;Option&amp;lt;&amp;amp;&#x27;static mut ListNode&amp;gt;&lt;&#x2F;code&gt; type. The &lt;code&gt;&amp;amp;&#x27;static mut&lt;&#x2F;code&gt; type semantically describes an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;owned&lt;&#x2F;a&gt; object behind a pointer. Basically, it‚Äôs a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;index.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; without a destructor that frees the object at the end of the scope.&lt;&#x2F;p&gt;
&lt;p&gt;We implement the following set of methods for &lt;code&gt;ListNode&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ListNode {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const fn &lt;&#x2F;span&gt;&lt;span&gt;new(size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        ListNode { size, next: None }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;start_addr(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const Self as usize
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;end_addr(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.start_addr() + self.size
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type has a simple constructor function named &lt;code&gt;new&lt;&#x2F;code&gt; and methods to calculate the start and end addresses of the represented region. We make the &lt;code&gt;new&lt;&#x2F;code&gt; function a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;functions.html#const-functions&quot;&gt;const function&lt;&#x2F;a&gt;, which will be required later when constructing a static linked list allocator. Note that any use of mutable references in const functions (including setting the &lt;code&gt;next&lt;&#x2F;code&gt; field to &lt;code&gt;None&lt;&#x2F;code&gt;) is still unstable. In order to get it to compile, we need to add &lt;strong&gt;&lt;code&gt;#![feature(const_mut_refs)]&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; to the beginning of our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;With the &lt;code&gt;ListNode&lt;&#x2F;code&gt; struct as a building block, we can now create the &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    head: ListNode,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates an empty LinkedListAllocator.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            head: ListNode::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Initialize the allocator with the given heap bounds.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the given
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; heap bounds are valid and that the heap is unused. This method must be
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; called only once.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, heap_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.add_free_region(heap_start, heap_size);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Adds the given memory region to the front of the list.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;add_free_region(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        todo!();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct contains a &lt;code&gt;head&lt;&#x2F;code&gt; node that points to the first heap region. We are only interested in the value of the &lt;code&gt;next&lt;&#x2F;code&gt; pointer, so we set the &lt;code&gt;size&lt;&#x2F;code&gt; to 0 in the &lt;code&gt;ListNode::new&lt;&#x2F;code&gt; function. Making &lt;code&gt;head&lt;&#x2F;code&gt; a &lt;code&gt;ListNode&lt;&#x2F;code&gt; instead of just a &lt;code&gt;&amp;amp;&#x27;static mut ListNode&lt;&#x2F;code&gt; has the advantage that the implementation of the &lt;code&gt;alloc&lt;&#x2F;code&gt; method will be simpler.&lt;&#x2F;p&gt;
&lt;p&gt;Like for the bump allocator, the &lt;code&gt;new&lt;&#x2F;code&gt; function doesn‚Äôt initialize the allocator with the heap bounds. In addition to maintaining API compatibility, the reason is that the initialization routine requires writing a node to the heap memory, which can only happen at runtime. The &lt;code&gt;new&lt;&#x2F;code&gt; function, however, needs to be a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;functions.html#const-functions&quot;&gt;&lt;code&gt;const&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; that can be evaluated at compile time because it will be used for initializing the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static. For this reason, we again provide a separate, non-constant &lt;code&gt;init&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;init&lt;&#x2F;code&gt; method uses an &lt;code&gt;add_free_region&lt;&#x2F;code&gt; method, whose implementation will be shown in a moment. For now, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;macro.todo.html&quot;&gt;&lt;code&gt;todo!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro to provide a placeholder implementation that always panics.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-add-free-region-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-add-free-region-method&quot; aria-label=&quot;Anchor link for: the-add-free-region-method&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;add_free_region&lt;&#x2F;code&gt; Method&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;add_free_region&lt;&#x2F;code&gt; method provides the fundamental &lt;em&gt;push&lt;&#x2F;em&gt; operation on the linked list. We currently only call this method from &lt;code&gt;init&lt;&#x2F;code&gt;, but it will also be the central method in our &lt;code&gt;dealloc&lt;&#x2F;code&gt; implementation. Remember, the &lt;code&gt;dealloc&lt;&#x2F;code&gt; method is called when an allocated memory region is freed again. To keep track of this freed memory region, we want to push it to the linked list.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;add_free_region&lt;&#x2F;code&gt; method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::align_up;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Adds the given memory region to the front of the list.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;add_free_region(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ensure that the freed region is capable of holding ListNode
&lt;&#x2F;span&gt;&lt;span&gt;        assert_eq!(align_up(addr, mem::align_of::&amp;lt;ListNode&amp;gt;()), addr);
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(size &amp;gt;= mem::size_of::&amp;lt;ListNode&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a new list node and append it at the start of the list
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; node = ListNode::new(size);
&lt;&#x2F;span&gt;&lt;span&gt;        node.next = self.head.next.take();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; node_ptr = addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode;
&lt;&#x2F;span&gt;&lt;span&gt;        node_ptr.write(node);
&lt;&#x2F;span&gt;&lt;span&gt;        self.head.next = Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*node_ptr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method takes the address and size of a memory region as an argument and adds it to the front of the list. First, it ensures that the given region has the necessary size and alignment for storing a &lt;code&gt;ListNode&lt;&#x2F;code&gt;. Then it creates the node and inserts it into the list through the following steps:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;linked-list-allocator-push.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Step 0 shows the state of the heap before &lt;code&gt;add_free_region&lt;&#x2F;code&gt; is called. In step 1, the method is called with the memory region marked as &lt;code&gt;freed&lt;&#x2F;code&gt; in the graphic. After the initial checks, the method creates a new &lt;code&gt;node&lt;&#x2F;code&gt; on its stack with the size of the freed region. It then uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;&lt;code&gt;Option::take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to set the &lt;code&gt;next&lt;&#x2F;code&gt; pointer of the node to the current &lt;code&gt;head&lt;&#x2F;code&gt; pointer, thereby resetting the &lt;code&gt;head&lt;&#x2F;code&gt; pointer to &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In step 2, the method writes the newly created &lt;code&gt;node&lt;&#x2F;code&gt; to the beginning of the freed memory region through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.write&quot;&gt;&lt;code&gt;write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. It then points the &lt;code&gt;head&lt;&#x2F;code&gt; pointer to the new node. The resulting pointer structure looks a bit chaotic because the freed region is always inserted at the beginning of the list, but if we follow the pointers, we see that each free region is still reachable from the &lt;code&gt;head&lt;&#x2F;code&gt; pointer.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-find-region-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-find-region-method&quot; aria-label=&quot;Anchor link for: the-find-region-method&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;find_region&lt;&#x2F;code&gt; Method&lt;&#x2F;h4&gt;
&lt;p&gt;The second fundamental operation on a linked list is finding an entry and removing it from the list. This is the central operation needed for implementing the &lt;code&gt;alloc&lt;&#x2F;code&gt; method. We implement the operation as a &lt;code&gt;find_region&lt;&#x2F;code&gt; method in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Looks for a free region with the given size and alignment and removes
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; it from the list.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns a tuple of the list node and the start address of the allocation.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;find_region(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Option&amp;lt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; reference to current list node, updated for each iteration
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; current = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.head;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; look for a large enough memory region in linked list
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2F;span&gt;&lt;span&gt; region) = current.next {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(alloc_start) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::alloc_from_region(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;region, size, align) {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; region suitable for allocation -&amp;gt; remove node from list
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next = region.next.take();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ret = Some((current.next.take().unwrap(), alloc_start));
&lt;&#x2F;span&gt;&lt;span&gt;                current.next = next;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; ret;
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; region not suitable -&amp;gt; continue with next region
&lt;&#x2F;span&gt;&lt;span&gt;                current = current.next.as_mut().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; no suitable region found
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method uses a &lt;code&gt;current&lt;&#x2F;code&gt; variable and a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;expressions&#x2F;loop-expr.html#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;&#x2F;code&gt; loop&lt;&#x2F;a&gt; to iterate over the list elements. At the beginning, &lt;code&gt;current&lt;&#x2F;code&gt; is set to the (dummy) &lt;code&gt;head&lt;&#x2F;code&gt; node. On each iteration, it is then updated to the &lt;code&gt;next&lt;&#x2F;code&gt; field of the current node (in the &lt;code&gt;else&lt;&#x2F;code&gt; block). If the region is suitable for an allocation with the given size and alignment, the region is removed from the list and returned together with the &lt;code&gt;alloc_start&lt;&#x2F;code&gt; address.&lt;&#x2F;p&gt;
&lt;p&gt;When the &lt;code&gt;current.next&lt;&#x2F;code&gt; pointer becomes &lt;code&gt;None&lt;&#x2F;code&gt;, the loop exits. This means we iterated over the whole list but found no region suitable for an allocation. In that case, we return &lt;code&gt;None&lt;&#x2F;code&gt;. Whether a region is suitable is checked by the &lt;code&gt;alloc_from_region&lt;&#x2F;code&gt; function, whose implementation will be shown in a moment.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs take a more detailed look at how a suitable region is removed from the list:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;linked-list-allocator-remove-region.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Step 0 shows the situation before any pointer adjustments. The &lt;code&gt;region&lt;&#x2F;code&gt; and &lt;code&gt;current&lt;&#x2F;code&gt; regions and the &lt;code&gt;region.next&lt;&#x2F;code&gt; and &lt;code&gt;current.next&lt;&#x2F;code&gt; pointers are marked in the graphic. In step 1, both the &lt;code&gt;region.next&lt;&#x2F;code&gt; and &lt;code&gt;current.next&lt;&#x2F;code&gt; pointers are reset to &lt;code&gt;None&lt;&#x2F;code&gt; by using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;&lt;code&gt;Option::take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. The original pointers are stored in local variables called &lt;code&gt;next&lt;&#x2F;code&gt; and &lt;code&gt;ret&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In step 2, the &lt;code&gt;current.next&lt;&#x2F;code&gt; pointer is set to the local &lt;code&gt;next&lt;&#x2F;code&gt; pointer, which is the original &lt;code&gt;region.next&lt;&#x2F;code&gt; pointer. The effect is that &lt;code&gt;current&lt;&#x2F;code&gt; now directly points to the region after &lt;code&gt;region&lt;&#x2F;code&gt;, so that &lt;code&gt;region&lt;&#x2F;code&gt; is no longer an element of the linked list. The function then returns the pointer to &lt;code&gt;region&lt;&#x2F;code&gt; stored in the local &lt;code&gt;ret&lt;&#x2F;code&gt; variable.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;the-alloc-from-region-function&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-alloc-from-region-function&quot; aria-label=&quot;Anchor link for: the-alloc-from-region-function&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;alloc_from_region&lt;&#x2F;code&gt; Function&lt;&#x2F;h5&gt;
&lt;p&gt;The &lt;code&gt;alloc_from_region&lt;&#x2F;code&gt; function returns whether a region is suitable for an allocation with a given size and alignment. It is defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Try to use the given region for an allocation with given size and
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; alignment.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns the allocation start address on success.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_from_region(region: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ListNode, size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, ()&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_start = align_up(region.start_addr(), align);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_end = alloc_start.checked_add(size).ok_or(())&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; alloc_end &amp;gt; region.end_addr() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; region too small
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Err(());
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; excess_size = region.end_addr() - alloc_end;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; excess_size &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; excess_size &amp;lt; mem::size_of::&amp;lt;ListNode&amp;gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; rest of region too small to hold a ListNode (required because the
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; allocation splits the region in a used and a free part)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Err(());
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; region suitable for allocation
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(alloc_start)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, the function calculates the start and end address of a potential allocation, using the &lt;code&gt;align_up&lt;&#x2F;code&gt; function we defined earlier and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.usize.html#method.checked_add&quot;&gt;&lt;code&gt;checked_add&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. If an overflow occurs or if the end address is behind the end address of the region, the allocation doesn‚Äôt fit in the region and we return an error.&lt;&#x2F;p&gt;
&lt;p&gt;The function performs a less obvious check after that. This check is necessary because most of the time an allocation does not fit a suitable region perfectly, so that a part of the region remains usable after the allocation. This part of the region must store its own &lt;code&gt;ListNode&lt;&#x2F;code&gt; after the allocation, so it must be large enough to do so. The check verifies exactly that: either the allocation fits perfectly (&lt;code&gt;excess_size == 0&lt;&#x2F;code&gt;) or the excess size is large enough to store a &lt;code&gt;ListNode&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;implementing-globalalloc-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-globalalloc-1&quot; aria-label=&quot;Anchor link for: implementing-globalalloc-1&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;With the fundamental operations provided by the &lt;code&gt;add_free_region&lt;&#x2F;code&gt; and &lt;code&gt;find_region&lt;&#x2F;code&gt; methods, we can now finally implement the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait. As with the bump allocator, we don‚Äôt implement the trait directly for the &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt; but only for a wrapped &lt;code&gt;Locked&amp;lt;LinkedListAllocator&amp;gt;&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#a-locked-wrapper-type&quot;&gt;&lt;code&gt;Locked&lt;&#x2F;code&gt; wrapper&lt;&#x2F;a&gt; adds interior mutability through a spinlock, which allows us to modify the allocator instance even though the &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; methods only take &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; references.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::Locked;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Locked&amp;lt;LinkedListAllocator&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; perform layout adjustments
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(size, align) = LinkedListAllocator::size_align(layout);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; allocator = self.lock();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some((region, alloc_start)) = allocator.find_region(size, align) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_end = alloc_start.checked_add(size).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;overflow&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; excess_size = region.end_addr() - alloc_end;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; excess_size &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                allocator.add_free_region(alloc_end, excess_size);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            ptr::null_mut()
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; perform layout adjustments
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(size, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = LinkedListAllocator::size_align(layout);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        self.lock().add_free_region(ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, size)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs start with the &lt;code&gt;dealloc&lt;&#x2F;code&gt; method because it is simpler: First, it performs some layout adjustments, which we will explain in a moment. Then, it retrieves a &lt;code&gt;&amp;amp;mut LinkedListAllocator&lt;&#x2F;code&gt; reference by calling the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.0&#x2F;spin&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function on the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#a-locked-wrapper-type&quot;&gt;&lt;code&gt;Locked&lt;&#x2F;code&gt; wrapper&lt;&#x2F;a&gt;. Lastly, it calls the &lt;code&gt;add_free_region&lt;&#x2F;code&gt; function to add the deallocated region to the free list.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;alloc&lt;&#x2F;code&gt; method is a bit more complex. It starts with the same layout adjustments and also calls the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.0&#x2F;spin&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;Mutex::lock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to receive a mutable allocator reference. Then it uses the &lt;code&gt;find_region&lt;&#x2F;code&gt; method to find a suitable memory region for the allocation and remove it from the list. If this doesn‚Äôt succeed and &lt;code&gt;None&lt;&#x2F;code&gt; is returned, it returns &lt;code&gt;null_mut&lt;&#x2F;code&gt; to signal an error as there is no suitable memory region.&lt;&#x2F;p&gt;
&lt;p&gt;In the success case, the &lt;code&gt;find_region&lt;&#x2F;code&gt; method returns a tuple of the suitable region (no longer in the list) and the start address of the allocation. Using &lt;code&gt;alloc_start&lt;&#x2F;code&gt;, the allocation size, and the end address of the region, it calculates the end address of the allocation and the excess size again. If the excess size is not null, it calls &lt;code&gt;add_free_region&lt;&#x2F;code&gt; to add the excess size of the memory region back to the free list. Finally, it returns the &lt;code&gt;alloc_start&lt;&#x2F;code&gt; address casted as a &lt;code&gt;*mut u8&lt;&#x2F;code&gt; pointer.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;layout-adjustments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#layout-adjustments&quot; aria-label=&quot;Anchor link for: layout-adjustments&quot;&gt;üîó&lt;&#x2F;a&gt;Layout Adjustments&lt;&#x2F;h4&gt;
&lt;p&gt;So what are these layout adjustments that we make at the beginning of both &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt;? They ensure that each allocated block is capable of storing a &lt;code&gt;ListNode&lt;&#x2F;code&gt;. This is important because the memory block is going to be deallocated at some point, where we want to write a &lt;code&gt;ListNode&lt;&#x2F;code&gt; to it. If the block is smaller than a &lt;code&gt;ListNode&lt;&#x2F;code&gt; or does not have the correct alignment, undefined behavior can occur.&lt;&#x2F;p&gt;
&lt;p&gt;The layout adjustments are performed by the &lt;code&gt;size_align&lt;&#x2F;code&gt; function, which is defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;linked_list.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;LinkedListAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Adjust the given layout so that the resulting allocated memory
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; region is also capable of storing a `ListNode`.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns the adjusted size and alignment as a (size, align) tuple.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;size_align(layout: Layout) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = layout
&lt;&#x2F;span&gt;&lt;span&gt;            .align_to(mem::align_of::&amp;lt;ListNode&amp;gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;adjusting alignment failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .pad_to_align();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; size = layout.size().max(mem::size_of::&amp;lt;ListNode&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        (size, layout.align())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, the function uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;alloc&#x2F;struct.Layout.html#method.align_to&quot;&gt;&lt;code&gt;align_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on the passed &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to increase the alignment to the alignment of a &lt;code&gt;ListNode&lt;&#x2F;code&gt; if necessary. It then uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;alloc&#x2F;struct.Layout.html#method.pad_to_align&quot;&gt;&lt;code&gt;pad_to_align&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to round up the size to a multiple of the alignment to ensure that the start address of the next memory block will have the correct alignment for storing a &lt;code&gt;ListNode&lt;&#x2F;code&gt; too.
In the second step, it uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cmp&#x2F;trait.Ord.html#method.max&quot;&gt;&lt;code&gt;max&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to enforce a minimum allocation size of &lt;code&gt;mem::size_of::&amp;lt;ListNode&amp;gt;&lt;&#x2F;code&gt;. This way, the &lt;code&gt;dealloc&lt;&#x2F;code&gt; function can safely write a &lt;code&gt;ListNode&lt;&#x2F;code&gt; to the freed memory block.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-it-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-it-1&quot; aria-label=&quot;Anchor link for: using-it-1&quot;&gt;üîó&lt;&#x2F;a&gt;Using it&lt;&#x2F;h3&gt;
&lt;p&gt;We can now update the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static in the &lt;code&gt;allocator&lt;&#x2F;code&gt; module to use our new &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;linked_list::LinkedListAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: Locked&amp;lt;LinkedListAllocator&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    Locked::new(LinkedListAllocator::new());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;code&gt;init&lt;&#x2F;code&gt; function behaves the same for the bump and linked list allocators, we don‚Äôt need to modify the &lt;code&gt;init&lt;&#x2F;code&gt; call in &lt;code&gt;init_heap&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When we now run our &lt;code&gt;heap_allocation&lt;&#x2F;code&gt; tests again, we see that all tests pass now, including the &lt;code&gt;many_boxes_long_lived&lt;&#x2F;code&gt; test that failed with the bump allocator:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --test heap_allocation
&lt;&#x2F;span&gt;&lt;span&gt;simple_allocation... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;large_vec... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes_long_lived... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This shows that our linked list allocator is able to reuse freed memory for subsequent allocations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;discussion-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion-1&quot; aria-label=&quot;Anchor link for: discussion-1&quot;&gt;üîó&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h3&gt;
&lt;p&gt;In contrast to the bump allocator, the linked list allocator is much more suitable as a general-purpose allocator, mainly because it is able to directly reuse freed memory. However, it also has some drawbacks. Some of them are only caused by our basic implementation, but there are also fundamental drawbacks of the allocator design itself.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;merging-freed-blocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#merging-freed-blocks&quot; aria-label=&quot;Anchor link for: merging-freed-blocks&quot;&gt;üîó&lt;&#x2F;a&gt;Merging Freed Blocks&lt;&#x2F;h4&gt;
&lt;p&gt;The main problem with our implementation is that it only splits the heap into smaller blocks but never merges them back together. Consider this example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;linked-list-allocator-fragmentation-on-dealloc.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the first line, three allocations are created on the heap. Two of them are freed again in line 2 and the third is freed in line 3. Now the complete heap is unused again, but it is still split into four individual blocks. At this point, a large allocation might not be possible anymore because none of the four blocks is large enough. Over time, the process continues, and the heap is split into smaller and smaller blocks. At some point, the heap is so fragmented that even normal sized allocations will fail.&lt;&#x2F;p&gt;
&lt;p&gt;To fix this problem, we need to merge adjacent freed blocks back together. For the above example, this would mean the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;linked-list-allocator-merge-on-dealloc.svg&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Like before, two of the three allocations are freed in line &lt;code&gt;2&lt;&#x2F;code&gt;. Instead of keeping the fragmented heap, we now perform an additional step in line &lt;code&gt;2a&lt;&#x2F;code&gt; to merge the two rightmost blocks back together. In line &lt;code&gt;3&lt;&#x2F;code&gt;, the third allocation is freed (like before), resulting in a completely unused heap represented by three distinct blocks. In an additional merging step in line &lt;code&gt;3a&lt;&#x2F;code&gt;, we then merge the three adjacent blocks back together.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate implements this merging strategy in the following way: Instead of inserting freed memory blocks at the beginning of the linked list on &lt;code&gt;deallocate&lt;&#x2F;code&gt;, it always keeps the list sorted by start address. This way, merging can be performed directly on the &lt;code&gt;deallocate&lt;&#x2F;code&gt; call by examining the addresses and sizes of the two neighboring blocks in the list. Of course, the deallocation operation is slower this way, but it prevents the heap fragmentation we saw above.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;performance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#performance&quot; aria-label=&quot;Anchor link for: performance&quot;&gt;üîó&lt;&#x2F;a&gt;Performance&lt;&#x2F;h4&gt;
&lt;p&gt;As we learned above, the bump allocator is extremely fast and can be optimized to just a few assembly operations. The linked list allocator performs much worse in this category. The problem is that an allocation request might need to traverse the complete linked list until it finds a suitable block.&lt;&#x2F;p&gt;
&lt;p&gt;Since the list length depends on the number of unused memory blocks, the performance can vary extremely for different programs. A program that only creates a couple of allocations will experience relatively fast allocation performance. For a program that fragments the heap with many allocations, however, the allocation performance will be very bad because the linked list will be very long and mostly contain very small blocks.&lt;&#x2F;p&gt;
&lt;p&gt;It‚Äôs worth noting that this performance issue isn‚Äôt a problem caused by our basic implementation but a fundamental problem of the linked list approach. Since allocation performance can be very important for kernel-level code, we explore a third allocator design in the following that trades improved performance for reduced memory utilization.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fixed-size-block-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixed-size-block-allocator&quot; aria-label=&quot;Anchor link for: fixed-size-block-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Fixed-Size Block Allocator&lt;&#x2F;h2&gt;
&lt;p&gt;In the following, we present an allocator design that uses fixed-size memory blocks for fulfilling allocation requests. This way, the allocator often returns blocks that are larger than needed for allocations, which results in wasted memory due to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)#Internal_fragmentation&quot;&gt;internal fragmentation&lt;&#x2F;a&gt;. On the other hand, it drastically reduces the time required to find a suitable block (compared to the linked list allocator), resulting in much better allocation performance.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;introduction-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction-1&quot; aria-label=&quot;Anchor link for: introduction-1&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind a &lt;em&gt;fixed-size block allocator&lt;&#x2F;em&gt; is the following: Instead of allocating exactly as much memory as requested, we define a small number of block sizes and round up each allocation to the next block size. For example, with block sizes of 16, 64, and 512 bytes, an allocation of 4 bytes would return a 16-byte block, an allocation of 48 bytes a 64-byte block, and an allocation of 128 bytes a 512-byte block.&lt;&#x2F;p&gt;
&lt;p&gt;Like the linked list allocator, we keep track of the unused memory by creating a linked list in the unused memory. However, instead of using a single list with different block sizes, we create a separate list for each size class. Each list then only stores blocks of a single size. For example, with block sizes of 16, 64, and 512, there would be three separate linked lists in memory:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;fixed-size-block-example.svg&quot; alt=&quot;&quot; &#x2F;&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of a single &lt;code&gt;head&lt;&#x2F;code&gt; pointer, we have the three head pointers &lt;code&gt;head_16&lt;&#x2F;code&gt;, &lt;code&gt;head_64&lt;&#x2F;code&gt;, and &lt;code&gt;head_512&lt;&#x2F;code&gt; that each point to the first unused block of the corresponding size. All nodes in a single list have the same size. For example, the list started by the &lt;code&gt;head_16&lt;&#x2F;code&gt; pointer only contains 16-byte blocks. This means that we no longer need to store the size in each list node since it is already specified by the name of the head pointer.&lt;&#x2F;p&gt;
&lt;p&gt;Since each element in a list has the same size, each list element is equally suitable for an allocation request. This means that we can very efficiently perform an allocation using the following steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Round up the requested allocation size to the next block size. For example, when an allocation of 12 bytes is requested, we would choose the block size of 16 in the above example.&lt;&#x2F;li&gt;
&lt;li&gt;Retrieve the head pointer for the list, e.g., for block size 16, we need to use &lt;code&gt;head_16&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Remove the first block from the list and return it.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Most notably, we can always return the first element of the list and no longer need to traverse the full list. Thus, allocations are much faster than with the linked list allocator.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;block-sizes-and-wasted-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#block-sizes-and-wasted-memory&quot; aria-label=&quot;Anchor link for: block-sizes-and-wasted-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Block Sizes and Wasted Memory&lt;&#x2F;h4&gt;
&lt;p&gt;Depending on the block sizes, we lose a lot of memory by rounding up. For example, when a 512-byte block is returned for a 128-byte allocation, three-quarters of the allocated memory is unused. By defining reasonable block sizes, it is possible to limit the amount of wasted memory to some degree. For example, when using the powers of 2 (4, 8, 16, 32, 64, 128, ‚Ä¶) as block sizes, we can limit the memory waste to half of the allocation size in the worst case and a quarter of the allocation size in the average case.&lt;&#x2F;p&gt;
&lt;p&gt;It is also common to optimize block sizes based on common allocation sizes in a program. For example, we could additionally add block size 24 to improve memory usage for programs that often perform allocations of 24 bytes. This way, the amount of wasted memory can often be reduced without losing the performance benefits.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;deallocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deallocation&quot; aria-label=&quot;Anchor link for: deallocation&quot;&gt;üîó&lt;&#x2F;a&gt;Deallocation&lt;&#x2F;h4&gt;
&lt;p&gt;Much like allocation, deallocation is also very performant. It involves the following steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Round up the freed allocation size to the next block size. This is required since the compiler only passes the requested allocation size to &lt;code&gt;dealloc&lt;&#x2F;code&gt;, not the size of the block that was returned by &lt;code&gt;alloc&lt;&#x2F;code&gt;. By using the same size-adjustment function in both &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt;, we can make sure that we always free the correct amount of memory.&lt;&#x2F;li&gt;
&lt;li&gt;Retrieve the head pointer for the list.&lt;&#x2F;li&gt;
&lt;li&gt;Add the freed block to the front of the list by updating the head pointer.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Most notably, no traversal of the list is required for deallocation either. This means that the time required for a &lt;code&gt;dealloc&lt;&#x2F;code&gt; call stays the same regardless of the list length.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fallback-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fallback-allocator&quot; aria-label=&quot;Anchor link for: fallback-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Fallback Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;Given that large allocations (&amp;gt;2¬†KB) are often rare, especially in operating system kernels, it might make sense to fall back to a different allocator for these allocations. For example, we could fall back to a linked list allocator for allocations greater than 2048 bytes in order to reduce memory waste. Since only very few allocations of that size are expected, the linked list would stay small and the (de)allocations would still be reasonably fast.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;creating-new-blocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-new-blocks&quot; aria-label=&quot;Anchor link for: creating-new-blocks&quot;&gt;üîó&lt;&#x2F;a&gt;Creating new Blocks&lt;&#x2F;h4&gt;
&lt;p&gt;Above, we always assumed that there are always enough blocks of a specific size in the list to fulfill all allocation requests. However, at some point, the linked list for a given block size becomes empty. At this point, there are two ways we can create new unused blocks of a specific size to fulfill an allocation request:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Allocate a new block from the fallback allocator (if there is one).&lt;&#x2F;li&gt;
&lt;li&gt;Split a larger block from a different list. This best works if block sizes are powers of two. For example, a 32-byte block can be split into two 16-byte blocks.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For our implementation, we will allocate new blocks from the fallback allocator since the implementation is much simpler.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-2&quot; aria-label=&quot;Anchor link for: implementation-2&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we know how a fixed-size block allocator works, we can start our implementation. We won‚Äôt depend on the implementation of the linked list allocator created in the previous section, so you can follow this part even if you skipped the linked list allocator implementation.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;list-node&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#list-node&quot; aria-label=&quot;Anchor link for: list-node&quot;&gt;üîó&lt;&#x2F;a&gt;List Node&lt;&#x2F;h4&gt;
&lt;p&gt;We start our implementation by creating a &lt;code&gt;ListNode&lt;&#x2F;code&gt; type in a new &lt;code&gt;allocator::fixed_size_block&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;fixed_size_block;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ListNode {
&lt;&#x2F;span&gt;&lt;span&gt;    next: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This type is similar to the &lt;code&gt;ListNode&lt;&#x2F;code&gt; type of our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#the-allocator-type&quot;&gt;linked list allocator implementation&lt;&#x2F;a&gt;, with the difference that we don‚Äôt have a &lt;code&gt;size&lt;&#x2F;code&gt; field. It isn‚Äôt needed because every block in a list has the same size with the fixed-size block allocator design.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;block-sizes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#block-sizes&quot; aria-label=&quot;Anchor link for: block-sizes&quot;&gt;üîó&lt;&#x2F;a&gt;Block Sizes&lt;&#x2F;h4&gt;
&lt;p&gt;Next, we define a constant &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice with the block sizes used for our implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; The block sizes to use.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; The sizes must each be power of 2 because they are also used as
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; the block alignment (alignments must be always powers of 2).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;128&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;256&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2048&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As block sizes, we use powers of 2, starting from 8 up to 2048. We don‚Äôt define any block sizes smaller than 8 because each block must be capable of storing a 64-bit pointer to the next block when freed. For allocations greater than 2048 bytes, we will fall back to a linked list allocator.&lt;&#x2F;p&gt;
&lt;p&gt;To simplify the implementation, we define the size of a block as its required alignment in memory. So a 16-byte block is always aligned on a 16-byte boundary and a 512-byte block is aligned on a 512-byte boundary. Since alignments always need to be powers of 2, this rules out any other block sizes. If we need block sizes that are not powers of 2 in the future, we can still adjust our implementation for this (e.g., by defining a second &lt;code&gt;BLOCK_ALIGNMENTS&lt;&#x2F;code&gt; array).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-allocator-type-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-type-1&quot; aria-label=&quot;Anchor link for: the-allocator-type-1&quot;&gt;üîó&lt;&#x2F;a&gt;The Allocator Type&lt;&#x2F;h4&gt;
&lt;p&gt;Using the &lt;code&gt;ListNode&lt;&#x2F;code&gt; type and the &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice, we can now define our allocator type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;FixedSizeBlockAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    list_heads: [Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode&amp;gt;; BLOCK_SIZES.len()],
&lt;&#x2F;span&gt;&lt;span&gt;    fallback_allocator: linked_list_allocator::Heap,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;list_heads&lt;&#x2F;code&gt; field is an array of &lt;code&gt;head&lt;&#x2F;code&gt; pointers, one for each block size. This is implemented by using the &lt;code&gt;len()&lt;&#x2F;code&gt; of the &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice as the array length. As a fallback allocator for allocations larger than the largest block size, we use the allocator provided by the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt;. We could also use the &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt; we implemented ourselves instead, but it has the disadvantage that it does not &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#merging-freed-blocks&quot;&gt;merge freed blocks&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For constructing a &lt;code&gt;FixedSizeBlockAllocator&lt;&#x2F;code&gt;, we provide the same &lt;code&gt;new&lt;&#x2F;code&gt; and &lt;code&gt;init&lt;&#x2F;code&gt; functions that we implemented for the other allocator types too:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FixedSizeBlockAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates an empty FixedSizeBlockAllocator.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode&amp;gt; = None;
&lt;&#x2F;span&gt;&lt;span&gt;        FixedSizeBlockAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;            list_heads: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;EMPTY&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;.len()],
&lt;&#x2F;span&gt;&lt;span&gt;            fallback_allocator: linked_list_allocator::Heap::empty(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Initialize the allocator with the given heap bounds.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the given
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; heap bounds are valid and that the heap is unused. This method must be
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; called only once.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, heap_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.fallback_allocator.init(heap_start, heap_size);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;new&lt;&#x2F;code&gt; function just initializes the &lt;code&gt;list_heads&lt;&#x2F;code&gt; array with empty nodes and creates an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.empty&quot;&gt;&lt;code&gt;empty&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; linked list allocator as &lt;code&gt;fallback_allocator&lt;&#x2F;code&gt;. The &lt;code&gt;EMPTY&lt;&#x2F;code&gt; constant is needed to tell the Rust compiler that we want to initialize the array with a constant value. Initializing the array directly as &lt;code&gt;[None; BLOCK_SIZES.len()]&lt;&#x2F;code&gt; does not work, because then the compiler requires &lt;code&gt;Option&amp;lt;&amp;amp;&#x27;static mut ListNode&amp;gt;&lt;&#x2F;code&gt; to implement the &lt;code&gt;Copy&lt;&#x2F;code&gt; trait, which it does not. This is a current limitation of the Rust compiler, which might go away in the future.&lt;&#x2F;p&gt;
&lt;p&gt;If you haven‚Äôt done so already for the &lt;code&gt;LinkedListAllocator&lt;&#x2F;code&gt; implementation, you also need to add &lt;strong&gt;&lt;code&gt;#![feature(const_mut_refs)]&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; to the top of your &lt;code&gt;lib.rs&lt;&#x2F;code&gt;. The reason is that any use of mutable reference types in const functions is still unstable, including the &lt;code&gt;Option&amp;lt;&amp;amp;&#x27;static mut ListNode&amp;gt;&lt;&#x2F;code&gt; array element type of the &lt;code&gt;list_heads&lt;&#x2F;code&gt; field (even if we set it to &lt;code&gt;None&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The unsafe &lt;code&gt;init&lt;&#x2F;code&gt; function only calls the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.init&quot;&gt;&lt;code&gt;init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function of the &lt;code&gt;fallback_allocator&lt;&#x2F;code&gt; without doing any additional initialization of the &lt;code&gt;list_heads&lt;&#x2F;code&gt; array. Instead, we will initialize the lists lazily on &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; calls.&lt;&#x2F;p&gt;
&lt;p&gt;For convenience, we also create a private &lt;code&gt;fallback_alloc&lt;&#x2F;code&gt; method that allocates using the &lt;code&gt;fallback_allocator&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::Layout;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FixedSizeBlockAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Allocates using the fallback allocator.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;fallback_alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;self.fallback_allocator.allocate_first_fit(layout) {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(ptr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; ptr.as_ptr(),
&lt;&#x2F;span&gt;&lt;span&gt;            Err(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;ptr::null_mut(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html&quot;&gt;&lt;code&gt;Heap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type of the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate does not implement &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (as it‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#globalalloc-and-mutability&quot;&gt;not possible without locking&lt;&#x2F;a&gt;). Instead, it provides an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.allocate_first_fit&quot;&gt;&lt;code&gt;allocate_first_fit&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method that has a slightly different interface. Instead of returning a &lt;code&gt;*mut u8&lt;&#x2F;code&gt; and using a null pointer to signal an error, it returns a &lt;code&gt;Result&amp;lt;NonNull&amp;lt;u8&amp;gt;, ()&amp;gt;&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;struct.NonNull.html&quot;&gt;&lt;code&gt;NonNull&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type is an abstraction for a raw pointer that is guaranteed to not be a null pointer. By mapping the &lt;code&gt;Ok&lt;&#x2F;code&gt; case to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;struct.NonNull.html#method.as_ptr&quot;&gt;&lt;code&gt;NonNull::as_ptr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method and the &lt;code&gt;Err&lt;&#x2F;code&gt; case to a null pointer, we can easily translate this back to a &lt;code&gt;*mut u8&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;calculating-the-list-index&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calculating-the-list-index&quot; aria-label=&quot;Anchor link for: calculating-the-list-index&quot;&gt;üîó&lt;&#x2F;a&gt;Calculating the List Index&lt;&#x2F;h4&gt;
&lt;p&gt;Before we implement the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait, we define a &lt;code&gt;list_index&lt;&#x2F;code&gt; helper function that returns the lowest possible block size for a given &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Choose an appropriate block size for the given layout.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns an index into the `BLOCK_SIZES` array.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;list_index(layout: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Layout) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; required_block_size = layout.size().max(layout.align());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;.iter().position(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;s| s &amp;gt;= required_block_size)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The block must have at least the size and alignment required by the given &lt;code&gt;Layout&lt;&#x2F;code&gt;. Since we defined that the block size is also its alignment, this means that the &lt;code&gt;required_block_size&lt;&#x2F;code&gt; is the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;cmp&#x2F;trait.Ord.html#method.max&quot;&gt;maximum&lt;&#x2F;a&gt; of the layout‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;alloc&#x2F;struct.Layout.html#method.size&quot;&gt;&lt;code&gt;size()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;alloc&#x2F;struct.Layout.html#method.align&quot;&gt;&lt;code&gt;align()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attributes. To find the next-larger block in the &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice, we first use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html#method.iter&quot;&gt;&lt;code&gt;iter()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to get an iterator and then the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.position&quot;&gt;&lt;code&gt;position()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to find the index of the first block that is at least as large as the &lt;code&gt;required_block_size&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we don‚Äôt return the block size itself, but the index into the &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice. The reason is that we want to use the returned index as an index into the &lt;code&gt;list_heads&lt;&#x2F;code&gt; array.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;implementing-globalalloc-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-globalalloc-2&quot; aria-label=&quot;Anchor link for: implementing-globalalloc-2&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The last step is to implement the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::Locked;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::GlobalAlloc;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Locked&amp;lt;FixedSizeBlockAllocator&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        todo!();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        todo!();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like for the other allocators, we don‚Äôt implement the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait directly for our allocator type, but use the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#a-locked-wrapper-type&quot;&gt;&lt;code&gt;Locked&lt;&#x2F;code&gt; wrapper&lt;&#x2F;a&gt; to add synchronized interior mutability. Since the &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; implementations are relatively large, we introduce them one by one in the following.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;alloc&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#alloc&quot; aria-label=&quot;Anchor link for: alloc&quot;&gt;üîó&lt;&#x2F;a&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;h5&gt;
&lt;p&gt;The implementation of the &lt;code&gt;alloc&lt;&#x2F;code&gt; method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl` block in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; allocator = self.lock();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;list_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        Some(index) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; allocator.list_heads[index].take() {
&lt;&#x2F;span&gt;&lt;span&gt;                Some(node) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    allocator.list_heads[index] = node.next.take();
&lt;&#x2F;span&gt;&lt;span&gt;                    node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;                None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; no block exists in list =&amp;gt; allocate new block
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; block_size = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;[index];
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; only works if all block sizes are a power of 2
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; block_align = block_size;
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; layout = Layout::from_size_align(block_size, block_align)
&lt;&#x2F;span&gt;&lt;span&gt;                        .unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;                    allocator.fallback_alloc(layout)
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; allocator.fallback_alloc(layout),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs go through it step by step:&lt;&#x2F;p&gt;
&lt;p&gt;First, we use the &lt;code&gt;Locked::lock&lt;&#x2F;code&gt; method to get a mutable reference to the wrapped allocator instance. Next, we call the &lt;code&gt;list_index&lt;&#x2F;code&gt; function we just defined to calculate the appropriate block size for the given layout and get the corresponding index into the &lt;code&gt;list_heads&lt;&#x2F;code&gt; array. If this index is &lt;code&gt;None&lt;&#x2F;code&gt;, no block size fits for the allocation, therefore we use the &lt;code&gt;fallback_allocator&lt;&#x2F;code&gt; using the &lt;code&gt;fallback_alloc&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;If the list index is &lt;code&gt;Some&lt;&#x2F;code&gt;, we try to remove the first node in the corresponding list started by &lt;code&gt;list_heads[index]&lt;&#x2F;code&gt; using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;&lt;code&gt;Option::take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. If the list is not empty, we enter the &lt;code&gt;Some(node)&lt;&#x2F;code&gt; branch of the &lt;code&gt;match&lt;&#x2F;code&gt; statement, where we point the head pointer of the list to the successor of the popped &lt;code&gt;node&lt;&#x2F;code&gt; (by using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;&lt;code&gt;take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; again). Finally, we return the popped &lt;code&gt;node&lt;&#x2F;code&gt; pointer as a &lt;code&gt;*mut u8&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If the list head is &lt;code&gt;None&lt;&#x2F;code&gt;, it indicates that the list of blocks is empty. This means that we need to construct a new block as &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#creating-new-blocks&quot;&gt;described above&lt;&#x2F;a&gt;. For that, we first get the current block size from the &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt; slice and use it as both the size and the alignment for the new block. Then we create a new &lt;code&gt;Layout&lt;&#x2F;code&gt; from it and call the &lt;code&gt;fallback_alloc&lt;&#x2F;code&gt; method to perform the allocation. The reason for adjusting the layout and alignment is that the block will be added to the block list on deallocation.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dealloc&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dealloc&quot; aria-label=&quot;Anchor link for: dealloc&quot;&gt;üîó&lt;&#x2F;a&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;The implementation of the &lt;code&gt;dealloc&lt;&#x2F;code&gt; method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator&#x2F;fixed_size_block.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::{mem, ptr::NonNull};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; inside the `unsafe impl GlobalAlloc` block
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; allocator = self.lock();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;list_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        Some(index) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_node = ListNode {
&lt;&#x2F;span&gt;&lt;span&gt;                next: allocator.list_heads[index].take(),
&lt;&#x2F;span&gt;&lt;span&gt;            };
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; verify that block has size and alignment required for storing node
&lt;&#x2F;span&gt;&lt;span&gt;            assert!(mem::size_of::&amp;lt;ListNode&amp;gt;() &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;[index]);
&lt;&#x2F;span&gt;&lt;span&gt;            assert!(mem::align_of::&amp;lt;ListNode&amp;gt;() &amp;lt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BLOCK_SIZES&lt;&#x2F;span&gt;&lt;span&gt;[index]);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_node_ptr = ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; ListNode;
&lt;&#x2F;span&gt;&lt;span&gt;            new_node_ptr.write(new_node);
&lt;&#x2F;span&gt;&lt;span&gt;            allocator.list_heads[index] = Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*new_node_ptr);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = NonNull::new(ptr).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;            allocator.fallback_allocator.deallocate(ptr, layout);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like in &lt;code&gt;alloc&lt;&#x2F;code&gt;, we first use the &lt;code&gt;lock&lt;&#x2F;code&gt; method to get a mutable allocator reference and then the &lt;code&gt;list_index&lt;&#x2F;code&gt; function to get the block list corresponding to the given &lt;code&gt;Layout&lt;&#x2F;code&gt;. If the index is &lt;code&gt;None&lt;&#x2F;code&gt;, no fitting block size exists in &lt;code&gt;BLOCK_SIZES&lt;&#x2F;code&gt;, which indicates that the allocation was created by the fallback allocator. Therefore, we use its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.deallocate&quot;&gt;&lt;code&gt;deallocate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to free the memory again. The method expects a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;struct.NonNull.html&quot;&gt;&lt;code&gt;NonNull&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instead of a &lt;code&gt;*mut u8&lt;&#x2F;code&gt;, so we need to convert the pointer first. (The &lt;code&gt;unwrap&lt;&#x2F;code&gt; call only fails when the pointer is null, which should never happen when the compiler calls &lt;code&gt;dealloc&lt;&#x2F;code&gt;.)&lt;&#x2F;p&gt;
&lt;p&gt;If &lt;code&gt;list_index&lt;&#x2F;code&gt; returns a block index, we need to add the freed memory block to the list. For that, we first create a new &lt;code&gt;ListNode&lt;&#x2F;code&gt; that points to the current list head (by using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;&lt;code&gt;Option::take&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; again). Before we write the new node into the freed memory block, we first assert that the current block size specified by &lt;code&gt;index&lt;&#x2F;code&gt; has the required size and alignment for storing a &lt;code&gt;ListNode&lt;&#x2F;code&gt;. Then we perform the write by converting the given &lt;code&gt;*mut u8&lt;&#x2F;code&gt; pointer to a &lt;code&gt;*mut ListNode&lt;&#x2F;code&gt; pointer and then calling the unsafe &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.write&quot;&gt;&lt;code&gt;write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on it. The last step is to set the head pointer of the list, which is currently &lt;code&gt;None&lt;&#x2F;code&gt; since we called &lt;code&gt;take&lt;&#x2F;code&gt; on it, to our newly written &lt;code&gt;ListNode&lt;&#x2F;code&gt;. For that, we convert the raw &lt;code&gt;new_node_ptr&lt;&#x2F;code&gt; to a mutable reference.&lt;&#x2F;p&gt;
&lt;p&gt;There are a few things worth noting:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We don‚Äôt differentiate between blocks allocated from a block list and blocks allocated from the fallback allocator. This means that new blocks created in &lt;code&gt;alloc&lt;&#x2F;code&gt; are added to the block list on &lt;code&gt;dealloc&lt;&#x2F;code&gt;, thereby increasing the number of blocks of that size.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;alloc&lt;&#x2F;code&gt; method is the only place where new blocks are created in our implementation. This means that we initially start with empty block lists and only fill these lists lazily when allocations of their block size are performed.&lt;&#x2F;li&gt;
&lt;li&gt;We don‚Äôt need &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks in &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt;, even though we perform some &lt;code&gt;unsafe&lt;&#x2F;code&gt; operations. The reason is that Rust currently treats the complete body of unsafe functions as one large &lt;code&gt;unsafe&lt;&#x2F;code&gt; block. Since using explicit &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks has the advantage that it‚Äôs obvious which operations are unsafe and which are not, there is a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2585&quot;&gt;proposed RFC&lt;&#x2F;a&gt; to change this behavior.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;using-it-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-it-2&quot; aria-label=&quot;Anchor link for: using-it-2&quot;&gt;üîó&lt;&#x2F;a&gt;Using it&lt;&#x2F;h3&gt;
&lt;p&gt;To use our new &lt;code&gt;FixedSizeBlockAllocator&lt;&#x2F;code&gt;, we need to update the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static in the &lt;code&gt;allocator&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fixed_size_block::FixedSizeBlockAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: Locked&amp;lt;FixedSizeBlockAllocator&amp;gt; = Locked::new(
&lt;&#x2F;span&gt;&lt;span&gt;    FixedSizeBlockAllocator::new());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;code&gt;init&lt;&#x2F;code&gt; function behaves the same for all allocators we implemented, we don‚Äôt need to modify the &lt;code&gt;init&lt;&#x2F;code&gt; call in &lt;code&gt;init_heap&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When we now run our &lt;code&gt;heap_allocation&lt;&#x2F;code&gt; tests again, all tests should still pass:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --test heap_allocation
&lt;&#x2F;span&gt;&lt;span&gt;simple_allocation... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;large_vec... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes_long_lived... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our new allocator seems to work!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;discussion-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#discussion-2&quot; aria-label=&quot;Anchor link for: discussion-2&quot;&gt;üîó&lt;&#x2F;a&gt;Discussion&lt;&#x2F;h3&gt;
&lt;p&gt;While the fixed-size block approach has much better performance than the linked list approach, it wastes up to half of the memory when using powers of 2 as block sizes. Whether this tradeoff is worth it heavily depends on the application type. For an operating system kernel, where performance is critical, the fixed-size block approach seems to be the better choice.&lt;&#x2F;p&gt;
&lt;p&gt;On the implementation side, there are various things that we could improve in our current implementation:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of only allocating blocks lazily using the fallback allocator, it might be better to pre-fill the lists to improve the performance of initial allocations.&lt;&#x2F;li&gt;
&lt;li&gt;To simplify the implementation, we only allowed block sizes that are powers of 2 so that we could also use them as the block alignment. By storing (or calculating) the alignment in a different way, we could also allow arbitrary other block sizes. This way, we could add more block sizes, e.g., for common allocation sizes, in order to minimize the wasted memory.&lt;&#x2F;li&gt;
&lt;li&gt;We currently only create new blocks, but never free them again. This results in fragmentation and might eventually result in allocation failure for large allocations. It might make sense to enforce a maximum list length for each block size. When the maximum length is reached, subsequent deallocations are freed using the fallback allocator instead of being added to the list.&lt;&#x2F;li&gt;
&lt;li&gt;Instead of falling back to a linked list allocator, we could have a special allocator for allocations greater than 4¬†KiB. The idea is to utilize &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;&quot;&gt;paging&lt;&#x2F;a&gt;, which operates on 4¬†KiB pages, to map a continuous block of virtual memory to non-continuous physical frames. This way, fragmentation of unused memory is no longer a problem for large allocations.&lt;&#x2F;li&gt;
&lt;li&gt;With such a page allocator, it might make sense to add block sizes up to 4¬†KiB and drop the linked list allocator completely. The main advantages of this would be reduced fragmentation and improved performance predictability, i.e., better worst-case performance.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;It‚Äôs important to note that the implementation improvements outlined above are only suggestions. Allocators used in operating system kernels are typically highly optimized for the specific workload of the kernel, which is only possible through extensive profiling.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;variations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#variations&quot; aria-label=&quot;Anchor link for: variations&quot;&gt;üîó&lt;&#x2F;a&gt;Variations&lt;&#x2F;h3&gt;
&lt;p&gt;There are also many variations of the fixed-size block allocator design. Two popular examples are the &lt;em&gt;slab allocator&lt;&#x2F;em&gt; and the &lt;em&gt;buddy allocator&lt;&#x2F;em&gt;, which are also used in popular kernels such as Linux. In the following, we give a short introduction to these two designs.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;slab-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#slab-allocator&quot; aria-label=&quot;Anchor link for: slab-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Slab Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;The idea behind a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Slab_allocation&quot;&gt;slab allocator&lt;&#x2F;a&gt; is to use block sizes that directly correspond to selected types in the kernel. This way, allocations of those types fit a block size exactly and no memory is wasted. Sometimes, it might be even possible to preinitialize type instances in unused blocks to further improve performance.&lt;&#x2F;p&gt;
&lt;p&gt;Slab allocation is often combined with other allocators. For example, it can be used together with a fixed-size block allocator to further split an allocated block in order to reduce memory waste. It is also often used to implement an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object_pool_pattern&quot;&gt;object pool pattern&lt;&#x2F;a&gt; on top of a single large allocation.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;buddy-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buddy-allocator&quot; aria-label=&quot;Anchor link for: buddy-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Buddy Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;Instead of using a linked list to manage freed blocks, the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Buddy_memory_allocation&quot;&gt;buddy allocator&lt;&#x2F;a&gt; design uses a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_tree&quot;&gt;binary tree&lt;&#x2F;a&gt; data structure together with power-of-2 block sizes. When a new block of a certain size is required, it splits a larger sized block into two halves, thereby creating two child nodes in the tree. Whenever a block is freed again, its neighbor block in the tree is analyzed. If the neighbor is also free, the two blocks are joined back together to form a block of twice the size.&lt;&#x2F;p&gt;
&lt;p&gt;The advantage of this merge process is that &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)#External_fragmentation&quot;&gt;external fragmentation&lt;&#x2F;a&gt; is reduced so that small freed blocks can be reused for a large allocation. It also does not use a fallback allocator, so the performance is more predictable. The biggest drawback is that only power-of-2 block sizes are possible, which might result in a large amount of wasted memory due to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)#Internal_fragmentation&quot;&gt;internal fragmentation&lt;&#x2F;a&gt;. For this reason, buddy allocators are often combined with a slab allocator to further split an allocated block into multiple smaller blocks.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post gave an overview of different allocator designs. We learned how to implement a basic &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#bump-allocator&quot;&gt;bump allocator&lt;&#x2F;a&gt;, which hands out memory linearly by increasing a single &lt;code&gt;next&lt;&#x2F;code&gt; pointer. While bump allocation is very fast, it can only reuse memory after all allocations have been freed. For this reason, it is rarely used as a global allocator.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we created a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#linked-list-allocator&quot;&gt;linked list allocator&lt;&#x2F;a&gt; that uses the freed memory blocks itself to create a linked list, the so-called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Free_list&quot;&gt;free list&lt;&#x2F;a&gt;. This list makes it possible to store an arbitrary number of freed blocks of different sizes. While no memory waste occurs, the approach suffers from poor performance because an allocation request might require a complete traversal of the list. Our implementation also suffers from &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)#External_fragmentation&quot;&gt;external fragmentation&lt;&#x2F;a&gt; because it does not merge adjacent freed blocks back together.&lt;&#x2F;p&gt;
&lt;p&gt;To fix the performance problems of the linked list approach, we created a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#fixed-size-block-allocator&quot;&gt;fixed-size block allocator&lt;&#x2F;a&gt; that predefines a fixed set of block sizes. For each block size, a separate &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Free_list&quot;&gt;free list&lt;&#x2F;a&gt; exists so that allocations and deallocations only need to insert&#x2F;pop at the front of the list and are thus very fast. Since each allocation is rounded up to the next larger block size, some memory is wasted due to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)#Internal_fragmentation&quot;&gt;internal fragmentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;There are many more allocator designs with different tradeoffs. &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#slab-allocator&quot;&gt;Slab allocation&lt;&#x2F;a&gt; works well to optimize the allocation of common fixed-size structures, but is not applicable in all situations. &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocator-designs&#x2F;#buddy-allocator&quot;&gt;Buddy allocation&lt;&#x2F;a&gt; uses a binary tree to merge freed blocks back together, but wastes a large amount of memory because it only supports power-of-2 block sizes. It‚Äôs also important to remember that each kernel implementation has a unique workload, so there is no ‚Äúbest‚Äù allocator design that fits all cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;With this post, we conclude our memory management implementation for now. Next, we will start exploring &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Computer_multitasking&quot;&gt;&lt;em&gt;multitasking&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, starting with cooperative multitasking in the form of &lt;a href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;async-book&#x2F;01_getting_started&#x2F;04_async_await_primer.html&quot;&gt;&lt;em&gt;async&#x2F;await&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. In subsequent posts, we will then explore &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_(computing)&quot;&gt;&lt;em&gt;threads&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiprocessing&quot;&gt;&lt;em&gt;multiprocessing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Process_(computing)&quot;&gt;&lt;em&gt;processes&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in December 2019</title>
                <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2020-01-07/</link>
                <guid>https://os.phil-opp.com/status-update/2020-01-07/</guid>
                <description>&lt;p&gt;Happy New Year!&lt;&#x2F;p&gt;
&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the corresponding libraries and tools.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The repository of the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog received the following updates:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Update &lt;code&gt;x86_64&lt;&#x2F;code&gt; dependency to version 0.8.1. This included the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;701&quot;&gt;dependency update&lt;&#x2F;a&gt; itself, an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;703&quot;&gt;update of the frame allocation code&lt;&#x2F;a&gt;, and an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;704&quot;&gt;update of the blog&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;705&quot;&gt;License the &lt;code&gt;blog&#x2F;content&lt;&#x2F;code&gt; folder under CC BY-NC&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;709&quot;&gt;Reword sentence in first post&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pamolloy&quot;&gt;@pamolloy&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Further, we‚Äôre still working on adding &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt; to the blog, starting with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;694&quot;&gt;Simplified Chinese&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;699&quot;&gt;Traditional Chinese&lt;&#x2F;a&gt;. Any help is appreciated!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the bootloader this month.&lt;&#x2F;p&gt;
&lt;p&gt;I‚Äôm currently working on rewriting the 16-bit&#x2F;32-bit stages in Rust and making the bootloader more modular in the process. This should make it much easier to add support for UEFI and GRUB booting later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;There were no updates to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool this month.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;We landed a number of breaking changes this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;91&quot;&gt;Replace &lt;code&gt;ux&lt;&#x2F;code&gt; dependency with custom wrapper structs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;89&quot;&gt;Add new UnusedPhysFrame type and use it in Mapper::map_to&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;84&quot;&gt;Make Mapper trait object safe by adding &lt;code&gt;Self: Sized&lt;&#x2F;code&gt; bounds on generic functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;108&quot;&gt;Rename divide_by_zero field of IDT to divide_error&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;109&quot;&gt;Introduce new diverging handler functions for exceptions classified as ‚Äúabort‚Äù&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These changes were released an version 0.8.0. Unfortunately, there was a missing re-export for the new &lt;code&gt;UnusedPhysFrame&lt;&#x2F;code&gt; type. We fixed it in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;110&quot;&gt;#110&lt;&#x2F;a&gt; and released the fix as version 0.8.1.&lt;&#x2F;p&gt;
&lt;p&gt;There was one more addition to the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate afterwards:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;111&quot;&gt;Add support for cr4 control register (with complete documentation)&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;KarimAllah&quot;&gt;@KarimAllah&lt;&#x2F;a&gt; (released as version 0.8.2).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There were also a few changes related to continuous integration:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;103&quot;&gt;Remove bors from this repo&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;104&quot;&gt;Run ‚Äòpush‚Äô builds only for master branch&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;105&quot;&gt;Remove Travis CI and Azure Pipelines scripts&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;100&quot;&gt;Add caching of cargo crates to GitHub Actions CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate, which cross-compiles the sysroot, received the following updates this month:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;43&quot;&gt;Add &lt;code&gt;--quiet&lt;&#x2F;code&gt; flag that suppresses ‚Äúwaiting for file lock‚Äù message&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Nils-TUD&quot;&gt;@Nils-TUD&lt;&#x2F;a&gt; (published as version 0.5.19)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;50&quot;&gt;Fix wrong feature name for memcpy=false&lt;&#x2F;a&gt; (released as version 0.5.20)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in October and November 2019</title>
                <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-12-02/</link>
                <guid>https://os.phil-opp.com/status-update/2019-12-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I moved to a new apartment mid-October and had lots of work to do there, so I didn‚Äôt have the time for creating the October status update post. Therefore, this post lists the changes from both October and November. I‚Äôm slowly picking up speed again, but I still have a lot of mails in my backlog. Sorry if you haven‚Äôt received an answer yet!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The blog itself received only a minor update: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;687&quot;&gt;Use panic! instead of println! + loop in double fault handler&lt;&#x2F;a&gt;. This fixes an issue where a double fault during &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; leads to an endless loop without any output on the serial port.&lt;&#x2F;p&gt;
&lt;p&gt;We also have other news: We plan to add &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;692&quot;&gt;Experimental Support for Community Translations&lt;&#x2F;a&gt; to the blog. While this imposes additional challenges, it makes the content accessible to people who don‚Äôt speak English, so it‚Äôs definitely worth trying in my opinion. The first additional language will be &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;694&quot;&gt;Chinese&lt;&#x2F;a&gt;, based on an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rustcc&#x2F;writing-an-os-in-rust&quot;&gt;existing translation&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;luojia65&quot;&gt;@luojia65&lt;&#x2F;a&gt;. Many thanks also to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TheBegining&quot;&gt;@TheBegining&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rustin-Liu&quot;&gt;@Rustin-Liu&lt;&#x2F;a&gt; for helping with the translation!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;81&quot;&gt;Change the way the kernel entry point is called to honor alignment ABI&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;GuillaumeDIDIER&quot;&gt;@GuillaumeDIDIER&lt;&#x2F;a&gt; (published as version 0.8.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;82&quot;&gt;Add support for Github Actions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;85&quot;&gt;Remove unnecessary &lt;code&gt;extern C&lt;&#x2F;code&gt; on panic handler to fix not-ffi-safe warning&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cmsd2&quot;&gt;@cmsd2&lt;&#x2F;a&gt; (published as version 0.8.3)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;47&quot;&gt;Don‚Äôt exit with expected exit code when failed to read QEMU exit code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;93&quot;&gt;Switch to GitHub Actions for CI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;94&quot;&gt;Use &lt;code&gt;repr C&lt;&#x2F;code&gt; to suppress not-ffi-safe when used with extern handler functions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;cmsd2&quot;&gt;@cmsd2&lt;&#x2F;a&gt; (published as version 0.7.6)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;95&quot;&gt;Add &lt;code&gt;slice&lt;&#x2F;code&gt; and &lt;code&gt;slice_mut&lt;&#x2F;code&gt; methods to IDT&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foxcob&quot;&gt;@foxcob&lt;&#x2F;a&gt; (published as version 0.7.7)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;47&quot;&gt;Add support for publishing and installing cross compiled crates&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ALSchwalm&quot;&gt;@ALSchwalm&lt;&#x2F;a&gt; (published as version 0.5.18)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in September 2019</title>
                <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-10-06/</link>
                <guid>https://os.phil-opp.com/status-update/2019-10-06/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I finished my master thesis and got my degree this month, so I only had limited time for my open source work. I still managed to perform a few minor updates, including code simplications for the &lt;em&gt;Paging Implementation&lt;&#x2F;em&gt; post and the evaluation of GitHub Actions as a CI service.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;666&quot;&gt;Improve Paging Implementation Post&lt;&#x2F;a&gt;: Improves and simplifies the code in multiple places&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;660&quot;&gt;Use GitHub Actions to build and deploy blog&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Set up GitHub Actions for &lt;code&gt;post-XX&lt;&#x2F;code&gt; branches: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;661&quot;&gt;&lt;code&gt;post-01&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;662&quot;&gt;&lt;code&gt;post-02&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;663&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;664&quot;&gt;Update to bootloader 0.8.0&lt;&#x2F;a&gt;: Considerably reduces compile times&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;670&quot;&gt;Update to Zola 0.9.0&lt;&#x2F;a&gt;: Updates the used static site generator to the latest version&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;&lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;44&quot;&gt;Print a warning when building for the host target&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;77&quot;&gt;Add a Cargo Feature for Enabling SSE&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;uart-16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;1&quot;&gt;Update to x86_64 0.7.3 and bitflags&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;uart_16550&#x2F;pull&#x2F;2&quot;&gt;Document how serial port is configured by default&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;edigaryev&quot;&gt;@edigaryev&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;No updates were merged in September. However, I‚Äôm planning some breaking changes for the crate, namely:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;91&quot;&gt;Replace &lt;code&gt;ux&lt;&#x2F;code&gt; dependency with custom wrapper structs&lt;&#x2F;a&gt; to reduce compile times&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;89&quot;&gt;Add new UnsafePhysFrame type and use it in Mapper::map_to&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;84&quot;&gt;Make Mapper trait object safe by adding &lt;code&gt;Self: Sized&lt;&#x2F;code&gt; bounds on generic functions&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!--
## `bootimage`

No updates were merged in September.
--&gt;
</description>
            </item>
        
            <item>
                <title>Updates in August 2019</title>
                <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-09-09/</link>
                <guid>https://os.phil-opp.com/status-update/2019-09-09/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;I was very busy with finishing my master‚Äôs thesis, so I didn‚Äôt have any to implement any notable changes myself. Thanks to contributions by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;, we were still able to publish new versions of the &lt;code&gt;x86_64&lt;&#x2F;code&gt;, &lt;code&gt;bootimage&lt;&#x2F;code&gt; and &lt;code&gt;bootloader&lt;&#x2F;code&gt; crates.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Apart from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;650&quot;&gt;rewriting the section about no-harness tests&lt;&#x2F;a&gt; of the &lt;em&gt;Testing&lt;&#x2F;em&gt; post, there were no notable changes to the blog in August. Now that I have some more free time again, I plan to upgrade the blog to the latest versions of &lt;code&gt;bootloader&lt;&#x2F;code&gt; and &lt;code&gt;bootimage&lt;&#x2F;code&gt;, evaluate the use of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;features&#x2F;actions&quot;&gt;GitHub Actions&lt;&#x2F;a&gt; for the repository, and continue the work on the upcoming post about heap allocator implementations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2F;a&gt;, the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate now has &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;87&quot;&gt;support for the &lt;code&gt;FsBase&lt;&#x2F;code&gt; and &lt;code&gt;GsBase&lt;&#x2F;code&gt; registers&lt;&#x2F;a&gt;. The change was published as version 0.7.5.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;To allow bootloaders to read configuration from the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file of the kernel, the &lt;code&gt;bootimage&lt;&#x2F;code&gt; crate now &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;45&quot;&gt;passes the location of the kernel‚Äôs Cargo.toml to bootloader crates&lt;&#x2F;a&gt;. This change was implemented by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; and published as version 0.7.7.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Apart from initializing the CPU and loading the kernel, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate is also responsible for creating several memory regions for the kernel, for example a program stack and the boot information struct. These regions must be mapped at some address in the virtual address space.&lt;&#x2F;p&gt;
&lt;p&gt;As a stop-gap solution, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate used fixed virtual addresses for these regions, which resulted in errors if the kernel tried to use the same address ranges itself. For example, the (optional) recursive mapping of page tables often conflicted with so-called &lt;em&gt;higher half kernels&lt;&#x2F;em&gt;, which live at the upper end of the address space. To avoid these conflicts, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; updated the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;71&quot;&gt;dynamically map the kernel stack, boot info, physical memory, and recursive table regions&lt;&#x2F;a&gt; at an unused virtual address range.&lt;&#x2F;p&gt;
&lt;p&gt;To also support specifying explicit addresses for these regions, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; further added support for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;73&quot;&gt;parsing bootloader configuration from the kernel‚Äôs Cargo.toml&lt;&#x2F;a&gt;. This way, the virtual addresses of the kernel stack and physical memory mapping can now be configured using a &lt;code&gt;package.metadata.bootloader&lt;&#x2F;code&gt; key in the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; of the kernel. In a third pull request, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; also made the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;72&quot;&gt;kernel stack size configurable&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The changes were published together as version 0.8.0. This is a breaking update because the new configuration system requires at least version 0.7.7 of &lt;code&gt;bootimage&lt;&#x2F;code&gt;, which is the first version that passes the location of the kernel‚Äôs &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in July 2019</title>
                <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-08-02/</link>
                <guid>https://os.phil-opp.com/status-update/2019-08-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;Since I‚Äôm still very busy with my master thesis, I haven‚Äôt had the time to work on a new post. But there were quite a few maintenance updates this month and also a few new features such as the new &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; type in the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;p&gt;We also had some great contributions this month. Thanks to the efforts of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;, we were able to considerably lower the compile times of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; and &lt;code&gt;bootloader&lt;&#x2F;code&gt; crates. Thanks to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt;, the &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crate now has a  &lt;code&gt;cargo xdoc&lt;&#x2F;code&gt; subcommands and support for the &lt;code&gt;cargo {c, b, t, r}&lt;&#x2F;code&gt; aliases.&lt;&#x2F;p&gt;
&lt;p&gt;The following list gives a short overview of notable changes to the different projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;638&quot;&gt;Fix a lot of dead links in both the second and first edition&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;644&quot;&gt;Update paging introduction post to use page fault error code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;82&quot;&gt;Reexport MappedPageTable on non-x86_64 platforms too&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;78&quot;&gt;Update GDT docs, add user_data_segment function and WRITABLE flag&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.7.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;83&quot;&gt;Add a new &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; mapper type&lt;&#x2F;a&gt; (published as version 0.7.3)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;86&quot;&gt;Update integration tests to use new testing framework&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;85&quot;&gt;Remove raw-cpuid dependency and use rdrand intrinsics&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.7.4)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;62&quot;&gt;Remove stabilized publish-lockfile feature&lt;&#x2F;a&gt; (published as version 0.6.2)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;63&quot;&gt;Update CI badge, use latest version of x86_64 crate and rustfmt&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt; (published as version 0.6.3)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;67&quot;&gt;Use volatile accesses in VGA code and make font dependency optional&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Making the dependency optional should improve compile times when the VGA text mode is used&lt;&#x2F;li&gt;
&lt;li&gt;Published as version 0.6.4&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Breaking&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;68&quot;&gt;Only include dependencies when &lt;code&gt;binary&lt;&#x2F;code&gt; feature is enabled&lt;&#x2F;a&gt; (published as version 0.7.0)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;43&quot;&gt;If the bootloader has a feature named &lt;code&gt;binary&lt;&#x2F;code&gt;, enable it&lt;&#x2F;a&gt; (published as version 0.7.6)
&lt;ul&gt;
&lt;li&gt;This is required for building &lt;code&gt;bootloader 0.7.0&lt;&#x2F;code&gt; or later&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;39&quot;&gt;Add &lt;code&gt;cargo xdoc&lt;&#x2F;code&gt; command for invoking &lt;code&gt;cargo doc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt; (published as version 0.5.13)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;40&quot;&gt;Don‚Äôt append a &lt;code&gt;--sysroot&lt;&#x2F;code&gt; argument to &lt;code&gt;RUSTFLAGS&lt;&#x2F;code&gt; if it already contains one&lt;&#x2F;a&gt; (published as version 0.5.14)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;42&quot;&gt;Add xb, xt, xc, and xr subcommands&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2F;a&gt; (published as version 0.5.15)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in June 2019</title>
                <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-07-06/</link>
                <guid>https://os.phil-opp.com/status-update/2019-07-06/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and the used libraries and tools.&lt;&#x2F;p&gt;
&lt;p&gt;My focus this month was to finish the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;&quot;&gt;&lt;em&gt;Heap Allocation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, on which I had been working since March. I originally wanted to include a section about different allocator designs (bump, linked list, slab, ‚Ä¶) and how to implement them, but I decided to split it out into a separate post because it became much too long. I try to release this half-done post soon.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from the new post, there were some minor updates to the &lt;code&gt;x86_64&lt;&#x2F;code&gt;, &lt;code&gt;bootloader&lt;&#x2F;code&gt; and &lt;code&gt;cargo-xbuild&lt;&#x2F;code&gt; crates. The following gives a short overview of notable changes to the different projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;617&quot;&gt;Use misspell tool to look for common typos&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;625&quot;&gt;New post about heap allocation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;77&quot;&gt;Add ring-3 flag to GDT descriptor&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mark-i-m&quot;&gt;@mark-i-m&lt;&#x2F;a&gt; (released as version 0.7.1)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;79&quot;&gt;Add bochs magic breakpoint, read instruction pointer, inline instructions&lt;&#x2F;a&gt; by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;64&quot;&gt;@64&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;58&quot;&gt;Make the physical memory offset configurable through a &lt;code&gt;BOOTLOADER_PHYSICAL_MEMORY_OFFSET&lt;&#x2F;code&gt; environment variable&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;59&quot;&gt;Use a stripped copy of the kernel binary (debug info removed) to reduce load times&lt;&#x2F;a&gt; (released as version 0.6.1)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;!-- ## Bootimage --&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;994b5e75e1a4062cf506700e0ff38d5404338a37&quot;&gt;Document the XBUILD_SYSROOT_PATH environment variable&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;a1ff03311dd74447e8e845b4b96f2e137850027d&quot;&gt;Fix incorrect joining of paths that caused some problems on Windows&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Heap Allocation</title>
                <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/heap-allocation/</link>
                <guid>https://os.phil-opp.com/heap-allocation/</guid>
                <description>&lt;p&gt;This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post, all the allocation and collection types of the built-in &lt;code&gt;alloc&lt;&#x2F;code&gt; crate will be available to our kernel.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-10&quot;&gt;&lt;code&gt;post-10&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;local-and-static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-and-static-variables&quot; aria-label=&quot;Anchor link for: local-and-static-variables&quot;&gt;üîó&lt;&#x2F;a&gt;Local and Static Variables&lt;&#x2F;h2&gt;
&lt;p&gt;We currently use two types of variables in our kernel: local variables and &lt;code&gt;static&lt;&#x2F;code&gt; variables. Local variables are stored on the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Call_stack&quot;&gt;call stack&lt;&#x2F;a&gt; and are only valid until the surrounding function returns. Static variables are stored at a fixed memory location and always live for the complete lifetime of the program.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;local-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-variables&quot; aria-label=&quot;Anchor link for: local-variables&quot;&gt;üîó&lt;&#x2F;a&gt;Local Variables&lt;&#x2F;h3&gt;
&lt;p&gt;Local variables are stored on the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Call_stack&quot;&gt;call stack&lt;&#x2F;a&gt;, which is a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stack_(abstract_data_type)&quot;&gt;stack data structure&lt;&#x2F;a&gt; that supports &lt;code&gt;push&lt;&#x2F;code&gt; and &lt;code&gt;pop&lt;&#x2F;code&gt; operations. On each function entry, the parameters, the return address, and the local variables of the called function are pushed by the compiler:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;call-stack.svg&quot; alt=&quot;An outer() and an inner(i: usize) function, where outer calls inner(1). Both have some local variables. The call stack contains the following slots: the local variables of outer, then the argument i = 1, then the return address, then the local variables of inner.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The above example shows the call stack after the &lt;code&gt;outer&lt;&#x2F;code&gt; function called the &lt;code&gt;inner&lt;&#x2F;code&gt; function. We see that the call stack contains the local variables of &lt;code&gt;outer&lt;&#x2F;code&gt; first. On the &lt;code&gt;inner&lt;&#x2F;code&gt; call, the parameter &lt;code&gt;1&lt;&#x2F;code&gt; and the return address for the function were pushed. Then control was transferred to &lt;code&gt;inner&lt;&#x2F;code&gt;, which pushed its local variables.&lt;&#x2F;p&gt;
&lt;p&gt;After the &lt;code&gt;inner&lt;&#x2F;code&gt; function returns, its part of the call stack is popped again and only the local variables of &lt;code&gt;outer&lt;&#x2F;code&gt; remain:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;call-stack-return.svg&quot; alt=&quot;The call stack containing only the local variables of outer&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that the local variables of &lt;code&gt;inner&lt;&#x2F;code&gt; only live until the function returns. The Rust compiler enforces these lifetimes and throws an error when we use a value for too long, for example when we try to return a reference to a local variable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;inner(i: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static u32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;z[i]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=6186a0f3a54f468e1de8894996d12819&quot;&gt;run the example on the playground&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;While returning a reference makes no sense in this example, there are cases where we want a variable to live longer than the function. We already saw such a case in our kernel when we tried to &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#loading-the-idt&quot;&gt;load an interrupt descriptor table&lt;&#x2F;a&gt; and had to use a &lt;code&gt;static&lt;&#x2F;code&gt; variable to extend the lifetime.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#static-variables&quot; aria-label=&quot;Anchor link for: static-variables&quot;&gt;üîó&lt;&#x2F;a&gt;Static Variables&lt;&#x2F;h3&gt;
&lt;p&gt;Static variables are stored at a fixed memory location separate from the stack. This memory location is assigned at compile time by the linker and encoded in the executable. Statics live for the complete runtime of the program, so they have the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime and can always be referenced from local variables:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;call-stack-static.svg&quot; alt=&quot;The same outer&#x2F;inner example, except that inner has a static Z: [u32; 3] = [1,2,3]; and returns a &amp;amp;Z[i] reference&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;When the &lt;code&gt;inner&lt;&#x2F;code&gt; function returns in the above example, its part of the call stack is destroyed. The static variables live in a separate memory range that is never destroyed, so the &lt;code&gt;&amp;amp;Z[1]&lt;&#x2F;code&gt; reference is still valid after the return.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime, static variables also have the useful property that their location is known at compile time, so that no reference is needed for accessing them. We utilized that property for our &lt;code&gt;println&lt;&#x2F;code&gt; macro: By using a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#a-global-interface&quot;&gt;static &lt;code&gt;Writer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; internally, there is no &lt;code&gt;&amp;amp;mut Writer&lt;&#x2F;code&gt; reference needed to invoke the macro, which is very useful in &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#implementation&quot;&gt;exception handlers&lt;&#x2F;a&gt;, where we don‚Äôt have access to any additional variables.&lt;&#x2F;p&gt;
&lt;p&gt;However, this property of static variables brings a crucial drawback: they are read-only by default. Rust enforces this because a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;races.html&quot;&gt;data race&lt;&#x2F;a&gt; would occur if, e.g., two threads modified a static variable at the same time. The only way to modify a static variable is to encapsulate it in a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.2&#x2F;spin&#x2F;struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type, which ensures that only a single &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference exists at any point in time. We already used a &lt;code&gt;Mutex&lt;&#x2F;code&gt; for our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#spinlocks&quot;&gt;static VGA buffer &lt;code&gt;Writer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dynamic-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamic-memory&quot; aria-label=&quot;Anchor link for: dynamic-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Dynamic Memory&lt;&#x2F;h2&gt;
&lt;p&gt;Local and static variables are already very powerful together and enable most use cases. However, we saw that they both have their limitations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Local variables only live until the end of the surrounding function or block. This is because they live on the call stack and are destroyed after the surrounding function returns.&lt;&#x2F;li&gt;
&lt;li&gt;Static variables always live for the complete runtime of the program, so there is no way to reclaim and reuse their memory when they‚Äôre no longer needed. Also, they have unclear ownership semantics and are accessible from all functions, so they need to be protected by a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.2&#x2F;spin&#x2F;struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when we want to modify them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Another limitation of local and static variables is that they have a fixed size. So they can‚Äôt store a collection that dynamically grows when more elements are added. (There are proposals for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;48055&quot;&gt;unsized rvalues&lt;&#x2F;a&gt; in Rust that would allow dynamically sized local variables, but they only work in some specific cases.)&lt;&#x2F;p&gt;
&lt;p&gt;To circumvent these drawbacks, programming languages often support a third memory region for storing variables called the &lt;strong&gt;heap&lt;&#x2F;strong&gt;. The heap supports &lt;em&gt;dynamic memory allocation&lt;&#x2F;em&gt; at runtime through two functions called &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt;. It works in the following way: The &lt;code&gt;allocate&lt;&#x2F;code&gt; function returns a free chunk of memory of the specified size that can be used to store a variable. This variable then lives until it is freed by calling the &lt;code&gt;deallocate&lt;&#x2F;code&gt; function with a reference to the variable.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs go through an example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;call-stack-heap.svg&quot; alt=&quot;The inner function calls allocate(size_of([u32; 3])), writes z.write([1,2,3]);, and returns (z as *mut u32).offset(i). On the returned value y, the outer function performs deallocate(y, size_of(u32)).&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here the &lt;code&gt;inner&lt;&#x2F;code&gt; function uses heap memory instead of static variables for storing &lt;code&gt;z&lt;&#x2F;code&gt;. It first allocates a memory block of the required size, which returns a &lt;code&gt;*mut u32&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2F;a&gt;. It then uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;ptr&#x2F;fn.write.html&quot;&gt;&lt;code&gt;ptr::write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to write the array &lt;code&gt;[1,2,3]&lt;&#x2F;code&gt; to it. In the last step, it uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.offset&quot;&gt;&lt;code&gt;offset&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to calculate a pointer to the &lt;code&gt;i&lt;&#x2F;code&gt;-th element and then returns it. (Note that we omitted some required casts and unsafe blocks in this example function for brevity.)&lt;&#x2F;p&gt;
&lt;p&gt;The allocated memory lives until it is explicitly freed through a call to &lt;code&gt;deallocate&lt;&#x2F;code&gt;. Thus, the returned pointer is still valid even after &lt;code&gt;inner&lt;&#x2F;code&gt; returned and its part of the call stack was destroyed. The advantage of using heap memory compared to static memory is that the memory can be reused after it is freed, which we do through the &lt;code&gt;deallocate&lt;&#x2F;code&gt; call in &lt;code&gt;outer&lt;&#x2F;code&gt;. After that call, the situation looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;call-stack-heap-freed.svg&quot; alt=&quot;The call stack contains the local variables of outer, the heap contains z[0] and z[2], but no longer z[1].&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that the &lt;code&gt;z[1]&lt;&#x2F;code&gt; slot is free again and can be reused for the next &lt;code&gt;allocate&lt;&#x2F;code&gt; call. However, we also see that &lt;code&gt;z[0]&lt;&#x2F;code&gt; and &lt;code&gt;z[2]&lt;&#x2F;code&gt; are never freed because we never deallocate them. Such a bug is called a &lt;em&gt;memory leak&lt;&#x2F;em&gt; and is often the cause of excessive memory consumption of programs (just imagine what happens when we call &lt;code&gt;inner&lt;&#x2F;code&gt; repeatedly in a loop). This might seem bad, but there are much more dangerous types of bugs that can happen with dynamic allocation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;common-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#common-errors&quot; aria-label=&quot;Anchor link for: common-errors&quot;&gt;üîó&lt;&#x2F;a&gt;Common Errors&lt;&#x2F;h3&gt;
&lt;p&gt;Apart from memory leaks, which are unfortunate but don‚Äôt make the program vulnerable to attackers, there are two common types of bugs with more severe consequences:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;When we accidentally continue to use a variable after calling &lt;code&gt;deallocate&lt;&#x2F;code&gt; on it, we have a so-called &lt;strong&gt;use-after-free&lt;&#x2F;strong&gt; vulnerability. Such a bug causes undefined behavior and can often be exploited by attackers to execute arbitrary code.&lt;&#x2F;li&gt;
&lt;li&gt;When we accidentally free a variable twice, we have a &lt;strong&gt;double-free&lt;&#x2F;strong&gt; vulnerability. This is problematic because it might free a different allocation that was allocated in the same spot after the first &lt;code&gt;deallocate&lt;&#x2F;code&gt; call. Thus, it can lead to a use-after-free vulnerability again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These types of vulnerabilities are commonly known, so one might expect that people have learned how to avoid them by now. But no, such vulnerabilities are still regularly found, for example this &lt;a href=&quot;https:&#x2F;&#x2F;securityboulevard.com&#x2F;2019&#x2F;02&#x2F;linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11&#x2F;&quot;&gt;use-after-free vulnerability in Linux&lt;&#x2F;a&gt; (2019), that allowed arbitrary code execution. A web search like &lt;code&gt;use-after-free linux {current year}&lt;&#x2F;code&gt; will probably always yield results. This shows that even the best programmers are not always able to correctly handle dynamic memory in complex projects.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid these issues, many languages, such as Java or Python, manage dynamic memory automatically using a technique called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Garbage_collection_(computer_science)&quot;&gt;&lt;em&gt;garbage collection&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. The idea is that the programmer never invokes &lt;code&gt;deallocate&lt;&#x2F;code&gt; manually. Instead, the program is regularly paused and scanned for unused heap variables, which are then automatically deallocated. Thus, the above vulnerabilities can never occur. The drawbacks are the performance overhead of the regular scan and the probably long pause times.&lt;&#x2F;p&gt;
&lt;p&gt;Rust takes a different approach to the problem: It uses a concept called &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-01-what-is-ownership.html&quot;&gt;&lt;em&gt;ownership&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; that is able to check the correctness of dynamic memory operations at compile time. Thus, no garbage collection is needed to avoid the mentioned vulnerabilities, which means that there is no performance overhead. Another advantage of this approach is that the programmer still has fine-grained control over the use of dynamic memory, just like with C or C++.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocations-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocations-in-rust&quot; aria-label=&quot;Anchor link for: allocations-in-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Allocations in Rust&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of letting the programmer manually call &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt;, the Rust standard library provides abstraction types that call these functions implicitly. The most important type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, which is an abstraction for a heap-allocated value. It provides a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; constructor function that takes a value, calls &lt;code&gt;allocate&lt;&#x2F;code&gt; with the size of the value, and then moves the value to the newly allocated slot on the heap. To free the heap memory again, the &lt;code&gt;Box&lt;&#x2F;code&gt; type implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-03-drop.html&quot;&gt;&lt;code&gt;Drop&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt; to call &lt;code&gt;deallocate&lt;&#x2F;code&gt; when it goes out of scope:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z = Box::new([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; z goes out of scope and `deallocate` is called
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This pattern has the strange name &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Resource_acquisition_is_initialization&quot;&gt;&lt;em&gt;resource acquisition is initialization&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (or &lt;em&gt;RAII&lt;&#x2F;em&gt; for short). It originated in C++, where it is used to implement a similar abstraction type called &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;memory&#x2F;unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Such a type alone does not suffice to prevent all use-after-free bugs since programmers can still hold on to references after the &lt;code&gt;Box&lt;&#x2F;code&gt; goes out of scope and the corresponding heap memory slot is deallocated:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; z = Box::new([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;z[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;}; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; z goes out of scope and `deallocate` is called
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, x);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is where Rust‚Äôs ownership comes in. It assigns an abstract &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html&quot;&gt;lifetime&lt;&#x2F;a&gt; to each reference, which is the scope in which the reference is valid. In the above example, the &lt;code&gt;x&lt;&#x2F;code&gt; reference is taken from the &lt;code&gt;z&lt;&#x2F;code&gt; array, so it becomes invalid after &lt;code&gt;z&lt;&#x2F;code&gt; goes out of scope. When you &lt;a href=&quot;https:&#x2F;&#x2F;play.rust-lang.org&#x2F;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=28180d8de7b62c6b4a681a7b1f745a48&quot;&gt;run the above example on the playground&lt;&#x2F;a&gt; you see that the Rust compiler indeed throws an error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0597]: `z[_]` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;main.rs:4:9
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;2 |     let x = {
&lt;&#x2F;span&gt;&lt;span&gt;  |         - borrow later stored here
&lt;&#x2F;span&gt;&lt;span&gt;3 |         let z = Box::new([1,2,3]);
&lt;&#x2F;span&gt;&lt;span&gt;4 |         &amp;amp;z[1]
&lt;&#x2F;span&gt;&lt;span&gt;  |         ^^^^^ borrowed value does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;5 |     }; &#x2F;&#x2F; z goes out of scope and `deallocate` is called
&lt;&#x2F;span&gt;&lt;span&gt;  |     - `z[_]` dropped here while still borrowed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The terminology can be a bit confusing at first. Taking a reference to a value is called &lt;em&gt;borrowing&lt;&#x2F;em&gt; the value since it‚Äôs similar to a borrow in real life: You have temporary access to an object but need to return it sometime, and you must not destroy it. By checking that all borrows end before an object is destroyed, the Rust compiler can guarantee that no use-after-free situation can occur.&lt;&#x2F;p&gt;
&lt;p&gt;Rust‚Äôs ownership system goes even further, preventing not only use-after-free bugs but also providing complete &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety&quot;&gt;&lt;em&gt;memory safety&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, as garbage collected languages like Java or Python do. Additionally, it guarantees &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thread_safety&quot;&gt;&lt;em&gt;thread safety&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and is thus even safer than those languages in multi-threaded code. And most importantly, all these checks happen at compile time, so there is no runtime overhead compared to hand-written memory management in C.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;use-cases&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#use-cases&quot; aria-label=&quot;Anchor link for: use-cases&quot;&gt;üîó&lt;&#x2F;a&gt;Use Cases&lt;&#x2F;h3&gt;
&lt;p&gt;We now know the basics of dynamic memory allocation in Rust, but when should we use it? We‚Äôve come really far with our kernel without dynamic memory allocation, so why do we need it now?&lt;&#x2F;p&gt;
&lt;p&gt;First, dynamic memory allocation always comes with a bit of performance overhead since we need to find a free slot on the heap for every allocation. For this reason, local variables are generally preferable, especially in performance-sensitive kernel code. However, there are cases where dynamic memory allocation is the best choice.&lt;&#x2F;p&gt;
&lt;p&gt;As a basic rule, dynamic memory is required for variables that have a dynamic lifetime or a variable size. The most important type with a dynamic lifetime is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Rc&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, which counts the references to its wrapped value and deallocates it after all references have gone out of scope. Examples for types with a variable size are &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Vec&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;string&#x2F;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;, and other &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt; that dynamically grow when more elements are added. These types work by allocating a larger amount of memory when they become full, copying all elements over, and then deallocating the old allocation.&lt;&#x2F;p&gt;
&lt;p&gt;For our kernel, we will mostly need the collection types, for example, to store a list of active tasks when implementing multitasking in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-allocator-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-interface&quot; aria-label=&quot;Anchor link for: the-allocator-interface&quot;&gt;üîó&lt;&#x2F;a&gt;The Allocator Interface&lt;&#x2F;h2&gt;
&lt;p&gt;The first step in implementing a heap allocator is to add a dependency on the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. Like the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;&quot;&gt;&lt;code&gt;core&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate, it is a subset of the standard library that additionally contains the allocation and collection types. To add the dependency on &lt;code&gt;alloc&lt;&#x2F;code&gt;, we add the following to our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; alloc;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Contrary to normal dependencies, we don‚Äôt need to modify the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;. The reason is that the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate ships with the Rust compiler as part of the standard library, so the compiler already knows about the crate. By adding this &lt;code&gt;extern crate&lt;&#x2F;code&gt; statement, we specify that the compiler should try to include it. (Historically, all dependencies needed an &lt;code&gt;extern crate&lt;&#x2F;code&gt; statement, which is now optional).&lt;&#x2F;p&gt;
&lt;p&gt;Since we are compiling for a custom target, we can‚Äôt use the precompiled version of &lt;code&gt;alloc&lt;&#x2F;code&gt; that is shipped with the Rust installation. Instead, we have to tell cargo to recompile the crate from source. We can do that by adding it to the &lt;code&gt;unstable.build-std&lt;&#x2F;code&gt; array in our &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;unstable&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;build-std &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;core&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;compiler_builtins&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;alloc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the compiler will recompile and include the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate in our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;The reason that the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate is disabled by default in &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; crates is that it has additional requirements. When we try to compile our project now, we will see these requirements as errors:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: no global memory allocator found but one is required; link to std or add
&lt;&#x2F;span&gt;&lt;span&gt;       #[global_allocator] to a static item that implements the GlobalAlloc trait.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first error occurs because the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate requires a heap allocator, which is an object that provides the &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt; functions. In Rust, heap allocators are described by the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, which is mentioned in the error message. To set the heap allocator for the crate, the &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute must be applied to a &lt;code&gt;static&lt;&#x2F;code&gt; variable that implements the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;The second error occurs because calls to &lt;code&gt;allocate&lt;&#x2F;code&gt; can fail, most commonly when there is no more memory available. Our program must be able to react to this case, which is what the &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; function is for.&lt;&#x2F;p&gt;
&lt;p&gt;We will describe these traits and attributes in detail in the following sections.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-globalalloc-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-globalalloc-trait&quot; aria-label=&quot;Anchor link for: the-globalalloc-trait&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; Trait&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait defines the functions that a heap allocator must provide. The trait is special because it is almost never used directly by the programmer. Instead, the compiler will automatically insert the appropriate calls to the trait methods when using the allocation and collection types of &lt;code&gt;alloc&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Since we will need to implement the trait for all our allocator types, it is worth taking a closer look at its declaration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_zeroed(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;realloc(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;        ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        layout: Layout,
&lt;&#x2F;span&gt;&lt;span&gt;        new_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It defines the two required methods &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which correspond to the &lt;code&gt;allocate&lt;&#x2F;code&gt; and &lt;code&gt;deallocate&lt;&#x2F;code&gt; functions we used in our examples:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method takes a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance as an argument, which describes the desired size and alignment that the allocated memory should have. It returns a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2F;a&gt; to the first byte of the allocated memory block. Instead of an explicit error value, the &lt;code&gt;alloc&lt;&#x2F;code&gt; method returns a null pointer to signal an allocation error. This is a bit non-idiomatic, but it has the advantage that wrapping existing system allocators is easy since they use the same convention.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is the counterpart and is responsible for freeing a memory block again. It receives two arguments: the pointer returned by &lt;code&gt;alloc&lt;&#x2F;code&gt; and the &lt;code&gt;Layout&lt;&#x2F;code&gt; that was used for the allocation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The trait additionally defines the two methods &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with default implementations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is equivalent to calling &lt;code&gt;alloc&lt;&#x2F;code&gt; and then setting the allocated memory block to zero, which is exactly what the provided default implementation does. An allocator implementation can override the default implementations with a more efficient custom implementation if possible.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;alloc&#x2F;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method allows to grow or shrink an allocation. The default implementation allocates a new memory block with the desired size and copies over all the content from the previous allocation. Again, an allocator implementation can probably provide a more efficient implementation of this method, for example by growing&#x2F;shrinking the allocation in-place if possible.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;unsafety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unsafety&quot; aria-label=&quot;Anchor link for: unsafety&quot;&gt;üîó&lt;&#x2F;a&gt;Unsafety&lt;&#x2F;h4&gt;
&lt;p&gt;One thing to notice is that both the trait itself and all trait methods are declared as &lt;code&gt;unsafe&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The reason for declaring the trait as &lt;code&gt;unsafe&lt;&#x2F;code&gt; is that the programmer must guarantee that the trait implementation for an allocator type is correct. For example, the &lt;code&gt;alloc&lt;&#x2F;code&gt; method must never return a memory block that is already used somewhere else because this would cause undefined behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, the reason that the methods are &lt;code&gt;unsafe&lt;&#x2F;code&gt; is that the caller must ensure various invariants when calling the methods, for example, that the &lt;code&gt;Layout&lt;&#x2F;code&gt; passed to &lt;code&gt;alloc&lt;&#x2F;code&gt; specifies a non-zero size. This is not really relevant in practice since the methods are normally called directly by the compiler, which ensures that the requirements are met.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;a-dummyallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummyallocator&quot; aria-label=&quot;Anchor link for: a-dummyallocator&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;DummyAllocator&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we know what an allocator type should provide, we can create a simple dummy allocator. For that, we create a new &lt;code&gt;allocator&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;allocator;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our dummy allocator does the absolute minimum to implement the trait and always returns an error when &lt;code&gt;alloc&lt;&#x2F;code&gt; is called. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::null_mut;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Dummy;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;GlobalAlloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Dummy {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _layout: Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        null_mut()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, _ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, _layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dealloc should be never called&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct does not need any fields, so we create it as a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized type&lt;&#x2F;a&gt;. As mentioned above, we always return the null pointer from &lt;code&gt;alloc&lt;&#x2F;code&gt;, which corresponds to an allocation error. Since the allocator never returns any memory, a call to &lt;code&gt;dealloc&lt;&#x2F;code&gt; should never occur. For this reason, we simply panic in the &lt;code&gt;dealloc&lt;&#x2F;code&gt; method. The &lt;code&gt;alloc_zeroed&lt;&#x2F;code&gt; and &lt;code&gt;realloc&lt;&#x2F;code&gt; methods have default implementations, so we don‚Äôt need to provide implementations for them.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a simple allocator, but we still have to tell the Rust compiler that it should use this allocator. This is where the &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute comes in.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-global-allocator-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-allocator-attribute&quot; aria-label=&quot;Anchor link for: the-global-allocator-attribute&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; Attribute&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; attribute tells the Rust compiler which allocator instance it should use as the global heap allocator. The attribute is only applicable to a &lt;code&gt;static&lt;&#x2F;code&gt; that implements the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait. Let‚Äôs register an instance of our &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator as the global allocator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: Dummy = Dummy;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized type&lt;&#x2F;a&gt;, we don‚Äôt need to specify any fields in the initialization expression.&lt;&#x2F;p&gt;
&lt;p&gt;When we now try to compile it, the first error should be gone. Let‚Äôs fix the remaining second error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;the-alloc-error-handler-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-alloc-error-handler-attribute&quot; aria-label=&quot;Anchor link for: the-alloc-error-handler-attribute&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; Attribute&lt;&#x2F;h3&gt;
&lt;p&gt;As we learned when discussing the &lt;code&gt;GlobalAlloc&lt;&#x2F;code&gt; trait, the &lt;code&gt;alloc&lt;&#x2F;code&gt; function can signal an allocation error by returning a null pointer. The question is: how should the Rust runtime react to such an allocation failure? This is where the &lt;code&gt;#[alloc_error_handler]&lt;&#x2F;code&gt; attribute comes in. It specifies a function that is called when an allocation error occurs, similar to how our panic handler is called when a panic occurs.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add such a function to fix the compilation error:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(alloc_error_handler)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; at the top of the file
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[alloc_error_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_error_handler(layout: alloc::alloc::Layout) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;allocation error: {:?}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, layout)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;alloc_error_handler&lt;&#x2F;code&gt; function is still unstable, so we need a feature gate to enable it. The function receives a single argument: the &lt;code&gt;Layout&lt;&#x2F;code&gt; instance that was passed to &lt;code&gt;alloc&lt;&#x2F;code&gt; when the allocation failure occurred. There‚Äôs nothing we can do to resolve the failure, so we just panic with a message that contains the &lt;code&gt;Layout&lt;&#x2F;code&gt; instance.&lt;&#x2F;p&gt;
&lt;p&gt;With this function, the compilation errors should be fixed. Now we can use the allocation and collection types of &lt;code&gt;alloc&lt;&#x2F;code&gt;. For example, we can use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to allocate a value on the heap:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; alloc;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] print &amp;quot;Hello World!&amp;quot;, call `init`, create `mapper` and `frame_allocator`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] call `test_main` in test mode
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we need to specify the &lt;code&gt;extern crate alloc&lt;&#x2F;code&gt; statement in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; too. This is required because the &lt;code&gt;lib.rs&lt;&#x2F;code&gt; and &lt;code&gt;main.rs&lt;&#x2F;code&gt; parts are treated as separate crates. However, we don‚Äôt need to create another &lt;code&gt;#[global_allocator]&lt;&#x2F;code&gt; static because the global allocator applies to all crates in the project. In fact, specifying an additional allocator in another crate would be an error.&lt;&#x2F;p&gt;
&lt;p&gt;When we run the above code, we see that our &lt;code&gt;alloc_error_handler&lt;&#x2F;code&gt; function is called:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;qemu-dummy-output.png&quot; alt=&quot;QEMU printing ‚Äúpanicked at `allocation error: Layout { size_: 4, align_: 4 }, src&#x2F;lib.rs:89:5‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The error handler is called because the &lt;code&gt;Box::new&lt;&#x2F;code&gt; function implicitly calls the &lt;code&gt;alloc&lt;&#x2F;code&gt; function of the global allocator. Our dummy allocator always returns a null pointer, so every allocation fails. To fix this, we need to create an allocator that actually returns usable memory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-kernel-heap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-kernel-heap&quot; aria-label=&quot;Anchor link for: creating-a-kernel-heap&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a Kernel Heap&lt;&#x2F;h2&gt;
&lt;p&gt;Before we can create a proper allocator, we first need to create a heap memory region from which the allocator can allocate memory. To do this, we need to define a virtual memory range for the heap region and then map this region to physical frames. See the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;&quot;&gt;&lt;em&gt;‚ÄúIntroduction To Paging‚Äù&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post for an overview of virtual memory and page tables.&lt;&#x2F;p&gt;
&lt;p&gt;The first step is to define a virtual memory region for the heap. We can choose any virtual address range that we like, as long as it is not already used for a different memory region. Let‚Äôs define it as the memory starting at address &lt;code&gt;0x_4444_4444_0000&lt;&#x2F;code&gt; so that we can easily recognize a heap pointer later:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x_4444_4444_0000&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 100 KiB
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the heap size to 100¬†KiB for now. If we need more space in the future, we can simply increase it.&lt;&#x2F;p&gt;
&lt;p&gt;If we tried to use this heap region now, a page fault would occur since the virtual memory region is not mapped to physical memory yet. To resolve this, we create an &lt;code&gt;init_heap&lt;&#x2F;code&gt; function that maps the heap pages using the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#using-offsetpagetable&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt; API&lt;&#x2F;a&gt; that we introduced in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;&quot;&gt;&lt;em&gt;‚ÄúPaging Implementation‚Äù&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{
&lt;&#x2F;span&gt;&lt;span&gt;    structures::paging::{
&lt;&#x2F;span&gt;&lt;span&gt;        mapper::MapToError, FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    VirtAddr,
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_heap(
&lt;&#x2F;span&gt;&lt;span&gt;    mapper: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), MapToError&amp;lt;Size4KiB&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page_range = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_start = VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_end = heap_start + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_start_page = Page::containing_address(heap_start);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_end_page = Page::containing_address(heap_end);
&lt;&#x2F;span&gt;&lt;span&gt;        Page::range_inclusive(heap_start_page, heap_end_page)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; page &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; page_range {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = frame_allocator
&lt;&#x2F;span&gt;&lt;span&gt;            .allocate_frame()
&lt;&#x2F;span&gt;&lt;span&gt;            .ok_or(MapToError::FrameAllocationFailed)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = PageTableFlags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;PageTableFlags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            mapper.map_to(page, frame, flags, frame_allocator)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;.flush()
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function takes mutable references to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, both limited to 4¬†KiB pages by using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;enum.Size4KiB.html&quot;&gt;&lt;code&gt;Size4KiB&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as the generic parameter. The return value of the function is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; with the unit type &lt;code&gt;()&lt;&#x2F;code&gt; as the success variant and a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;enum.MapToError.html&quot;&gt;&lt;code&gt;MapToError&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as the error variant, which is the error type returned by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. Reusing the error type makes sense here because the &lt;code&gt;map_to&lt;&#x2F;code&gt; method is the main source of errors in this function.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation can be broken down into two parts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Creating the page range:&lt;&#x2F;strong&gt;: To create a range of the pages that we want to map, we convert the &lt;code&gt;HEAP_START&lt;&#x2F;code&gt; pointer to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;addr&#x2F;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. Then we calculate the heap end address from it by adding the &lt;code&gt;HEAP_SIZE&lt;&#x2F;code&gt;. We want an inclusive bound (the address of the last byte of the heap), so we subtract 1. Next, we convert the addresses into &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html&quot;&gt;&lt;code&gt;Page&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; types using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html#method.containing_address&quot;&gt;&lt;code&gt;containing_address&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function. Finally, we create a page range from the start and end pages using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html#method.range_inclusive&quot;&gt;&lt;code&gt;Page::range_inclusive&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mapping the pages:&lt;&#x2F;strong&gt; The second step is to map all pages of the page range we just created. For that, we iterate over these pages using a &lt;code&gt;for&lt;&#x2F;code&gt; loop. For each page, we do the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We allocate a physical frame that the page should be mapped to using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html#tymethod.allocate_frame&quot;&gt;&lt;code&gt;FrameAllocator::allocate_frame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. This method returns &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when there are no more frames left. We deal with that case by mapping it to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;enum.MapToError.html#variant.FrameAllocationFailed&quot;&gt;&lt;code&gt;MapToError::FrameAllocationFailed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; error through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.ok_or&quot;&gt;&lt;code&gt;Option::ok_or&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method and then applying the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;edition-guide&#x2F;rust-2018&#x2F;error-handling-and-panics&#x2F;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2F;a&gt; to return early in the case of an error.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We set the required &lt;code&gt;PRESENT&lt;&#x2F;code&gt; flag and the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag for the page. With these flags, both read and write accesses are allowed, which makes sense for heap memory.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method for creating the mapping in the active page table. The method can fail, so we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;edition-guide&#x2F;rust-2018&#x2F;error-handling-and-panics&#x2F;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2F;a&gt; again to forward the error to the caller. On success, the method returns a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance that we can use to update the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#the-translation-lookaside-buffer&quot;&gt;&lt;em&gt;translation lookaside buffer&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The final step is to call this function from our &lt;code&gt;kernel_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::allocator; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new import
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::{self, BootInfoFrameAllocator};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        BootInfoFrameAllocator::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;boot_info.memory_map)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    allocator::init_heap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; mapper, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] call `test_main` in test mode
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We show the full function for context here. The only new lines are the &lt;code&gt;blog_os::allocator&lt;&#x2F;code&gt; import and the call to the &lt;code&gt;allocator::init_heap&lt;&#x2F;code&gt; function. In case the &lt;code&gt;init_heap&lt;&#x2F;code&gt; function returns an error, we panic using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;Result::expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method since there is currently no sensible way for us to handle this error.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a mapped heap memory region that is ready to be used. The &lt;code&gt;Box::new&lt;&#x2F;code&gt; call still uses our old &lt;code&gt;Dummy&lt;&#x2F;code&gt; allocator, so you will still see the ‚Äúout of memory‚Äù error when you run it. Let‚Äôs fix this by using a proper allocator.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-an-allocator-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-an-allocator-crate&quot; aria-label=&quot;Anchor link for: using-an-allocator-crate&quot;&gt;üîó&lt;&#x2F;a&gt;Using an Allocator Crate&lt;&#x2F;h2&gt;
&lt;p&gt;Since implementing an allocator is somewhat complex, we start by using an external allocator crate. We will learn how to implement our own allocator in the next post.&lt;&#x2F;p&gt;
&lt;p&gt;A simple allocator crate for &lt;code&gt;no_std&lt;&#x2F;code&gt; applications is the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;linked-list-allocator&#x2F;&quot;&gt;&lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. Its name comes from the fact that it uses a linked list data structure to keep track of deallocated memory regions. See the next post for a more detailed explanation of this approach.&lt;&#x2F;p&gt;
&lt;p&gt;To use the crate, we first need to add a dependency on it in our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;linked_list_allocator &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we can replace our dummy allocator with the allocator provided by the crate:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;linked_list_allocator::LockedHeap;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: LockedHeap = LockedHeap::empty();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct is named &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; because it uses the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spinning_top&#x2F;0.1.0&#x2F;spinning_top&#x2F;type.Spinlock.html&quot;&gt;&lt;code&gt;spinning_top::Spinlock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type for synchronization. This is required because multiple threads could access the &lt;code&gt;ALLOCATOR&lt;&#x2F;code&gt; static at the same time. As always, when using a spinlock or a mutex, we need to be careful to not accidentally cause a deadlock. This means that we shouldn‚Äôt perform any allocations in interrupt handlers, since they can run at an arbitrary time and might interrupt an in-progress allocation.&lt;&#x2F;p&gt;
&lt;p&gt;Setting the &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; as global allocator is not enough. The reason is that we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.LockedHeap.html#method.empty&quot;&gt;&lt;code&gt;empty&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; constructor function, which creates an allocator without any backing memory. Like our dummy allocator, it always returns an error on &lt;code&gt;alloc&lt;&#x2F;code&gt;. To fix this, we need to initialize the allocator after creating the heap:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_heap(
&lt;&#x2F;span&gt;&lt;span&gt;    mapper: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), MapToError&amp;lt;Size4KiB&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] map all heap pages to physical frames
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;.lock().init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lock_api&#x2F;0.3.3&#x2F;lock_api&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;lock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method on the inner spinlock of the &lt;code&gt;LockedHeap&lt;&#x2F;code&gt; type to get an exclusive reference to the wrapped &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html&quot;&gt;&lt;code&gt;Heap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instance, on which we then call the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.init&quot;&gt;&lt;code&gt;init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method with the heap bounds as arguments. Because the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.9.0&#x2F;linked_list_allocator&#x2F;struct.Heap.html#method.init&quot;&gt;&lt;code&gt;init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function already tries to write to the heap memory, we must initialize the heap only &lt;em&gt;after&lt;&#x2F;em&gt; mapping the heap pages.&lt;&#x2F;p&gt;
&lt;p&gt;After initializing the heap, we can now use all allocation and collection types of the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;&quot;&gt;&lt;code&gt;alloc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate without error:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::{boxed::Box, vec, vec::Vec, rc::Rc};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] initialize interrupts, mapper, frame_allocator, heap
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; allocate a number on the heap
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_value = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap_value at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, heap_value);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a dynamically sized vector
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; vec = Vec::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;500 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        vec.push(i);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;vec at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, vec.as_slice());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a reference counted vector -&amp;gt; will be freed when count reaches 0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; reference_counted = Rc::new(vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; cloned_reference = reference_counted.clone();
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;current reference count is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Rc::strong_count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;cloned_reference));
&lt;&#x2F;span&gt;&lt;span&gt;    core::mem::drop(reference_counted);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;reference count is &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; now&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Rc::strong_count(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;cloned_reference));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; [‚Ä¶] call `test_main` in test context
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code example shows some uses of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;&quot;&gt;&lt;code&gt;Vec&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;&quot;&gt;&lt;code&gt;Rc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; types. For the &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt; types, we print the underlying heap pointers using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;fmt&#x2F;trait.Pointer.html&quot;&gt;&lt;code&gt;{:p}&lt;&#x2F;code&gt; formatting specifier&lt;&#x2F;a&gt;. To showcase &lt;code&gt;Rc&lt;&#x2F;code&gt;, we create a reference-counted heap value and use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;rc&#x2F;struct.Rc.html#method.strong_count&quot;&gt;&lt;code&gt;Rc::strong_count&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to print the current reference count before and after dropping an instance (using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;mem&#x2F;fn.drop.html&quot;&gt;&lt;code&gt;core::mem::drop&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;When we run it, we see the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;heap-allocation&#x2F;qemu-alloc-showcase.png&quot; alt=&quot;QEMU printing ` heap_value at 0x444444440000 vec at 0x4444444408000 current reference count is 2 reference count is 1 now &quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, we see that the &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt; values live on the heap, as indicated by the pointer starting with the &lt;code&gt;0x_4444_4444_*&lt;&#x2F;code&gt; prefix. The reference counted value also behaves as expected, with the reference count being 2 after the &lt;code&gt;clone&lt;&#x2F;code&gt; call, and 1 again after one of the instances was dropped.&lt;&#x2F;p&gt;
&lt;p&gt;The reason that the vector starts at offset &lt;code&gt;0x800&lt;&#x2F;code&gt; is not that the boxed value is &lt;code&gt;0x800&lt;&#x2F;code&gt; bytes large, but the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;vec&#x2F;struct.Vec.html#capacity-and-reallocation&quot;&gt;reallocations&lt;&#x2F;a&gt; that occur when the vector needs to increase its capacity. For example, when the vector‚Äôs capacity is 32 and we try to add the next element, the vector allocates a new backing array with a capacity of 64 behind the scenes and copies all elements over. Then it frees the old allocation.&lt;&#x2F;p&gt;
&lt;p&gt;Of course, there are many more allocation and collection types in the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate that we can now all use in our kernel, including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the thread-safe reference counted pointer &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;sync&#x2F;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the owned string type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;string&#x2F;struct.String.html&quot;&gt;&lt;code&gt;String&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;macro.format.html&quot;&gt;&lt;code&gt;format!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;linked_list&#x2F;struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the growable ring buffer &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;binary_heap&#x2F;struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; priority queue&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;btree_set&#x2F;struct.BTreeSet.html&quot;&gt;&lt;code&gt;BTreeSet&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These types will become very useful when we want to implement thread lists, scheduling queues, or support for async&#x2F;await.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adding-a-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-a-test&quot; aria-label=&quot;Anchor link for: adding-a-test&quot;&gt;üîó&lt;&#x2F;a&gt;Adding a Test&lt;&#x2F;h2&gt;
&lt;p&gt;To ensure that we don‚Äôt accidentally break our new allocation code, we should add an integration test for it. We start by creating a new &lt;code&gt;tests&#x2F;heap_allocation.rs&lt;&#x2F;code&gt; file with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(blog_os::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; alloc;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::{entry_point, BootInfo};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;entry_point!(main);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    unimplemented!();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::test_panic_handler(info)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We reuse the &lt;code&gt;test_runner&lt;&#x2F;code&gt; and &lt;code&gt;test_panic_handler&lt;&#x2F;code&gt; functions from our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;. Since we want to test allocations, we enable the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate through the &lt;code&gt;extern crate alloc&lt;&#x2F;code&gt; statement. For more information about the test boilerplate, check out the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;main&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::allocator;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::{self, BootInfoFrameAllocator};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::VirtAddr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        BootInfoFrameAllocator::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;boot_info.memory_map)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    allocator::init_heap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; mapper, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It is very similar to the &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, with the differences that we don‚Äôt invoke &lt;code&gt;println&lt;&#x2F;code&gt;, don‚Äôt include any example allocations, and call &lt;code&gt;test_main&lt;&#x2F;code&gt; unconditionally.&lt;&#x2F;p&gt;
&lt;p&gt;Now we‚Äôre ready to add a few test cases. First, we add a test that performs some simple allocations using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and checks the allocated values to ensure that basic allocations work:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;simple_allocation() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_value_1 = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_value_2 = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(*heap_value_1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(*heap_value_2, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most importantly, this test verifies that no allocation error occurs.&lt;&#x2F;p&gt;
&lt;p&gt;Next, we iteratively build a large vector, to test both large allocations and multiple allocations (due to reallocations):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::vec::Vec;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;large_vec() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; vec = Vec::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;n {
&lt;&#x2F;span&gt;&lt;span&gt;        vec.push(i);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(vec.iter().sum::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(), (n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) * n &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We verify the sum by comparing it with the formula for the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums&quot;&gt;n-th partial sum&lt;&#x2F;a&gt;. This gives us some confidence that the allocated values are all correct.&lt;&#x2F;p&gt;
&lt;p&gt;As a third test, we create ten thousand allocations after each other:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;heap_allocation.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::allocator::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;many_boxes() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = Box::new(i);
&lt;&#x2F;span&gt;&lt;span&gt;        assert_eq!(*x, i);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This test ensures that the allocator reuses freed memory for subsequent allocations since it would run out of memory otherwise. This might seem like an obvious requirement for an allocator, but there are allocator designs that don‚Äôt do this. An example is the bump allocator design that will be explained in the next post.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs run our new integration test:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --test heap_allocation
&lt;&#x2F;span&gt;&lt;span&gt;[‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;Running 3 tests
&lt;&#x2F;span&gt;&lt;span&gt;simple_allocation... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;large_vec... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;many_boxes... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All three tests succeeded! You can also invoke &lt;code&gt;cargo test&lt;&#x2F;code&gt; (without the &lt;code&gt;--test&lt;&#x2F;code&gt; argument) to run all unit and integration tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post gave an introduction to dynamic memory and explained why and where it is needed. We saw how Rust‚Äôs borrow checker prevents common vulnerabilities and learned how Rust‚Äôs allocation API works.&lt;&#x2F;p&gt;
&lt;p&gt;After creating a minimal implementation of Rust‚Äôs allocator interface using a dummy allocator, we created a proper heap memory region for our kernel. For that, we defined a virtual address range for the heap and then mapped all pages of that range to physical frames using the &lt;code&gt;Mapper&lt;&#x2F;code&gt; and &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; from the previous post.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we added a dependency on the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate to add a proper allocator to our kernel. With this allocator, we were able to use &lt;code&gt;Box&lt;&#x2F;code&gt;, &lt;code&gt;Vec&lt;&#x2F;code&gt;, and other allocation and collection types from the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;While we already added heap allocation support in this post, we left most of the work to the &lt;code&gt;linked_list_allocator&lt;&#x2F;code&gt; crate. The next post will show in detail how an allocator can be implemented from scratch. It will present multiple possible allocator designs, show how to implement simple versions of them, and explain their advantages and drawbacks.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in May 2019</title>
                <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-06-03/</link>
                <guid>https://os.phil-opp.com/status-update/2019-06-03/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; blog and to the used tools. I was quite busy with my master thesis this month, so I didn‚Äôt have the time to create new content or major new features. However, there were quite a few minor updates.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;70&quot;&gt;Use cast crate instead of usize_conversions crate&lt;&#x2F;a&gt; (released as version 0.5.5).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;71&quot;&gt;Make FrameAllocator an unsafe trait&lt;&#x2F;a&gt; (released as version 0.6.0).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;pull&#x2F;76&quot;&gt;Change Port::read and PortReadOnly::read to take &amp;amp;mut self&lt;&#x2F;a&gt; (released as version 0.7.0).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;npmccallum&quot;&gt;@npmccallum&lt;&#x2F;a&gt; started working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;issues&#x2F;72&quot;&gt;moving the type declarations to a separate crate&lt;&#x2F;a&gt; to make them usable for more projects. We created the experimental &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64_types&#x2F;&quot;&gt;x86_64_types&lt;&#x2F;a&gt; crate for this.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;Cargo-Xbuild&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;commit&#x2F;bd73f5a1b975f1938abd5b4c17a048d2018741b7&quot;&gt;Make backtraces optional&lt;&#x2F;a&gt; to remove the transitive dependency on the &lt;code&gt;cc&lt;&#x2F;code&gt; crate, which has additional &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alexcrichton&#x2F;cc-rs#compile-time-requirements&quot;&gt;compile-time requirements&lt;&#x2F;a&gt; (e.g. a working &lt;code&gt;gcc&lt;&#x2F;code&gt; installation). These requirements caused &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;612&quot;&gt;problems for some people&lt;&#x2F;a&gt;, so we decided to disable backtraces by default. Released as version 0.5.9.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;32&quot;&gt;Error when the sysroot path contains spaces&lt;&#x2F;a&gt;: This pull request adds a special error message that points to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;6139&quot;&gt;rust-lang&#x2F;cargo#6139&lt;&#x2F;a&gt; when a sysroot path contains spaces. This should avoid the regular confusion, e.g. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;464#issuecomment-427793367&quot;&gt;here&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;403#issuecomment-483046786&quot;&gt;here&lt;&#x2F;a&gt;, or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;403#issuecomment-487313363&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;33&quot;&gt;Add a &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; environment variable to override sysroot path&lt;&#x2F;a&gt;: This feature is useful when the default sysroot path contains a space. Released as version 0.5.10.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;cargo-xbuild&#x2F;pull&#x2F;34&quot;&gt;Fix the new &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; environment variable&lt;&#x2F;a&gt;. Released as version 0.5.11.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;40&quot;&gt;Update Azure Pipelines CI script&lt;&#x2F;a&gt;
&lt;ul&gt;
&lt;li&gt;Build all branches instead of just &lt;code&gt;master&lt;&#x2F;code&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;bors.tech&#x2F;&quot;&gt;bors&lt;&#x2F;a&gt; &lt;code&gt;staging&lt;&#x2F;code&gt; branch.&lt;&#x2F;li&gt;
&lt;li&gt;Rustup is now included in the official Windows image of Azure Pipelines, so we don‚Äôt need to install it again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rybot666&quot;&gt;@rybot666&lt;&#x2F;a&gt; started working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;issues&#x2F;24&quot;&gt;porting the 16-bit assembly of the bootloader to Rust&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;toothbrush7777777&quot;&gt;@toothbrush7777777&lt;&#x2F;a&gt; landed a pull request to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;39&quot;&gt;pad the boot image to a hard disk block size&lt;&#x2F;a&gt;. This is required for booting the image in VirtualBox. Released as version 0.7.4.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;41&quot;&gt;Set &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2F;code&gt; when building bootloader&lt;&#x2F;a&gt;. Released as version 0.7.5.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;600&quot;&gt;Update to version 0.6.0 of x86_64&lt;&#x2F;a&gt;, which made the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait unsafe to implement.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;604&quot;&gt;Use &lt;code&gt;-serial stdio&lt;&#x2F;code&gt; instead of &lt;code&gt;-serial mon:stdio&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; as QEMU arguments when testing.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;606&quot;&gt;Update x86_64 to version 0.7.0&lt;&#x2F;a&gt;, which changed the &lt;code&gt;Port::read&lt;&#x2F;code&gt; method to take &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; instead of &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;josephlr&quot;&gt;@josephlr&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;609&quot;&gt;replaced some leftover tabs with spaces&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;611&quot;&gt;Rewrite &lt;code&gt;CompareMessage&lt;&#x2F;code&gt; struct to check the whole string&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in April 2019</title>
                <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-05-01/</link>
                <guid>https://os.phil-opp.com/status-update/2019-05-01/</guid>
                <description>&lt;p&gt;Lot‚Äôs of things changed in the &lt;em&gt;Writing an OS in Rust&lt;&#x2F;em&gt; series in the past month, both on the blog itself and in the tools behind the scenes. This post gives an overview of the most important updates.&lt;&#x2F;p&gt;
&lt;p&gt;This post is an experiment inspired by &lt;a href=&quot;https:&#x2F;&#x2F;this-week-in-rust.org&#x2F;&quot;&gt;&lt;em&gt;This Week in Rust&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and similar series. The goal is to provide a resource that allows following the project more closely and staying up-to-date with the changes in the tools&#x2F;libraries behind the scenes. If enough people find this useful, I will try to turn this in a semi-regular series.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;The build system of the bootloader was rewritten to do a proper linking instead of appending the kernel executable manually like before. The relevant pull requests are &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;51&quot;&gt;&lt;em&gt;Rewrite build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;53&quot;&gt;&lt;em&gt;Updates for new build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. These (breaking) changes were released as version &lt;code&gt;0.5.0&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#050&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;To make the bootloader work with future versions of &lt;code&gt;bootimage&lt;&#x2F;code&gt;, a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;commit&#x2F;33b8ce6059e90485c56883b23d4834d06ddfd517&quot;&gt;&lt;code&gt;package.metadata.bootloader.target&lt;&#x2F;code&gt; key was added&lt;&#x2F;a&gt; to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; of the bootloader. This key specifies the name of the target JSON file, so that &lt;code&gt;bootimage&lt;&#x2F;code&gt; knows which &lt;code&gt;--target&lt;&#x2F;code&gt; argument to pass. This change was released as version &lt;code&gt;0.5.1&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#051&quot;&gt;changelog&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;pull&#x2F;55&quot;&gt;&lt;em&gt;Version 0.6.0&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, the &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt; attribute was removed from the &lt;code&gt;entry_point&lt;&#x2F;code&gt; macro. This makes it possible to use the macro together with &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; and a custom test framework. Since the change is breaking, it was released as version &lt;code&gt;0.6.0&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&#x2F;blob&#x2F;master&#x2F;Changelog.md#060&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;34&quot;&gt;&lt;em&gt;Rewrite bootimage for new bootloader build system&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request completely revamped the implementation of the crate. This was released as version &lt;code&gt;0.7.0&lt;&#x2F;code&gt;. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#070&quot;&gt;changelog&lt;&#x2F;a&gt; for a list of changes.
&lt;ul&gt;
&lt;li&gt;The rewrite had the unintended side-effect that &lt;code&gt;bootimage run&lt;&#x2F;code&gt; no longer ignored executables named &lt;code&gt;test-*&lt;&#x2F;code&gt;, so that an additional &lt;code&gt;--bin&lt;&#x2F;code&gt; argument was required for specifying which executable to run. To avoid breaking users of &lt;code&gt;bootimage test&lt;&#x2F;code&gt;, we yanked version &lt;code&gt;0.7.0&lt;&#x2F;code&gt;. After &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;commit&#x2F;8746c15bf326cf8438a4e64ffdda332fbe59e30d&quot;&gt;fixing the issue&lt;&#x2F;a&gt;, version &lt;code&gt;0.7.1&lt;&#x2F;code&gt; was released (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#071&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;pull&#x2F;36&quot;&gt;&lt;em&gt;New features for &lt;code&gt;bootimage runner&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request added support for additional arguments and various functionality for supporting &lt;code&gt;cargo xtest&lt;&#x2F;code&gt;. The changes were released as version &lt;code&gt;0.7.2&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;blob&#x2F;master&#x2F;Changelog.md#072&quot;&gt;changelog&lt;&#x2F;a&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;An argument parsing bug that broke the new &lt;code&gt;cargo bootimage&lt;&#x2F;code&gt; subcommand on Windows was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&#x2F;commit&#x2F;101eb43de403fd9f3cb3f044e2c263356d2c179a&quot;&gt;fixed&lt;&#x2F;a&gt;. The fix was released as version &lt;code&gt;0.7.3&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Performed an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;575&quot;&gt;&lt;em&gt;Update to new bootloader 0.5.1 and bootimage 0.7.2&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. Apart from requiring the &lt;code&gt;llvm-tools-preview&lt;&#x2F;code&gt; rustup component, this only changes version numbers.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;577&quot;&gt;&lt;em&gt;Rewrite the linking section of ‚ÄúA Freestanding Rust Binary‚Äù&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request updated the first post to compile for the bare-metal &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2F;code&gt; target instead of adding linker arguments for Linux&#x2F;Windows&#x2F;macOS.&lt;&#x2F;li&gt;
&lt;li&gt;Since the blog came close to the free bandwidth limit of Netlify, we needed to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;579&quot;&gt;&lt;em&gt;Migrate from Netlify to Github Pages&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; to avoid additional fees.&lt;&#x2F;li&gt;
&lt;li&gt;With the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;582&quot;&gt;&lt;em&gt;Minimal Rust Kernel: Use a runner to make cargo xrun work&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, we integrated the new &lt;code&gt;bootimage runner&lt;&#x2F;code&gt; into the blog.
&lt;ul&gt;
&lt;li&gt;The required updates to the &lt;code&gt;post-02&lt;&#x2F;code&gt; and &lt;code&gt;post-03&lt;&#x2F;code&gt; branches were performed in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;585&quot;&gt;&lt;em&gt;Add &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file to post-02 branch&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;586&quot;&gt;&lt;em&gt;Merge the changes from #585 into the post-03 branch&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull requests.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;584&quot;&gt;&lt;em&gt;New testing post&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request, we replaced the previous &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;integration-tests&#x2F;&quot;&gt;&lt;em&gt;Integration Tests&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; with the new &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, which uses &lt;code&gt;cargo xtest&lt;&#x2F;code&gt; and a custom test framework for running tests.
&lt;ul&gt;
&lt;li&gt;The required updates for the &lt;code&gt;post-04&lt;&#x2F;code&gt; branch were performed in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;587&quot;&gt;&lt;em&gt;Implement code for new testing post in post-xx branches&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request. The updates for the other &lt;code&gt;post-*&lt;&#x2F;code&gt; branches were pushed manually to avoid spamming the repository with pull requests. You can find a list of the commits in the pull request description.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;595&quot;&gt;&lt;em&gt;Avoid generic impl trait parameters in BootInfoFrameAllocator&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; pull request made the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; non-generic by reconstructing the frame iterator on every allocation. This way, we avoid using a &lt;code&gt;impl Trait&lt;&#x2F;code&gt; type parameter, which makes it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;593&quot;&gt;impossible to store the type in a &lt;code&gt;static&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;60367&quot;&gt;rust-lang&#x2F;rust#60367&lt;&#x2F;a&gt; for the fundamental problem.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
            </item>
        
            <item>
                <title>Testing</title>
                <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/testing/</link>
                <guid>https://os.phil-opp.com/testing/</guid>
                <description>&lt;p&gt;This post explores unit and integration testing in &lt;code&gt;no_std&lt;&#x2F;code&gt; executables. We will use Rust‚Äôs support for custom test frameworks to execute test functions inside our kernel. To report the results out of QEMU, we will use different features of QEMU and the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;üîó&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;p&gt;This post replaces the (now deprecated) &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;integration-tests&#x2F;&quot;&gt;&lt;em&gt;Integration Tests&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; posts. It assumes that you have followed the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;&quot;&gt;&lt;em&gt;A Minimal Rust Kernel&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post after 2019-04-27. Mainly, it requires that you have a &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; file that &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#set-a-default-target&quot;&gt;sets a default target&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#using-cargo-run&quot;&gt;defines a runner executable&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-in-rust&quot; aria-label=&quot;Anchor link for: testing-in-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Testing in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Rust has a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-00-testing.html&quot;&gt;built-in test framework&lt;&#x2F;a&gt; that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute to the function header. Then &lt;code&gt;cargo test&lt;&#x2F;code&gt; will automatically find and execute all test functions of your crate.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, it‚Äôs a bit more complicated for &lt;code&gt;no_std&lt;&#x2F;code&gt; applications such as our kernel. The problem is that Rust‚Äôs test framework implicitly uses the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;test&#x2F;index.html&quot;&gt;&lt;code&gt;test&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; library, which depends on the standard library. This means that we can‚Äôt use the default test framework for our &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; kernel.&lt;&#x2F;p&gt;
&lt;p&gt;We can see this when we try to run &lt;code&gt;cargo test&lt;&#x2F;code&gt; in our project:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `test`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the &lt;code&gt;test&lt;&#x2F;code&gt; crate depends on the standard library, it is not available for our bare metal target. While porting the &lt;code&gt;test&lt;&#x2F;code&gt; crate to a &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; context &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;japaric&#x2F;utest&quot;&gt;is possible&lt;&#x2F;a&gt;, it is highly unstable and requires some hacks, such as redefining the &lt;code&gt;panic&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;custom-test-frameworks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#custom-test-frameworks&quot; aria-label=&quot;Anchor link for: custom-test-frameworks&quot;&gt;üîó&lt;&#x2F;a&gt;Custom Test Frameworks&lt;&#x2F;h3&gt;
&lt;p&gt;Fortunately, Rust supports replacing the default test framework through the unstable &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;unstable-book&#x2F;language-features&#x2F;custom-test-frameworks.html&quot;&gt;&lt;code&gt;custom_test_frameworks&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; feature. This feature requires no external libraries and thus also works in &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; environments. It works by collecting all functions annotated with a &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; attribute and then invoking a user-specified runner function with the list of tests as an argument. Thus, it gives the implementation maximal control over the test process.&lt;&#x2F;p&gt;
&lt;p&gt;The disadvantage compared to the default test framework is that many advanced features, such as &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-01-writing-tests.html#checking-for-panics-with-should_panic&quot;&gt;&lt;code&gt;should_panic&lt;&#x2F;code&gt; tests&lt;&#x2F;a&gt;, are not available. Instead, it is up to the implementation to provide such features itself if needed. This is ideal for us since we have a very special execution environment where the default implementations of such advanced features probably wouldn‚Äôt work anyway. For example, the &lt;code&gt;#[should_panic]&lt;&#x2F;code&gt; attribute relies on stack unwinding to catch the panics, which we disabled for our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;To implement a custom test framework for our kernel, we add the following to our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(crate::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Fn()]) {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; tests {
&lt;&#x2F;span&gt;&lt;span&gt;        test();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our runner just prints a short debug message and then calls each test function in the list. The argument type &lt;code&gt;&amp;amp;[&amp;amp;dyn Fn()]&lt;&#x2F;code&gt; is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.slice.html&quot;&gt;&lt;em&gt;slice&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;trait-objects.html&quot;&gt;&lt;em&gt;trait object&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; references of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ops&#x2F;trait.Fn.html&quot;&gt;&lt;em&gt;Fn()&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; trait. It is basically a list of references to types that can be called like a function. Since the function is useless for non-test runs, we use the &lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt; attribute to include it only for tests.&lt;&#x2F;p&gt;
&lt;p&gt;When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; now, we see that it now succeeds (if it doesn‚Äôt, see the note below). However, we still see our ‚ÄúHello World‚Äù instead of the message from our &lt;code&gt;test_runner&lt;&#x2F;code&gt;. The reason is that our &lt;code&gt;_start&lt;&#x2F;code&gt; function is still used as entry point. The custom test frameworks feature generates a &lt;code&gt;main&lt;&#x2F;code&gt; function that calls &lt;code&gt;test_runner&lt;&#x2F;code&gt;, but this function is ignored because we use the &lt;code&gt;#[no_main]&lt;&#x2F;code&gt; attribute and provide our own entry point.&lt;&#x2F;p&gt;
&lt;div class = &quot;warning&quot;&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; There is currently a bug in cargo that leads to ‚Äúduplicate lang item‚Äù errors on &lt;code&gt;cargo test&lt;&#x2F;code&gt; in some cases. It occurs when you have set &lt;code&gt;panic = &amp;quot;abort&amp;quot;&lt;&#x2F;code&gt; for a profile in your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;. Try removing it, then &lt;code&gt;cargo test&lt;&#x2F;code&gt; should work. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;7359&quot;&gt;cargo issue&lt;&#x2F;a&gt; for more information on this.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;To fix this, we first need to change the name of the generated function to something different than &lt;code&gt;main&lt;&#x2F;code&gt; through the &lt;code&gt;reexport_test_harness_main&lt;&#x2F;code&gt; attribute. Then we can call the renamed function from our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the name of the test framework entry function to &lt;code&gt;test_main&lt;&#x2F;code&gt; and call it from our &lt;code&gt;_start&lt;&#x2F;code&gt; entry point. We use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt; to add the call to &lt;code&gt;test_main&lt;&#x2F;code&gt; only in test contexts because the function is not generated on a normal run.&lt;&#x2F;p&gt;
&lt;p&gt;When we now execute &lt;code&gt;cargo test&lt;&#x2F;code&gt;, we see the ‚ÄúRunning 0 tests‚Äù message from our &lt;code&gt;test_runner&lt;&#x2F;code&gt; on the screen. We are now ready to create our first test function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;trivial_assertion() {
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;trivial assertion... &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; now, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;qemu-test-runner-output.png&quot; alt=&quot;QEMU printing ‚ÄúHello World!‚Äù, ‚ÄúRunning 1 tests‚Äù, and ‚Äútrivial assertion‚Ä¶ [ok]‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;tests&lt;&#x2F;code&gt; slice passed to our &lt;code&gt;test_runner&lt;&#x2F;code&gt; function now contains a reference to the &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; function. From the &lt;code&gt;trivial assertion... [ok]&lt;&#x2F;code&gt; output on the screen, we see that the test was called and that it succeeded.&lt;&#x2F;p&gt;
&lt;p&gt;After executing the tests, our &lt;code&gt;test_runner&lt;&#x2F;code&gt; returns to the &lt;code&gt;test_main&lt;&#x2F;code&gt; function, which in turn returns to our &lt;code&gt;_start&lt;&#x2F;code&gt; entry point function. At the end of &lt;code&gt;_start&lt;&#x2F;code&gt;, we enter an endless loop because the entry point function is not allowed to return. This is a problem, because we want &lt;code&gt;cargo test&lt;&#x2F;code&gt; to exit after running all tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exiting-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exiting-qemu&quot; aria-label=&quot;Anchor link for: exiting-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Exiting QEMU&lt;&#x2F;h2&gt;
&lt;p&gt;Right now, we have an endless loop at the end of our &lt;code&gt;_start&lt;&#x2F;code&gt; function and need to close QEMU manually on each execution of &lt;code&gt;cargo test&lt;&#x2F;code&gt;. This is unfortunate because we also want to run &lt;code&gt;cargo test&lt;&#x2F;code&gt; in scripts without user interaction. The clean solution to this would be to implement a proper way to shutdown our OS. Unfortunately, this is relatively complex because it requires implementing support for either the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;APM&quot;&gt;APM&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;ACPI&quot;&gt;ACPI&lt;&#x2F;a&gt; power management standard.&lt;&#x2F;p&gt;
&lt;p&gt;Luckily, there is an escape hatch: QEMU supports a special &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device, which provides an easy way to exit QEMU from the guest system. To enable it, we need to pass a &lt;code&gt;-device&lt;&#x2F;code&gt; argument to QEMU. We can do so by adding a &lt;code&gt;package.metadata.bootimage.test-args&lt;&#x2F;code&gt; configuration key in our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;bootimage runner&lt;&#x2F;code&gt; appends the &lt;code&gt;test-args&lt;&#x2F;code&gt; to the default QEMU command for all test executables. For a normal &lt;code&gt;cargo run&lt;&#x2F;code&gt;, the arguments are ignored.&lt;&#x2F;p&gt;
&lt;p&gt;Together with the device name (&lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt;), we pass the two parameters &lt;code&gt;iobase&lt;&#x2F;code&gt; and &lt;code&gt;iosize&lt;&#x2F;code&gt; that specify the &lt;em&gt;I&#x2F;O port&lt;&#x2F;em&gt; through which the device can be reached from our kernel.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;i-o-ports&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#i-o-ports&quot; aria-label=&quot;Anchor link for: i-o-ports&quot;&gt;üîó&lt;&#x2F;a&gt;I&#x2F;O Ports&lt;&#x2F;h3&gt;
&lt;p&gt;There are two different approaches for communicating between the CPU and peripheral hardware on x86, &lt;strong&gt;memory-mapped I&#x2F;O&lt;&#x2F;strong&gt; and &lt;strong&gt;port-mapped I&#x2F;O&lt;&#x2F;strong&gt;. We already used memory-mapped I&#x2F;O for accessing the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;&quot;&gt;VGA text buffer&lt;&#x2F;a&gt; through the memory address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. This address is not mapped to RAM but to some memory on the VGA device.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, port-mapped I&#x2F;O uses a separate I&#x2F;O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I&#x2F;O port, there are special CPU instructions called &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt;, which take a port number and a data byte (there are also variations of these commands that allow sending a &lt;code&gt;u16&lt;&#x2F;code&gt; or &lt;code&gt;u32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device uses port-mapped I&#x2F;O. The &lt;code&gt;iobase&lt;&#x2F;code&gt; parameter specifies on which port address the device should live (&lt;code&gt;0xf4&lt;&#x2F;code&gt; is a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;I&#x2F;O_Ports#The_list&quot;&gt;generally unused&lt;&#x2F;a&gt; port on the x86‚Äôs IO bus) and the &lt;code&gt;iosize&lt;&#x2F;code&gt; specifies the port size (&lt;code&gt;0x04&lt;&#x2F;code&gt; means four bytes).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-the-exit-device&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-exit-device&quot; aria-label=&quot;Anchor link for: using-the-exit-device&quot;&gt;üîó&lt;&#x2F;a&gt;Using the Exit Device&lt;&#x2F;h3&gt;
&lt;p&gt;The functionality of the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device is very simple. When a &lt;code&gt;value&lt;&#x2F;code&gt; is written to the I&#x2F;O port specified by &lt;code&gt;iobase&lt;&#x2F;code&gt;, it causes QEMU to exit with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exit_status&quot;&gt;exit status&lt;&#x2F;a&gt; &lt;code&gt;(value &amp;lt;&amp;lt; 1) | 1&lt;&#x2F;code&gt;. So when we write &lt;code&gt;0&lt;&#x2F;code&gt; to the port, QEMU will exit with exit status &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2F;code&gt;, and when we write &lt;code&gt;1&lt;&#x2F;code&gt; to the port, it will exit with exit status &lt;code&gt;(1 &amp;lt;&amp;lt; 1) | 1 = 3&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of manually invoking the &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt; assembly instructions, we use the abstractions provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. To add a dependency on that crate, we add it to the &lt;code&gt;dependencies&lt;&#x2F;code&gt; section in our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.14.2&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;port&#x2F;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type provided by the crate to create an &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u32)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;QemuExitCode {
&lt;&#x2F;span&gt;&lt;span&gt;    Success = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Failed = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x11&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;exit_qemu(exit_code: QemuExitCode) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        port.write(exit_code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function creates a new &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;port&#x2F;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; at &lt;code&gt;0xf4&lt;&#x2F;code&gt;, which is the &lt;code&gt;iobase&lt;&#x2F;code&gt; of the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device. Then it writes the passed exit code to the port. We use &lt;code&gt;u32&lt;&#x2F;code&gt; because we specified the &lt;code&gt;iosize&lt;&#x2F;code&gt; of the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device as 4 bytes. Both operations are unsafe because writing to an I&#x2F;O port can generally result in arbitrary behavior.&lt;&#x2F;p&gt;
&lt;p&gt;To specify the exit status, we create a &lt;code&gt;QemuExitCode&lt;&#x2F;code&gt; enum. The idea is to exit with the success exit code if all tests succeeded and with the failure exit code otherwise. The enum is marked as &lt;code&gt;#[repr(u32)]&lt;&#x2F;code&gt; to represent each variant by a &lt;code&gt;u32&lt;&#x2F;code&gt; integer. We use the exit code &lt;code&gt;0x10&lt;&#x2F;code&gt; for success and &lt;code&gt;0x11&lt;&#x2F;code&gt; for failure. The actual exit codes don‚Äôt matter much, as long as they don‚Äôt clash with the default exit codes of QEMU. For example, using exit code &lt;code&gt;0&lt;&#x2F;code&gt; for success is not a good idea because it becomes &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2F;code&gt; after the transformation, which is the default exit code when QEMU fails to run. So we could not differentiate a QEMU error from a successful test run.&lt;&#x2F;p&gt;
&lt;p&gt;We can now update our &lt;code&gt;test_runner&lt;&#x2F;code&gt; to exit QEMU after all tests have run:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Fn()]) {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; tests {
&lt;&#x2F;span&gt;&lt;span&gt;        test();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; now, we see that QEMU immediately closes after executing the tests. The problem is that &lt;code&gt;cargo test&lt;&#x2F;code&gt; interprets the test as failed even though we passed our &lt;code&gt;Success&lt;&#x2F;code&gt; exit code:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
&lt;&#x2F;span&gt;&lt;span&gt;     Running target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;deps&#x2F;blog_os-5804fc7d2dd4c9be
&lt;&#x2F;span&gt;&lt;span&gt;Building bootloader
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling bootloader v0.5.3 (&#x2F;home&#x2F;philipp&#x2F;Documents&#x2F;bootloader)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized + debuginfo] target(s) in 1.07s
&lt;&#x2F;span&gt;&lt;span&gt;Running: `qemu-system-x86_64 -drive format=raw,file=&#x2F;‚Ä¶&#x2F;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    deps&#x2F;bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,
&lt;&#x2F;span&gt;&lt;span&gt;    iosize=0x04`
&lt;&#x2F;span&gt;&lt;span&gt;error: test failed, to rerun pass &amp;#39;--bin blog_os&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that &lt;code&gt;cargo test&lt;&#x2F;code&gt; considers all error codes other than &lt;code&gt;0&lt;&#x2F;code&gt; as failure.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;success-exit-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#success-exit-code&quot; aria-label=&quot;Anchor link for: success-exit-code&quot;&gt;üîó&lt;&#x2F;a&gt;Success Exit Code&lt;&#x2F;h3&gt;
&lt;p&gt;To work around this, &lt;code&gt;bootimage&lt;&#x2F;code&gt; provides a &lt;code&gt;test-success-exit-code&lt;&#x2F;code&gt; configuration key that maps a specified exit code to the exit code &lt;code&gt;0&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;‚Ä¶&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-success-exit-code &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;33         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# (0x10 &amp;lt;&amp;lt; 1) | 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this configuration, &lt;code&gt;bootimage&lt;&#x2F;code&gt; maps our success exit code to exit code 0, so that &lt;code&gt;cargo test&lt;&#x2F;code&gt; correctly recognizes the success case and does not count the test as failed.&lt;&#x2F;p&gt;
&lt;p&gt;Our test runner now automatically closes QEMU and correctly reports the test results. We still see the QEMU window open for a very short time, but it does not suffice to read the results. It would be nice if we could print the test results to the console instead, so we can still see them after QEMU exits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;printing-to-the-console&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-to-the-console&quot; aria-label=&quot;Anchor link for: printing-to-the-console&quot;&gt;üîó&lt;&#x2F;a&gt;Printing to the Console&lt;&#x2F;h2&gt;
&lt;p&gt;To see the test output on the console, we need to send the data from our kernel to the host system somehow. There are various ways to achieve this, for example, by sending the data over a TCP network interface. However, setting up a networking stack is quite a complex task, so we will choose a simpler solution instead.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;serial-port&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serial-port&quot; aria-label=&quot;Anchor link for: serial-port&quot;&gt;üîó&lt;&#x2F;a&gt;Serial Port&lt;&#x2F;h3&gt;
&lt;p&gt;A simple way to send the data is to use the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Serial_port&quot;&gt;serial port&lt;&#x2F;a&gt;, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host‚Äôs standard output or a file.&lt;&#x2F;p&gt;
&lt;p&gt;The chips implementing a serial interface are called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter&quot;&gt;UARTs&lt;&#x2F;a&gt;. There are &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter#UART_models&quot;&gt;lots of UART models&lt;&#x2F;a&gt; on x86, but fortunately the only differences between them are some advanced features we don‚Äôt need. The common UARTs today are all compatible with the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;16550_UART&quot;&gt;16550 UART&lt;&#x2F;a&gt;, so we will use that model for our testing framework.&lt;&#x2F;p&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;uart_16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;uart_16550 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate contains a &lt;code&gt;SerialPort&lt;&#x2F;code&gt; struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that, we create a new &lt;code&gt;serial&lt;&#x2F;code&gt; module with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;serial;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;serial.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;uart_16550::SerialPort;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;SerialPort&amp;gt; = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; serial_port = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ SerialPort::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x3F8&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;        serial_port.init();
&lt;&#x2F;span&gt;&lt;span&gt;        Mutex::new(serial_port)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like with the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#lazy-statics&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;, we use &lt;code&gt;lazy_static&lt;&#x2F;code&gt; and a spinlock to create a &lt;code&gt;static&lt;&#x2F;code&gt; writer instance. By using &lt;code&gt;lazy_static&lt;&#x2F;code&gt; we can ensure that the &lt;code&gt;init&lt;&#x2F;code&gt; method is called exactly once on its first use.&lt;&#x2F;p&gt;
&lt;p&gt;Like the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device, the UART is programmed using port I&#x2F;O. Since the UART is more complex, it uses multiple I&#x2F;O ports for programming different device registers. The unsafe &lt;code&gt;SerialPort::new&lt;&#x2F;code&gt; function expects the address of the first I&#x2F;O port of the UART as an argument, from which it can calculate the addresses of all needed ports. We‚Äôre passing the port address &lt;code&gt;0x3F8&lt;&#x2F;code&gt;, which is the standard port number for the first serial interface.&lt;&#x2F;p&gt;
&lt;p&gt;To make the serial port easily usable, we add &lt;code&gt;serial_print!&lt;&#x2F;code&gt; and &lt;code&gt;serial_println!&lt;&#x2F;code&gt; macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;serial.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: ::core::fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface.
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! serial_print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        $crate::serial::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface, appending a newline.
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! serial_println {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The implementation is very similar to the implementation of our &lt;code&gt;print&lt;&#x2F;code&gt; and &lt;code&gt;println&lt;&#x2F;code&gt; macros. Since the &lt;code&gt;SerialPort&lt;&#x2F;code&gt; type already implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Write.html&quot;&gt;&lt;code&gt;fmt::Write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, we don‚Äôt need to provide our own implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can print to the serial interface instead of the VGA text buffer in our test code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Fn()]) {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;trivial_assertion() {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;trivial assertion... &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro lives directly under the root namespace because we used the &lt;code&gt;#[macro_export]&lt;&#x2F;code&gt; attribute, so importing it through &lt;code&gt;use crate::serial::serial_println&lt;&#x2F;code&gt; will not work.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qemu-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qemu-arguments&quot; aria-label=&quot;Anchor link for: qemu-arguments&quot;&gt;üîó&lt;&#x2F;a&gt;QEMU Arguments&lt;&#x2F;h3&gt;
&lt;p&gt;To see the serial output from QEMU, we need to use the &lt;code&gt;-serial&lt;&#x2F;code&gt; argument to redirect the output to stdout:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2F;span&gt;&lt;span&gt;= [
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-serial&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stdio&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; now, we see the test output directly in the console:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
&lt;&#x2F;span&gt;&lt;span&gt;     Running target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;deps&#x2F;blog_os-7b7c37b4ad62551a
&lt;&#x2F;span&gt;&lt;span&gt;Building bootloader
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized + debuginfo] target(s) in 0.02s
&lt;&#x2F;span&gt;&lt;span&gt;Running: `qemu-system-x86_64 -drive format=raw,file=&#x2F;‚Ä¶&#x2F;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    deps&#x2F;bootimage-blog_os-7b7c37b4ad62551a.bin -device
&lt;&#x2F;span&gt;&lt;span&gt;    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
&lt;&#x2F;span&gt;&lt;span&gt;Running 1 tests
&lt;&#x2F;span&gt;&lt;span&gt;trivial assertion... [ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, when a test fails, we still see the output inside QEMU because our panic handler still uses &lt;code&gt;println&lt;&#x2F;code&gt;. To simulate this, we can change the assertion in our &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; test to &lt;code&gt;assert_eq!(0, 1)&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;qemu-failed-test.png&quot; alt=&quot;QEMU printing ‚ÄúHello World!‚Äù and ‚Äúpanicked at ‚Äòassertion failed: (left == right) left: 0, right: 1‚Äô, src&#x2F;main.rs:55:5&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that the panic message is still printed to the VGA buffer, while the other test output is printed to the serial port. The panic message is quite useful, so it would be useful to see it in the console too.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;print-an-error-message-on-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#print-an-error-message-on-panic&quot; aria-label=&quot;Anchor link for: print-an-error-message-on-panic&quot;&gt;üîó&lt;&#x2F;a&gt;Print an Error Message on Panic&lt;&#x2F;h3&gt;
&lt;p&gt;To exit QEMU with an error message on a panic, we can use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt; to use a different panic handler in testing mode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; our existing panic handler
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new attribute
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; our panic handler in test mode
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Failed);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For our test panic handler, we use &lt;code&gt;serial_println&lt;&#x2F;code&gt; instead of &lt;code&gt;println&lt;&#x2F;code&gt; and then exit QEMU with a failure exit code. Note that we still need an endless &lt;code&gt;loop&lt;&#x2F;code&gt; after the &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; call because the compiler does not know that the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device causes a program exit.&lt;&#x2F;p&gt;
&lt;p&gt;Now QEMU also exits for failed tests and prints a useful error message on the console:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
&lt;&#x2F;span&gt;&lt;span&gt;     Running target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;deps&#x2F;blog_os-7b7c37b4ad62551a
&lt;&#x2F;span&gt;&lt;span&gt;Building bootloader
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized + debuginfo] target(s) in 0.02s
&lt;&#x2F;span&gt;&lt;span&gt;Running: `qemu-system-x86_64 -drive format=raw,file=&#x2F;‚Ä¶&#x2F;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    deps&#x2F;bootimage-blog_os-7b7c37b4ad62551a.bin -device
&lt;&#x2F;span&gt;&lt;span&gt;    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
&lt;&#x2F;span&gt;&lt;span&gt;Running 1 tests
&lt;&#x2F;span&gt;&lt;span&gt;trivial assertion... [failed]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Error: panicked at &amp;#39;assertion failed: `(left == right)`
&lt;&#x2F;span&gt;&lt;span&gt;  left: `0`,
&lt;&#x2F;span&gt;&lt;span&gt; right: `1`&amp;#39;, src&#x2F;main.rs:65:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we see all test output on the console now, we no longer need the QEMU window that pops up for a short time. So we can hide it completely.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hiding-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-qemu&quot; aria-label=&quot;Anchor link for: hiding-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Hiding QEMU&lt;&#x2F;h3&gt;
&lt;p&gt;Since we report out the complete test results using the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device and the serial port, we don‚Äôt need the QEMU window anymore. We can hide it by passing the &lt;code&gt;-display none&lt;&#x2F;code&gt; argument to QEMU:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2F;span&gt;&lt;span&gt;= [
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-serial&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stdio&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-display&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now QEMU runs completely in the background and no window gets opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as CI services or &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Secure_Shell&quot;&gt;SSH&lt;&#x2F;a&gt; connections.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;timeouts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#timeouts&quot; aria-label=&quot;Anchor link for: timeouts&quot;&gt;üîó&lt;&#x2F;a&gt;Timeouts&lt;&#x2F;h3&gt;
&lt;p&gt;Since &lt;code&gt;cargo test&lt;&#x2F;code&gt; waits until the test runner exits, a test that never returns can block the test runner forever. That‚Äôs unfortunate, but not a big problem in practice since it‚Äôs usually easy to avoid endless loops. In our case, however, endless loops can occur in various situations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The bootloader fails to load our kernel, which causes the system to reboot endlessly.&lt;&#x2F;li&gt;
&lt;li&gt;The BIOS&#x2F;UEFI firmware fails to load the bootloader, which causes the same endless rebooting.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU enters a &lt;code&gt;loop {}&lt;&#x2F;code&gt; statement at the end of some of our functions, for example because the QEMU exit device doesn‚Äôt work properly.&lt;&#x2F;li&gt;
&lt;li&gt;The hardware causes a system reset, for example when a CPU exception is not caught (explained in a future post).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Since endless loops can occur in so many situations, the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool sets a timeout of 5 minutes for each test executable by default. If the test does not finish within this time, it is marked as failed and a ‚ÄúTimed Out‚Äù error is printed to the console. This feature ensures that tests that are stuck in an endless loop don‚Äôt block &lt;code&gt;cargo test&lt;&#x2F;code&gt; forever.&lt;&#x2F;p&gt;
&lt;p&gt;You can try it yourself by adding a &lt;code&gt;loop {}&lt;&#x2F;code&gt; statement in the &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; test. When you run &lt;code&gt;cargo test&lt;&#x2F;code&gt;, you see that the test is marked as timed out after 5 minutes. The timeout duration is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage#configuration&quot;&gt;configurable&lt;&#x2F;a&gt; through a &lt;code&gt;test-timeout&lt;&#x2F;code&gt; key in the Cargo.toml:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-timeout &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;300          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# (in seconds)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you don‚Äôt want to wait 5 minutes for the &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; test to time out, you can temporarily decrease the above value.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;insert-printing-automatically&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#insert-printing-automatically&quot; aria-label=&quot;Anchor link for: insert-printing-automatically&quot;&gt;üîó&lt;&#x2F;a&gt;Insert Printing Automatically&lt;&#x2F;h3&gt;
&lt;p&gt;Our &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; test currently needs to print its own status information using &lt;code&gt;serial_print!&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;serial_println!&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;trivial_assertion() {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;trivial assertion... &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Manually adding these print statements for every test we write is cumbersome, so let‚Äôs update our &lt;code&gt;test_runner&lt;&#x2F;code&gt; to print these messages automatically. To do that, we need to create a new &lt;code&gt;Testable&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Testable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; ();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The trick now is to implement this trait for all types &lt;code&gt;T&lt;&#x2F;code&gt; that implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;ops&#x2F;trait.Fn.html&quot;&gt;&lt;code&gt;Fn()&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Testable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    T: Fn(),
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, core::any::type_name::&amp;lt;T&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        self();
&lt;&#x2F;span&gt;&lt;span&gt;        serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We implement the &lt;code&gt;run&lt;&#x2F;code&gt; function by first printing the function name using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;any&#x2F;fn.type_name.html&quot;&gt;&lt;code&gt;any::type_name&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function. This function is implemented directly in the compiler and returns a string description of every type. For functions, the type is their name, so this is exactly what we want in this case. The &lt;code&gt;\t&lt;&#x2F;code&gt; character is the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tab_key#Tab_characters&quot;&gt;tab character&lt;&#x2F;a&gt;, which adds some alignment to the &lt;code&gt;[ok]&lt;&#x2F;code&gt; messages.&lt;&#x2F;p&gt;
&lt;p&gt;After printing the function name, we invoke the test function through &lt;code&gt;self()&lt;&#x2F;code&gt;. This only works because we require that &lt;code&gt;self&lt;&#x2F;code&gt; implements the &lt;code&gt;Fn()&lt;&#x2F;code&gt; trait. After the test function returns, we print &lt;code&gt;[ok]&lt;&#x2F;code&gt; to indicate that the function did not panic.&lt;&#x2F;p&gt;
&lt;p&gt;The last step is to update our &lt;code&gt;test_runner&lt;&#x2F;code&gt; to use the new &lt;code&gt;Testable&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Testable]) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; tests {
&lt;&#x2F;span&gt;&lt;span&gt;        test.run(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only two changes are the type of the &lt;code&gt;tests&lt;&#x2F;code&gt; argument from &lt;code&gt;&amp;amp;[&amp;amp;dyn Fn()]&lt;&#x2F;code&gt; to &lt;code&gt;&amp;amp;[&amp;amp;dyn Testable]&lt;&#x2F;code&gt; and the fact that we now call &lt;code&gt;test.run()&lt;&#x2F;code&gt; instead of &lt;code&gt;test()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can now remove the print statements from our &lt;code&gt;trivial_assertion&lt;&#x2F;code&gt; test since they‚Äôre now printed automatically:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;trivial_assertion() {
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;cargo test&lt;&#x2F;code&gt; output now looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;Running 1 tests
&lt;&#x2F;span&gt;&lt;span&gt;blog_os::trivial_assertion...	[ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function name now includes the full path to the function, which is useful when test functions in different modules have the same name. Otherwise, the output looks the same as before, but we no longer need to add print statements to our tests manually.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-the-vga-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-the-vga-buffer&quot; aria-label=&quot;Anchor link for: testing-the-vga-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;Testing the VGA Buffer&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have a working test framework, we can create a few tests for our VGA buffer implementation. First, we create a very simple test to verify that &lt;code&gt;println&lt;&#x2F;code&gt; works without panicking:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println_simple() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_simple output&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test just prints something to the VGA buffer. If it finishes without panicking, it means that the &lt;code&gt;println&lt;&#x2F;code&gt; invocation did not panic either.&lt;&#x2F;p&gt;
&lt;p&gt;To ensure that no panic occurs even if many lines are printed and lines are shifted off the screen, we can create another test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println_many() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for _ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;200 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_many output&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can also create a test function to verify that the printed lines really appear on the screen:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println_output() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, s);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.chars().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; screen_char = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().buffer.chars[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;][i].read();
&lt;&#x2F;span&gt;&lt;span&gt;        assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;::from(screen_char.ascii_character), c);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function defines a test string, prints it using &lt;code&gt;println&lt;&#x2F;code&gt;, and then iterates over the screen characters of the static &lt;code&gt;WRITER&lt;&#x2F;code&gt;, which represents the VGA text buffer. Since &lt;code&gt;println&lt;&#x2F;code&gt; prints to the last screen line and then immediately appends a newline, the string should appear on line &lt;code&gt;BUFFER_HEIGHT - 2&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, we count the number of iterations in the variable &lt;code&gt;i&lt;&#x2F;code&gt;, which we then use for loading the screen character corresponding to &lt;code&gt;c&lt;&#x2F;code&gt;. By comparing the &lt;code&gt;ascii_character&lt;&#x2F;code&gt; of the screen character with &lt;code&gt;c&lt;&#x2F;code&gt;, we ensure that each character of the string really appears in the VGA text buffer.&lt;&#x2F;p&gt;
&lt;p&gt;As you can imagine, we could create many more test functions. For example, a function that tests that no panic occurs when printing very long lines and that they‚Äôre wrapped correctly, or a function for testing that newlines, non-printable characters, and non-unicode characters are handled correctly.&lt;&#x2F;p&gt;
&lt;p&gt;For the rest of this post, however, we will explain how to create &lt;em&gt;integration tests&lt;&#x2F;em&gt; to test the interaction of different components together.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integration-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#integration-tests&quot; aria-label=&quot;Anchor link for: integration-tests&quot;&gt;üîó&lt;&#x2F;a&gt;Integration Tests&lt;&#x2F;h2&gt;
&lt;p&gt;The convention for &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-03-test-organization.html#integration-tests&quot;&gt;integration tests&lt;&#x2F;a&gt; in Rust is to put them into a &lt;code&gt;tests&lt;&#x2F;code&gt; directory in the project root (i.e., next to the &lt;code&gt;src&lt;&#x2F;code&gt; directory). Both the default test framework and custom test frameworks will automatically pick up and execute all tests in that directory.&lt;&#x2F;p&gt;
&lt;p&gt;All integration tests are their own executables and completely separate from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;. This means that each test needs to define its own entry point function. Let‚Äôs create an example integration test named &lt;code&gt;basic_boot&lt;&#x2F;code&gt; to see how it works in detail:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;basic_boot.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(crate::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Fn()]) {
&lt;&#x2F;span&gt;&lt;span&gt;    unimplemented!();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since integration tests are separate executables, we need to provide all the crate attributes (&lt;code&gt;no_std&lt;&#x2F;code&gt;, &lt;code&gt;no_main&lt;&#x2F;code&gt;, &lt;code&gt;test_runner&lt;&#x2F;code&gt;, etc.) again. We also need to create a new entry point function &lt;code&gt;_start&lt;&#x2F;code&gt;, which calls the test entry point function &lt;code&gt;test_main&lt;&#x2F;code&gt;. We don‚Äôt need any &lt;code&gt;cfg(test)&lt;&#x2F;code&gt; attributes because integration test executables are never built in non-test mode.&lt;&#x2F;p&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;macro.unimplemented.html&quot;&gt;&lt;code&gt;unimplemented&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro that always panics as a placeholder for the &lt;code&gt;test_runner&lt;&#x2F;code&gt; function and just &lt;code&gt;loop&lt;&#x2F;code&gt; in the &lt;code&gt;panic&lt;&#x2F;code&gt; handler for now. Ideally, we want to implement these functions exactly as we did in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; using the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro and the &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; function. The problem is that we don‚Äôt have access to these functions since tests are built completely separately from our &lt;code&gt;main.rs&lt;&#x2F;code&gt; executable.&lt;&#x2F;p&gt;
&lt;p&gt;If you run &lt;code&gt;cargo test&lt;&#x2F;code&gt; at this stage, you will get an endless loop because the panic handler loops endlessly. You need to use the &lt;code&gt;ctrl+c&lt;&#x2F;code&gt; keyboard shortcut for exiting QEMU.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;create-a-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#create-a-library&quot; aria-label=&quot;Anchor link for: create-a-library&quot;&gt;üîó&lt;&#x2F;a&gt;Create a Library&lt;&#x2F;h3&gt;
&lt;p&gt;To make the required functions available to our integration test, we need to split off a library from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, which can be included by other crates and integration test executables. To do this, we create a new &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like the &lt;code&gt;main.rs&lt;&#x2F;code&gt;, the &lt;code&gt;lib.rs&lt;&#x2F;code&gt; is a special file that is automatically recognized by cargo. The library is a separate compilation unit, so we need to specify the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; attribute again.&lt;&#x2F;p&gt;
&lt;p&gt;To make our library work with &lt;code&gt;cargo test&lt;&#x2F;code&gt;, we need to also move the test functions and attributes from &lt;code&gt;main.rs&lt;&#x2F;code&gt;  to &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(test, no_main)]
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(crate::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Testable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; ();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Testable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    T: Fn(),
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;run(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, core::any::type_name::&amp;lt;T&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;        self();
&lt;&#x2F;span&gt;&lt;span&gt;        serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Testable]) {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; tests {
&lt;&#x2F;span&gt;&lt;span&gt;        test.run();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_panic_handler(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Failed);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point for `cargo test`
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    test_panic_handler(info)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make our &lt;code&gt;test_runner&lt;&#x2F;code&gt; available to executables and integration tests, we make it public and don‚Äôt apply the &lt;code&gt;cfg(test)&lt;&#x2F;code&gt; attribute to it. We also factor out the implementation of our panic handler into a public &lt;code&gt;test_panic_handler&lt;&#x2F;code&gt; function, so that it is available for executables too.&lt;&#x2F;p&gt;
&lt;p&gt;Since our &lt;code&gt;lib.rs&lt;&#x2F;code&gt; is tested independently of our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, we need to add a &lt;code&gt;_start&lt;&#x2F;code&gt; entry point and a panic handler when the library is compiled in test mode. By using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;conditional-compilation.html#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate attribute, we conditionally enable the &lt;code&gt;no_main&lt;&#x2F;code&gt; attribute in this case.&lt;&#x2F;p&gt;
&lt;p&gt;We also move over the &lt;code&gt;QemuExitCode&lt;&#x2F;code&gt; enum and the &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; function and make them public:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u32)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;QemuExitCode {
&lt;&#x2F;span&gt;&lt;span&gt;    Success = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Failed = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x11&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;exit_qemu(exit_code: QemuExitCode) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        port.write(exit_code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now executables and integration tests can import these functions from the library and don‚Äôt need to define their own implementations. To also make &lt;code&gt;println&lt;&#x2F;code&gt; and &lt;code&gt;serial_println&lt;&#x2F;code&gt; available, we move the module declarations too:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;serial;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We make the modules public to make them usable outside of our library. This is also required for making our &lt;code&gt;println&lt;&#x2F;code&gt; and &lt;code&gt;serial_println&lt;&#x2F;code&gt; macros usable since they use the &lt;code&gt;_print&lt;&#x2F;code&gt; functions of the modules.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can update our &lt;code&gt;main.rs&lt;&#x2F;code&gt; to use the library:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(blog_os::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::println;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::test_panic_handler(info)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The library is usable like a normal external crate. It is called &lt;code&gt;blog_os&lt;&#x2F;code&gt;, like our crate. The above code uses the &lt;code&gt;blog_os::test_runner&lt;&#x2F;code&gt; function in the &lt;code&gt;test_runner&lt;&#x2F;code&gt; attribute and the &lt;code&gt;blog_os::test_panic_handler&lt;&#x2F;code&gt; function in our &lt;code&gt;cfg(test)&lt;&#x2F;code&gt; panic handler. It also imports the &lt;code&gt;println&lt;&#x2F;code&gt; macro to make it available to our &lt;code&gt;_start&lt;&#x2F;code&gt; and &lt;code&gt;panic&lt;&#x2F;code&gt; functions.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, &lt;code&gt;cargo run&lt;&#x2F;code&gt; and &lt;code&gt;cargo test&lt;&#x2F;code&gt; should work again. Of course, &lt;code&gt;cargo test&lt;&#x2F;code&gt; still loops endlessly (you can exit with &lt;code&gt;ctrl+c&lt;&#x2F;code&gt;). Let‚Äôs fix this by using the required library functions in our integration test.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;completing-the-integration-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#completing-the-integration-test&quot; aria-label=&quot;Anchor link for: completing-the-integration-test&quot;&gt;üîó&lt;&#x2F;a&gt;Completing the Integration Test&lt;&#x2F;h3&gt;
&lt;p&gt;Like our &lt;code&gt;src&#x2F;main.rs&lt;&#x2F;code&gt;, our &lt;code&gt;tests&#x2F;basic_boot.rs&lt;&#x2F;code&gt; executable can import types from our new library. This allows us to import the missing components to complete our test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;basic_boot.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(blog_os::test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::test_panic_handler(info)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of reimplementing the test runner, we use the &lt;code&gt;test_runner&lt;&#x2F;code&gt; function from our library by changing the &lt;code&gt;#![test_runner(crate::test_runner)]&lt;&#x2F;code&gt; attribute to &lt;code&gt;#![test_runner(blog_os::test_runner)]&lt;&#x2F;code&gt;. We then don‚Äôt need the &lt;code&gt;test_runner&lt;&#x2F;code&gt; stub function in &lt;code&gt;basic_boot.rs&lt;&#x2F;code&gt; anymore, so we can remove it. For our &lt;code&gt;panic&lt;&#x2F;code&gt; handler, we call the &lt;code&gt;blog_os::test_panic_handler&lt;&#x2F;code&gt; function like we did in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now &lt;code&gt;cargo test&lt;&#x2F;code&gt; exits normally again. When you run it, you will see that it builds and runs the tests for our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, &lt;code&gt;main.rs&lt;&#x2F;code&gt;, and &lt;code&gt;basic_boot.rs&lt;&#x2F;code&gt; separately after each other. For the &lt;code&gt;main.rs&lt;&#x2F;code&gt; and the &lt;code&gt;basic_boot&lt;&#x2F;code&gt; integration tests, it reports ‚ÄúRunning 0 tests‚Äù since these files don‚Äôt have any functions annotated with &lt;code&gt;#[test_case]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can now add tests to our &lt;code&gt;basic_boot.rs&lt;&#x2F;code&gt;. For example, we can test that &lt;code&gt;println&lt;&#x2F;code&gt; works without panicking, like we did in the VGA buffer tests:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;basic_boot.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::println;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println output&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; now, we see that it finds and executes the test function.&lt;&#x2F;p&gt;
&lt;p&gt;The test might seem a bit useless right now since it‚Äôs almost identical to one of the VGA buffer tests. However, in the future, the &lt;code&gt;_start&lt;&#x2F;code&gt; functions of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; and &lt;code&gt;lib.rs&lt;&#x2F;code&gt; might grow and call various initialization routines before running the &lt;code&gt;test_main&lt;&#x2F;code&gt; function, so that the two tests are executed in very different environments.&lt;&#x2F;p&gt;
&lt;p&gt;By testing &lt;code&gt;println&lt;&#x2F;code&gt; in a &lt;code&gt;basic_boot&lt;&#x2F;code&gt; environment without calling any initialization routines in &lt;code&gt;_start&lt;&#x2F;code&gt;, we can ensure that &lt;code&gt;println&lt;&#x2F;code&gt; works right after booting. This is important because we rely on it, e.g., for printing panic messages.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;future-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-tests&quot; aria-label=&quot;Anchor link for: future-tests&quot;&gt;üîó&lt;&#x2F;a&gt;Future Tests&lt;&#x2F;h3&gt;
&lt;p&gt;The power of integration tests is that they‚Äôre treated as completely separate executables. This gives them complete control over the environment, which makes it possible to test that the code interacts correctly with the CPU or hardware devices.&lt;&#x2F;p&gt;
&lt;p&gt;Our &lt;code&gt;basic_boot&lt;&#x2F;code&gt; test is a very simple example of an integration test. In the future, our kernel will become much more featureful and interact with the hardware in various ways. By adding integration tests, we can ensure that these interactions work (and keep working) as expected. Some ideas for possible future tests are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU Exceptions&lt;&#x2F;strong&gt;: When the code performs invalid operations (e.g., divides by zero), the CPU throws an exception. The kernel can register handler functions for such exceptions. An integration test could verify that the correct exception handler is called when a CPU exception occurs or that the execution continues correctly after a resolvable exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Page Tables&lt;&#x2F;strong&gt;: Page tables define which memory regions are valid and accessible. By modifying the page tables, it is possible to allocate new memory regions, for example when launching programs. An integration test could modify the page tables in the &lt;code&gt;_start&lt;&#x2F;code&gt; function and verify that the modifications have the desired effects in &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; functions.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Userspace Programs&lt;&#x2F;strong&gt;: Userspace programs are programs with limited access to the system‚Äôs resources. For example, they don‚Äôt have access to kernel data structures or to the memory of other programs. An integration test could launch userspace programs that perform forbidden operations and verify that the kernel prevents them all.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As you can imagine, many more tests are possible. By adding such tests, we can ensure that we don‚Äôt break them accidentally when we add new features to our kernel or refactor our code. This is especially important when our kernel becomes larger and more complex.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tests-that-should-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tests-that-should-panic&quot; aria-label=&quot;Anchor link for: tests-that-should-panic&quot;&gt;üîó&lt;&#x2F;a&gt;Tests that Should Panic&lt;&#x2F;h3&gt;
&lt;p&gt;The test framework of the standard library supports a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;testing&#x2F;unit_testing.html#testing-panics&quot;&gt;&lt;code&gt;#[should_panic]&lt;&#x2F;code&gt; attribute&lt;&#x2F;a&gt; that allows constructing tests that should fail. This is useful, for example, to verify that a function fails when an invalid argument is passed. Unfortunately, this attribute isn‚Äôt supported in &lt;code&gt;#[no_std]&lt;&#x2F;code&gt; crates since it requires support from the standard library.&lt;&#x2F;p&gt;
&lt;p&gt;While we can‚Äôt use the &lt;code&gt;#[should_panic]&lt;&#x2F;code&gt; attribute in our kernel, we can get similar behavior by creating an integration test that exits with a success error code from the panic handler. Let‚Äôs start creating such a test with the name &lt;code&gt;should_panic&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;should_panic.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::{QemuExitCode, exit_qemu, serial_println};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This test is still incomplete as it doesn‚Äôt define a &lt;code&gt;_start&lt;&#x2F;code&gt; function or any of the custom test runner attributes yet. Let‚Äôs add the missing parts:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;should_panic.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(custom_test_frameworks)]
&lt;&#x2F;span&gt;&lt;span&gt;#![test_runner(test_runner)]
&lt;&#x2F;span&gt;&lt;span&gt;#![reexport_test_harness_main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_runner(tests: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Fn()]) {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, tests.len());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; test &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; tests {
&lt;&#x2F;span&gt;&lt;span&gt;        test();
&lt;&#x2F;span&gt;&lt;span&gt;        serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[test did not panic]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        exit_qemu(QemuExitCode::Failed);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of reusing the &lt;code&gt;test_runner&lt;&#x2F;code&gt; from our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, the test defines its own &lt;code&gt;test_runner&lt;&#x2F;code&gt; function that exits with a failure exit code when a test returns without panicking (we want our tests to panic). If no test function is defined, the runner exits with a success error code. Since the runner always exits after running a single test, it does not make sense to define more than one &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can create a test that should fail:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;should_panic.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::serial_print;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;should_fail() {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_panic::should_fail...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test uses &lt;code&gt;assert_eq&lt;&#x2F;code&gt; to assert that &lt;code&gt;0&lt;&#x2F;code&gt; and &lt;code&gt;1&lt;&#x2F;code&gt; are equal. Of course, this fails, so our test panics as desired. Note that we need to manually print the function name using &lt;code&gt;serial_print!&lt;&#x2F;code&gt; here because we don‚Äôt use the &lt;code&gt;Testable&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;When we run the test through &lt;code&gt;cargo test --test should_panic&lt;&#x2F;code&gt; we see that it is successful because the test panicked as expected. When we comment out the assertion and run the test again, we see that it indeed fails with the &lt;em&gt;‚Äútest did not panic‚Äù&lt;&#x2F;em&gt; message.&lt;&#x2F;p&gt;
&lt;p&gt;A significant drawback of this approach is that it only works for a single test function. With multiple &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; functions, only the first function is executed because the execution cannot continue after the panic handler has been called. I currently don‚Äôt know of a good way to solve this problem, so let me know if you have an idea!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;no-harness-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#no-harness-tests&quot; aria-label=&quot;Anchor link for: no-harness-tests&quot;&gt;üîó&lt;&#x2F;a&gt;No Harness Tests&lt;&#x2F;h3&gt;
&lt;p&gt;For integration tests that only have a single test function (like our &lt;code&gt;should_panic&lt;&#x2F;code&gt; test), the test runner isn‚Äôt really needed. For cases like this, we can disable the test runner completely and run our test directly in the &lt;code&gt;_start&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;The key to this is to disable the &lt;code&gt;harness&lt;&#x2F;code&gt; flag for the test in the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;, which defines whether a test runner is used for an integration test. When it‚Äôs set to &lt;code&gt;false&lt;&#x2F;code&gt;, both the default test runner and the custom test runner feature are disabled, so that the test is treated like a normal executable.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs disable the &lt;code&gt;harness&lt;&#x2F;code&gt; flag for our &lt;code&gt;should_panic&lt;&#x2F;code&gt; test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_panic&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;harness &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we vastly simplify our &lt;code&gt;should_panic&lt;&#x2F;code&gt; test by removing the &lt;code&gt;test_runner&lt;&#x2F;code&gt;-related code. The result looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;should_panic.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::{exit_qemu, serial_print, serial_println, QemuExitCode};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    should_fail();
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[test did not panic]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Failed);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;should_fail() {
&lt;&#x2F;span&gt;&lt;span&gt;    serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_panic::should_fail...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We now call the &lt;code&gt;should_fail&lt;&#x2F;code&gt; function directly from our &lt;code&gt;_start&lt;&#x2F;code&gt; function and exit with a failure exit code if it returns. When we run &lt;code&gt;cargo test --test should_panic&lt;&#x2F;code&gt; now, we see that the test behaves exactly as before.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from creating &lt;code&gt;should_panic&lt;&#x2F;code&gt; tests, disabling the &lt;code&gt;harness&lt;&#x2F;code&gt; attribute can also be useful for complex integration tests, for example, when the individual test functions have side effects and need to be run in a specified order.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Testing is a very useful technique to ensure that certain components have the desired behavior. Even if they cannot show the absence of bugs, they‚Äôre still a useful tool for finding them and especially for avoiding regressions.&lt;&#x2F;p&gt;
&lt;p&gt;This post explained how to set up a test framework for our Rust kernel. We used Rust‚Äôs custom test frameworks feature to implement support for a simple &lt;code&gt;#[test_case]&lt;&#x2F;code&gt; attribute in our bare-metal environment. Using the &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device of QEMU, our test runner can exit QEMU after running the tests and report the test status. To print error messages to the console instead of the VGA buffer, we created a basic driver for the serial port.&lt;&#x2F;p&gt;
&lt;p&gt;After creating some tests for our &lt;code&gt;println&lt;&#x2F;code&gt; macro, we explored integration tests in the second half of the post. We learned that they live in the &lt;code&gt;tests&lt;&#x2F;code&gt; directory and are treated as completely separate executables. To give them access to the &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; function and the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro, we moved most of our code into a library that can be imported by all executables and integration tests. Since integration tests run in their own separate environment, they make it possible to test interactions with the hardware or to create tests that should panic.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a test framework that runs in a realistic environment inside QEMU. By creating more tests in future posts, we can keep our kernel maintainable when it becomes more complex.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2F;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called ‚Äúpage fault‚Äù). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Paging Implementation</title>
                <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/paging-implementation/</link>
                <guid>https://os.phil-opp.com/paging-implementation/</guid>
                <description>&lt;p&gt;This post shows how to implement paging support in our kernel. It first explores different techniques to make the physical page table frames accessible to the kernel and discusses their respective advantages and drawbacks. It then implements an address translation function and a function to create a new mapping.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-09&quot;&gt;&lt;code&gt;post-09&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; gave an introduction to the concept of paging. It motivated paging by comparing it with segmentation, explained how paging and page tables work, and then introduced the 4-level page table design of &lt;code&gt;x86_64&lt;&#x2F;code&gt;. We found out that the bootloader already set up a page table hierarchy for our kernel, which means that our kernel already runs on virtual addresses. This improves safety since illegal memory accesses cause page fault exceptions instead of modifying arbitrary physical memory.&lt;&#x2F;p&gt;
&lt;p&gt;The post ended with the problem that we &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#accessing-the-page-tables&quot;&gt;can‚Äôt access the page tables from our kernel&lt;&#x2F;a&gt; because they are stored in physical memory and our kernel already runs on virtual addresses. This post explores different approaches to making the page table frames accessible to our kernel. We will discuss the advantages and drawbacks of each approach and then decide on an approach for our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;To implement the approach, we will need support from the bootloader, so we‚Äôll configure it first. Afterward, we will implement a function that traverses the page table hierarchy in order to translate virtual to physical addresses. Finally, we learn how to create new mappings in the page tables and how to find unused memory frames for creating new page tables.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;accessing-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-page-tables&quot; aria-label=&quot;Anchor link for: accessing-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Accessing Page Tables&lt;&#x2F;h2&gt;
&lt;p&gt;Accessing the page tables from our kernel is not as easy as it may seem. To understand the problem, let‚Äôs take a look at the example 4-level page table hierarchy from the previous post again:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;..&#x2F;paging-introduction&#x2F;x86_64-page-table-translation.svg&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The important thing here is that each page entry stores the &lt;em&gt;physical&lt;&#x2F;em&gt; address of the next table. This avoids the need to run a translation for these addresses too, which would be bad for performance and could easily cause endless translation loops.&lt;&#x2F;p&gt;
&lt;p&gt;The problem for us is that we can‚Äôt directly access physical addresses from our kernel since our kernel also runs on top of virtual addresses. For example, when we access address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt; we access the &lt;em&gt;virtual&lt;&#x2F;em&gt; address &lt;code&gt;4 KiB&lt;&#x2F;code&gt;, not the &lt;em&gt;physical&lt;&#x2F;em&gt; address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt; where the level 4 page table is stored. When we want to access the physical address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, we can only do so through some virtual address that maps to it.&lt;&#x2F;p&gt;
&lt;p&gt;So in order to access page table frames, we need to map some virtual pages to them. There are different ways to create these mappings that all allow us to access arbitrary page table frames.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;identity-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#identity-mapping&quot; aria-label=&quot;Anchor link for: identity-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Identity Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;A simple solution is to &lt;strong&gt;identity map all page tables&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;identity-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with various virtual pages mapped to the physical frame with the same address&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this example, we see various identity-mapped page table frames. This way, the physical addresses of page tables are also valid virtual addresses so that we can easily access the page tables of all levels starting from the CR3 register.&lt;&#x2F;p&gt;
&lt;p&gt;However, it clutters the virtual address space and makes it more difficult to find continuous memory regions of larger sizes. For example, imagine that we want to create a virtual memory region of size 1000¬†KiB in the above graphic, e.g., for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory-mapped_file&quot;&gt;memory-mapping a file&lt;&#x2F;a&gt;. We can‚Äôt start the region at &lt;code&gt;28‚ÄØKiB&lt;&#x2F;code&gt; because it would collide with the already mapped page at &lt;code&gt;1004‚ÄØKiB&lt;&#x2F;code&gt;. So we have to look further until we find a large enough unmapped area, for example at &lt;code&gt;1008‚ÄØKiB&lt;&#x2F;code&gt;. This is a similar fragmentation problem as with &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#fragmentation&quot;&gt;segmentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Equally, it makes it much more difficult to create new page tables because we need to find physical frames whose corresponding pages aren‚Äôt already in use. For example, let‚Äôs assume that we reserved the &lt;em&gt;virtual&lt;&#x2F;em&gt; 1000¬†KiB memory region starting at &lt;code&gt;1008‚ÄØKiB&lt;&#x2F;code&gt; for our memory-mapped file. Now we can‚Äôt use any frame with a &lt;em&gt;physical&lt;&#x2F;em&gt; address between &lt;code&gt;1000‚ÄØKiB&lt;&#x2F;code&gt; and &lt;code&gt;2008‚ÄØKiB&lt;&#x2F;code&gt; anymore, because we can‚Äôt identity map it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;map-at-a-fixed-offset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-at-a-fixed-offset&quot; aria-label=&quot;Anchor link for: map-at-a-fixed-offset&quot;&gt;üîó&lt;&#x2F;a&gt;Map at a Fixed Offset&lt;&#x2F;h3&gt;
&lt;p&gt;To avoid the problem of cluttering the virtual address space, we can &lt;strong&gt;use a separate memory region for page table mappings&lt;&#x2F;strong&gt;. So instead of identity mapping page table frames, we map them at a fixed offset in the virtual address space. For example, the offset could be 10¬†TiB:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;page-tables-mapped-at-offset.svg&quot; alt=&quot;The same figure as for the identity mapping, but each mapped virtual page is offset by 10 TiB.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;By using the virtual memory in the range &lt;code&gt;10 TiB..(10 TiB + physical memory size)&lt;&#x2F;code&gt; exclusively for page table mappings, we avoid the collision problems of the identity mapping. Reserving such a large region of the virtual address space is only possible if the virtual address space is much larger than the physical memory size. This isn‚Äôt a problem on x86_64 since the 48-bit address space is 256¬†TiB large.&lt;&#x2F;p&gt;
&lt;p&gt;This approach still has the disadvantage that we need to create a new mapping whenever we create a new page table. Also, it does not allow accessing page tables of other address spaces, which would be useful when creating a new process.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;map-the-complete-physical-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-the-complete-physical-memory&quot; aria-label=&quot;Anchor link for: map-the-complete-physical-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Map the Complete Physical Memory&lt;&#x2F;h3&gt;
&lt;p&gt;We can solve these problems by &lt;strong&gt;mapping the complete physical memory&lt;&#x2F;strong&gt; instead of only page table frames:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;map-complete-physical-memory.svg&quot; alt=&quot;The same figure as for the offset mapping, but every physical frame has a mapping (at 10 TiB + X) instead of only page table frames.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This approach allows our kernel to access arbitrary physical memory, including page table frames of other address spaces. The reserved virtual memory range has the same size as before, with the difference that it no longer contains unmapped pages.&lt;&#x2F;p&gt;
&lt;p&gt;The disadvantage of this approach is that additional page tables are needed for storing the mapping of the physical memory. These page tables need to be stored somewhere, so they use up a part of physical memory, which can be a problem on devices with a small amount of memory.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, however, we can use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Page_%28computer_memory%29#Multiple_page_sizes&quot;&gt;huge pages&lt;&#x2F;a&gt; with a size of 2¬†MiB for the mapping, instead of the default 4¬†KiB pages. This way, mapping 32¬†GiB of physical memory only requires 132¬†KiB for page tables since only one level 3 table and 32 level 2 tables are needed. Huge pages are also more cache efficient since they use fewer entries in the translation lookaside buffer (TLB).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;temporary-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#temporary-mapping&quot; aria-label=&quot;Anchor link for: temporary-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Temporary Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;For devices with very small amounts of physical memory, we could &lt;strong&gt;map the page table frames only temporarily&lt;&#x2F;strong&gt; when we need to access them. To be able to create the temporary mappings, we only need a single identity-mapped level 1 table:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;temporarily-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with an identity mapped level 1 table, which maps its 0th entry to the level 2 table frame, thereby mapping that frame to the page with address 0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The level 1 table in this graphic controls the first 2¬†MiB of the virtual address space. This is because it is reachable by starting at the CR3 register and following the 0th entry in the level 4, level 3, and level 2 page tables. The entry with index &lt;code&gt;8&lt;&#x2F;code&gt; maps the virtual page at address &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt; to the physical frame at address &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt;, thereby identity mapping the level 1 table itself. The graphic shows this identity-mapping by the horizontal arrow at &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By writing to the identity-mapped level 1 table, our kernel can create up to 511 temporary mappings (512 minus the entry required for the identity mapping). In the above example, the kernel created two temporary mappings:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;By mapping the 0th entry of the level 1 table to the frame with address &lt;code&gt;24‚ÄØKiB&lt;&#x2F;code&gt;, it created a temporary mapping of the virtual page at &lt;code&gt;0‚ÄØKiB&lt;&#x2F;code&gt; to the physical frame of the level 2 page table, indicated by the dashed arrow.&lt;&#x2F;li&gt;
&lt;li&gt;By mapping the 9th entry of the level 1 table to the frame with address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, it created a temporary mapping of the virtual page at &lt;code&gt;36‚ÄØKiB&lt;&#x2F;code&gt; to the physical frame of the level 4 page table, indicated by the dashed arrow.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now the kernel can access the level 2 page table by writing to page &lt;code&gt;0‚ÄØKiB&lt;&#x2F;code&gt; and the level 4 page table by writing to page &lt;code&gt;36‚ÄØKiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The process for accessing an arbitrary page table frame with temporary mappings would be:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Search for a free entry in the identity-mapped level 1 table.&lt;&#x2F;li&gt;
&lt;li&gt;Map that entry to the physical frame of the page table that we want to access.&lt;&#x2F;li&gt;
&lt;li&gt;Access the target frame through the virtual page that maps to the entry.&lt;&#x2F;li&gt;
&lt;li&gt;Set the entry back to unused, thereby removing the temporary mapping again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This approach reuses the same 512 virtual pages for creating the mappings and thus requires only 4¬†KiB of physical memory. The drawback is that it is a bit cumbersome, especially since a new mapping might require modifications to multiple table levels, which means that we would need to repeat the above process multiple times.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;recursive-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-page-tables&quot; aria-label=&quot;Anchor link for: recursive-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Recursive Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;Another interesting approach, which requires no additional page tables at all, is to &lt;strong&gt;map the page table recursively&lt;&#x2F;strong&gt;. The idea behind this approach is to map an entry from the level 4 page table to the level 4 table itself. By doing this, we effectively reserve a part of the virtual address space and map all current and future page table frames to that space.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs go through an example to understand how this all works:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;recursive-page-table.png&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory. Entry 511 of the level 4 page is mapped to frame 4KiB, the frame of the level 4 table itself.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The only difference to the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#accessing-page-tables&quot;&gt;example at the beginning of this post&lt;&#x2F;a&gt; is the additional entry at index &lt;code&gt;511&lt;&#x2F;code&gt; in the level 4 table, which is mapped to physical frame &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, the frame of the level 4 table itself.&lt;&#x2F;p&gt;
&lt;p&gt;By letting the CPU follow this entry on a translation, it doesn‚Äôt reach a level 3 table but the same level 4 table again. This is similar to a recursive function that calls itself, therefore this table is called a &lt;em&gt;recursive page table&lt;&#x2F;em&gt;. The important thing is that the CPU assumes that every entry in the level 4 table points to a level 3 table, so it now treats the level 4 table as a level 3 table. This works because tables of all levels have the exact same layout on x86_64.&lt;&#x2F;p&gt;
&lt;p&gt;By following the recursive entry one or multiple times before we start the actual translation, we can effectively shorten the number of levels that the CPU traverses. For example, if we follow the recursive entry once and then proceed to the level 3 table, the CPU thinks that the level 3 table is a level 2 table. Going further, it treats the level 2 table as a level 1 table and the level 1 table as the mapped frame. This means that we can now read and write the level 1 page table because the CPU thinks that it is the mapped frame. The graphic below illustrates the five translation steps:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;recursive-page-table-access-level-1.png&quot; alt=&quot;The above example 4-level page hierarchy with 5 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúStep 1‚Äù from level 4 table to level 4 table, ‚ÄúStep 2‚Äù from level 4 table to level 3 table, ‚ÄúStep 3‚Äù from level 3 table to level 2 table, and ‚ÄúStep 4‚Äù from level 2 table to level 1 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, we can follow the recursive entry twice before starting the translation to reduce the number of traversed levels to two:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;recursive-page-table-access-level-2.png&quot; alt=&quot;The same 4-level page hierarchy with the following 4 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúSteps 1&amp;amp;2‚Äù from level 4 table to level 4 table, ‚ÄúStep 3‚Äù from level 4 table to level 3 table, and ‚ÄúStep 4‚Äù from level 3 table to level 2 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs go through it step by step: First, the CPU follows the recursive entry on the level 4 table and thinks that it reaches a level 3 table. Then it follows the recursive entry again and thinks that it reaches a level 2 table. But in reality, it is still on the level 4 table. When the CPU now follows a different entry, it lands on a level 3 table but thinks it is already on a level 1 table. So while the next entry points to a level 2 table, the CPU thinks that it points to the mapped frame, which allows us to read and write the level 2 table.&lt;&#x2F;p&gt;
&lt;p&gt;Accessing the tables of levels 3 and 4 works in the same way. To access the level 3 table, we follow the recursive entry three times, tricking the CPU into thinking it is already on a level 1 table. Then we follow another entry and reach a level 3 table, which the CPU treats as a mapped frame. For accessing the level 4 table itself, we just follow the recursive entry four times until the CPU treats the level 4 table itself as the mapped frame (in blue in the graphic below).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;recursive-page-table-access-level-3.png&quot; alt=&quot;The same 4-level page hierarchy with the following 3 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúSteps 1,2,3‚Äù from level 4 table to level 4 table, and ‚ÄúStep 4‚Äù from level 4 table to level 3 table. In blue, the alternative ‚ÄúSteps 1,2,3,4‚Äù arrow from level 4 table to level 4 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It might take some time to wrap your head around the concept, but it works quite well in practice.&lt;&#x2F;p&gt;
&lt;p&gt;In the section below, we explain how to construct virtual addresses for following the recursive entry one or multiple times. We will not use recursive paging for our implementation, so you don‚Äôt need to read it to continue with the post. If it interests you, just click on &lt;em&gt;‚ÄúAddress Calculation‚Äù&lt;&#x2F;em&gt; to expand it.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;details&gt;
&lt;summary&gt;&lt;h4&gt;Address Calculation&lt;&#x2F;h4&gt;&lt;&#x2F;summary&gt;
&lt;p&gt;We saw that we can access tables of all levels by following the recursive entry once or multiple times before the actual translation. Since the indexes into the tables of the four levels are derived directly from the virtual address, we need to construct special virtual addresses for this technique. Remember, the page table indexes are derived from the address in the following way:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;..&#x2F;paging-introduction&#x2F;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0‚Äì12 are the page offset, bits 12‚Äì21 the level 1 index, bits 21‚Äì30 the level 2 index, bits 30‚Äì39 the level 3 index, and bits 39‚Äì48 the level 4 index&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs assume that we want to access the level 1 page table that maps a specific page. As we learned above, this means that we have to follow the recursive entry once before continuing with the level 4, level 3, and level 2 indexes. To do that, we move each block of the address one block to the right and set the original level 4 index to the index of the recursive entry:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;table-indices-from-address-recursive-level-1.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 1 table frame, bits 12‚Äì21 the level 2 index, bits 21‚Äì30 the level 3 index, bits 30‚Äì39 the level 4 index, and bits 39‚Äì48 the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For accessing the level 2 table of that page, we move each index block two blocks to the right and set both the blocks of the original level 4 index and the original level 3 index to the index of the recursive entry:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;table-indices-from-address-recursive-level-2.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 2 table frame, bits 12‚Äì21 the level 3 index, bits 21‚Äì30 the level 4 index, and bits 30‚Äì39 and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Accessing the level 3 table works by moving each block three blocks to the right and using the recursive index for the original level 4, level 3, and level 2 address blocks:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;table-indices-from-address-recursive-level-3.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 3 table frame, bits 12‚Äì21 the level 4 index, and bits 21‚Äì30, bits 30‚Äì39 and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we can access the level 4 table by moving each block four blocks to the right and using the recursive index for all address blocks except for the offset:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;table-indices-from-address-recursive-level-4.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level l table frame and bits 12‚Äì21, bits 21‚Äì30, bits 30‚Äì39, and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can now calculate virtual addresses for the page tables of all four levels. We can even calculate an address that points exactly to a specific page table entry by multiplying its index by 8, the size of a page table entry.&lt;&#x2F;p&gt;
&lt;p&gt;The table below summarizes the address structure for accessing the different kinds of frames:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Virtual Address for&lt;&#x2F;th&gt;&lt;th&gt;Address Structure (&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Octal&quot;&gt;octal&lt;&#x2F;a&gt;)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Page&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 1 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 2 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 3 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 4 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Whereas &lt;code&gt;AAA&lt;&#x2F;code&gt; is the level 4 index, &lt;code&gt;BBB&lt;&#x2F;code&gt; the level 3 index, &lt;code&gt;CCC&lt;&#x2F;code&gt; the level 2 index, and &lt;code&gt;DDD&lt;&#x2F;code&gt; the level 1 index of the mapped frame, and &lt;code&gt;EEEE&lt;&#x2F;code&gt; the offset into it. &lt;code&gt;RRR&lt;&#x2F;code&gt; is the index of the recursive entry. When an index (three digits) is transformed to an offset (four digits), it is done by multiplying it by 8 (the size of a page table entry). With this offset, the resulting address directly points to the respective page table entry.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;SSSSSS&lt;&#x2F;code&gt; are sign extension bits, which means that they are all copies of bit 47. This is a special requirement for valid addresses on the x86_64 architecture. We explained it in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#paging-on-x86-64&quot;&gt;previous post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Octal&quot;&gt;octal&lt;&#x2F;a&gt; numbers for representing the addresses since each octal character represents three bits, which allows us to clearly separate the 9-bit indexes of the different page table levels. This isn‚Äôt possible with the hexadecimal system, where each character represents four bits.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;in-rust-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#in-rust-code&quot; aria-label=&quot;Anchor link for: in-rust-code&quot;&gt;üîó&lt;&#x2F;a&gt;In Rust Code&lt;&#x2F;h5&gt;
&lt;p&gt;To construct such addresses in Rust code, you can use bitwise operations:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the virtual address whose corresponding page tables you want to access
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= [‚Ä¶];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; r = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; recursive index
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sign = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o177777 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;48&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; sign extension
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; retrieve the page table indices of the address that we want to translate
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l4_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 4 index
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l3_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 3 index
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l2_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 2 index
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l1_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 1 index
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page_offset = addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o7777&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; calculate the table addresses
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;    sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_3_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;    sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_2_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;    sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l3_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_1_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;    sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l3_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l2_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above code assumes that the last level 4 entry with index &lt;code&gt;0o777&lt;&#x2F;code&gt; (511) is recursively mapped. This isn‚Äôt the case currently, so the code won‚Äôt work yet. See below on how to tell the bootloader to set up the recursive mapping.&lt;&#x2F;p&gt;
&lt;p&gt;Alternatively to performing the bitwise operations by hand, you can use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate, which provides safe abstractions for various page table operations. For example, the code below shows how to translate a virtual address to its mapped physical address:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{VirtAddr, PhysAddr};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates a RecursivePageTable instance from the level 4 address.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_addr = [‚Ä¶];
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_ptr = level_4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*level_4_table_ptr;
&lt;&#x2F;span&gt;&lt;span&gt;    RecursivePageTable::new(level_4_table).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Retrieve the physical address for the given virtual address
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64 &lt;&#x2F;span&gt;&lt;span&gt;= [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr = VirtAddr::new(addr);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page: Page = Page::containing_address(addr);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; perform the translation
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = recursive_page_table.translate_page(page);
&lt;&#x2F;span&gt;&lt;span&gt;frame.map(|frame| frame.start_address() + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::from(addr.page_offset()))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, a valid recursive mapping is required for this code. With such a mapping, the missing &lt;code&gt;level_4_table_addr&lt;&#x2F;code&gt; can be calculated as in the first code example.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Recursive Paging is an interesting technique that shows how powerful a single mapping in a page table can be. It is relatively easy to implement and only requires a minimal amount of setup (just a single recursive entry), so it‚Äôs a good choice for first experiments with paging.&lt;&#x2F;p&gt;
&lt;p&gt;However, it also has some disadvantages:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It occupies a large amount of virtual memory (512¬†GiB). This isn‚Äôt a big problem in the large 48-bit address space, but it might lead to suboptimal cache behavior.&lt;&#x2F;li&gt;
&lt;li&gt;It only allows accessing the currently active address space easily. Accessing other address spaces is still possible by changing the recursive entry, but a temporary mapping is required for switching back. We described how to do this in the (outdated) &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#overview&quot;&gt;&lt;em&gt;Remap The Kernel&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post.&lt;&#x2F;li&gt;
&lt;li&gt;It heavily relies on the page table format of x86 and might not work on other architectures.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bootloader-support&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bootloader-support&quot; aria-label=&quot;Anchor link for: bootloader-support&quot;&gt;üîó&lt;&#x2F;a&gt;Bootloader Support&lt;&#x2F;h2&gt;
&lt;p&gt;All of these approaches require page table modifications for their setup. For example, mappings for the physical memory need to be created or an entry of the level 4 table needs to be mapped recursively. The problem is that we can‚Äôt create these required mappings without an existing way to access the page tables.&lt;&#x2F;p&gt;
&lt;p&gt;This means that we need the help of the bootloader, which creates the page tables that our kernel runs on. The bootloader has access to the page tables, so it can create any mappings that we need. In its current implementation, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate has support for two of the above approaches, controlled through &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;features.html#the-features-section&quot;&gt;cargo features&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;map_physical_memory&lt;&#x2F;code&gt; feature maps the complete physical memory somewhere into the virtual address space. Thus, the kernel has access to all physical memory and can follow the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#map-the-complete-physical-memory&quot;&gt;&lt;em&gt;Map the Complete Physical Memory&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; approach.&lt;&#x2F;li&gt;
&lt;li&gt;With the &lt;code&gt;recursive_page_table&lt;&#x2F;code&gt; feature, the bootloader maps an entry of the level 4 page table recursively. This allows the kernel to access the page tables as described in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#recursive-page-tables&quot;&gt;&lt;em&gt;Recursive Page Tables&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; section.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We choose the first approach for our kernel since it is simple, platform-independent, and more powerful (it also allows access to non-page-table-frames). To enable the required bootloader support, we add the &lt;code&gt;map_physical_memory&lt;&#x2F;code&gt; feature to our &lt;code&gt;bootloader&lt;&#x2F;code&gt; dependency:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2F;span&gt;&lt;span&gt;= { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.23&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_physical_memory&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this feature enabled, the bootloader maps the complete physical memory to some unused virtual address range. To communicate the virtual address range to our kernel, the bootloader passes a &lt;em&gt;boot information&lt;&#x2F;em&gt; structure.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boot-information&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#boot-information&quot; aria-label=&quot;Anchor link for: boot-information&quot;&gt;üîó&lt;&#x2F;a&gt;Boot Information&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate defines a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.9.3&#x2F;bootloader&#x2F;bootinfo&#x2F;struct.BootInfo.html&quot;&gt;&lt;code&gt;BootInfo&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct that contains all the information it passes to our kernel. The struct is still in an early stage, so expect some breakage when updating to future &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html#caret-requirements&quot;&gt;semver-incompatible&lt;&#x2F;a&gt; bootloader versions. With the &lt;code&gt;map_physical_memory&lt;&#x2F;code&gt; feature enabled, it currently has the two fields &lt;code&gt;memory_map&lt;&#x2F;code&gt; and &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;memory_map&lt;&#x2F;code&gt; field contains an overview of the available physical memory. This tells our kernel how much physical memory is available in the system and which memory regions are reserved for devices such as the VGA hardware. The memory map can be queried from the BIOS or UEFI firmware, but only very early in the boot process. For this reason, it must be provided by the bootloader because there is no way for the kernel to retrieve it later. We will need the memory map later in this post.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; tells us the virtual start address of the physical memory mapping. By adding this offset to a physical address, we get the corresponding virtual address. This allows us to access arbitrary physical memory from our kernel.&lt;&#x2F;li&gt;
&lt;li&gt;This physical memory offset can be customized by adding a &lt;code&gt;[package.metadata.bootloader]&lt;&#x2F;code&gt; table in Cargo.toml and setting the field &lt;code&gt;physical-memory-offset = &amp;quot;0x0000f00000000000&amp;quot;&lt;&#x2F;code&gt; (or any other value). However, note that the bootloader can panic if it runs into physical address values that start to overlap with the the space beyond the offset, i.e., areas it would have previously mapped to some other early physical addresses. So in general, the higher the value (&amp;gt; 1 TiB), the better.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The bootloader passes the &lt;code&gt;BootInfo&lt;&#x2F;code&gt; struct to our kernel in the form of a &lt;code&gt;&amp;amp;&#x27;static BootInfo&lt;&#x2F;code&gt; argument to our &lt;code&gt;_start&lt;&#x2F;code&gt; function. We don‚Äôt have this argument declared in our function yet, so let‚Äôs add it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::BootInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new argument
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It wasn‚Äôt a problem to leave off this argument before because the x86_64 calling convention passes the first argument in a CPU register. Thus, the argument is simply ignored when it isn‚Äôt declared. However, it would be a problem if we accidentally used a wrong argument type, since the compiler doesn‚Äôt know the correct type signature of our entry point function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-entry-point-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-entry-point-macro&quot; aria-label=&quot;Anchor link for: the-entry-point-macro&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;entry_point&lt;&#x2F;code&gt; Macro&lt;&#x2F;h3&gt;
&lt;p&gt;Since our &lt;code&gt;_start&lt;&#x2F;code&gt; function is called externally from the bootloader, no checking of our function signature occurs. This means that we could let it take arbitrary arguments without any compilation errors, but it would fail or cause undefined behavior at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;To make sure that the entry point function always has the correct signature that the bootloader expects, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate provides an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.6.4&#x2F;bootloader&#x2F;macro.entry_point.html&quot;&gt;&lt;code&gt;entry_point&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro that provides a type-checked way to define a Rust function as the entry point. Let‚Äôs rewrite our entry point function to use this macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::{BootInfo, entry_point};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;entry_point!(kernel_main);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We no longer need to use &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2F;code&gt; or &lt;code&gt;no_mangle&lt;&#x2F;code&gt; for our entry point, as the macro defines the real lower level &lt;code&gt;_start&lt;&#x2F;code&gt; entry point for us. The &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function is now a completely normal Rust function, so we can choose an arbitrary name for it. The important thing is that it is type-checked so that a compilation error occurs when we use a wrong function signature, for example by adding an argument or changing the argument type.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs perform the same change in our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::{entry_point, BootInfo};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;entry_point!(test_kernel_main);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point for `cargo test`
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_kernel_main(_boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; like before
&lt;&#x2F;span&gt;&lt;span&gt;    init();
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;    hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the entry point is only used in test mode, we add the &lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt; attribute to all items. We give our test entry point the distinct name &lt;code&gt;test_kernel_main&lt;&#x2F;code&gt; to avoid confusion with the &lt;code&gt;kernel_main&lt;&#x2F;code&gt; of our &lt;code&gt;main.rs&lt;&#x2F;code&gt;. We don‚Äôt use the &lt;code&gt;BootInfo&lt;&#x2F;code&gt; parameter for now, so we prefix the parameter name with a &lt;code&gt;_&lt;&#x2F;code&gt; to silence the unused variable warning.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have access to physical memory, we can finally start to implement our page table code. First, we will take a look at the currently active page tables that our kernel runs on. In the second step, we will create a translation function that returns the physical address that a given virtual address is mapped to. As a last step, we will try to modify the page tables in order to create a new mapping.&lt;&#x2F;p&gt;
&lt;p&gt;Before we begin, we create a new &lt;code&gt;memory&lt;&#x2F;code&gt; module for our code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;memory;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the module, we create an empty &lt;code&gt;src&#x2F;memory.rs&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;accessing-the-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-the-page-tables&quot; aria-label=&quot;Anchor link for: accessing-the-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Accessing the Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;At the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#accessing-the-page-tables&quot;&gt;end of the previous post&lt;&#x2F;a&gt;, we tried to take a look at the page tables our kernel runs on, but failed since we couldn‚Äôt access the physical frame that the &lt;code&gt;CR3&lt;&#x2F;code&gt; register points to. We‚Äôre now able to continue from there by creating an &lt;code&gt;active_level_4_table&lt;&#x2F;code&gt; function that returns a reference to the active level 4 page table:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{
&lt;&#x2F;span&gt;&lt;span&gt;    structures::paging::PageTable,
&lt;&#x2F;span&gt;&lt;span&gt;    VirtAddr,
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns a mutable reference to the active level 4 table.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; complete physical memory is mapped to virtual memory at the passed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `physical_memory_offset`. Also, this function must be only called once
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; to avoid aliasing `&amp;amp;mut` references (which is undefined behavior).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;active_level_4_table(physical_memory_offset: VirtAddr)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control::Cr3;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(level_4_table_frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = Cr3::read();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys = level_4_table_frame.start_address();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt = physical_memory_offset + phys.as_u64();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page_table_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable = virt.as_mut_ptr();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*page_table_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; unsafe
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we read the physical frame of the active level 4 table from the &lt;code&gt;CR3&lt;&#x2F;code&gt; register. We then take its physical start address, convert it to a &lt;code&gt;u64&lt;&#x2F;code&gt;, and add it to &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; to get the virtual address where the page table frame is mapped. Finally, we convert the virtual address to a &lt;code&gt;*mut PageTable&lt;&#x2F;code&gt; raw pointer through the &lt;code&gt;as_mut_ptr&lt;&#x2F;code&gt; method and then unsafely create a &lt;code&gt;&amp;amp;mut PageTable&lt;&#x2F;code&gt; reference from it. We create a &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference instead of a &lt;code&gt;&amp;amp;&lt;&#x2F;code&gt; reference because we will mutate the page tables later in this post.&lt;&#x2F;p&gt;
&lt;p&gt;We don‚Äôt need to use an unsafe block here because Rust treats the complete body of an &lt;code&gt;unsafe fn&lt;&#x2F;code&gt; like a large &lt;code&gt;unsafe&lt;&#x2F;code&gt; block. This makes our code more dangerous since we could accidentally introduce an unsafe operation in previous lines without noticing. It also makes it much more difficult to spot unsafe operations in between safe operations. There is an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2585&quot;&gt;RFC&lt;&#x2F;a&gt; to change this behavior.&lt;&#x2F;p&gt;
&lt;p&gt;We can now use this function to print the entries of the level 4 table:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::active_level_4_table;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::VirtAddr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ active_level_4_table(phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, entry) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; l4_table.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;entry.is_unused() {
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;L4 Entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, i, entry);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as before
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we convert the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; of the &lt;code&gt;BootInfo&lt;&#x2F;code&gt; struct to a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;addr&#x2F;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and pass it to the &lt;code&gt;active_level_4_table&lt;&#x2F;code&gt; function. We then use the &lt;code&gt;iter&lt;&#x2F;code&gt; function to iterate over the page table entries and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combinator to additionally add an index &lt;code&gt;i&lt;&#x2F;code&gt; to each element. We only print non-empty entries because all 512 entries wouldn‚Äôt fit on the screen.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;qemu-print-level-4-table.png&quot; alt=&quot;QEMU printing entry 0 (0x2000, PRESENT, WRITABLE, ACCESSED), entry 1 (0x894000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 31 (0x88e000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 175 (0x891000, PRESENT, WRITABLE, ACCESSED, DIRTY), and entry 504 (0x897000, PRESENT, WRITABLE, ACCESSED, DIRTY)&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that there are various non-empty entries, which all map to different level 3 tables. There are so many regions because kernel code, kernel stack, physical memory mapping, and boot information all use separate memory areas.&lt;&#x2F;p&gt;
&lt;p&gt;To traverse the page tables further and take a look at a level 3 table, we can take the mapped frame of an entry and convert it to a virtual address again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in the `for` loop in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::PageTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;entry.is_unused() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;L4 Entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, i, entry);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; get the physical address from the entry and convert it
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys = entry.frame().unwrap().start_address();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt = phys.as_u64() + boot_info.physical_memory_offset;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = VirtAddr::new(virt).as_mut_ptr();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l3_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PageTable = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*ptr };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; print non-empty entries of the level 3 table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, entry) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; l3_table.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;entry.is_unused() {
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;  L3 Entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, i, entry);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For looking at the level 2 and level 1 tables, we repeat that process for the level 3 and level 2 entries. As you can imagine, this gets very verbose very quickly, so we don‚Äôt show the full code here.&lt;&#x2F;p&gt;
&lt;p&gt;Traversing the page tables manually is interesting because it helps to understand how the CPU performs the translation. However, most of the time, we are only interested in the mapped physical address for a given virtual address, so let‚Äôs create a function for that.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;üîó&lt;&#x2F;a&gt;Translating Addresses&lt;&#x2F;h3&gt;
&lt;p&gt;To translate a virtual to a physical address, we have to traverse the four-level page table until we reach the mapped frame. Let‚Äôs create a function that performs this translation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::PhysAddr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Translates the given virtual address to the mapped physical address, or
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `None` if the address is not mapped.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; complete physical memory is mapped to virtual memory at the passed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `physical_memory_offset`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;translate_addr(addr: VirtAddr, physical_memory_offset: VirtAddr)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option&amp;lt;PhysAddr&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    translate_addr_inner(addr, physical_memory_offset)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We forward the function to a safe &lt;code&gt;translate_addr_inner&lt;&#x2F;code&gt; function to limit the scope of &lt;code&gt;unsafe&lt;&#x2F;code&gt;. As we noted above, Rust treats the complete body of an &lt;code&gt;unsafe fn&lt;&#x2F;code&gt; like a large unsafe block. By calling into a private safe function, we make each &lt;code&gt;unsafe&lt;&#x2F;code&gt; operation explicit again.&lt;&#x2F;p&gt;
&lt;p&gt;The private inner function contains the real implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Private function that is called by `translate_addr`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is safe to limit the scope of `unsafe` because Rust treats
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; the whole body of unsafe functions as an unsafe block. This function must
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; only be reachable through `unsafe fn` from outside of this module.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;translate_addr_inner(addr: VirtAddr, physical_memory_offset: VirtAddr)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option&amp;lt;PhysAddr&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::page_table::FrameError;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control::Cr3;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; read the active level 4 frame from the CR3 register
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(level_4_table_frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = Cr3::read();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; table_indexes = [
&lt;&#x2F;span&gt;&lt;span&gt;        addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index()
&lt;&#x2F;span&gt;&lt;span&gt;    ];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame = level_4_table_frame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; traverse the multi-level page table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;table_indexes {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; convert the frame into a page table reference
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt = physical_memory_offset + frame.start_address().as_u64();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; table_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt; PageTable = virt.as_ptr();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*table_ptr};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; read the page table entry and update `frame`
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; entry = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;table[index];
&lt;&#x2F;span&gt;&lt;span&gt;        frame = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; entry.frame() {
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(frame) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; frame,
&lt;&#x2F;span&gt;&lt;span&gt;            Err(FrameError::FrameNotPresent) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; return &lt;&#x2F;span&gt;&lt;span&gt;None,
&lt;&#x2F;span&gt;&lt;span&gt;            Err(FrameError::HugeFrame) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;huge pages not supported&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; calculate the physical address by adding the page offset
&lt;&#x2F;span&gt;&lt;span&gt;    Some(frame.start_address() + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;::from(addr.page_offset()))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of reusing our &lt;code&gt;active_level_4_table&lt;&#x2F;code&gt; function, we read the level 4 frame from the &lt;code&gt;CR3&lt;&#x2F;code&gt; register again. We do this because it simplifies this prototype implementation. Don‚Äôt worry, we will create a better solution in a moment.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;VirtAddr&lt;&#x2F;code&gt; struct already provides methods to compute the indexes into the page tables of the four levels. We store these indexes in a small array because it allows us to traverse the page tables using a &lt;code&gt;for&lt;&#x2F;code&gt; loop. Outside of the loop, we remember the last visited &lt;code&gt;frame&lt;&#x2F;code&gt; to calculate the physical address later. The &lt;code&gt;frame&lt;&#x2F;code&gt; points to page table frames while iterating and to the mapped frame after the last iteration, i.e., after following the level 1 entry.&lt;&#x2F;p&gt;
&lt;p&gt;Inside the loop, we again use the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; to convert the frame into a page table reference. We then read the entry of the current page table and use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page_table&#x2F;struct.PageTableEntry.html#method.frame&quot;&gt;&lt;code&gt;PageTableEntry::frame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to retrieve the mapped frame. If the entry is not mapped to a frame, we return &lt;code&gt;None&lt;&#x2F;code&gt;. If the entry maps a huge 2¬†MiB or 1¬†GiB page, we panic for now.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs test our translation function by translating some addresses:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new import
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::translate_addr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; hello world and blog_os::init
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addresses = [
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the identity-mapped vga buffer page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some code page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x201008&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some stack page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0100_0020_1a10&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; virtual address mapped to physical address 0
&lt;&#x2F;span&gt;&lt;span&gt;        boot_info.physical_memory_offset,
&lt;&#x2F;span&gt;&lt;span&gt;    ];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;addresses {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt = VirtAddr::new(address);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ translate_addr(virt, phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, virt, phys);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;qemu-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x201008 -&amp;gt; 0x401008, 0x10000201a10 -&amp;gt; 0x279a10, ‚Äúpanicked at ‚Äòhuge pages not supported‚Äô&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, the identity-mapped address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; translates to the same physical address. The code page and the stack page translate to some arbitrary physical addresses, which depend on how the bootloader created the initial mapping for our kernel. It‚Äôs worth noting that the last 12 bits always stay the same after translation, which makes sense because these bits are the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#paging-on-x86-64&quot;&gt;&lt;em&gt;page offset&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and not part of the translation.&lt;&#x2F;p&gt;
&lt;p&gt;Since each physical address can be accessed by adding the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt;, the translation of the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; address itself should point to physical address &lt;code&gt;0&lt;&#x2F;code&gt;. However, the translation fails because the mapping uses huge pages for efficiency, which is not supported in our implementation yet.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-offsetpagetable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-offsetpagetable&quot; aria-label=&quot;Anchor link for: using-offsetpagetable&quot;&gt;üîó&lt;&#x2F;a&gt;Using &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Translating virtual to physical addresses is a common task in an OS kernel, therefore the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides an abstraction for it. The implementation already supports huge pages and several other page table functions apart from &lt;code&gt;translate_addr&lt;&#x2F;code&gt;, so we will use it in the following instead of adding huge page support to our own implementation.&lt;&#x2F;p&gt;
&lt;p&gt;At the basis of the abstraction are two traits that define various page table mapping functions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait is generic over the page size and provides functions that operate on pages. Examples are &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#tymethod.translate_page&quot;&gt;&lt;code&gt;translate_page&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which translates a given page to a frame of the same size, and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which creates a new mapping in the page table.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Translate.html&quot;&gt;&lt;code&gt;Translate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait provides functions that work with multiple page sizes, such as &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Translate.html#method.translate_addr&quot;&gt;&lt;code&gt;translate_addr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; or the general &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Translate.html&quot;&gt;&lt;code&gt;translate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The traits only define the interface, they don‚Äôt provide any implementation. The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate currently provides three types that implement the traits with different requirements. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.OffsetPageTable.html&quot;&gt;&lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type assumes that the complete physical memory is mapped to the virtual address space at some offset. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MappedPageTable.html&quot;&gt;&lt;code&gt;MappedPageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a bit more flexible: It only requires that each page table frame is mapped to the virtual address space at a calculable address. Finally, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type can be used to access page table frames through &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#recursive-page-tables&quot;&gt;recursive page tables&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In our case, the bootloader maps the complete physical memory at a virtual address specified by the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; variable, so we can use the &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; type. To initialize it, we create a new &lt;code&gt;init&lt;&#x2F;code&gt; function in our &lt;code&gt;memory&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::OffsetPageTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Initialize a new OffsetPageTable.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; complete physical memory is mapped to virtual memory at the passed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `physical_memory_offset`. Also, this function must be only called once
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; to avoid aliasing `&amp;amp;mut` references (which is undefined behavior).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(physical_memory_offset: VirtAddr) -&amp;gt; OffsetPageTable&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = active_level_4_table(physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    OffsetPageTable::new(level_4_table, physical_memory_offset)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; make private
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;active_level_4_table(physical_memory_offset: VirtAddr)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable
&lt;&#x2F;span&gt;&lt;span&gt;{‚Ä¶}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function takes the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; as an argument and returns a new &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; instance with a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime. This means that the instance stays valid for the complete runtime of our kernel. In the function body, we first call the &lt;code&gt;active_level_4_table&lt;&#x2F;code&gt; function to retrieve a mutable reference to the level 4 page table. We then invoke the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.OffsetPageTable.html#method.new&quot;&gt;&lt;code&gt;OffsetPageTable::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function with this reference. As the second parameter, the &lt;code&gt;new&lt;&#x2F;code&gt; function expects the virtual address at which the mapping of the physical memory starts, which is given in the &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; variable.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;active_level_4_table&lt;&#x2F;code&gt; function should only be called from the &lt;code&gt;init&lt;&#x2F;code&gt; function from now on because it can easily lead to aliased mutable references when called multiple times, which can cause undefined behavior. For this reason, we make the function private by removing the &lt;code&gt;pub&lt;&#x2F;code&gt; specifier.&lt;&#x2F;p&gt;
&lt;p&gt;We can now use the &lt;code&gt;Translate::translate_addr&lt;&#x2F;code&gt; method instead of our own &lt;code&gt;memory::translate_addr&lt;&#x2F;code&gt; function. We only need to change a few lines in our &lt;code&gt;kernel_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new: different imports
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{structures::paging::Translate, VirtAddr};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; hello world and blog_os::init
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new: initialize a mapper
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addresses = [‚Ä¶]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; same as before
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;addresses {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt = VirtAddr::new(address);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new: use the `mapper.translate_addr` method
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys = mapper.translate_addr(virt);
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, virt, phys);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to import the &lt;code&gt;Translate&lt;&#x2F;code&gt; trait in order to use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Translate.html#method.translate_addr&quot;&gt;&lt;code&gt;translate_addr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method it provides.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it now, we see the same translation results as before, with the difference that the huge page translation now also works:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;qemu-mapper-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x201008 -&amp;gt; 0x401008, 0x10000201a10 -&amp;gt; 0x279a10, 0x18000000000 -&amp;gt; 0x0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, the translations of &lt;code&gt;0xb8000&lt;&#x2F;code&gt; and the code and stack addresses stay the same as with our own translation function. Additionally, we now see that the virtual address &lt;code&gt;physical_memory_offset&lt;&#x2F;code&gt; is mapped to the physical address &lt;code&gt;0x0&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By using the translation function of the &lt;code&gt;MappedPageTable&lt;&#x2F;code&gt; type, we can spare ourselves the work of implementing huge page support. We also have access to other page functions, such as &lt;code&gt;map_to&lt;&#x2F;code&gt;, which we will use in the next section.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, we no longer need our &lt;code&gt;memory::translate_addr&lt;&#x2F;code&gt; and &lt;code&gt;memory::translate_addr_inner&lt;&#x2F;code&gt; functions, so we can delete them.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-a-new-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-new-mapping&quot; aria-label=&quot;Anchor link for: creating-a-new-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a new Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;Until now, we only looked at the page tables without modifying anything. Let‚Äôs change that by creating a new mapping for a previously unmapped page.&lt;&#x2F;p&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait for our implementation, so let‚Äôs take a look at that function first. The documentation tells us that it takes four arguments: the page that we want to map, the frame that the page should be mapped to, a set of flags for the page table entry, and a &lt;code&gt;frame_allocator&lt;&#x2F;code&gt;. The frame allocator is needed because mapping the given page might require creating additional page tables, which need unused frames as backing storage.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-create-example-mapping-function&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-create-example-mapping-function&quot; aria-label=&quot;Anchor link for: a-create-example-mapping-function&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; Function&lt;&#x2F;h4&gt;
&lt;p&gt;The first step of our implementation is to create a new &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function that maps a given virtual page to &lt;code&gt;0xb8000&lt;&#x2F;code&gt;, the physical frame of the VGA text buffer. We choose that frame because it allows us to easily test if the mapping was created correctly: We just need to write to the newly mapped page and see whether we see the write appear on the screen.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{
&lt;&#x2F;span&gt;&lt;span&gt;    PhysAddr,
&lt;&#x2F;span&gt;&lt;span&gt;    structures::paging::{Page, PhysFrame, Mapper, Size4KiB, FrameAllocator}
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates an example mapping for the given page to frame `0xb8000`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;create_example_mapping(
&lt;&#x2F;span&gt;&lt;span&gt;    page: Page,
&lt;&#x2F;span&gt;&lt;span&gt;    mapper: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; OffsetPageTable,
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::PageTableFlags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; Flags;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = PhysFrame::containing_address(PhysAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = Flags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Flags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; map_to_result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; FIXME: this is not safe, we do it only for testing
&lt;&#x2F;span&gt;&lt;span&gt;        mapper.map_to(page, frame, flags, frame_allocator)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    map_to_result.expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_to failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).flush();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In addition to the &lt;code&gt;page&lt;&#x2F;code&gt; that should be mapped, the function expects a mutable reference to an &lt;code&gt;OffsetPageTable&lt;&#x2F;code&gt; instance and a &lt;code&gt;frame_allocator&lt;&#x2F;code&gt;. The &lt;code&gt;frame_allocator&lt;&#x2F;code&gt; parameter uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-02-traits.html#traits-as-parameters&quot;&gt;&lt;code&gt;impl Trait&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; syntax to be &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-00-generics.html&quot;&gt;generic&lt;&#x2F;a&gt; over all types that implement the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait. The trait is generic over the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;trait.PageSize.html&quot;&gt;&lt;code&gt;PageSize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait to work with both standard 4¬†KiB pages and huge 2¬†MiB&#x2F;1¬†GiB pages. We only want to create a 4¬†KiB mapping, so we set the generic parameter to &lt;code&gt;Size4KiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is unsafe because the caller must ensure that the frame is not already in use. The reason for this is that mapping the same frame twice could result in undefined behavior, for example when two different &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references point to the same physical memory location. In our case, we reuse the VGA text buffer frame, which is already mapped, so we break the required condition. However, the &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function is only a temporary testing function and will be removed after this post, so it is ok. To remind us of the unsafety, we put a &lt;code&gt;FIXME&lt;&#x2F;code&gt; comment on the line.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to the &lt;code&gt;page&lt;&#x2F;code&gt; and the &lt;code&gt;unused_frame&lt;&#x2F;code&gt;, the &lt;code&gt;map_to&lt;&#x2F;code&gt; method takes a set of flags for the mapping and a reference to the &lt;code&gt;frame_allocator&lt;&#x2F;code&gt;, which will be explained in a moment. For the flags, we set the &lt;code&gt;PRESENT&lt;&#x2F;code&gt; flag because it is required for all valid entries and the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag to make the mapped page writable. For a list of all possible flags, see the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#page-table-format&quot;&gt;&lt;em&gt;Page Table Format&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; section of the previous post.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#method.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function can fail, so it returns a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Since this is just some example code that does not need to be robust, we just use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to panic when an error occurs. On success, the function returns a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type that provides an easy way to flush the newly mapped page from the translation lookaside buffer (TLB) with its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. Like &lt;code&gt;Result&lt;&#x2F;code&gt;, the type uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;result&#x2F;#results-must-be-used&quot;&gt;&lt;code&gt;#[must_use]&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attribute to emit a warning when we accidentally forget to use it.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-dummy-frameallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummy-frameallocator&quot; aria-label=&quot;Anchor link for: a-dummy-frameallocator&quot;&gt;üîó&lt;&#x2F;a&gt;A dummy &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;To be able to call &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt;, we need to create a type that implements the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait first. As noted above, the trait is responsible for allocating frames for new page tables if they are needed by &lt;code&gt;map_to&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs start with the simple case and assume that we don‚Äôt need to create new page tables. For this case, a frame allocator that always returns &lt;code&gt;None&lt;&#x2F;code&gt; suffices. We create such an &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt; for testing our mapping function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A FrameAllocator that always returns `None`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EmptyFrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EmptyFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Implementing the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; is unsafe because the implementer must guarantee that the allocator yields only unused frames. Otherwise, undefined behavior might occur, for example when two virtual pages are mapped to the same physical frame. Our &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt; only returns &lt;code&gt;None&lt;&#x2F;code&gt;, so this isn‚Äôt a problem in this case.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;choosing-a-virtual-page&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#choosing-a-virtual-page&quot; aria-label=&quot;Anchor link for: choosing-a-virtual-page&quot;&gt;üîó&lt;&#x2F;a&gt;Choosing a Virtual Page&lt;&#x2F;h4&gt;
&lt;p&gt;We now have a simple frame allocator that we can pass to our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function. However, the allocator always returns &lt;code&gt;None&lt;&#x2F;code&gt;, so this will only work if no additional page table frames are needed for creating the mapping. To understand when additional page table frames are needed and when not, let‚Äôs consider an example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;required-page-frames-example.svg&quot; alt=&quot;A virtual and a physical address space with a single mapped page and the page tables of all four levels&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The graphic shows the virtual address space on the left, the physical address space on the right, and the page tables in between. The page tables are stored in physical memory frames, indicated by the dashed lines. The virtual address space contains a single mapped page at address &lt;code&gt;0x803fe00000&lt;&#x2F;code&gt;, marked in blue. To translate this page to its frame, the CPU walks the 4-level page table until it reaches the frame at address 36¬†KiB.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, the graphic shows the physical frame of the VGA text buffer in red. Our goal is to map a previously unmapped virtual page to this frame using our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function. Since our &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt; always returns &lt;code&gt;None&lt;&#x2F;code&gt;, we want to create the mapping so that no additional frames are needed from the allocator. This depends on the virtual page that we select for the mapping.&lt;&#x2F;p&gt;
&lt;p&gt;The graphic shows two candidate pages in the virtual address space, both marked in yellow. One page is at address &lt;code&gt;0x803fdfd000&lt;&#x2F;code&gt;, which is 3 pages before the mapped page (in blue). While the level 4 and level 3 page table indices are the same as for the blue page, the level 2 and level 1 indices are different (see the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#paging-on-x86-64&quot;&gt;previous post&lt;&#x2F;a&gt;). The different index into the level 2 table means that a different level 1 table is used for this page. Since this level 1 table does not exist yet, we would need to create it if we chose that page for our example mapping, which would require an additional unused physical frame. In contrast, the second candidate page at address &lt;code&gt;0x803fe02000&lt;&#x2F;code&gt; does not have this problem because it uses the same level 1 page table as the blue page. Thus, all the required page tables already exist.&lt;&#x2F;p&gt;
&lt;p&gt;In summary, the difficulty of creating a new mapping depends on the virtual page that we want to map. In the easiest case, the level 1 page table for the page already exists and we just need to write a single entry. In the most difficult case, the page is in a memory region for which no level 3 exists yet, so we need to create new level 3, level 2 and level 1 page tables first.&lt;&#x2F;p&gt;
&lt;p&gt;For calling our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function with the &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt;, we need to choose a page for which all page tables already exist. To find such a page, we can utilize the fact that the bootloader loads itself in the first megabyte of the virtual address space. This means that a valid level 1 table exists for all pages in this region. Thus, we can choose any unused page in this memory region for our example mapping, such as the page at address &lt;code&gt;0&lt;&#x2F;code&gt;. Normally, this page should stay unused to guarantee that dereferencing a null pointer causes a page fault, so we know that the bootloader leaves it unmapped.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;creating-the-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-the-mapping&quot; aria-label=&quot;Anchor link for: creating-the-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Creating the Mapping&lt;&#x2F;h4&gt;
&lt;p&gt;We now have all the required parameters for calling our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function, so let‚Äôs modify our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function to map the page at virtual address &lt;code&gt;0&lt;&#x2F;code&gt;. Since we map the page to the frame of the VGA text buffer, we should be able to write to the screen through it afterward. The implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{structures::paging::Page, VirtAddr}; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new import
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; hello world and blog_os::init
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; mapper = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(phys_mem_offset) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = memory::EmptyFrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; map an unused page
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page = Page::containing_address(VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    memory::create_example_mapping(page, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; mapper, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; write the string `New!` to the screen through the new mapping
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u64 &lt;&#x2F;span&gt;&lt;span&gt;= page.start_address().as_mut_ptr();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ page_ptr.offset(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;400&lt;&#x2F;span&gt;&lt;span&gt;).write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x_f021_f077_f065_f04e&lt;&#x2F;span&gt;&lt;span&gt;)};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first create the mapping for the page at address &lt;code&gt;0&lt;&#x2F;code&gt; by calling our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function with a mutable reference to the &lt;code&gt;mapper&lt;&#x2F;code&gt; and the &lt;code&gt;frame_allocator&lt;&#x2F;code&gt; instances. This maps the page to the VGA text buffer frame, so we should see any write to it on the screen.&lt;&#x2F;p&gt;
&lt;p&gt;Then we convert the page to a raw pointer and write a value to offset &lt;code&gt;400&lt;&#x2F;code&gt;. We don‚Äôt write to the start of the page because the top line of the VGA buffer is directly shifted off the screen by the next &lt;code&gt;println&lt;&#x2F;code&gt;. We write the value &lt;code&gt;0x_f021_f077_f065_f04e&lt;&#x2F;code&gt;, which represents the string &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on a white background. As we learned &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#volatile&quot;&gt;in the &lt;em&gt;‚ÄúVGA Text Mode‚Äù&lt;&#x2F;em&gt; post&lt;&#x2F;a&gt;, writes to the VGA buffer should be volatile, so we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it in QEMU, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;qemu-new-mapping.png&quot; alt=&quot;QEMU printing ‚ÄúIt did not crash!‚Äù with four completely white cells in the middle of the screen&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on the screen is caused by our write to page &lt;code&gt;0&lt;&#x2F;code&gt;, which means that we successfully created a new mapping in the page tables.&lt;&#x2F;p&gt;
&lt;p&gt;Creating that mapping only worked because the level 1 table responsible for the page at address &lt;code&gt;0&lt;&#x2F;code&gt; already exists. When we try to map a page for which no level 1 table exists yet, the &lt;code&gt;map_to&lt;&#x2F;code&gt; function fails because it tries to create new page tables by allocating frames with the &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt;. We can see that happen when we try to map page &lt;code&gt;0xdeadbeaf000&lt;&#x2F;code&gt; instead of &lt;code&gt;0&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page = Page::containing_address(VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf000&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, a panic with the following error message occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;panicked at &amp;#39;map_to failed: FrameAllocationFailed&amp;#39;, &#x2F;‚Ä¶&#x2F;result.rs:999:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To map pages that don‚Äôt have a level 1 page table yet, we need to create a proper &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;. But how do we know which frames are unused and how much physical memory is available?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocating-frames&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-frames&quot; aria-label=&quot;Anchor link for: allocating-frames&quot;&gt;üîó&lt;&#x2F;a&gt;Allocating Frames&lt;&#x2F;h3&gt;
&lt;p&gt;In order to create new page tables, we need to create a proper frame allocator. To do that, we use the &lt;code&gt;memory_map&lt;&#x2F;code&gt; that is passed by the bootloader as part of the &lt;code&gt;BootInfo&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::bootinfo::MemoryMap;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A FrameAllocator that returns usable frames from the bootloader&amp;#39;s memory map.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    memory_map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; MemoryMap,
&lt;&#x2F;span&gt;&lt;span&gt;    next: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Create a FrameAllocator from the passed memory map.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because the caller must guarantee that the passed
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; memory map is valid. The main requirement is that all frames that are marked
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; as `USABLE` in it are really unused.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; MemoryMap) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        BootInfoFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;            memory_map,
&lt;&#x2F;span&gt;&lt;span&gt;            next: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The struct has two fields: A &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; reference to the memory map passed by the bootloader and a &lt;code&gt;next&lt;&#x2F;code&gt; field that keeps track of the number of the next frame that the allocator should return.&lt;&#x2F;p&gt;
&lt;p&gt;As we explained in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#boot-information&quot;&gt;&lt;em&gt;Boot Information&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; section, the memory map is provided by the BIOS&#x2F;UEFI firmware. It can only be queried very early in the boot process, so the bootloader already calls the respective functions for us. The memory map consists of a list of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.6.4&#x2F;bootloader&#x2F;bootinfo&#x2F;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; structs, which contain the start address, the length, and the type (e.g. unused, reserved, etc.) of each memory region.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;init&lt;&#x2F;code&gt; function initializes a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; with a given memory map. The &lt;code&gt;next&lt;&#x2F;code&gt; field is initialized with &lt;code&gt;0&lt;&#x2F;code&gt; and will be increased for every frame allocation to avoid returning the same frame twice. Since we don‚Äôt know if the usable frames of the memory map were already used somewhere else, our &lt;code&gt;init&lt;&#x2F;code&gt; function must be &lt;code&gt;unsafe&lt;&#x2F;code&gt; to require additional guarantees from the caller.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-usable-frames-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-usable-frames-method&quot; aria-label=&quot;Anchor link for: a-usable-frames-method&quot;&gt;üîó&lt;&#x2F;a&gt;A &lt;code&gt;usable_frames&lt;&#x2F;code&gt; Method&lt;&#x2F;h4&gt;
&lt;p&gt;Before we implement the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait, we add an auxiliary method that converts the memory map into an iterator of usable frames:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::bootinfo::MemoryRegionType;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns an iterator over the usable frames specified in the memory map.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;usable_frames(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; impl Iterator&amp;lt;Item = PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; get usable regions from memory map
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; regions = self.memory_map.iter();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; usable_regions = regions
&lt;&#x2F;span&gt;&lt;span&gt;            .filter(|r| r.region_type == MemoryRegionType::Usable);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; map each region to its address range
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr_ranges = usable_regions
&lt;&#x2F;span&gt;&lt;span&gt;            .map(|r| r.range.start_addr()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;r.range.end_addr());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; transform to an iterator of frame start addresses
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame_addresses = addr_ranges.flat_map(|r| r.step_by(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create `PhysFrame` types from the start addresses
&lt;&#x2F;span&gt;&lt;span&gt;        frame_addresses.map(|addr| PhysFrame::containing_address(PhysAddr::new(addr)))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function uses iterator combinator methods to transform the initial &lt;code&gt;MemoryMap&lt;&#x2F;code&gt; into an iterator of usable physical frames:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First, we call the &lt;code&gt;iter&lt;&#x2F;code&gt; method to convert the memory map to an iterator of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.6.4&#x2F;bootloader&#x2F;bootinfo&#x2F;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;s.&lt;&#x2F;li&gt;
&lt;li&gt;Then we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.filter&quot;&gt;&lt;code&gt;filter&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to skip any reserved or otherwise unavailable regions. The bootloader updates the memory map for all the mappings it creates, so frames that are used by our kernel (code, data, or stack) or to store the boot information are already marked as &lt;code&gt;InUse&lt;&#x2F;code&gt; or similar. Thus, we can be sure that &lt;code&gt;Usable&lt;&#x2F;code&gt; frames are not used somewhere else.&lt;&#x2F;li&gt;
&lt;li&gt;Afterwards, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combinator and Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;ops&#x2F;struct.Range.html&quot;&gt;range syntax&lt;&#x2F;a&gt; to transform our iterator of memory regions to an iterator of address ranges.&lt;&#x2F;li&gt;
&lt;li&gt;Next, we use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to transform the address ranges into an iterator of frame start addresses, choosing every 4096th address using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Since 4096 bytes (= 4¬†KiB) is the page size, we get the start address of each frame. The bootloader page-aligns all usable memory areas so that we don‚Äôt need any alignment or rounding code here. By using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instead of &lt;code&gt;map&lt;&#x2F;code&gt;, we get an &lt;code&gt;Iterator&amp;lt;Item = u64&amp;gt;&lt;&#x2F;code&gt; instead of an &lt;code&gt;Iterator&amp;lt;Item = Iterator&amp;lt;Item = u64&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we convert the start addresses to &lt;code&gt;PhysFrame&lt;&#x2F;code&gt; types to construct an &lt;code&gt;Iterator&amp;lt;Item = PhysFrame&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The return type of the function uses the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-02-traits.html#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; feature. This way, we can specify that we return some type that implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait with item type &lt;code&gt;PhysFrame&lt;&#x2F;code&gt; but don‚Äôt need to name the concrete return type. This is important here because we &lt;em&gt;can‚Äôt&lt;&#x2F;em&gt; name the concrete type since it depends on unnamable closure types.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;implementing-the-frameallocator-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-the-frameallocator-trait&quot; aria-label=&quot;Anchor link for: implementing-the-frameallocator-trait&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; Trait&lt;&#x2F;h4&gt;
&lt;p&gt;Now we can implement the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = self.usable_frames().nth(self.next);
&lt;&#x2F;span&gt;&lt;span&gt;        self.next += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        frame
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first use the &lt;code&gt;usable_frames&lt;&#x2F;code&gt; method to get an iterator of usable frames from the memory map. Then, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.nth&quot;&gt;&lt;code&gt;Iterator::nth&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to get the frame with index &lt;code&gt;self.next&lt;&#x2F;code&gt; (thereby skipping &lt;code&gt;(self.next - 1)&lt;&#x2F;code&gt; frames). Before returning that frame, we increase &lt;code&gt;self.next&lt;&#x2F;code&gt; by one so that we return the following frame on the next call.&lt;&#x2F;p&gt;
&lt;p&gt;This implementation is not quite optimal since it recreates the &lt;code&gt;usable_frame&lt;&#x2F;code&gt; allocator on every allocation. It would be better to directly store the iterator as a struct field instead. Then we wouldn‚Äôt need the &lt;code&gt;nth&lt;&#x2F;code&gt; method and could just call &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;next&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; on every allocation. The problem with this approach is that it‚Äôs not possible to store an &lt;code&gt;impl Trait&lt;&#x2F;code&gt; type in a struct field currently. It might work someday when &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2071&quot;&gt;&lt;em&gt;named existential types&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; are fully implemented.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;using-the-bootinfoframeallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-bootinfoframeallocator&quot; aria-label=&quot;Anchor link for: using-the-bootinfoframeallocator&quot;&gt;üîó&lt;&#x2F;a&gt;Using the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;We can now modify our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function to pass a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; instance instead of an &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::BootInfoFrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        BootInfoFrameAllocator::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;boot_info.memory_map)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With the boot info frame allocator, the mapping succeeds and we see the black-on-white &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on the screen again. Behind the scenes, the &lt;code&gt;map_to&lt;&#x2F;code&gt; method creates the missing page tables in the following way:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Use the passed &lt;code&gt;frame_allocator&lt;&#x2F;code&gt; to allocate an unused frame.&lt;&#x2F;li&gt;
&lt;li&gt;Zero the frame to create a new, empty page table.&lt;&#x2F;li&gt;
&lt;li&gt;Map the entry of the higher level table to that frame.&lt;&#x2F;li&gt;
&lt;li&gt;Continue with the next table level.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function is just some example code, we are now able to create new mappings for arbitrary pages. This will be essential for allocating memory or implementing multithreading in future posts.&lt;&#x2F;p&gt;
&lt;p&gt;At this point, we should delete the &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function again to avoid accidentally invoking undefined behavior, as explained &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-implementation&#x2F;#a-create-example-mapping-function&quot;&gt;above&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned about different techniques to access the physical frames of page tables, including identity mapping, mapping of the complete physical memory, temporary mapping, and recursive page tables. We chose to map the complete physical memory since it‚Äôs simple, portable, and powerful.&lt;&#x2F;p&gt;
&lt;p&gt;We can‚Äôt map the physical memory from our kernel without page table access, so we need support from the bootloader. The &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate supports creating the required mapping through optional cargo crate features. It passes the required information to our kernel in the form of a &lt;code&gt;&amp;amp;BootInfo&lt;&#x2F;code&gt; argument to our entry point function.&lt;&#x2F;p&gt;
&lt;p&gt;For our implementation, we first manually traversed the page tables to implement a translation function, and then used the &lt;code&gt;MappedPageTable&lt;&#x2F;code&gt; type of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate. We also learned how to create new mappings in the page table and how to create the necessary &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; on top of the memory map passed by the bootloader.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;allocate memory&lt;&#x2F;a&gt; and use various &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Advanced Paging</title>
                <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/advanced-paging/</link>
                <guid>https://os.phil-opp.com/advanced-paging/</guid>
                <description>&lt;p&gt;This post explains techniques to make the physical page table frames accessible to our kernel. It then uses such a technique to implement a function that translates virtual to physical addresses. It also explains how to create new mappings in the page tables.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;5c0fb63f33380fc8596d7166c2ebde03ef3d6726&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; we learned about the principles of paging and how the 4-level page tables on x86_64 work. We also found out that the bootloader already set up a page table hierarchy for our kernel, which means that our kernel already runs on virtual addresses. This improves safety since illegal memory accesses cause page fault exceptions instead of modifying arbitrary physical memory.&lt;&#x2F;p&gt;
&lt;p&gt;However, it also causes a problem when we try to access the page tables from our kernel because we can‚Äôt directly access the physical addresses that are stored in page table entries or the &lt;code&gt;CR3&lt;&#x2F;code&gt; register. We experienced that problem already &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#accessing-the-page-tables&quot;&gt;at the end of the previous post&lt;&#x2F;a&gt; when we tried to inspect the active page tables.&lt;&#x2F;p&gt;
&lt;p&gt;The next section discusses the problem in detail and provides different approaches to a solution. Afterward, we implement a function that traverses the page table hierarchy in order to translate virtual to physical addresses. Finally, we learn how to create new mappings in the page tables and how to find unused memory frames for creating new page tables.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dependency-versions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dependency-versions&quot; aria-label=&quot;Anchor link for: dependency-versions&quot;&gt;üîó&lt;&#x2F;a&gt;Dependency Versions&lt;&#x2F;h3&gt;
&lt;p&gt;This post requires version 0.3.12 of the &lt;code&gt;bootloader&lt;&#x2F;code&gt; dependency and version 0.5.0 of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; dependency. You can set the dependency versions in your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.3.12&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;accessing-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-page-tables&quot; aria-label=&quot;Anchor link for: accessing-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Accessing Page Tables&lt;&#x2F;h2&gt;
&lt;p&gt;Accessing the page tables from our kernel is not as easy as it may seem. To understand the problem let‚Äôs take a look at the example 4-level page table hierarchy of the previous post again:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;..&#x2F;paging-introduction&#x2F;x86_64-page-table-translation.svg&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The important thing here is that each page entry stores the &lt;em&gt;physical&lt;&#x2F;em&gt; address of the next table. This avoids the need to run a translation for these addresses too, which would be bad for performance and could easily cause endless translation loops.&lt;&#x2F;p&gt;
&lt;p&gt;The problem for us is that we can‚Äôt directly access physical addresses from our kernel since our kernel also runs on top of virtual addresses. For example when we access address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, we access the &lt;em&gt;virtual&lt;&#x2F;em&gt; address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, not the &lt;em&gt;physical&lt;&#x2F;em&gt; address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt; where the level 4 page table is stored. When we want to access the physical address &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, we can only do so through some virtual address that maps to it.&lt;&#x2F;p&gt;
&lt;p&gt;So in order to access page table frames, we need to map some virtual pages to them. There are different ways to create these mappings that all allow us to access arbitrary page table frames:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A simple solution is to &lt;strong&gt;identity map all page tables&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;identity-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with various virtual pages mapped to the physical frame with the same address&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this example, we see various identity-mapped page table frames. This way the physical addresses of page tables are also valid virtual addresses so that we can easily access the page tables of all levels starting from the CR3 register.&lt;&#x2F;p&gt;
&lt;p&gt;However, it clutters the virtual address space and makes it more difficult to find continuous memory regions of larger sizes. For example, imagine that we want to create a virtual memory region of size 1000‚ÄØKiB in the above graphic, e.g. for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory-mapped_file&quot;&gt;memory-mapping a file&lt;&#x2F;a&gt;. We can‚Äôt start the region at &lt;code&gt;28‚ÄØKiB&lt;&#x2F;code&gt; because it would collide with the already mapped page at &lt;code&gt;1004‚ÄØMiB&lt;&#x2F;code&gt;. So we have to look further until we find a large enough unmapped area, for example at &lt;code&gt;1008‚ÄØKiB&lt;&#x2F;code&gt;. This is a similar fragmentation problem as with &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#fragmentation&quot;&gt;segmentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Equally, it makes it much more difficult to create new page tables, because we need to find physical frames whose corresponding pages aren‚Äôt already in use. For example, let‚Äôs assume that we reserved the &lt;em&gt;virtual&lt;&#x2F;em&gt; 1000‚ÄØKiB memory region starting at &lt;code&gt;1008‚ÄØKiB&lt;&#x2F;code&gt; for our memory-mapped file. Now we can‚Äôt use any frame with a &lt;em&gt;physical&lt;&#x2F;em&gt; address between &lt;code&gt;1000‚ÄØKiB&lt;&#x2F;code&gt; and &lt;code&gt;2008‚ÄØKiB&lt;&#x2F;code&gt; anymore, because we can‚Äôt identity map it.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Alternatively, we could &lt;strong&gt;map the page tables frames only temporarily&lt;&#x2F;strong&gt; when we need to access them. To be able to create the temporary mappings we only need a single identity-mapped level 1 table:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;temporarily-mapped-page-tables.png&quot; alt=&quot;A virtual and a physical address space with an identity mapped level 1 table, which maps its 0th entry to the level 2 table frame, thereby mapping that frame to page with address 0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The level 1 table in this graphic controls the first 2‚ÄØMiB of the virtual address space. This is because it is reachable by starting at the CR3 register and following the 0th entry in the level 4, level 3, and level 2 page tables. The entry with index &lt;code&gt;8&lt;&#x2F;code&gt; maps the virtual page at address &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt; to the physical frame at address &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt;, thereby identity mapping the level 1 table itself. The graphic shows this identity-mapping by the horizontal arrow at &lt;code&gt;32‚ÄØKiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By writing to the identity-mapped level 1 table, our kernel can create up to 511 temporary mappings (512 minus the entry required for the identity mapping). In the above example, the kernel mapped the 0th entry of the level 1 table to the frame with address &lt;code&gt;24‚ÄØKiB&lt;&#x2F;code&gt;. This created a temporary mapping of the virtual page at &lt;code&gt;0‚ÄØKiB&lt;&#x2F;code&gt; to the physical frame of the level 2 page table, indicated by the dashed arrow. Now the kernel can access the level 2 page table by writing to the page starting at &lt;code&gt;0‚ÄØKiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The process for accessing an arbitrary page table frame with temporary mappings would be:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Search for a free entry in the identity-mapped level 1 table.&lt;&#x2F;li&gt;
&lt;li&gt;Map that entry to the physical frame of the page table that we want to access.&lt;&#x2F;li&gt;
&lt;li&gt;Access the target frame through the virtual page that maps to the entry.&lt;&#x2F;li&gt;
&lt;li&gt;Set the entry back to unused thereby removing the temporary mapping again.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This approach keeps the virtual address space clean since it reuses the same 512 virtual pages for creating the mappings. The drawback is that it is a bit cumbersome, especially since a new mapping might require modifications of multiple table levels, which means that we would need to repeat the above process multiple times.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;While both of the above approaches work, there is a third technique called &lt;strong&gt;recursive page tables&lt;&#x2F;strong&gt; that combines their advantages: It keeps all page table frames mapped at all times so that no temporary mappings are needed, and also keeps the mapped pages together to avoid fragmentation of the virtual address space. This is the technique that we will use for our implementation, therefore it is described in detail in the following section.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;recursive-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-page-tables&quot; aria-label=&quot;Anchor link for: recursive-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Recursive Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind this approach is to map some entry of the level 4 page table to the level 4 table itself. By doing this, we effectively reserve a part of the virtual address space and map all current and future page table frames to that space.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs go through an example to understand how this all works:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;recursive-page-table.png&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory. Entry 511 of the level 4 page is mapped to frame 4KiB, the frame of the level 4 table itself.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The only difference to the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;#accessing-page-tables&quot;&gt;example at the beginning of this post&lt;&#x2F;a&gt; is the additional entry at index &lt;code&gt;511&lt;&#x2F;code&gt; in the level 4 table, which is mapped to physical frame &lt;code&gt;4‚ÄØKiB&lt;&#x2F;code&gt;, the frame of the level 4 table itself.&lt;&#x2F;p&gt;
&lt;p&gt;By letting the CPU follow this entry on a translation, it doesn‚Äôt reach a level 3 table, but the same level 4 table again. This is similar to a recursive function that calls itself, therefore this table is called a &lt;em&gt;recursive page table&lt;&#x2F;em&gt;. The important thing is that the CPU assumes that every entry in the level 4 table points to a level 3 table, so it now treats the level 4 table as a level 3 table. This works because tables of all levels have the exact same layout on x86_64.&lt;&#x2F;p&gt;
&lt;p&gt;By following the recursive entry one or multiple times before we start the actual translation, we can effectively shorten the number of levels that the CPU traverses. For example, if we follow the recursive entry once and then proceed to the level 3 table, the CPU thinks that the level 3 table is a level 2 table. Going further, it treats the level 2 table as a level 1 table and the level 1 table as the mapped frame. This means that we can now read and write the level 1 page table because the CPU thinks that it is the mapped frame. The graphic below illustrates the 5 translation steps:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;recursive-page-table-access-level-1.png&quot; alt=&quot;The above example 4-level page hierarchy with 5 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúStep 1‚Äù from level 4 table to level 4 table, ‚ÄúStep 2‚Äù from level 4 table to level 3 table, ‚ÄúStep 3‚Äù from level 3 table to level 2 table, and ‚ÄúStep 4‚Äù from level 2 table to level 1 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, we can follow the recursive entry twice before starting the translation to reduce the number of traversed levels to two:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;recursive-page-table-access-level-2.png&quot; alt=&quot;The same 4-level page hierarchy with the following 4 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúSteps 1&amp;amp;2‚Äù from level 4 table to level 4 table, ‚ÄúStep 3‚Äù from level 4 table to level 3 table, and ‚ÄúStep 4‚Äù from level 3 table to level 2 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs go through it step by step: First, the CPU follows the recursive entry on the level 4 table and thinks that it reaches a level 3 table. Then it follows the recursive entry again and thinks that it reaches a level 2 table. But in reality, it is still on the level 4 table. When the CPU now follows a different entry, it lands on a level 3 table but thinks it is already on a level 1 table. So while the next entry points at a level 2 table, the CPU thinks that it points to the mapped frame, which allows us to read and write the level 2 table.&lt;&#x2F;p&gt;
&lt;p&gt;Accessing the tables of levels 3 and 4 works in the same way. For accessing the level 3 table, we follow the recursive entry three times, tricking the CPU into thinking it is already on a level 1 table. Then we follow another entry and reach a level 3 table, which the CPU treats as a mapped frame. For accessing the level 4 table itself, we just follow the recursive entry four times until the CPU treats the level 4 table itself as mapped frame (in blue in the graphic below).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;recursive-page-table-access-level-3.png&quot; alt=&quot;The same 4-level page hierarchy with the following 3 arrows: ‚ÄúStep 0‚Äù from CR4 to level 4 table, ‚ÄúSteps 1,2,3‚Äù from level 4 table to level 4 table, and ‚ÄúStep 4‚Äù from level 4 table to level 3 table. In blue the alternative ‚ÄúSteps 1,2,3,4‚Äù arrow from level 4 table to level 4 table.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It might take some time to wrap your head around the concept, but it works quite well in practice.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;address-calculation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#address-calculation&quot; aria-label=&quot;Anchor link for: address-calculation&quot;&gt;üîó&lt;&#x2F;a&gt;Address Calculation&lt;&#x2F;h4&gt;
&lt;p&gt;We saw that we can access tables of all levels by following the recursive entry once or multiple times before the actual translation. Since the indexes into the tables of the four levels are derived directly from the virtual address, we need to construct special virtual addresses for this technique. Remember, the page table indexes are derived from the address in the following way:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;..&#x2F;paging-introduction&#x2F;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0‚Äì12 are the page offset, bits 12‚Äì21 the level 1 index, bits 21‚Äì30 the level 2 index, bits 30‚Äì39 the level 3 index, and bits 39‚Äì48 the level 4 index&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs assume that we want to access the level 1 page table that maps a specific page. As we learned above, this means that we have to follow the recursive entry one time before continuing with the level 4, level 3, and level 2 indexes. To do that we move each block of the address one block to the right and set the original level 4 index to the index of the recursive entry:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;table-indices-from-address-recursive-level-1.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 1 table frame, bits 12‚Äì21 the level 2 index, bits 21‚Äì30 the level 3 index, bits 30‚Äì39 the level 4 index, and bits 39‚Äì48 the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For accessing the level 2 table of that page, we move each index block two blocks to the right and set both the blocks of the original level 4 index and the original level 3 index to the index of the recursive entry:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;table-indices-from-address-recursive-level-2.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 2 table frame, bits 12‚Äì21 the level 3 index, bits 21‚Äì30 the level 4 index, and bits 30‚Äì39 and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Accessing the level 3 table works by moving each block three blocks to the right and using the recursive index for the original level 4, level 3, and level 2 address blocks:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;table-indices-from-address-recursive-level-3.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level 3 table frame, bits 12‚Äì21 the level 4 index, and bits 21‚Äì30, bits 30‚Äì39 and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we can access the level 4 table by moving each block four blocks to the right and using the recursive index for all address blocks except for the offset:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;table-indices-from-address-recursive-level-4.svg&quot; alt=&quot;Bits 0‚Äì12 are the offset into the level l table frame and bits 12‚Äì21, bits 21‚Äì30, bits 30‚Äì39 and bits 39‚Äì48 are the index of the recursive entry&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can now calculate virtual addresses for the page tables of all four levels. We can even calculate an address that points exactly to a specific page table entry by multiplying its index by 8, the size of a page table entry.&lt;&#x2F;p&gt;
&lt;p&gt;The table below summarizes the address structure for accessing the different kinds of frames:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Virtual Address for&lt;&#x2F;th&gt;&lt;th&gt;Address Structure (&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Octal&quot;&gt;octal&lt;&#x2F;a&gt;)&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Page&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 1 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 2 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 3 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 4 Table Entry&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Whereas &lt;code&gt;AAA&lt;&#x2F;code&gt; is the level 4 index, &lt;code&gt;BBB&lt;&#x2F;code&gt; the level 3 index, &lt;code&gt;CCC&lt;&#x2F;code&gt; the level 2 index, and &lt;code&gt;DDD&lt;&#x2F;code&gt; the level 1 index of the mapped frame, and &lt;code&gt;EEEE&lt;&#x2F;code&gt; the offset into it. &lt;code&gt;RRR&lt;&#x2F;code&gt; is the index of the recursive entry. When an index (three digits) is transformed to an offset (four digits), it is done by multiplying it by 8 (the size of a page table entry). With this offset, the resulting address directly points to the respective page table entry.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;SSSSSS&lt;&#x2F;code&gt; are sign extension bits, which means that they are all copies of bit 47. This is a special requirement for valid addresses on the x86_64 architecture. We explained it in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#paging-on-x86-64&quot;&gt;previous post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Octal&quot;&gt;octal&lt;&#x2F;a&gt; numbers for representing the addresses since each octal character represents three bits, which allows us to clearly separate the 9-bit indexes of the different page table levels. This isn‚Äôt possible with the hexadecimal system where each character represents four bits.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;After all this theory we can finally start our implementation. Conveniently, the bootloader not only created page tables for our kernel, but it also created a recursive mapping in the last entry of the level 4 table. The bootloader did this because otherwise there would be a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Chicken_or_the_egg&quot;&gt;chicken or egg problem&lt;&#x2F;a&gt;: We need to access the level 4 table to create a recursive mapping, but we can‚Äôt access it without some kind of mapping.&lt;&#x2F;p&gt;
&lt;p&gt;We already used this recursive mapping &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#accessing-the-page-tables&quot;&gt;at the end of the previous post&lt;&#x2F;a&gt; to access the level 4 table. We did this through the hardcoded address &lt;code&gt;0xffff_ffff_ffff_f000&lt;&#x2F;code&gt;. When we convert this address to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Octal&quot;&gt;octal&lt;&#x2F;a&gt; and compare it with the above table, we can see that it exactly follows the structure of a level 4 table entry with &lt;code&gt;RRR&lt;&#x2F;code&gt; = &lt;code&gt;0o777&lt;&#x2F;code&gt;, &lt;code&gt;AAAA&lt;&#x2F;code&gt; = 0, and the sign extension bits set to &lt;code&gt;1&lt;&#x2F;code&gt; each:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;structure: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
&lt;&#x2F;span&gt;&lt;span&gt;address:   0o_177777_777_777_777_777_0000
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With our knowledge about recursive page tables we can now create virtual addresses to access all active page tables. This allows us to create a translation function in software.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;üîó&lt;&#x2F;a&gt;Translating Addresses&lt;&#x2F;h3&gt;
&lt;p&gt;As a first step, let‚Äôs create a function that translates a virtual address to a physical address by walking the page table hierarchy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;memory;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::PhysAddr;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::PageTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns the physical address for the given virtual address, or `None` if the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; virtual address is not mapped.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;translate_addr(addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;PhysAddr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; introduce variables for the recursive index and the sign extension bits
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO: Don&amp;#39;t hardcode these values
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; r = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; recursive index
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; sign = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o177777 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;48&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; sign extension
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; retrieve the page table indices of the address that we want to translate
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l4_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 4 index
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l3_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 3 index
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l2_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 2 index
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; l1_idx = (addr &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; level 1 index
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page_offset = addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o7777&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; calculate the table addresses
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;        sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_3_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;        sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_2_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;        sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l3_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_1_table_addr =
&lt;&#x2F;span&gt;&lt;span&gt;        sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(r &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l4_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l3_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(l2_idx &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; check that level 4 entry is mapped
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*(level_4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2F;span&gt;&lt;span&gt; PageTable) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; level_4_table[l4_idx].addr().is_null() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; check that level 3 entry is mapped
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_3_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*(level_3_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2F;span&gt;&lt;span&gt; PageTable) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; level_3_table[l3_idx].addr().is_null() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; check that level 2 entry is mapped
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_2_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*(level_2_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2F;span&gt;&lt;span&gt; PageTable) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; level_2_table[l2_idx].addr().is_null() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; check that level 1 entry is mapped and retrieve physical address from it
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_1_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*(level_1_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2F;span&gt;&lt;span&gt; PageTable) };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_addr = level_1_table[l1_idx].addr();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; phys_addr.is_null() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Some(phys_addr + page_offset)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we introduce variables for the recursive index (511 = &lt;code&gt;0o777&lt;&#x2F;code&gt;) and the sign extension bits (which are 1 each). Then we calculate the page table indices and the page offset from the address through bitwise operations as specified in the graphic:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;..&#x2F;paging-introduction&#x2F;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0‚Äì12 are the page offset, bits 12‚Äì21 the level 1 index, bits 21‚Äì30 the level 2 index, bits 30‚Äì39 the level 3 index, and bits 39‚Äì48 the level 4 index&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the next step we calculate the virtual addresses of the four page tables as descripbed in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;#address-calculation&quot;&gt;address calculation&lt;&#x2F;a&gt; section. We transform each of these addresses to &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page_table&#x2F;struct.PageTable.html&quot;&gt;&lt;code&gt;PageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; references later in the function. These transformations are &lt;code&gt;unsafe&lt;&#x2F;code&gt; operations since the compiler can‚Äôt know that these addresses are valid.&lt;&#x2F;p&gt;
&lt;p&gt;After the address calculation, we use the indexing operator to look at the entry in the level 4 table. If that entry is null, there is no level 3 table for this level 4 entry, which means that the &lt;code&gt;addr&lt;&#x2F;code&gt; is not mapped to any physical memory, so we return &lt;code&gt;None&lt;&#x2F;code&gt;. If the entry is not &lt;code&gt;None&lt;&#x2F;code&gt;, we know that a level 3 table exists. We then do the same cast and entry-checking as with the level 4 table.&lt;&#x2F;p&gt;
&lt;p&gt;After we checked the three higher level pages, we can finally read the entry of the level 1 table that tells us the physical frame that the address is mapped to. As the last step, we add the page offset to that address and return it.&lt;&#x2F;p&gt;
&lt;p&gt;If we knew that the address is mapped, we could directly access the level 1 table without looking at the higher level pages first. But since we don‚Äôt know this, we have to check whether the level 1 table exists first, otherwise our function would cause a page fault for unmapped addresses.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;üîó&lt;&#x2F;a&gt;Try it out&lt;&#x2F;h4&gt;
&lt;p&gt;We can use our new translation function to translate some virtual addresses in our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize GDT, IDT, PICS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::translate_addr;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addresses = [
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the identity-mapped vga buffer page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some code page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x20010a&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some stack page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x57ac_001f_fe48&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;addresses {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, address, translate_addr(address));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;qemu-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x20010a -&amp;gt; 0x40010a, 0x57ac001ffe48 -&amp;gt; 0x27be48&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, the identity-mapped address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; translates to the same physical address. The code page and the stack page translate to some arbitrary physical addresses, which depend on how the bootloader created the initial mapping for our kernel.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-recursivepagetable-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-recursivepagetable-type&quot; aria-label=&quot;Anchor link for: the-recursivepagetable-type&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; Type&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; provides a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type that implements safe abstractions for various page table operations. The type implements the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.MapperAllSizes.html&quot;&gt;&lt;code&gt;MapperAllSizes&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, which already contains a &lt;code&gt;translate_addr&lt;&#x2F;code&gt; function that we can use instead of hand-rolling our own. To create a new &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt;, we create a &lt;code&gt;memory::init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{VirtAddr, PhysAddr};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Creates a RecursivePageTable instance from the level 4 address.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is unsafe because it can break memory safety if an invalid
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; address is passed.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(level_4_table_addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_ptr = level_4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*level_4_table_ptr;
&lt;&#x2F;span&gt;&lt;span&gt;    RecursivePageTable::new(level_4_table).unwrap()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; type encapsulates the unsafety of the page table walk completely so that we no longer need &lt;code&gt;unsafe&lt;&#x2F;code&gt; to implement our own &lt;code&gt;translate_addr&lt;&#x2F;code&gt; function. The &lt;code&gt;init&lt;&#x2F;code&gt; function needs to be unsafe because the caller has to guarantee that the passed &lt;code&gt;level_4_table_addr&lt;&#x2F;code&gt; is valid.&lt;&#x2F;p&gt;
&lt;p&gt;We can now use the &lt;code&gt;MapperAllSizes::translate_addr&lt;&#x2F;code&gt; function in our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize GDT, IDT, PICS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::{
&lt;&#x2F;span&gt;&lt;span&gt;        structures::paging::MapperAllSizes,
&lt;&#x2F;span&gt;&lt;span&gt;        VirtAddr,
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_177777_777_777_777_777_0000&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addresses = [‚Ä¶]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as before
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;addresses {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; virt_addr = VirtAddr::new(address);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; phys_addr = recursive_page_table.translate_addr(virt_addr);
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, virt_addr, phys_addr);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;u64&lt;&#x2F;code&gt; for all addresses we now use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;struct.PhysAddr.html&quot;&gt;&lt;code&gt;PhysAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper types to differentiate the two kinds of addresses. In order to be able to call the &lt;code&gt;translate_addr&lt;&#x2F;code&gt; method, we need to import the &lt;code&gt;MapperAllSizes&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;p&gt;By using the &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; type, we now have a safe abstraction and clear ownership semantics. This ensures that we can‚Äôt accidentally modify the page table concurrently, because an exclusive borrow of the &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; is needed in order to modify it.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it, we see the same result as with our handcrafted translation function.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;making-unsafe-functions-safer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#making-unsafe-functions-safer&quot; aria-label=&quot;Anchor link for: making-unsafe-functions-safer&quot;&gt;üîó&lt;&#x2F;a&gt;Making Unsafe Functions Safer&lt;&#x2F;h4&gt;
&lt;p&gt;Our &lt;code&gt;memory::init&lt;&#x2F;code&gt; function is an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method&quot;&gt;unsafe function&lt;&#x2F;a&gt;, which means that an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block is required for calling it because the caller has to guarantee that certain requirements are met. In our case, the requirement is that the passed address is mapped to the physical frame of the level 4 page table.&lt;&#x2F;p&gt;
&lt;p&gt;The second property of unsafe functions is that their complete body is treated as an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block, which means that it can perform all kinds of unsafe operations without additional unsafe blocks. This is the reason that we didn‚Äôt need an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block for dereferencing the raw &lt;code&gt;level_4_table_ptr&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(level_4_table_addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_ptr = level_4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*level_4_table_ptr; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; &amp;lt;- this operation is unsafe
&lt;&#x2F;span&gt;&lt;span&gt;    RecursivePageTable::new(level_4_table).unwrap()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem with this is that we don‚Äôt immediately see which parts are unsafe. For example, we don‚Äôt know whether the &lt;code&gt;RecursivePageTable::new&lt;&#x2F;code&gt; function is unsafe or not without looking at &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;struct.RecursivePageTable.html#method.new&quot;&gt;its definition&lt;&#x2F;a&gt;. This makes it very easy to accidentally do something unsafe without noticing.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid this problem, we can add a safe inner function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;init(level_4_table_addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Rust currently treats the whole body of unsafe functions as an unsafe
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; block, which makes it difficult to see which operations are unsafe. To
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; limit the scope of unsafe we use a safe inner function.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;init_inner(level_4_table_addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table_ptr = level_4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; PageTable;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; level_4_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*level_4_table_ptr };
&lt;&#x2F;span&gt;&lt;span&gt;        RecursivePageTable::new(level_4_table).unwrap()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    init_inner(level_4_table_addr)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block is required again for dereferencing the &lt;code&gt;level_4_table_ptr&lt;&#x2F;code&gt; and we immediately see that this is the only unsafe operations in the function. There is currently an open &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2585&quot;&gt;RFC&lt;&#x2F;a&gt; to change this unfortunate property of unsafe functions that would allow us to avoid the above boilerplate.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-a-new-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-new-mapping&quot; aria-label=&quot;Anchor link for: creating-a-new-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a new Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;After reading the page tables and creating a translation function, the next step is to create a new mapping in the page table hierarchy.&lt;&#x2F;p&gt;
&lt;p&gt;The difficulty of creating a new mapping depends on the virtual page that we want to map. In the easiest case, the level 1 page table for the page already exists and we just need to write a single entry. In the most difficult case, the page is in a memory region for that no level 3 exists yet so that we need to create new level 3, level 2 and level 1 page tables first.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs start with the simple case and assume that we don‚Äôt need to create new page tables. The bootloader loads itself in the first megabyte of the virtual address space, so we know that a valid level 1 table exists for this region. We can choose any unused page in this memory region for our example mapping, for example, the page at address &lt;code&gt;0x1000&lt;&#x2F;code&gt;. As the target frame we use &lt;code&gt;0xb8000&lt;&#x2F;code&gt;, the frame of the VGA text buffer. This way we can easily test whether our mapping worked.&lt;&#x2F;p&gt;
&lt;p&gt;We implement it in a new &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function in our &lt;code&gt;memory&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;create_example_mapping(
&lt;&#x2F;span&gt;&lt;span&gt;    recursive_page_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; RecursivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::PageTableFlags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; Flags;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page: Page = Page::containing_address(VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1000&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = PhysFrame::containing_address(PhysAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = Flags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Flags::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; map_to_result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        recursive_page_table.map_to(page, frame, flags, frame_allocator)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    map_to_result.expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_to failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).flush();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function takes a mutable reference to the &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; because it needs to modify it and a &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; that is explained below. It then uses the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait to map the page at address &lt;code&gt;0x1000&lt;&#x2F;code&gt; to the physical frame at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. The function is unsafe because it‚Äôs possible to break memory safety with invalid arguments.&lt;&#x2F;p&gt;
&lt;p&gt;Apart from the &lt;code&gt;page&lt;&#x2F;code&gt; and &lt;code&gt;frame&lt;&#x2F;code&gt; arguments, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function takes two more arguments. The third argument is a set of flags for the page table entry. We set the &lt;code&gt;PRESENT&lt;&#x2F;code&gt; flag because it is required for all valid entries and the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag to make the mapped page writable.&lt;&#x2F;p&gt;
&lt;p&gt;The fourth argument needs to be some structure that implements the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait. The &lt;code&gt;map_to&lt;&#x2F;code&gt; method needs this argument because it might need unused frames for creating new page tables. The &lt;code&gt;Size4KiB&lt;&#x2F;code&gt; argument in the trait implementation is needed because the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;struct.Page.html&quot;&gt;&lt;code&gt;Page&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;frame&#x2F;struct.PhysFrame.html&quot;&gt;&lt;code&gt;PhysFrame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; types are &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-00-generics.html&quot;&gt;generic&lt;&#x2F;a&gt; over the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page&#x2F;trait.PageSize.html&quot;&gt;&lt;code&gt;PageSize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait to work with both standard 4KiB pages and huge 2MiB&#x2F;1GiB pages.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;map_to&lt;&#x2F;code&gt; function can fail, so it returns a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Since this is just some example code that does not need to be robust, we just use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to panic when an error occurs. On success, the function returns a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type that provides an easy way to flush the newly mapped page from the translation lookaside buffer (TLB) with its &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;mapper&#x2F;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method. Like &lt;code&gt;Result&lt;&#x2F;code&gt;, the type uses the [&lt;code&gt;#[must_use]&lt;&#x2F;code&gt;] attribute to emit a warning when we accidentally forget to use it.&lt;&#x2F;p&gt;
&lt;p&gt;[&lt;code&gt;#[must_use]&lt;&#x2F;code&gt;]: https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;result&#x2F;#results-must-be-used&lt;&#x2F;p&gt;
&lt;p&gt;Since we know that no new page tables are required for the address &lt;code&gt;0x1000&lt;&#x2F;code&gt;, a frame allocator that always returns &lt;code&gt;None&lt;&#x2F;code&gt; suffices. We create such an &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt; for testing our mapping function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A FrameAllocator that always returns `None`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EmptyFrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;EmptyFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(If you‚Äôre getting a ‚Äòmethod &lt;code&gt;allocate_frame&lt;&#x2F;code&gt; is not a member of trait &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;‚Äô error, you need to update &lt;code&gt;x86_64&lt;&#x2F;code&gt; to version 0.4.0.)&lt;&#x2F;p&gt;
&lt;p&gt;We can now test the new mapping function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize GDT, IDT, PICS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::memory::{create_example_mapping, EmptyFrameAllocator};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_177777_777_777_777_777_0000&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ memory::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    create_example_mapping(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; EmptyFrameAllocator);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1900 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;).write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2F;span&gt;&lt;span&gt;)};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first create the mapping for the page at &lt;code&gt;0x1000&lt;&#x2F;code&gt; by calling our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function with a mutable reference to the &lt;code&gt;RecursivePageTable&lt;&#x2F;code&gt; instance. This maps the page &lt;code&gt;0x1000&lt;&#x2F;code&gt; to the VGA text buffer, so we should see any write to it on the screen.&lt;&#x2F;p&gt;
&lt;p&gt;Then we write the value &lt;code&gt;0xf021_f077_f065_f04e&lt;&#x2F;code&gt; to this page, which represents the string &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on white background. We don‚Äôt write directly to the beginning of the page at &lt;code&gt;0x1000&lt;&#x2F;code&gt; since the top line is directly shifted off the screen by the next &lt;code&gt;println&lt;&#x2F;code&gt;. Instead, we write to offset &lt;code&gt;0x900&lt;&#x2F;code&gt;, which is about in the middle of the screen. As we learned &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#volatile&quot;&gt;in the &lt;em&gt;‚ÄúVGA Text Mode‚Äù&lt;&#x2F;em&gt; post&lt;&#x2F;a&gt;, writes to the VGA buffer should be volatile, so we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it in QEMU, we see the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;advanced-paging&#x2F;qemu-new-mapping.png&quot; alt=&quot;QEMU printing ‚ÄúIt did not crash!‚Äù with four completely white cells in the middle of the screen&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on the screen is by our write to &lt;code&gt;0x1900&lt;&#x2F;code&gt;, which means that we successfully created a new mapping in the page tables.&lt;&#x2F;p&gt;
&lt;p&gt;This only worked because there was already a level 1 table for mapping page &lt;code&gt;0x1000&lt;&#x2F;code&gt;. When we try to map a page for that no level 1 table exists yet, the &lt;code&gt;map_to&lt;&#x2F;code&gt; function fails because it tries to allocate frames from the &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt; for creating new page tables. We can see that happen when we try to map page &lt;code&gt;0xdeadbeaf000&lt;&#x2F;code&gt; instead of &lt;code&gt;0x1000&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;create_example_mapping(‚Ä¶) {
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page: Page = Page::containing_address(VirtAddr::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf000&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf900 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;).write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2F;span&gt;&lt;span&gt;)};
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, a panic with the following error message occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;panicked at &amp;#39;map_to failed: FrameAllocationFailed&amp;#39;, &#x2F;‚Ä¶&#x2F;result.rs:999:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To map pages that don‚Äôt have a level 1 page table yet we need to create a proper &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;. But how do we know which frames are unused and how much physical memory is available?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boot-information&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#boot-information&quot; aria-label=&quot;Anchor link for: boot-information&quot;&gt;üîó&lt;&#x2F;a&gt;Boot Information&lt;&#x2F;h3&gt;
&lt;p&gt;The amount of physical memory and the memory regions reserved by devices like the VGA hardware vary between different machines. Only the BIOS or UEFI firmware knows exactly which memory regions can be used by the operating system and which regions are reserved. Both firmware standards provide functions to retrieve the memory map, but they can only be called very early in the boot process. For this reason, the bootloader already queries this and other information from the firmware.&lt;&#x2F;p&gt;
&lt;p&gt;To communicate this information to our kernel, the bootloader passes a reference to a boot information structure as an argument when calling our &lt;code&gt;_start&lt;&#x2F;code&gt; function. Right now we don‚Äôt have this argument declared in our function, so it is ignored. Let‚Äôs add it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::bootinfo::BootInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new argument
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.3.11&#x2F;bootloader&#x2F;bootinfo&#x2F;struct.BootInfo.html&quot;&gt;&lt;code&gt;BootInfo&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct is still in an early stage, so expect some breakage when updating to future &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html#caret-requirements&quot;&gt;semver-incompatible&lt;&#x2F;a&gt; bootloader versions. It currently has the three fields &lt;code&gt;p4_table_addr&lt;&#x2F;code&gt;, &lt;code&gt;memory_map&lt;&#x2F;code&gt;, and &lt;code&gt;package&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;p4_table_addr&lt;&#x2F;code&gt; field contains the recursive virtual address of the level 4 page table. By using this field we can avoid hardcoding the address &lt;code&gt;0o_177777_777_777_777_777_0000&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;memory_map&lt;&#x2F;code&gt; field is most interesting to us since it contains a list of all memory regions and their type (i.e. unused, reserved, or other).&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;package&lt;&#x2F;code&gt; field is an in-progress feature to bundle additional data with the bootloader. The implementation is not finished, so we can ignore this field for now.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Before we use the &lt;code&gt;memory_map&lt;&#x2F;code&gt; field to create a proper &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;, we want to ensure that we can‚Äôt use a &lt;code&gt;boot_info&lt;&#x2F;code&gt; argument of the wrong type.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-entry-point-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-entry-point-macro&quot; aria-label=&quot;Anchor link for: the-entry-point-macro&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;entry_point&lt;&#x2F;code&gt; Macro&lt;&#x2F;h4&gt;
&lt;p&gt;Since our &lt;code&gt;_start&lt;&#x2F;code&gt; function is called externally from the bootloader, no checking of our function signature occurs. This means that we could let it take arbitrary arguments without any compilation errors, but it would fail or cause undefined behavior at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;To make sure that the entry point function has always the correct signature that the bootloader expects, the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate provides an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.3.12&#x2F;bootloader&#x2F;macro.entry_point.html&quot;&gt;&lt;code&gt;entry_point&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro that provides a type-checked way to define a Rust function as the entry point. Let‚Äôs rewrite our entry point function to use this macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::{bootinfo::BootInfo, entry_point};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;entry_point!(kernel_main);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize GDT, IDT, PICS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        memory::init(boot_info.p4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create and test example mapping
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We no longer need to use &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2F;code&gt; or &lt;code&gt;no_mangle&lt;&#x2F;code&gt; for our entry point, as the macro defines the real lower level &lt;code&gt;_start&lt;&#x2F;code&gt; entry point for us. The &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function is now a completely normal Rust function, so we can choose an arbitrary name for it. The important thing is that it is type-checked so that a compilation error occurs when we now try to modify the function signature in any way, for example adding an argument or changing the argument type.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we now pass &lt;code&gt;boot_info.p4_table_addr&lt;&#x2F;code&gt; instead of a hardcoded address to our &lt;code&gt;memory::init&lt;&#x2F;code&gt;. Thus our code continues to work even if a future version of the bootloader chooses a different entry of the level 4 page table for the recursive mapping.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocating-frames&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-frames&quot; aria-label=&quot;Anchor link for: allocating-frames&quot;&gt;üîó&lt;&#x2F;a&gt;Allocating Frames&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we have access to the memory map through the boot information we can create a proper frame allocator on top. We start with a generic skeleton:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator&amp;lt;I&amp;gt; where I: Iterator&amp;lt;Item = PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    frames: I,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;I&amp;gt; FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BootInfoFrameAllocator&amp;lt;I&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; I: Iterator&amp;lt;Item = PhysFrame&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        self.frames.next()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;frames&lt;&#x2F;code&gt; field can be initialized with an arbitrary &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; of frames. This allows us to just delegate &lt;code&gt;alloc&lt;&#x2F;code&gt; calls to the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;Iterator::next&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method.&lt;&#x2F;p&gt;
&lt;p&gt;The initialization of the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; happens in a new &lt;code&gt;init_frame_allocator&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bootloader::bootinfo::{MemoryMap, MemoryRegionType};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Create a FrameAllocator from the passed memory map
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_frame_allocator(
&lt;&#x2F;span&gt;&lt;span&gt;    memory_map: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; MemoryMap,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; BootInfoFrameAllocator&amp;lt;impl Iterator&amp;lt;Item = PhysFrame&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; get usable regions from memory map
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; regions = memory_map
&lt;&#x2F;span&gt;&lt;span&gt;        .iter()
&lt;&#x2F;span&gt;&lt;span&gt;        .filter(|r| r.region_type == MemoryRegionType::Usable);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; map each region to its address range
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr_ranges = regions.map(|r| r.range.start_addr()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;r.range.end_addr());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; transform to an iterator of frame start addresses
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create `PhysFrame` types from the start addresses
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frames = frame_addresses.map(|addr| {
&lt;&#x2F;span&gt;&lt;span&gt;        PhysFrame::containing_address(PhysAddr::new(addr))
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    BootInfoFrameAllocator { frames }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function uses iterator combinator methods to transform the initial &lt;code&gt;MemoryMap&lt;&#x2F;code&gt; into an iterator of usable physical frames:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First, we call the &lt;code&gt;iter&lt;&#x2F;code&gt; method to convert the memory map to an iterator of &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bootloader&#x2F;0.3.12&#x2F;bootloader&#x2F;bootinfo&#x2F;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;s. Then we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.filter&quot;&gt;&lt;code&gt;filter&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to skip any reserved or otherwise unavailable regions. The bootloader updates the memory map for all the mappings it creates, so frames that are used by our kernel (code, data or stack) or to store the boot information are already marked as &lt;code&gt;InUse&lt;&#x2F;code&gt; or similar. Thus we can be sure that &lt;code&gt;Usable&lt;&#x2F;code&gt; frames are not used somewhere else.&lt;&#x2F;li&gt;
&lt;li&gt;In the second step, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; combinator and Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;ops&#x2F;struct.Range.html&quot;&gt;range syntax&lt;&#x2F;a&gt; to transform our iterator of memory regions to an iterator of address ranges.&lt;&#x2F;li&gt;
&lt;li&gt;The third step is the most complicated: We convert each range to an iterator through the &lt;code&gt;into_iter&lt;&#x2F;code&gt; method and then choose every 4096th address using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. Since 4096 bytes (= 4 KiB) is the page size, we get the start address of each frame. The bootloader page aligns all usable memory areas so that we don‚Äôt need any alignment or rounding code here. By using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instead of &lt;code&gt;map&lt;&#x2F;code&gt;, we get an &lt;code&gt;Iterator&amp;lt;Item = u64&amp;gt;&lt;&#x2F;code&gt; instead of an &lt;code&gt;Iterator&amp;lt;Item = Iterator&amp;lt;Item = u64&amp;gt;&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;In the final step, we convert the start addresses to &lt;code&gt;PhysFrame&lt;&#x2F;code&gt; types to construct the desired &lt;code&gt;Iterator&amp;lt;Item = PhysFrame&amp;gt;&lt;&#x2F;code&gt;. We then use this iterator to create and return a new &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We can now modify our &lt;code&gt;kernel_main&lt;&#x2F;code&gt; function to pass a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2F;code&gt; instance instead of an &lt;code&gt;EmptyFrameAllocator&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_main(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; BootInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize GDT, IDT, PICS
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::paging::{PageTable, RecursivePageTable};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        memory::init(boot_info.p4_table_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = memory::init_frame_allocator(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;boot_info.memory_map);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::memory::create_example_mapping(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; recursive_page_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf900 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;).write_volatile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2F;span&gt;&lt;span&gt;)};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the mapping succeeds and we see the black-on-white &lt;em&gt;‚ÄúNew!‚Äù&lt;&#x2F;em&gt; on the screen again. Behind the scenes, the &lt;code&gt;map_to&lt;&#x2F;code&gt; method creates the missing page tables in the following way:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Allocate an unused frame from the passed &lt;code&gt;frame_allocator&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Map the entry of the higher level table to that frame. Now the frame is accessible through the recursive page table.&lt;&#x2F;li&gt;
&lt;li&gt;Zero the frame to create a new, empty page table.&lt;&#x2F;li&gt;
&lt;li&gt;Continue with the next table level.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While our &lt;code&gt;create_example_mapping&lt;&#x2F;code&gt; function is just some example code, we are now able to create new mappings for arbitrary pages. This will be essential for allocating memory or implementing multithreading in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned how a recursive level 4 table entry can be used to map all page table frames to calculatable virtual addresses. We used this technique to implement an address translation function and to create a new mapping in the page tables.&lt;&#x2F;p&gt;
&lt;p&gt;We saw that the creation of new mappings requires unused frames for creating new page tables. Such a frame allocator can be implemented on top of the boot information structure that the bootloader passes to our kernel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;allocate memory&lt;&#x2F;a&gt; and use various &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;alloc&#x2F;collections&#x2F;index.html&quot;&gt;collection types&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Introduction to Paging</title>
                <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/paging-introduction/</link>
                <guid>https://os.phil-opp.com/paging-introduction/</guid>
                <description>&lt;p&gt;This post introduces &lt;em&gt;paging&lt;&#x2F;em&gt;, a very common memory management scheme that we will also use for our operating system. It explains why memory isolation is needed, how &lt;em&gt;segmentation&lt;&#x2F;em&gt; works, what &lt;em&gt;virtual memory&lt;&#x2F;em&gt; is, and how paging solves memory fragmentation issues. It also explores the layout of multilevel page tables on the x86_64 architecture.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-08&quot;&gt;&lt;code&gt;post-08&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;memory-protection&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-protection&quot; aria-label=&quot;Anchor link for: memory-protection&quot;&gt;üîó&lt;&#x2F;a&gt;Memory Protection&lt;&#x2F;h2&gt;
&lt;p&gt;One main task of an operating system is to isolate programs from each other. Your web browser shouldn‚Äôt be able to interfere with your text editor, for example. To achieve this goal, operating systems utilize hardware functionality to ensure that memory areas of one process are not accessible by other processes. There are different approaches depending on the hardware and the OS implementation.&lt;&#x2F;p&gt;
&lt;p&gt;As an example, some ARM Cortex-M processors (used for embedded systems) have a &lt;a href=&quot;https:&#x2F;&#x2F;developer.arm.com&#x2F;docs&#x2F;ddi0337&#x2F;e&#x2F;memory-protection-unit&#x2F;about-the-mpu&quot;&gt;&lt;em&gt;Memory Protection Unit&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (MPU), which allows you to define a small number (e.g., 8) of memory regions with different access permissions (e.g., no access, read-only, read-write). On each memory access, the MPU ensures that the address is in a region with correct access permissions and throws an exception otherwise. By changing the regions and access permissions on each process switch, the operating system can ensure that each process only accesses its own memory and thus isolates processes from each other.&lt;&#x2F;p&gt;
&lt;p&gt;On x86, the hardware supports two different approaches to memory protection: &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_memory_segmentation&quot;&gt;segmentation&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Virtual_memory#Paged_virtual_memory&quot;&gt;paging&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;segmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#segmentation&quot; aria-label=&quot;Anchor link for: segmentation&quot;&gt;üîó&lt;&#x2F;a&gt;Segmentation&lt;&#x2F;h2&gt;
&lt;p&gt;Segmentation was already introduced in 1978, originally to increase the amount of addressable memory. The situation back then was that CPUs only used 16-bit addresses, which limited the amount of addressable memory to 64¬†KiB. To make more than these 64¬†KiB accessible, additional segment registers were introduced, each containing an offset address. The CPU automatically added this offset on each memory access, so that up to 1¬†MiB of memory was accessible.&lt;&#x2F;p&gt;
&lt;p&gt;The segment register is chosen automatically by the CPU depending on the kind of memory access: For fetching instructions, the code segment &lt;code&gt;CS&lt;&#x2F;code&gt; is used, and for stack operations (push&#x2F;pop), the stack segment &lt;code&gt;SS&lt;&#x2F;code&gt; is used. Other instructions use the data segment &lt;code&gt;DS&lt;&#x2F;code&gt; or the extra segment &lt;code&gt;ES&lt;&#x2F;code&gt;. Later, two additional segment registers, &lt;code&gt;FS&lt;&#x2F;code&gt; and &lt;code&gt;GS&lt;&#x2F;code&gt;, were added, which can be used freely.&lt;&#x2F;p&gt;
&lt;p&gt;In the first version of segmentation, the segment registers directly contained the offset and no access control was performed. This was changed later with the introduction of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_memory_segmentation#Protected_mode&quot;&gt;&lt;em&gt;protected mode&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. When the CPU runs in this mode, the segment descriptors contain an index into a local or global &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Global_Descriptor_Table&quot;&gt;&lt;em&gt;descriptor table&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, which contains ‚Äì in addition to an offset address ‚Äì the segment size and access permissions. By loading separate global&#x2F;local descriptor tables for each process, which confine memory accesses to the process‚Äôs own memory areas, the OS can isolate processes from each other.&lt;&#x2F;p&gt;
&lt;p&gt;By modifying the memory addresses before the actual access, segmentation already employed a technique that is now used almost everywhere: &lt;em&gt;virtual memory&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;virtual-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#virtual-memory&quot; aria-label=&quot;Anchor link for: virtual-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Virtual Memory&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind virtual memory is to abstract away the memory addresses from the underlying physical storage device. Instead of directly accessing the storage device, a translation step is performed first. For segmentation, the translation step is to add the offset address of the active segment. Imagine a program accessing memory address &lt;code&gt;0x1234000&lt;&#x2F;code&gt; in a segment with an offset of &lt;code&gt;0x1111000&lt;&#x2F;code&gt;: The address that is really accessed is &lt;code&gt;0x2345000&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To differentiate the two address types, addresses before the translation are called &lt;em&gt;virtual&lt;&#x2F;em&gt;, and addresses after the translation are called &lt;em&gt;physical&lt;&#x2F;em&gt;. One important difference between these two kinds of addresses is that physical addresses are unique and always refer to the same distinct memory location. Virtual addresses, on the other hand, depend on the translation function. It is entirely possible that two different virtual addresses refer to the same physical address. Also, identical virtual addresses can refer to different physical addresses when they use different translation functions.&lt;&#x2F;p&gt;
&lt;p&gt;An example where this property is useful is running the same program twice in parallel:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;segmentation-same-program-twice.svg&quot; alt=&quot;Two virtual address spaces with address 0‚Äì150, one translated to 100‚Äì250, the other to 300‚Äì450&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here the same program runs twice, but with different translation functions. The first instance has a segment offset of 100, so that its virtual addresses 0‚Äì150 are translated to the physical addresses 100‚Äì250. The second instance has an offset of 300, which translates its virtual addresses  0‚Äì150 to physical addresses 300‚Äì450. This allows both programs to run the same code and use the same virtual addresses without interfering with each other.&lt;&#x2F;p&gt;
&lt;p&gt;Another advantage is that programs can now be placed at arbitrary physical memory locations, even if they use completely different virtual addresses. Thus, the OS can utilize the full amount of available memory without needing to recompile programs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fragmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fragmentation&quot; aria-label=&quot;Anchor link for: fragmentation&quot;&gt;üîó&lt;&#x2F;a&gt;Fragmentation&lt;&#x2F;h3&gt;
&lt;p&gt;The differentiation between virtual and physical addresses makes segmentation really powerful. However, it has the problem of fragmentation. As an example, imagine that we want to run a third copy of the program we saw above:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;segmentation-fragmentation.svg&quot; alt=&quot;Three virtual address spaces, but there is not enough continuous space for the third&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There is no way to map the third instance of the program to virtual memory without overlapping, even though there is more than enough free memory available. The problem is that we need &lt;em&gt;continuous&lt;&#x2F;em&gt; memory and can‚Äôt use the small free chunks.&lt;&#x2F;p&gt;
&lt;p&gt;One way to combat this fragmentation is to pause execution, move the used parts of the memory closer together, update the translation, and then resume execution:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;segmentation-fragmentation-compacted.svg&quot; alt=&quot;Three virtual address spaces after defragmentation&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now there is enough continuous space to start the third instance of our program.&lt;&#x2F;p&gt;
&lt;p&gt;The disadvantage of this defragmentation process is that it needs to copy large amounts of memory, which decreases performance. It also needs to be done regularly before the memory becomes too fragmented. This makes performance unpredictable since programs are paused at random times and might become unresponsive.&lt;&#x2F;p&gt;
&lt;p&gt;The fragmentation problem is one of the reasons that segmentation is no longer used by most systems. In fact, segmentation is not even supported in 64-bit mode on x86 anymore. Instead, &lt;em&gt;paging&lt;&#x2F;em&gt; is used, which completely avoids the fragmentation problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;üîó&lt;&#x2F;a&gt;Paging&lt;&#x2F;h2&gt;
&lt;p&gt;The idea is to divide both the virtual and physical memory space into small, fixed-size blocks. The blocks of the virtual memory space are called &lt;em&gt;pages&lt;&#x2F;em&gt;, and the blocks of the physical address space are called &lt;em&gt;frames&lt;&#x2F;em&gt;. Each page can be individually mapped to a frame, which makes it possible to split larger memory regions across non-continuous physical frames.&lt;&#x2F;p&gt;
&lt;p&gt;The advantage of this becomes visible if we recap the example of the fragmented memory space, but use paging instead of segmentation this time:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;paging-fragmentation.svg&quot; alt=&quot;With paging, the third program instance can be split across many smaller physical areas.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this example, we have a page size of 50 bytes, which means that each of our memory regions is split across three pages. Each page is mapped to a frame individually, so a continuous virtual memory region can be mapped to non-continuous physical frames. This allows us to start the third instance of the program without performing any defragmentation before.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hidden-fragmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hidden-fragmentation&quot; aria-label=&quot;Anchor link for: hidden-fragmentation&quot;&gt;üîó&lt;&#x2F;a&gt;Hidden Fragmentation&lt;&#x2F;h3&gt;
&lt;p&gt;Compared to segmentation, paging uses lots of small, fixed-sized memory regions instead of a few large, variable-sized regions. Since every frame has the same size, there are no frames that are too small to be used, so no fragmentation occurs.&lt;&#x2F;p&gt;
&lt;p&gt;Or it &lt;em&gt;seems&lt;&#x2F;em&gt; like no fragmentation occurs. There is still some hidden kind of fragmentation, the so-called &lt;em&gt;internal fragmentation&lt;&#x2F;em&gt;. Internal fragmentation occurs because not every memory region is an exact multiple of the page size. Imagine a program of size 101 in the above example: It would still need three pages of size 50, so it would occupy 49 bytes more than needed. To differentiate the two types of fragmentation, the kind of fragmentation that happens when using segmentation is called &lt;em&gt;external fragmentation&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Internal fragmentation is unfortunate but often better than the external fragmentation that occurs with segmentation. It still wastes memory, but does not require defragmentation and makes the amount of fragmentation predictable (on average half a page per memory region).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-tables&quot; aria-label=&quot;Anchor link for: page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;We saw that each of the potentially millions of pages is individually mapped to a frame. This mapping information needs to be stored somewhere. Segmentation uses an individual segment selector register for each active memory region, which is not possible for paging since there are way more pages than registers. Instead, paging uses a table structure called &lt;em&gt;page table&lt;&#x2F;em&gt; to store the mapping information.&lt;&#x2F;p&gt;
&lt;p&gt;For our above example, the page tables would look like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;paging-page-tables.svg&quot; alt=&quot;Three page tables, one for each program instance. For instance 1, the mapping is 0-&amp;gt;100, 50-&amp;gt;150, 100-&amp;gt;200. For instance 2, it is 0-&amp;gt;300, 50-&amp;gt;350, 100-&amp;gt;400. For instance 3, it is 0-&amp;gt;250, 50-&amp;gt;450, 100-&amp;gt;500.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that each program instance has its own page table. A pointer to the currently active table is stored in a special CPU register. On &lt;code&gt;x86&lt;&#x2F;code&gt;, this register is called &lt;code&gt;CR3&lt;&#x2F;code&gt;. It is the job of the operating system to load this register with the pointer to the correct page table before running each program instance.&lt;&#x2F;p&gt;
&lt;p&gt;On each memory access, the CPU reads the table pointer from the register and looks up the mapped frame for the accessed page in the table. This is entirely done in hardware and completely invisible to the running program. To speed up the translation process, many CPU architectures have a special cache that remembers the results of the last translations.&lt;&#x2F;p&gt;
&lt;p&gt;Depending on the architecture, page table entries can also store attributes such as access permissions in a flags field. In the above example, the ‚Äúr&#x2F;w‚Äù flag makes the page both readable and writable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;multilevel-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multilevel-page-tables&quot; aria-label=&quot;Anchor link for: multilevel-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Multilevel Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;The simple page tables we just saw have a problem in larger address spaces: they waste memory. For example, imagine a program that uses the four virtual pages &lt;code&gt;0&lt;&#x2F;code&gt;, &lt;code&gt;1_000_000&lt;&#x2F;code&gt;, &lt;code&gt;1_000_050&lt;&#x2F;code&gt;, and &lt;code&gt;1_000_100&lt;&#x2F;code&gt; (we use &lt;code&gt;_&lt;&#x2F;code&gt; as a thousands separator):&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;single-level-page-table.svg&quot; alt=&quot;Page 0 mapped to frame 0 and pages 1_000_000‚Äì1_000_150 mapped to frames 100‚Äì250&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It only needs 4 physical frames, but the page table has over a million entries. We can‚Äôt omit the empty entries because then the CPU would no longer be able to jump directly to the correct entry in the translation process (e.g., it is no longer guaranteed that the fourth page uses the fourth entry).&lt;&#x2F;p&gt;
&lt;p&gt;To reduce the wasted memory, we can use a &lt;strong&gt;two-level page table&lt;&#x2F;strong&gt;. The idea is that we use different page tables for different address regions. An additional table called &lt;em&gt;level 2&lt;&#x2F;em&gt; page table contains the mapping between address regions and (level 1) page tables.&lt;&#x2F;p&gt;
&lt;p&gt;This is best explained by an example. Let‚Äôs define that each level 1 page table is responsible for a region of size &lt;code&gt;10_000&lt;&#x2F;code&gt;. Then the following tables would exist for the above example mapping:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;multilevel-page-table.svg&quot; alt=&quot;Page 0 points to entry 0 of the level 2 page table, which points to the level 1 page table T1. The first entry of T1 points to frame 0; the other entries are empty. Pages 1_000_000‚Äì1_000_150 point to the 100th entry of the level 2 page table, which points to a different level 1 page table T2. The first three entries of T2 point to frames 100‚Äì250; the other entries are empty.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Page 0 falls into the first &lt;code&gt;10_000&lt;&#x2F;code&gt; byte region, so it uses the first entry of the level 2 page table. This entry points to level 1 page table T1, which specifies that page &lt;code&gt;0&lt;&#x2F;code&gt; points to frame &lt;code&gt;0&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The pages &lt;code&gt;1_000_000&lt;&#x2F;code&gt;, &lt;code&gt;1_000_050&lt;&#x2F;code&gt;, and &lt;code&gt;1_000_100&lt;&#x2F;code&gt; all fall into the 100th &lt;code&gt;10_000&lt;&#x2F;code&gt; byte region, so they use the 100th entry of the level 2 page table. This entry points to a different level 1 page table T2, which maps the three pages to frames &lt;code&gt;100&lt;&#x2F;code&gt;, &lt;code&gt;150&lt;&#x2F;code&gt;, and &lt;code&gt;200&lt;&#x2F;code&gt;. Note that the page address in level 1 tables does not include the region offset. For example, the entry for page &lt;code&gt;1_000_050&lt;&#x2F;code&gt; is just &lt;code&gt;50&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We still have 100 empty entries in the level 2 table, but much fewer than the million empty entries before. The reason for these savings is that we don‚Äôt need to create level 1 page tables for the unmapped memory regions between &lt;code&gt;10_000&lt;&#x2F;code&gt; and &lt;code&gt;1_000_000&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The principle of two-level page tables can be extended to three, four, or more levels. Then the page table register points to the highest level table, which points to the next lower level table, which points to the next lower level, and so on. The level 1 page table then points to the mapped frame. The principle in general is called a &lt;em&gt;multilevel&lt;&#x2F;em&gt; or &lt;em&gt;hierarchical&lt;&#x2F;em&gt; page table.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we know how paging and multilevel page tables work, we can look at how paging is implemented in the x86_64 architecture (we assume in the following that the CPU runs in 64-bit mode).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paging-on-x86-64&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging-on-x86-64&quot; aria-label=&quot;Anchor link for: paging-on-x86-64&quot;&gt;üîó&lt;&#x2F;a&gt;Paging on x86_64&lt;&#x2F;h2&gt;
&lt;p&gt;The x86_64 architecture uses a 4-level page table and a page size of 4¬†KiB. Each page table, independent of the level, has a fixed size of 512 entries. Each entry has a size of 8 bytes, so each table is 512 * 8¬†B = 4¬†KiB large and thus fits exactly into one page.&lt;&#x2F;p&gt;
&lt;p&gt;The page table index for each level is derived directly from the virtual address:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0‚Äì12 are the page offset, bits 12‚Äì21 the level 1 index, bits 21‚Äì30 the level 2 index, bits 30‚Äì39 the level 3 index, and bits 39‚Äì48 the level 4 index&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that each table index consists of 9 bits, which makes sense because each table has 2^9 = 512 entries. The lowest 12 bits are the offset in the 4¬†KiB page (2^12 bytes = 4¬†KiB). Bits 48 to 64 are discarded, which means that x86_64 is not really 64-bit since it only supports 48-bit addresses.&lt;&#x2F;p&gt;
&lt;p&gt;Even though bits 48 to 64 are discarded, they can‚Äôt be set to arbitrary values. Instead, all bits in this range have to be copies of bit 47 in order to keep addresses unique and allow future extensions like the 5-level page table. This is called &lt;em&gt;sign-extension&lt;&#x2F;em&gt; because it‚Äôs very similar to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two&amp;#x27;s_complement#Sign_extension&quot;&gt;sign extension in two‚Äôs complement&lt;&#x2F;a&gt;. When an address is not correctly sign-extended, the CPU throws an exception.&lt;&#x2F;p&gt;
&lt;p&gt;It‚Äôs worth noting that the recent ‚ÄúIce Lake‚Äù Intel CPUs optionally support &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_5-level_paging&quot;&gt;5-level page tables&lt;&#x2F;a&gt; to extend virtual addresses from 48-bit to 57-bit. Given that optimizing our kernel for a specific CPU does not make sense at this stage, we will only work with standard 4-level page tables in this post.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example-translation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-translation&quot; aria-label=&quot;Anchor link for: example-translation&quot;&gt;üîó&lt;&#x2F;a&gt;Example Translation&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs go through an example to understand how the translation process works in detail:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;x86_64-page-table-translation.svg&quot; alt=&quot;An example of a 4-level page hierarchy with each page table shown in physical memory&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The physical address of the currently active level 4 page table, which is the root of the 4-level page table, is stored in the &lt;code&gt;CR3&lt;&#x2F;code&gt; register. Each page table entry then points to the physical frame of the next level table. The entry of the level 1 table then points to the mapped frame. Note that all addresses in the page tables are physical instead of virtual, because otherwise the CPU would need to translate those addresses too (which could cause a never-ending recursion).&lt;&#x2F;p&gt;
&lt;p&gt;The above page table hierarchy maps two pages (in blue). From the page table indices, we can deduce that the virtual addresses of these two pages are &lt;code&gt;0x803FE7F000&lt;&#x2F;code&gt; and &lt;code&gt;0x803FE00000&lt;&#x2F;code&gt;. Let‚Äôs see what happens when the program tries to read from address &lt;code&gt;0x803FE7F5CE&lt;&#x2F;code&gt;. First, we convert the address to binary and determine the page table indices and the page offset for the address:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;x86_64-page-table-translation-addresses.png&quot; alt=&quot;The sign extension bits are all 0, the level 4 index is 1, the level 3 index is 0, the level 2 index is 511, the level 1 index is 127, and the page offset is 0x5ce&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With these indices, we can now walk the page table hierarchy to determine the mapped frame for the address:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We start by reading the address of the level 4 table out of the &lt;code&gt;CR3&lt;&#x2F;code&gt; register.&lt;&#x2F;li&gt;
&lt;li&gt;The level 4 index is 1, so we look at the entry with index 1 of that table, which tells us that the level 3 table is stored at address 16¬†KiB.&lt;&#x2F;li&gt;
&lt;li&gt;We load the level 3 table from that address and look at the entry with index 0, which points us to the level 2 table at 24¬†KiB.&lt;&#x2F;li&gt;
&lt;li&gt;The level 2 index is 511, so we look at the last entry of that page to find out the address of the level 1 table.&lt;&#x2F;li&gt;
&lt;li&gt;Through the entry with index 127 of the level 1 table, we finally find out that the page is mapped to frame 12¬†KiB, or 0x3000 in hexadecimal.&lt;&#x2F;li&gt;
&lt;li&gt;The final step is to add the page offset to the frame address to get the physical address 0x3000 + 0x5ce = 0x35ce.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;x86_64-page-table-translation-steps.svg&quot; alt=&quot;The same example 4-level page hierarchy with 5 additional arrows: ‚ÄúStep 0‚Äù from the CR3 register to the level 4 table, ‚ÄúStep 1‚Äù from the level 4 entry to the level 3 table, ‚ÄúStep 2‚Äù from the level 3 entry to the level 2 table, ‚ÄúStep 3‚Äù from the level 2 entry to the level 1 table, and ‚ÄúStep 4‚Äù from the level 1 table to the mapped frames.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The permissions for the page in the level 1 table are &lt;code&gt;r&lt;&#x2F;code&gt;, which means read-only. The hardware enforces these permissions and would throw an exception if we tried to write to that page. Permissions in higher level pages restrict the possible permissions in lower levels, so if we set the level 3 entry to read-only, no pages that use this entry can be writable, even if lower levels specify read&#x2F;write permissions.&lt;&#x2F;p&gt;
&lt;p&gt;It‚Äôs important to note that even though this example used only a single instance of each table, there are typically multiple instances of each level in each address space. At maximum, there are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;one level 4 table,&lt;&#x2F;li&gt;
&lt;li&gt;512 level 3 tables (because the level 4 table has 512 entries),&lt;&#x2F;li&gt;
&lt;li&gt;512 * 512 level 2 tables (because each of the 512 level 3 tables has 512 entries), and&lt;&#x2F;li&gt;
&lt;li&gt;512 * 512 * 512 level 1 tables (512 entries for each level 2 table).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;page-table-format&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-format&quot; aria-label=&quot;Anchor link for: page-table-format&quot;&gt;üîó&lt;&#x2F;a&gt;Page Table Format&lt;&#x2F;h3&gt;
&lt;p&gt;Page tables on the x86_64 architecture are basically an array of 512 entries. In Rust syntax:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[repr(align(4096))]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    entries: [PageTableEntry; 512],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As indicated by the &lt;code&gt;repr&lt;&#x2F;code&gt; attribute, page tables need to be page-aligned, i.e., aligned on a 4¬†KiB boundary. This requirement guarantees that a page table always fills a complete page and allows an optimization that makes entries very compact.&lt;&#x2F;p&gt;
&lt;p&gt;Each entry is 8 bytes (64 bits) large and has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;present&lt;&#x2F;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;writable&lt;&#x2F;td&gt;&lt;td&gt;it‚Äôs allowed to write to this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;user accessible&lt;&#x2F;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;write-through caching&lt;&#x2F;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;disable cache&lt;&#x2F;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;accessed&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;dirty&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;huge page&#x2F;null&lt;&#x2F;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1¬†GiB page in P3, creates a 2¬†MiB page in P2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;global&lt;&#x2F;td&gt;&lt;td&gt;page isn‚Äôt flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12-51&lt;&#x2F;td&gt;&lt;td&gt;physical address&lt;&#x2F;td&gt;&lt;td&gt;the page aligned 52bit physical address of the frame or the next page table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;63&lt;&#x2F;td&gt;&lt;td&gt;no execute&lt;&#x2F;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;We see that only bits 12‚Äì51 are used to store the physical frame address. The remaining bits are used as flags or can be freely used by the operating system. This is possible because we always point to a 4096-byte aligned address, either to a page-aligned page table or to the start of a mapped frame. This means that bits 0‚Äì11 are always zero, so there is no reason to store these bits because the hardware can just set them to zero before using the address. The same is true for bits 52‚Äì63, because the x86_64 architecture only supports 52-bit physical addresses (similar to how it only supports 48-bit virtual addresses).&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs take a closer look at the available flags:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;present&lt;&#x2F;code&gt; flag differentiates mapped pages from unmapped ones. It can be used to temporarily swap out pages to disk when the main memory becomes full. When the page is accessed subsequently, a special exception called &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs, to which the operating system can react by reloading the missing page from disk and then continuing the program.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;writable&lt;&#x2F;code&gt; and &lt;code&gt;no execute&lt;&#x2F;code&gt; flags control whether the contents of the page are writable or contain executable instructions, respectively.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;accessed&lt;&#x2F;code&gt; and &lt;code&gt;dirty&lt;&#x2F;code&gt; flags are automatically set by the CPU when a read or write to the page occurs. This information can be leveraged by the operating system, e.g., to decide which pages to swap out or whether the page contents have been modified since the last save to disk.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;write-through caching&lt;&#x2F;code&gt; and &lt;code&gt;disable cache&lt;&#x2F;code&gt; flags allow the control of caches for every page individually.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;user accessible&lt;&#x2F;code&gt; flag makes a page available to userspace code, otherwise, it is only accessible when the CPU is in kernel mode. This feature can be used to make &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;System_call&quot;&gt;system calls&lt;&#x2F;a&gt; faster by keeping the kernel mapped while a userspace program is running. However, the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spectre_(security_vulnerability)&quot;&gt;Spectre&lt;&#x2F;a&gt; vulnerability can allow userspace programs to read these pages nonetheless.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;global&lt;&#x2F;code&gt; flag signals to the hardware that a page is available in all address spaces and thus does not need to be removed from the translation cache (see the section about the TLB below) on address space switches. This flag is commonly used together with a cleared &lt;code&gt;user accessible&lt;&#x2F;code&gt; flag to map the kernel code to all address spaces.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;huge page&lt;&#x2F;code&gt; flag allows the creation of pages of larger sizes by letting the entries of the level 2 or level 3 page tables directly point to a mapped frame. With this bit set, the page size increases by factor 512 to either 2¬†MiB = 512 * 4¬†KiB for level 2 entries or even 1¬†GiB = 512 * 2¬†MiB for level 3 entries. The advantage of using larger pages is that fewer lines of the translation cache and fewer page tables are needed.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides types for &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page_table&#x2F;struct.PageTable.html&quot;&gt;page tables&lt;&#x2F;a&gt; and their &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;page_table&#x2F;struct.PageTableEntry.html&quot;&gt;entries&lt;&#x2F;a&gt;, so we don‚Äôt need to create these structures ourselves.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-translation-lookaside-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-translation-lookaside-buffer&quot; aria-label=&quot;Anchor link for: the-translation-lookaside-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;The Translation Lookaside Buffer&lt;&#x2F;h3&gt;
&lt;p&gt;A 4-level page table makes the translation of virtual addresses expensive because each translation requires four memory accesses. To improve performance, the x86_64 architecture caches the last few translations in the so-called &lt;em&gt;translation lookaside buffer&lt;&#x2F;em&gt; (TLB). This allows skipping the translation when it is still cached.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike the other CPU caches, the TLB is not fully transparent and does not update or remove translations when the contents of page tables change. This means that the kernel must manually update the TLB whenever it modifies a page table. To do this, there is a special CPU instruction called &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;INVLPG.html&quot;&gt;&lt;code&gt;invlpg&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (‚Äúinvalidate page‚Äù) that removes the translation for the specified page from the TLB, so that it is loaded again from the page table on the next access. The TLB can also be flushed completely by reloading the &lt;code&gt;CR3&lt;&#x2F;code&gt; register, which simulates an address space switch. The &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides Rust functions for both variants in the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;tlb&#x2F;index.html&quot;&gt;&lt;code&gt;tlb&lt;&#x2F;code&gt; module&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It is important to remember to flush the TLB on each page table modification because otherwise, the CPU might keep using the old translation, which can lead to non-deterministic bugs that are very hard to debug.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;One thing that we did not mention yet: &lt;strong&gt;Our kernel already runs on paging&lt;&#x2F;strong&gt;. The bootloader that we added in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#creating-a-bootimage&quot;&gt;‚ÄúA minimal Rust Kernel‚Äù&lt;&#x2F;a&gt; post has already set up a 4-level paging hierarchy that maps every page of our kernel to a physical frame. The bootloader does this because paging is mandatory in 64-bit mode on x86_64.&lt;&#x2F;p&gt;
&lt;p&gt;This means that every memory address that we used in our kernel was a virtual address. Accessing the VGA buffer at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; only worked because the bootloader &lt;em&gt;identity mapped&lt;&#x2F;em&gt; that memory page, which means that it mapped the virtual page &lt;code&gt;0xb8000&lt;&#x2F;code&gt; to the physical frame &lt;code&gt;0xb8000&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Paging makes our kernel already relatively safe, since every memory access that is out of bounds causes a page fault exception instead of writing to random physical memory. The bootloader even sets the correct access permissions for each page, which means that only the pages containing code are executable and only data pages are writable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-faults&quot; aria-label=&quot;Anchor link for: page-faults&quot;&gt;üîó&lt;&#x2F;a&gt;Page Faults&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs try to cause a page fault by accessing some memory outside of our kernel. First, we create a page fault handler and register it in our IDT, so that we see a page fault exception instead of a generic &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-fault-exceptions&#x2F;&quot;&gt;double fault&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt.page_fault.set_handler_fn(page_fault_handler); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::PageFaultErrorCode;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::hlt_loop;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;page_fault_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    stack_frame: InterruptStackFrame,
&lt;&#x2F;span&gt;&lt;span&gt;    error_code: PageFaultErrorCode,
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control::Cr2;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: PAGE FAULT&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Accessed Address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Cr2::read());
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error Code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, error_code);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;    hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control_register#CR2&quot;&gt;&lt;code&gt;CR2&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; register is automatically set by the CPU on a page fault and contains the accessed virtual address that caused the page fault. We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;registers&#x2F;control&#x2F;struct.Cr2.html#method.read&quot;&gt;&lt;code&gt;Cr2::read&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate to read and print it. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.PageFaultErrorCode.html&quot;&gt;&lt;code&gt;PageFaultErrorCode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type provides more information about the type of memory access that caused the page fault, for example, whether it was caused by a read or write operation. For this reason, we print it too. We can‚Äôt continue execution without resolving the page fault, so we enter a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;#the-hlt-instruction&quot;&gt;&lt;code&gt;hlt_loop&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; at the end.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can try to access some memory outside our kernel:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as before
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, we see that our page fault handler is called:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;qemu-page-fault.png&quot; alt=&quot;EXCEPTION: Page Fault, Accessed Address: VirtAddr(0xdeadbeaf), Error Code: CAUSED_BY_WRITE, InterruptStackFrame: {‚Ä¶}&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;CR2&lt;&#x2F;code&gt; register indeed contains &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;, the address that we tried to access. The error code tells us through the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.PageFaultErrorCode.html#associatedconstant.CAUSED_BY_WRITE&quot;&gt;&lt;code&gt;CAUSED_BY_WRITE&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; that the fault occurred while trying to perform a write operation. It tells us even more through the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.PageFaultErrorCode.html&quot;&gt;bits that are &lt;em&gt;not&lt;&#x2F;em&gt; set&lt;&#x2F;a&gt;. For example, the fact that the &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2F;code&gt; flag is not set means that the page fault occurred because the target page wasn‚Äôt present.&lt;&#x2F;p&gt;
&lt;p&gt;We see that the current instruction pointer is &lt;code&gt;0x2031b2&lt;&#x2F;code&gt;, so we know that this address points to a code page. Code pages are mapped read-only by the bootloader, so reading from this address works but writing causes a page fault. You can try this by changing the &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt; pointer to &lt;code&gt;0x2031b2&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Note: The actual address might be different for you. Use the address that
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; your page fault handler reports.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x2031b2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; read from a code page
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = *ptr; }
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;read worked&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; write to a code page
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *ptr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;write worked&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By commenting out the last line, we see that the read access works, but the write access causes a page fault:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;paging-introduction&#x2F;qemu-page-fault-protection.png&quot; alt=&quot;QEMU with output: ‚Äúread worked, EXCEPTION: Page Fault, Accessed Address: VirtAddr(0x2031b2), Error Code: PROTECTION_VIOLATION | CAUSED_BY_WRITE, InterruptStackFrame: {‚Ä¶}‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that the &lt;em&gt;‚Äúread worked‚Äù&lt;&#x2F;em&gt; message is printed, which indicates that the read operation did not cause any errors. However, instead of the &lt;em&gt;‚Äúwrite worked‚Äù&lt;&#x2F;em&gt; message, a page fault occurs. This time the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.PageFaultErrorCode.html#associatedconstant.PROTECTION_VIOLATION&quot;&gt;&lt;code&gt;PROTECTION_VIOLATION&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; flag is set in addition to the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.PageFaultErrorCode.html#associatedconstant.CAUSED_BY_WRITE&quot;&gt;&lt;code&gt;CAUSED_BY_WRITE&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; flag, which indicates that the page was present, but the operation was not allowed on it. In this case, writes to the page are not allowed since code pages are mapped as read-only.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;accessing-the-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-the-page-tables&quot; aria-label=&quot;Anchor link for: accessing-the-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Accessing the Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs try to take a look at the page tables that define how our kernel is mapped:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control::Cr3;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(level_4_page_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) = Cr3::read();
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Level 4 page table at: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, level_4_page_table.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test_main(), println(‚Ä¶), and hlt_loop()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;registers&#x2F;control&#x2F;struct.Cr3.html#method.read&quot;&gt;&lt;code&gt;Cr3::read&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; returns the currently active level 4 page table from the &lt;code&gt;CR3&lt;&#x2F;code&gt; register. It returns a tuple of a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;paging&#x2F;frame&#x2F;struct.PhysFrame.html&quot;&gt;&lt;code&gt;PhysFrame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;registers&#x2F;control&#x2F;struct.Cr3Flags.html&quot;&gt;&lt;code&gt;Cr3Flags&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type. We are only interested in the frame, so we ignore the second element of the tuple.&lt;&#x2F;p&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;Level 4 page table at: PhysAddr(0x1000)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the currently active level 4 page table is stored at address &lt;code&gt;0x1000&lt;&#x2F;code&gt; in &lt;em&gt;physical&lt;&#x2F;em&gt; memory, as indicated by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;addr&#x2F;struct.PhysAddr.html&quot;&gt;&lt;code&gt;PhysAddr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; wrapper type. The question now is: how can we access this table from our kernel?&lt;&#x2F;p&gt;
&lt;p&gt;Accessing physical memory directly is not possible when paging is active, since programs could easily circumvent memory protection and access the memory of other programs otherwise. So the only way to access the table is through some virtual page that is mapped to the physical frame at address &lt;code&gt;0x1000&lt;&#x2F;code&gt;. This problem of creating mappings for page table frames is a general problem since the kernel needs to access the page tables regularly, for example, when allocating a stack for a new thread.&lt;&#x2F;p&gt;
&lt;p&gt;Solutions to this problem are explained in detail in the next post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post introduced two memory protection techniques: segmentation and paging. While the former uses variable-sized memory regions and suffers from external fragmentation, the latter uses fixed-sized pages and allows much more fine-grained control over access permissions.&lt;&#x2F;p&gt;
&lt;p&gt;Paging stores the mapping information for pages in page tables with one or more levels. The x86_64 architecture uses 4-level page tables and a page size of 4¬†KiB. The hardware automatically walks the page tables and caches the resulting translations in the translation lookaside buffer (TLB). This buffer is not updated transparently and needs to be flushed manually on page table changes.&lt;&#x2F;p&gt;
&lt;p&gt;We learned that our kernel already runs on top of paging and that illegal memory accesses cause page fault exceptions. We tried to access the currently active page tables, but we weren‚Äôt able to do it because the CR3 register stores a physical address that we can‚Äôt access directly from our kernel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how to implement support for paging in our kernel. It presents different ways to access physical memory from our kernel, which makes it possible to access the page tables that our kernel runs on. At this point, we are able to implement functions for translating virtual to physical addresses and for creating new mappings in the page tables.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Hardware Interrupts</title>
                <pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/hardware-interrupts/</link>
                <guid>https://os.phil-opp.com/hardware-interrupts/</guid>
                <description>&lt;p&gt;In this post, we set up the programmable interrupt controller to correctly forward hardware interrupts to the CPU. To handle these interrupts, we add new entries to our interrupt descriptor table, just like we did for our exception handlers. We will learn how to get periodic timer interrupts and how to get input from the keyboard.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-07&quot;&gt;&lt;code&gt;post-07&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;üîó&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;Interrupts provide a way to notify the CPU from attached hardware devices. So instead of letting the kernel periodically check the keyboard for new characters (a process called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Polling_(computer_science)&quot;&gt;&lt;em&gt;polling&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;), the keyboard can notify the kernel of each keypress. This is much more efficient because the kernel only needs to act when something happened. It also allows faster reaction times since the kernel can react immediately and not only at the next poll.&lt;&#x2F;p&gt;
&lt;p&gt;Connecting all hardware devices directly to the CPU is not possible. Instead, a separate &lt;em&gt;interrupt controller&lt;&#x2F;em&gt; aggregates the interrupts from all devices and then notifies the CPU:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;                                    ____________             _____
&lt;&#x2F;span&gt;&lt;span&gt;               Timer ------------&amp;gt; |            |           |     |
&lt;&#x2F;span&gt;&lt;span&gt;               Keyboard ---------&amp;gt; | Interrupt  |---------&amp;gt; | CPU |
&lt;&#x2F;span&gt;&lt;span&gt;               Other Hardware ---&amp;gt; | Controller |           |_____|
&lt;&#x2F;span&gt;&lt;span&gt;               Etc. -------------&amp;gt; |____________|
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most interrupt controllers are programmable, which means they support different priority levels for interrupts. For example, this allows to give timer interrupts a higher priority than keyboard interrupts to ensure accurate timekeeping.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike exceptions, hardware interrupts occur &lt;em&gt;asynchronously&lt;&#x2F;em&gt;. This means they are completely independent from the executed code and can occur at any time. Thus, we suddenly have a form of concurrency in our kernel with all the potential concurrency-related bugs. Rust‚Äôs strict ownership model helps us here because it forbids mutable global state. However, deadlocks are still possible, as we will see later in this post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-8259-pic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-8259-pic&quot; aria-label=&quot;Anchor link for: the-8259-pic&quot;&gt;üîó&lt;&#x2F;a&gt;The 8259 PIC&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8259&quot;&gt;Intel 8259&lt;&#x2F;a&gt; is a programmable interrupt controller (PIC) introduced in 1976. It has long been replaced by the newer &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_APIC_Architecture&quot;&gt;APIC&lt;&#x2F;a&gt;, but its interface is still supported on current systems for backwards compatibility reasons. The 8259 PIC is significantly easier to set up than the APIC, so we will use it to introduce ourselves to interrupts before we switch to the APIC in a later post.&lt;&#x2F;p&gt;
&lt;p&gt;The 8259 has eight interrupt lines and several lines for communicating with the CPU. The typical systems back then were equipped with two instances of the 8259 PIC, one primary and one secondary PIC, connected to one of the interrupt lines of the primary:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;                     ____________                          ____________
&lt;&#x2F;span&gt;&lt;span&gt;Real Time Clock --&amp;gt; |            |   Timer -------------&amp;gt; |            |
&lt;&#x2F;span&gt;&lt;span&gt;ACPI -------------&amp;gt; |            |   Keyboard-----------&amp;gt; |            |      _____
&lt;&#x2F;span&gt;&lt;span&gt;Available --------&amp;gt; | Secondary  |----------------------&amp;gt; | Primary    |     |     |
&lt;&#x2F;span&gt;&lt;span&gt;Available --------&amp;gt; | Interrupt  |   Serial Port 2 -----&amp;gt; | Interrupt  |---&amp;gt; | CPU |
&lt;&#x2F;span&gt;&lt;span&gt;Mouse ------------&amp;gt; | Controller |   Serial Port 1 -----&amp;gt; | Controller |     |_____|
&lt;&#x2F;span&gt;&lt;span&gt;Co-Processor -----&amp;gt; |            |   Parallel Port 2&#x2F;3 -&amp;gt; |            |
&lt;&#x2F;span&gt;&lt;span&gt;Primary ATA ------&amp;gt; |            |   Floppy disk -------&amp;gt; |            |
&lt;&#x2F;span&gt;&lt;span&gt;Secondary ATA ----&amp;gt; |____________|   Parallel Port 1----&amp;gt; |____________|
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This graphic shows the typical assignment of interrupt lines. We see that most of the 15 lines have a fixed mapping, e.g., line 4 of the secondary PIC is assigned to the mouse.&lt;&#x2F;p&gt;
&lt;p&gt;Each controller can be configured through two &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;#i-o-ports&quot;&gt;I&#x2F;O ports&lt;&#x2F;a&gt;, one ‚Äúcommand‚Äù port and one ‚Äúdata‚Äù port. For the primary controller, these ports are &lt;code&gt;0x20&lt;&#x2F;code&gt; (command) and &lt;code&gt;0x21&lt;&#x2F;code&gt; (data). For the secondary controller, they are &lt;code&gt;0xa0&lt;&#x2F;code&gt; (command) and &lt;code&gt;0xa1&lt;&#x2F;code&gt; (data). For more information on how the PICs can be configured, see the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;8259_PIC&quot;&gt;article on osdev.org&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;The default configuration of the PICs is not usable because it sends interrupt vector numbers in the range of 0‚Äì15 to the CPU. These numbers are already occupied by CPU exceptions. For example, number 8 corresponds to a double fault. To fix this overlapping issue, we need to remap the PIC interrupts to different numbers. The actual range doesn‚Äôt matter as long as it does not overlap with the exceptions, but typically the range of 32‚Äì47 is chosen, because these are the first free numbers after the 32 exception slots.&lt;&#x2F;p&gt;
&lt;p&gt;The configuration happens by writing special values to the command and data ports of the PICs. Fortunately, there is already a crate called &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pic8259&#x2F;0.10.1&#x2F;pic8259&#x2F;&quot;&gt;&lt;code&gt;pic8259&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, so we don‚Äôt need to write the initialization sequence ourselves. However, if you are interested in how it works, check out &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crate&#x2F;pic8259&#x2F;0.10.1&#x2F;source&#x2F;src&#x2F;lib.rs&quot;&gt;its source code&lt;&#x2F;a&gt;. It‚Äôs fairly small and well documented.&lt;&#x2F;p&gt;
&lt;p&gt;To add the crate as a dependency, we add the following to our project:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pic8259 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.10.1&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The main abstraction provided by the crate is the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pic8259&#x2F;0.10.1&#x2F;pic8259&#x2F;struct.ChainedPics.html&quot;&gt;&lt;code&gt;ChainedPics&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct that represents the primary&#x2F;secondary PIC layout we saw above. It is designed to be used in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;pic8259::ChainedPics;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use&lt;&#x2F;span&gt;&lt;span&gt; spin;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_2_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;: spin::Mutex&amp;lt;ChainedPics&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;    spin::Mutex::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ChainedPics::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_2_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;) });
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As noted above, we‚Äôre setting the offsets for the PICs to the range 32‚Äì47. By wrapping the &lt;code&gt;ChainedPics&lt;&#x2F;code&gt; struct in a &lt;code&gt;Mutex&lt;&#x2F;code&gt;, we can get safe mutable access (through the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.5.2&#x2F;spin&#x2F;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;lock&lt;&#x2F;code&gt; method&lt;&#x2F;a&gt;), which we need in the next step. The &lt;code&gt;ChainedPics::new&lt;&#x2F;code&gt; function is unsafe because wrong offsets could cause undefined behavior.&lt;&#x2F;p&gt;
&lt;p&gt;We can now initialize the 8259 PIC in our &lt;code&gt;init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    gdt::init();
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init_idt();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ interrupts::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock().initialize() }; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pic8259&#x2F;0.10.1&#x2F;pic8259&#x2F;struct.ChainedPics.html#method.initialize&quot;&gt;&lt;code&gt;initialize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function to perform the PIC initialization. Like the &lt;code&gt;ChainedPics::new&lt;&#x2F;code&gt; function, this function is also unsafe because it can cause undefined behavior if the PIC is misconfigured.&lt;&#x2F;p&gt;
&lt;p&gt;If all goes well, we should continue to see the ‚ÄúIt did not crash‚Äù message when executing &lt;code&gt;cargo run&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;enabling-interrupts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#enabling-interrupts&quot; aria-label=&quot;Anchor link for: enabling-interrupts&quot;&gt;üîó&lt;&#x2F;a&gt;Enabling Interrupts&lt;&#x2F;h2&gt;
&lt;p&gt;Until now, nothing happened because interrupts are still disabled in the CPU configuration. This means that the CPU does not listen to the interrupt controller at all, so no interrupts can reach the CPU. Let‚Äôs change that:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    gdt::init();
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init_idt();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ interrupts::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock().initialize() };
&lt;&#x2F;span&gt;&lt;span&gt;    x86_64::instructions::interrupts::enable();     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;interrupts::enable&lt;&#x2F;code&gt; function of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate executes the special &lt;code&gt;sti&lt;&#x2F;code&gt; instruction (‚Äúset interrupts‚Äù) to enable external interrupts. When we try &lt;code&gt;cargo run&lt;&#x2F;code&gt; now, we see that a double fault occurs:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-hardware-timer-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT because of hardware timer&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The reason for this double fault is that the hardware timer (the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8253&quot;&gt;Intel 8253&lt;&#x2F;a&gt;, to be exact) is enabled by default, so we start receiving timer interrupts as soon as we enable interrupts. Since we didn‚Äôt define a handler function for it yet, our double fault handler is invoked.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handling-timer-interrupts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-timer-interrupts&quot; aria-label=&quot;Anchor link for: handling-timer-interrupts&quot;&gt;üîó&lt;&#x2F;a&gt;Handling Timer Interrupts&lt;&#x2F;h2&gt;
&lt;p&gt;As we see from the graphic &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;#the-8259-pic&quot;&gt;above&lt;&#x2F;a&gt;, the timer uses line 0 of the primary PIC. This means that it arrives at the CPU as interrupt 32 (0 + offset 32). Instead of hardcoding index 32, we store it in an &lt;code&gt;InterruptIndex&lt;&#x2F;code&gt; enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u8)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;InterruptIndex {
&lt;&#x2F;span&gt;&lt;span&gt;    Timer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;InterruptIndex {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;as_u8(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;as_usize(self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;::from(self.as_u8())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The enum is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;items&#x2F;enumerations.html#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;C-like enum&lt;&#x2F;a&gt; so that we can directly specify the index for each variant. The &lt;code&gt;repr(u8)&lt;&#x2F;code&gt; attribute specifies that each variant is represented as a &lt;code&gt;u8&lt;&#x2F;code&gt;. We will add more variants for other interrupts in the future.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can add a handler function for the timer interrupt:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::print;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;        idt[InterruptIndex::Timer.as_usize()]
&lt;&#x2F;span&gt;&lt;span&gt;            .set_handler_fn(timer_interrupt_handler); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;timer_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;.&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our &lt;code&gt;timer_interrupt_handler&lt;&#x2F;code&gt; has the same signature as our exception handlers, because the CPU reacts identically to exceptions and external interrupts (the only difference is that some exceptions push an error code). The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;ops&#x2F;trait.IndexMut.html&quot;&gt;&lt;code&gt;IndexMut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, so we can access individual entries through array indexing syntax.&lt;&#x2F;p&gt;
&lt;p&gt;In our timer interrupt handler, we print a dot to the screen. As the timer interrupt happens periodically, we would expect to see a dot appearing on each timer tick. However, when we run it, we see that only a single dot is printed:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-single-dot-printed.png&quot; alt=&quot;QEMU printing only a single dot for hardware timer&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;end-of-interrupt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#end-of-interrupt&quot; aria-label=&quot;Anchor link for: end-of-interrupt&quot;&gt;üîó&lt;&#x2F;a&gt;End of Interrupt&lt;&#x2F;h3&gt;
&lt;p&gt;The reason is that the PIC expects an explicit ‚Äúend of interrupt‚Äù (EOI) signal from our interrupt handler. This signal tells the controller that the interrupt was processed and that the system is ready to receive the next interrupt. So the PIC thinks we‚Äôre still busy processing the first timer interrupt and waits patiently for the EOI signal before sending the next one.&lt;&#x2F;p&gt;
&lt;p&gt;To send the EOI, we use our static &lt;code&gt;PICS&lt;&#x2F;code&gt; struct again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;timer_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;.&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;notify_end_of_interrupt&lt;&#x2F;code&gt; figures out whether the primary or secondary PIC sent the interrupt and then uses the &lt;code&gt;command&lt;&#x2F;code&gt; and &lt;code&gt;data&lt;&#x2F;code&gt; ports to send an EOI signal to the respective controllers. If the secondary PIC sent the interrupt, both PICs need to be notified because the secondary PIC is connected to an input line of the primary PIC.&lt;&#x2F;p&gt;
&lt;p&gt;We need to be careful to use the correct interrupt vector number, otherwise we could accidentally delete an important unsent interrupt or cause our system to hang. This is the reason that the function is unsafe.&lt;&#x2F;p&gt;
&lt;p&gt;When we now execute &lt;code&gt;cargo run&lt;&#x2F;code&gt; we see dots periodically appearing on the screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-hardware-timer-dots.gif&quot; alt=&quot;QEMU printing consecutive dots showing the hardware timer&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;configuring-the-timer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#configuring-the-timer&quot; aria-label=&quot;Anchor link for: configuring-the-timer&quot;&gt;üîó&lt;&#x2F;a&gt;Configuring the Timer&lt;&#x2F;h3&gt;
&lt;p&gt;The hardware timer that we use is called the &lt;em&gt;Programmable Interval Timer&lt;&#x2F;em&gt;, or PIT, for short. Like the name says, it is possible to configure the interval between two interrupts. We won‚Äôt go into details here because we will switch to the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;APIC_timer&quot;&gt;APIC timer&lt;&#x2F;a&gt; soon, but the OSDev wiki has an extensive article about the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Programmable_Interval_Timer&quot;&gt;configuring the PIT&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;deadlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deadlocks&quot; aria-label=&quot;Anchor link for: deadlocks&quot;&gt;üîó&lt;&#x2F;a&gt;Deadlocks&lt;&#x2F;h2&gt;
&lt;p&gt;We now have a form of concurrency in our kernel: The timer interrupts occur asynchronously, so they can interrupt our &lt;code&gt;_start&lt;&#x2F;code&gt; function at any time. Fortunately, Rust‚Äôs ownership system prevents many types of concurrency-related bugs at compile time. One notable exception is deadlocks. Deadlocks occur if a thread tries to acquire a lock that will never become free. Thus, the thread hangs indefinitely.&lt;&#x2F;p&gt;
&lt;p&gt;We can already provoke a deadlock in our kernel. Remember, our &lt;code&gt;println&lt;&#x2F;code&gt; macro calls the &lt;code&gt;vga_buffer::_print&lt;&#x2F;code&gt; function, which &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#spinlocks&quot;&gt;locks a global &lt;code&gt;WRITER&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; using a spinlock:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It locks the &lt;code&gt;WRITER&lt;&#x2F;code&gt;, calls &lt;code&gt;write_fmt&lt;&#x2F;code&gt; on it, and implicitly unlocks it at the end of the function. Now imagine that an interrupt occurs while the &lt;code&gt;WRITER&lt;&#x2F;code&gt; is locked and the interrupt handler tries to print something too:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Timestep&lt;&#x2F;th&gt;&lt;th&gt;_start&lt;&#x2F;th&gt;&lt;th&gt;interrupt_handler&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;calls &lt;code&gt;println!&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;¬†&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2F;code&gt; locks &lt;code&gt;WRITER&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;¬†&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;interrupt occurs&lt;&#x2F;strong&gt;, handler begins to run&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;calls &lt;code&gt;println!&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2F;code&gt; tries to lock &lt;code&gt;WRITER&lt;&#x2F;code&gt; (already locked)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2F;code&gt; tries to lock &lt;code&gt;WRITER&lt;&#x2F;code&gt; (already locked)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;‚Ä¶&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;‚Ä¶&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;never&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;em&gt;unlock &lt;code&gt;WRITER&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The &lt;code&gt;WRITER&lt;&#x2F;code&gt; is locked, so the interrupt handler waits until it becomes free. But this never happens, because the &lt;code&gt;_start&lt;&#x2F;code&gt; function only continues to run after the interrupt handler returns. Thus, the entire system hangs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;provoking-a-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#provoking-a-deadlock&quot; aria-label=&quot;Anchor link for: provoking-a-deadlock&quot;&gt;üîó&lt;&#x2F;a&gt;Provoking a Deadlock&lt;&#x2F;h3&gt;
&lt;p&gt;We can easily provoke such a deadlock in our kernel by printing something in the loop at the end of our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::print;
&lt;&#x2F;span&gt;&lt;span&gt;        print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it in QEMU, we get an output of the form:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;.&#x2F;qemu-deadlock.png&quot; alt=&quot;QEMU output with many rows of hyphens and no dots&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that only a limited number of hyphens are printed until the first timer interrupt occurs. Then the system hangs because the timer interrupt handler deadlocks when it tries to print a dot. This is the reason that we see no dots in the above output.&lt;&#x2F;p&gt;
&lt;p&gt;The actual number of hyphens varies between runs because the timer interrupt occurs asynchronously. This non-determinism is what makes concurrency-related bugs so difficult to debug.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-the-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-deadlock&quot; aria-label=&quot;Anchor link for: fixing-the-deadlock&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the Deadlock&lt;&#x2F;h3&gt;
&lt;p&gt;To avoid this deadlock, we can disable interrupts as long as the &lt;code&gt;Mutex&lt;&#x2F;code&gt; is locked:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints the given formatted string to the VGA text buffer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; through the global `WRITER` instance.
&lt;&#x2F;span&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::interrupts;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::without_interrupts(|| {     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;interrupts&#x2F;fn.without_interrupts.html&quot;&gt;&lt;code&gt;without_interrupts&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function takes a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch13-01-closures.html&quot;&gt;closure&lt;&#x2F;a&gt; and executes it in an interrupt-free environment. We use it to ensure that no interrupt can occur as long as the &lt;code&gt;Mutex&lt;&#x2F;code&gt; is locked. When we run our kernel now, we see that it keeps running without hanging. (We still don‚Äôt notice any dots, but this is because they‚Äôre scrolling by too fast. Try to slow down the printing, e.g., by putting a &lt;code&gt;for _ in 0..10000 {}&lt;&#x2F;code&gt; inside the loop.)&lt;&#x2F;p&gt;
&lt;p&gt;We can apply the same change to our serial printing function to ensure that no deadlocks occur with it either:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;serial.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: ::core::fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::interrupts;       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::without_interrupts(|| {         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1
&lt;&#x2F;span&gt;&lt;span&gt;            .lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .write_fmt(args)
&lt;&#x2F;span&gt;&lt;span&gt;            .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that disabling interrupts shouldn‚Äôt be a general solution. The problem is that it increases the worst-case interrupt latency, i.e., the time until the system reacts to an interrupt. Therefore, interrupts should only be disabled for a very short time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fixing-a-race-condition&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-a-race-condition&quot; aria-label=&quot;Anchor link for: fixing-a-race-condition&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing a Race Condition&lt;&#x2F;h2&gt;
&lt;p&gt;If you run &lt;code&gt;cargo test&lt;&#x2F;code&gt;, you might see the &lt;code&gt;test_println_output&lt;&#x2F;code&gt; test failing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test --lib
&lt;&#x2F;span&gt;&lt;span&gt;[‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;Running 4 tests
&lt;&#x2F;span&gt;&lt;span&gt;test_breakpoint_exception...[ok]
&lt;&#x2F;span&gt;&lt;span&gt;test_println... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;test_println_many... [ok]
&lt;&#x2F;span&gt;&lt;span&gt;test_println_output... [failed]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Error: panicked at &amp;#39;assertion failed: `(left == right)`
&lt;&#x2F;span&gt;&lt;span&gt;  left: `&amp;#39;.&amp;#39;`,
&lt;&#x2F;span&gt;&lt;span&gt; right: `&amp;#39;S&amp;#39;`&amp;#39;, src&#x2F;vga_buffer.rs:205:9
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason is a &lt;em&gt;race condition&lt;&#x2F;em&gt; between the test and our timer handler. Remember, the test looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println_output() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, s);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.chars().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; screen_char = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().buffer.chars[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;][i].read();
&lt;&#x2F;span&gt;&lt;span&gt;        assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;::from(screen_char.ascii_character), c);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test prints a string to the VGA buffer and then checks the output by manually iterating over the &lt;code&gt;buffer_chars&lt;&#x2F;code&gt; array. The race condition occurs because the timer interrupt handler might run between the &lt;code&gt;println&lt;&#x2F;code&gt; and the reading of the screen characters. Note that this isn‚Äôt a dangerous &lt;em&gt;data race&lt;&#x2F;em&gt;, which Rust completely prevents at compile time. See the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;races.html&quot;&gt;&lt;em&gt;Rustonomicon&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; for details.&lt;&#x2F;p&gt;
&lt;p&gt;To fix this, we need to keep the &lt;code&gt;WRITER&lt;&#x2F;code&gt; locked for the complete duration of the test, so that the timer handler can‚Äôt write a &lt;code&gt;.&lt;&#x2F;code&gt; to the screen in between. The fixed test looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_println_output() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::interrupts;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::without_interrupts(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock();
&lt;&#x2F;span&gt;&lt;span&gt;        writeln!(writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, s).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;writeln failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, c) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.chars().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; screen_char = writer.buffer.chars[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;][i].read();
&lt;&#x2F;span&gt;&lt;span&gt;            assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;::from(screen_char.ascii_character), c);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We performed the following changes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We keep the writer locked for the complete test by using the &lt;code&gt;lock()&lt;&#x2F;code&gt; method explicitly. Instead of &lt;code&gt;println&lt;&#x2F;code&gt;, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;macro.writeln.html&quot;&gt;&lt;code&gt;writeln&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro that allows printing to an already locked writer.&lt;&#x2F;li&gt;
&lt;li&gt;To avoid another deadlock, we disable interrupts for the test‚Äôs duration. Otherwise, the test might get interrupted while the writer is still locked.&lt;&#x2F;li&gt;
&lt;li&gt;Since the timer interrupt handler can still run before the test, we print an additional newline &lt;code&gt;\n&lt;&#x2F;code&gt; before printing the string &lt;code&gt;s&lt;&#x2F;code&gt;. This way, we avoid test failure when the timer handler has already printed some &lt;code&gt;.&lt;&#x2F;code&gt; characters to the current line.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With the above changes, &lt;code&gt;cargo test&lt;&#x2F;code&gt; now deterministically succeeds again.&lt;&#x2F;p&gt;
&lt;p&gt;This was a very harmless race condition that only caused a test failure. As you can imagine, other race conditions can be much more difficult to debug due to their non-deterministic nature. Luckily, Rust prevents us from data races, which are the most serious class of race conditions since they can cause all kinds of undefined behavior, including system crashes and silent memory corruptions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-hlt-instruction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-hlt-instruction&quot; aria-label=&quot;Anchor link for: the-hlt-instruction&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;hlt&lt;&#x2F;code&gt; Instruction&lt;&#x2F;h2&gt;
&lt;p&gt;Until now, we used a simple empty loop statement at the end of our &lt;code&gt;_start&lt;&#x2F;code&gt; and &lt;code&gt;panic&lt;&#x2F;code&gt; functions. This causes the CPU to spin endlessly, and thus works as expected. But it is also very inefficient, because the CPU continues to run at full speed even though there‚Äôs no work to do. You can see this problem in your task manager when you run your kernel: The QEMU process needs close to 100% CPU the whole time.&lt;&#x2F;p&gt;
&lt;p&gt;What we really want to do is to halt the CPU until the next interrupt arrives. This allows the CPU to enter a sleep state in which it consumes much less energy. The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;HLT_(x86_instruction)&quot;&gt;&lt;code&gt;hlt&lt;&#x2F;code&gt; instruction&lt;&#x2F;a&gt; does exactly that. Let‚Äôs use this instruction to create an energy-efficient endless loop:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;hlt_loop() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        x86_64::instructions::hlt();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;instructions::hlt&lt;&#x2F;code&gt; function is just a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;x86_64&#x2F;blob&#x2F;5e8e218381c5205f5777cb50da3ecac5d7e3b1ab&#x2F;src&#x2F;instructions&#x2F;mod.rs#L16-L22&quot;&gt;thin wrapper&lt;&#x2F;a&gt; around the assembly instruction. It is safe because there‚Äôs no way it can compromise memory safety.&lt;&#x2F;p&gt;
&lt;p&gt;We can now use this &lt;code&gt;hlt_loop&lt;&#x2F;code&gt; instead of the endless loops in our &lt;code&gt;_start&lt;&#x2F;code&gt; and &lt;code&gt;panic&lt;&#x2F;code&gt; functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::hlt_loop();            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs update our &lt;code&gt;lib.rs&lt;&#x2F;code&gt; as well:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point for `cargo test`
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    init();
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;    hlt_loop();         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_panic_handler(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Failed);
&lt;&#x2F;span&gt;&lt;span&gt;    hlt_loop();         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run our kernel now in QEMU, we see a much lower CPU usage.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;keyboard-input&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#keyboard-input&quot; aria-label=&quot;Anchor link for: keyboard-input&quot;&gt;üîó&lt;&#x2F;a&gt;Keyboard Input&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we are able to handle interrupts from external devices, we are finally able to add support for keyboard input. This will allow us to interact with our kernel for the first time.&lt;&#x2F;p&gt;
&lt;aside class=&quot;post_aside&quot;&gt;
&lt;p&gt;Note that we only describe how to handle &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;PS&#x2F;2_port&quot;&gt;PS&#x2F;2&lt;&#x2F;a&gt; keyboards here, not USB keyboards. However, the mainboard emulates USB keyboards as PS&#x2F;2 devices to support older software, so we can safely ignore USB keyboards until we have USB support in our kernel.&lt;&#x2F;p&gt;
&lt;&#x2F;aside&gt;
&lt;p&gt;Like the hardware timer, the keyboard controller is already enabled by default. So when you press a key, the keyboard controller sends an interrupt to the PIC, which forwards it to the CPU. The CPU looks for a handler function in the IDT, but the corresponding entry is empty. Therefore, a double fault occurs.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs add a handler function for the keyboard interrupt. It‚Äôs quite similar to how we defined the handler for the timer interrupt; it just uses a different interrupt number:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u8)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;InterruptIndex {
&lt;&#x2F;span&gt;&lt;span&gt;    Timer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Keyboard, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt[InterruptIndex::Keyboard.as_usize()]
&lt;&#x2F;span&gt;&lt;span&gt;            .set_handler_fn(keyboard_interrupt_handler);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;keyboard_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;k&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As we see from the graphic &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;#the-8259-pic&quot;&gt;above&lt;&#x2F;a&gt;, the keyboard uses line 1 of the primary PIC. This means that it arrives at the CPU as interrupt 33 (1 + offset 32). We add this index as a new &lt;code&gt;Keyboard&lt;&#x2F;code&gt; variant to the &lt;code&gt;InterruptIndex&lt;&#x2F;code&gt; enum. We don‚Äôt need to specify the value explicitly, since it defaults to the previous value plus one, which is also 33. In the interrupt handler, we print a &lt;code&gt;k&lt;&#x2F;code&gt; and send the end of interrupt signal to the interrupt controller.&lt;&#x2F;p&gt;
&lt;p&gt;We now see that a &lt;code&gt;k&lt;&#x2F;code&gt; appears on the screen when we press a key. However, this only works for the first key we press. Even if we continue to press keys, no more &lt;code&gt;k&lt;&#x2F;code&gt;s appear on the screen. This is because the keyboard controller won‚Äôt send another interrupt until we have read the so-called &lt;em&gt;scancode&lt;&#x2F;em&gt; of the pressed key.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;reading-the-scancodes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reading-the-scancodes&quot; aria-label=&quot;Anchor link for: reading-the-scancodes&quot;&gt;üîó&lt;&#x2F;a&gt;Reading the Scancodes&lt;&#x2F;h3&gt;
&lt;p&gt;To find out &lt;em&gt;which&lt;&#x2F;em&gt; key was pressed, we need to query the keyboard controller. We do this by reading from the data port of the PS&#x2F;2 controller, which is the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;#i-o-ports&quot;&gt;I&#x2F;O port&lt;&#x2F;a&gt; with the number &lt;code&gt;0x60&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;keyboard_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ port.read() };
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, scancode);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;port&#x2F;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate to read a byte from the keyboard‚Äôs data port. This byte is called the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scancode&quot;&gt;&lt;em&gt;scancode&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; and it represents the key press&#x2F;release. We don‚Äôt do anything with the scancode yet, other than print it to the screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-printing-scancodes.gif&quot; alt=&quot;QEMU printing scancodes to the screen when keys are pressed&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The above image shows me slowly typing ‚Äú123‚Äù. We see that adjacent keys have adjacent scancodes and that pressing a key causes a different scancode than releasing it. But how do we translate the scancodes to the actual key actions exactly?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;interpreting-the-scancodes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#interpreting-the-scancodes&quot; aria-label=&quot;Anchor link for: interpreting-the-scancodes&quot;&gt;üîó&lt;&#x2F;a&gt;Interpreting the Scancodes&lt;&#x2F;h3&gt;
&lt;p&gt;There are three different standards for the mapping between scancodes and keys, the so-called &lt;em&gt;scancode sets&lt;&#x2F;em&gt;. All three go back to the keyboards of early IBM computers: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_Personal_Computer_XT&quot;&gt;IBM XT&lt;&#x2F;a&gt;, the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_3270_PC&quot;&gt;IBM 3270 PC&lt;&#x2F;a&gt;, and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_Personal_Computer&#x2F;AT&quot;&gt;IBM AT&lt;&#x2F;a&gt;. Later computers fortunately did not continue the trend of defining new scancode sets, but rather emulated the existing sets and extended them. Today, most keyboards can be configured to emulate any of the three sets.&lt;&#x2F;p&gt;
&lt;p&gt;By default, PS&#x2F;2 keyboards emulate scancode set 1 (‚ÄúXT‚Äù). In this set, the lower 7 bits of a scancode byte define the key, and the most significant bit defines whether it‚Äôs a press (‚Äú0‚Äù) or a release (‚Äú1‚Äù). Keys that were not present on the original &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IBM_Personal_Computer_XT&quot;&gt;IBM XT&lt;&#x2F;a&gt; keyboard, such as the enter key on the keypad, generate two scancodes in succession: a &lt;code&gt;0xe0&lt;&#x2F;code&gt; escape byte and then a byte representing the key. For a list of all set 1 scancodes and their corresponding keys, check out the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Keyboard#Scan_Code_Set_1&quot;&gt;OSDev Wiki&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To translate the scancodes to keys, we can use a &lt;code&gt;match&lt;&#x2F;code&gt; statement:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;keyboard_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ port.read() };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; key = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; scancode {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x02 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;1&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x03 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;2&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x04 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;3&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x05 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;4&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x06 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;5&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x07 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;6&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x08 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;7&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x09 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;8&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;9&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;0&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;None,
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(key) = key {
&lt;&#x2F;span&gt;&lt;span&gt;        print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, key);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above code translates keypresses of the number keys 0-9 and ignores all other keys. It uses a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch06-02-match.html&quot;&gt;match&lt;&#x2F;a&gt; statement to assign a character or &lt;code&gt;None&lt;&#x2F;code&gt; to each scancode. It then uses &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch18-01-all-the-places-for-patterns.html#conditional-if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to destructure the optional &lt;code&gt;key&lt;&#x2F;code&gt;. By using the same variable name &lt;code&gt;key&lt;&#x2F;code&gt; in the pattern, we &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch03-01-variables-and-mutability.html#shadowing&quot;&gt;shadow&lt;&#x2F;a&gt; the previous declaration, which is a common pattern for destructuring &lt;code&gt;Option&lt;&#x2F;code&gt; types in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can write numbers:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-printing-numbers.gif&quot; alt=&quot;QEMU printing numbers to the screen&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Translating the other keys works in the same way. Fortunately, there is a crate named &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;&quot;&gt;&lt;code&gt;pc-keyboard&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for translating scancodes of scancode sets 1 and 2, so we don‚Äôt have to implement this ourselves. To use the crate, we add it to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and import it in our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pc-keyboard &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can use this crate to rewrite our &lt;code&gt;keyboard_interrupt_handler&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in&#x2F;src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;keyboard_interrupt_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;pc_keyboard::{layouts, DecodedKey, HandleControl, Keyboard, ScancodeSet1};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;KEYBOARD&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Keyboard&amp;lt;layouts::Us104Key, ScancodeSet1&amp;gt;&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;            Mutex::new(Keyboard::new(layouts::Us104Key, ScancodeSet1,
&lt;&#x2F;span&gt;&lt;span&gt;                HandleControl::Ignore)
&lt;&#x2F;span&gt;&lt;span&gt;            );
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; keyboard = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;KEYBOARD&lt;&#x2F;span&gt;&lt;span&gt;.lock();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; scancode: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ port.read() };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Ok(Some(key_event)) = keyboard.add_byte(scancode) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(key) = keyboard.process_keyevent(key_event) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; key {
&lt;&#x2F;span&gt;&lt;span&gt;                DecodedKey::Unicode(character) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, character),
&lt;&#x2F;span&gt;&lt;span&gt;                DecodedKey::RawKey(key) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, key),
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2F;span&gt;&lt;span&gt;.lock()
&lt;&#x2F;span&gt;&lt;span&gt;            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; macro to create a static &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;struct.Keyboard.html&quot;&gt;&lt;code&gt;Keyboard&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; object protected by a Mutex. We initialize the &lt;code&gt;Keyboard&lt;&#x2F;code&gt; with a US keyboard layout and the scancode set 1. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;enum.HandleControl.html&quot;&gt;&lt;code&gt;HandleControl&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; parameter allows to map &lt;code&gt;ctrl+[a-z]&lt;&#x2F;code&gt; to the Unicode characters &lt;code&gt;U+0001&lt;&#x2F;code&gt; through &lt;code&gt;U+001A&lt;&#x2F;code&gt;. We don‚Äôt want to do that, so we use the &lt;code&gt;Ignore&lt;&#x2F;code&gt; option to handle the &lt;code&gt;ctrl&lt;&#x2F;code&gt; like normal keys.&lt;&#x2F;p&gt;
&lt;p&gt;On each interrupt, we lock the Mutex, read the scancode from the keyboard controller, and pass it to the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;struct.Keyboard.html#method.add_byte&quot;&gt;&lt;code&gt;add_byte&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method, which translates the scancode into an &lt;code&gt;Option&amp;lt;KeyEvent&amp;gt;&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;struct.KeyEvent.html&quot;&gt;&lt;code&gt;KeyEvent&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; contains the key which caused the event and whether it was a press or release event.&lt;&#x2F;p&gt;
&lt;p&gt;To interpret this key event, we pass it to the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pc-keyboard&#x2F;0.5.0&#x2F;pc_keyboard&#x2F;struct.Keyboard.html#method.process_keyevent&quot;&gt;&lt;code&gt;process_keyevent&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method, which translates the key event to a character, if possible. For example, it translates a press event of the &lt;code&gt;A&lt;&#x2F;code&gt; key to either a lowercase &lt;code&gt;a&lt;&#x2F;code&gt; character or an uppercase &lt;code&gt;A&lt;&#x2F;code&gt; character, depending on whether the shift key was pressed.&lt;&#x2F;p&gt;
&lt;p&gt;With this modified interrupt handler, we can now write text:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;hardware-interrupts&#x2F;qemu-typing.gif&quot; alt=&quot;Typing ‚ÄúHello World‚Äù in QEMU&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;configuring-the-keyboard&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#configuring-the-keyboard&quot; aria-label=&quot;Anchor link for: configuring-the-keyboard&quot;&gt;üîó&lt;&#x2F;a&gt;Configuring the Keyboard&lt;&#x2F;h3&gt;
&lt;p&gt;It‚Äôs possible to configure some aspects of a PS&#x2F;2 keyboard, for example, which scancode set it should use. We won‚Äôt cover it here because this post is already long enough, but the OSDev Wiki has an overview of possible &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;PS&#x2F;2_Keyboard#Commands&quot;&gt;configuration commands&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;This post explained how to enable and handle external interrupts. We learned about the 8259 PIC and its primary&#x2F;secondary layout, the remapping of the interrupt numbers, and the ‚Äúend of interrupt‚Äù signal. We implemented handlers for the hardware timer and the keyboard and learned about the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction, which halts the CPU until the next interrupt.&lt;&#x2F;p&gt;
&lt;p&gt;Now we are able to interact with our kernel and have some fundamental building blocks for creating a small shell or simple games.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;Timer interrupts are essential for an operating system because they provide a way to periodically interrupt the running process and let the kernel regain control. The kernel can then switch to a different process and create the illusion of multiple processes running in parallel.&lt;&#x2F;p&gt;
&lt;p&gt;But before we can create processes or threads, we need a way to allocate memory for them. The next posts will explore memory management to provide this fundamental building block.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Double Faults</title>
                <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/double-fault-exceptions/</link>
                <guid>https://os.phil-opp.com/double-fault-exceptions/</guid>
                <description>&lt;p&gt;This post explores the double fault exception in detail, which occurs when the CPU fails to invoke an exception handler. By handling this exception, we avoid fatal &lt;em&gt;triple faults&lt;&#x2F;em&gt; that cause a system reset. To prevent triple faults in all cases, we also set up an &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; to catch double faults on a separate kernel stack.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-fault-exceptions&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-06&quot;&gt;&lt;code&gt;post-06&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;what-is-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-double-fault&quot; aria-label=&quot;Anchor link for: what-is-a-double-fault&quot;&gt;üîó&lt;&#x2F;a&gt;What is a Double Fault?&lt;&#x2F;h2&gt;
&lt;p&gt;In simplified terms, a double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered but there is no page fault handler registered in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;Interrupt Descriptor Table&lt;&#x2F;a&gt; (IDT). So it‚Äôs kind of similar to catch-all blocks in programming languages with exceptions, e.g., &lt;code&gt;catch(...)&lt;&#x2F;code&gt; in C++ or &lt;code&gt;catch(Exception e)&lt;&#x2F;code&gt; in Java or C#.&lt;&#x2F;p&gt;
&lt;p&gt;A double fault behaves like a normal exception. It has the vector number &lt;code&gt;8&lt;&#x2F;code&gt; and we can define a normal handler function for it in the IDT. It is really important to provide a double fault handler, because if a double fault is unhandled, a fatal &lt;em&gt;triple fault&lt;&#x2F;em&gt; occurs. Triple faults can‚Äôt be caught, and most hardware reacts with a system reset.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;triggering-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#triggering-a-double-fault&quot; aria-label=&quot;Anchor link for: triggering-a-double-fault&quot;&gt;üîó&lt;&#x2F;a&gt;Triggering a Double Fault&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs provoke a double fault by triggering an exception for which we didn‚Äôt define a handler function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a page fault
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as before
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;code&gt;unsafe&lt;&#x2F;code&gt; to write to the invalid address &lt;code&gt;0xdeadbeef&lt;&#x2F;code&gt;. The virtual address is not mapped to a physical address in the page tables, so a page fault occurs. We haven‚Äôt registered a page fault handler in our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;IDT&lt;&#x2F;a&gt;, so a double fault occurs.&lt;&#x2F;p&gt;
&lt;p&gt;When we start our kernel now, we see that it enters an endless boot loop. The reason for the boot loop is the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU tries to write to &lt;code&gt;0xdeadbeef&lt;&#x2F;code&gt;, which causes a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU looks at the corresponding entry in the IDT and sees that no handler function is specified. Thus, it can‚Äôt call the page fault handler and a double fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU looks at the IDT entry of the double fault handler, but this entry does not specify a handler function either. Thus, a &lt;em&gt;triple&lt;&#x2F;em&gt; fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;A triple fault is fatal. QEMU reacts to it like most real hardware and issues a system reset.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So in order to prevent this triple fault, we need to either provide a handler function for page faults or a double fault handler. We want to avoid triple faults in all cases, so let‚Äôs start with a double fault handler that is invoked for all unhandled exception types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-double-fault-handler&quot; aria-label=&quot;Anchor link for: a-double-fault-handler&quot;&gt;üîó&lt;&#x2F;a&gt;A Double Fault Handler&lt;&#x2F;h2&gt;
&lt;p&gt;A double fault is a normal exception with an error code, so we can specify a handler function similar to our breakpoint handler:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        idt.double_fault.set_handler_fn(double_fault_handler); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;double_fault_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    stack_frame: InterruptStackFrame, _error_code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: DOUBLE FAULT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;{:#?}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our handler prints a short error message and dumps the exception stack frame. The error code of the double fault handler is always zero, so there‚Äôs no reason to print it. One difference to the breakpoint handler is that the double fault handler is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;rust-by-example&#x2F;fn&#x2F;diverging.html&quot;&gt;&lt;em&gt;diverging&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. The reason is that the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture does not permit returning from a double fault exception.&lt;&#x2F;p&gt;
&lt;p&gt;When we start our kernel now, we should see that the double fault handler is invoked:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-fault-exceptions&#x2F;qemu-catch-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It worked! Here is what happened this time:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU tries to write to &lt;code&gt;0xdeadbeef&lt;&#x2F;code&gt;, which causes a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;Like before, the CPU looks at the corresponding entry in the IDT and sees that no handler function is defined. Thus, a double fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU jumps to the ‚Äì now present ‚Äì double fault handler.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The triple fault (and the boot-loop) no longer occurs, since the CPU can now call the double fault handler.&lt;&#x2F;p&gt;
&lt;p&gt;That was quite straightforward! So why do we need a whole post for this topic? Well, we‚Äôre now able to catch &lt;em&gt;most&lt;&#x2F;em&gt; double faults, but there are some cases where our current approach doesn‚Äôt suffice.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;causes-of-double-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#causes-of-double-faults&quot; aria-label=&quot;Anchor link for: causes-of-double-faults&quot;&gt;üîó&lt;&#x2F;a&gt;Causes of Double Faults&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at the special cases, we need to know the exact causes of double faults. Above, we used a pretty vague definition:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A double fault is a special exception that occurs when the CPU fails to invoke an exception handler.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;What does &lt;em&gt;‚Äúfails to invoke‚Äù&lt;&#x2F;em&gt; mean exactly? The handler is not present? The handler is &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;vm-beyondphys.pdf&quot;&gt;swapped out&lt;&#x2F;a&gt;? And what happens if a handler causes exceptions itself?&lt;&#x2F;p&gt;
&lt;p&gt;For example, what happens if:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;a breakpoint exception occurs, but the corresponding handler function is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;a page fault occurs, but the page fault handler is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;a divide-by-zero handler causes a breakpoint exception, but the breakpoint handler is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;our kernel overflows its stack and the &lt;em&gt;guard page&lt;&#x2F;em&gt; is hit?&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Fortunately, the AMD64 manual (&lt;a href=&quot;https:&#x2F;&#x2F;www.amd.com&#x2F;system&#x2F;files&#x2F;TechDocs&#x2F;24593.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) has an exact definition (in Section 8.2.9). According to it, a ‚Äúdouble fault exception &lt;em&gt;can&lt;&#x2F;em&gt; occur when a second exception occurs during the handling of a prior (first) exception handler‚Äù. The &lt;em&gt;‚Äúcan‚Äù&lt;&#x2F;em&gt; is important: Only very specific combinations of exceptions lead to a double fault. These combinations are:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;First Exception&lt;&#x2F;th&gt;&lt;th&gt;Second Exception&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Divide-by-zero_Error&quot;&gt;Divide-by-zero&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So, for example, a divide-by-zero fault followed by a page fault is fine (the page fault handler is invoked), but a divide-by-zero fault followed by a general-protection fault leads to a double fault.&lt;&#x2F;p&gt;
&lt;p&gt;With the help of this table, we can answer the first three of the above questions:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;If a breakpoint exception occurs and the corresponding handler function is swapped out, a &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;li&gt;If a page fault occurs and the page fault handler is swapped out, a &lt;em&gt;double fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;double fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;li&gt;If a divide-by-zero handler causes a breakpoint exception, the CPU tries to invoke the breakpoint handler. If the breakpoint handler is swapped out, a &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In fact, even the case of an exception without a handler function in the IDT follows this scheme: When the exception occurs, the CPU tries to read the corresponding IDT entry. Since the entry is 0, which is not a valid IDT entry, a &lt;em&gt;general protection fault&lt;&#x2F;em&gt; occurs. We did not define a handler function for the general protection fault either, so another general protection fault occurs. According to the table, this leads to a double fault.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kernel-stack-overflow&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-stack-overflow&quot; aria-label=&quot;Anchor link for: kernel-stack-overflow&quot;&gt;üîó&lt;&#x2F;a&gt;Kernel Stack Overflow&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs look at the fourth question:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What happens if our kernel overflows its stack and the guard page is hit?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;A guard page is a special memory page at the bottom of a stack that makes it possible to detect stack overflows. The page is not mapped to any physical frame, so accessing it causes a page fault instead of silently corrupting other memory. The bootloader sets up a guard page for our kernel stack, so a stack overflow causes a &lt;em&gt;page fault&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When a page fault occurs, the CPU looks up the page fault handler in the IDT and tries to push the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#the-interrupt-stack-frame&quot;&gt;interrupt stack frame&lt;&#x2F;a&gt; onto the stack. However, the current stack pointer still points to the non-present guard page. Thus, a second page fault occurs, which causes a double fault (according to the above table).&lt;&#x2F;p&gt;
&lt;p&gt;So the CPU tries to call the &lt;em&gt;double fault handler&lt;&#x2F;em&gt; now. However, on a double fault, the CPU tries to push the exception stack frame, too. The stack pointer still points to the guard page, so a &lt;em&gt;third&lt;&#x2F;em&gt; page fault occurs, which causes a &lt;em&gt;triple fault&lt;&#x2F;em&gt; and a system reboot. So our current double fault handler can‚Äôt avoid a triple fault in this case.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs try it ourselves! We can easily provoke a kernel stack overflow by calling a function that recurses endlessly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;stack_overflow() {
&lt;&#x2F;span&gt;&lt;span&gt;        stack_overflow(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; for each recursion, the return address is pushed
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a stack overflow
&lt;&#x2F;span&gt;&lt;span&gt;    stack_overflow();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test_main(), println(‚Ä¶), and loop {}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we try this code in QEMU, we see that the system enters a bootloop again.&lt;&#x2F;p&gt;
&lt;p&gt;So how can we avoid this problem? We can‚Äôt omit the pushing of the exception stack frame, since the CPU itself does it. So we need to ensure somehow that the stack is always valid when a double fault exception occurs. Fortunately, the x86_64 architecture has a solution to this problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;switching-stacks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-stacks&quot; aria-label=&quot;Anchor link for: switching-stacks&quot;&gt;üîó&lt;&#x2F;a&gt;Switching Stacks&lt;&#x2F;h2&gt;
&lt;p&gt;The x86_64 architecture is able to switch to a predefined, known-good stack when an exception occurs. This switch happens at hardware level, so it can be performed before the CPU pushes the exception stack frame.&lt;&#x2F;p&gt;
&lt;p&gt;The switching mechanism is implemented as an &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; (IST). The IST is a table of 7 pointers to known-good stacks. In Rust-like pseudocode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;InterruptStackTable {
&lt;&#x2F;span&gt;&lt;span&gt;    stack_pointers: [Option&amp;lt;StackPointer&amp;gt;; 7],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For each exception handler, we can choose a stack from the IST through the &lt;code&gt;stack_pointers&lt;&#x2F;code&gt; field in the corresponding &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;IDT entry&lt;&#x2F;a&gt;. For example, our double fault handler could use the first stack in the IST. Then the CPU automatically switches to this stack whenever a double fault occurs. This switch would happen before anything is pushed, preventing the triple fault.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-ist-and-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-ist-and-tss&quot; aria-label=&quot;Anchor link for: the-ist-and-tss&quot;&gt;üîó&lt;&#x2F;a&gt;The IST and TSS&lt;&#x2F;h3&gt;
&lt;p&gt;The Interrupt Stack Table (IST) is part of an old legacy structure called &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Task_state_segment&quot;&gt;Task State Segment&lt;&#x2F;a&gt;&lt;&#x2F;em&gt; (TSS). The TSS used to hold various pieces of information (e.g., processor register state) about a task in 32-bit mode and was, for example, used for &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Context_Switching#Hardware_Context_Switching&quot;&gt;hardware context switching&lt;&#x2F;a&gt;. However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS has changed completely.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, the TSS no longer holds any task-specific information at all. Instead, it holds two stack tables (the IST is one of them). The only common field between the 32-bit and 64-bit TSS is the pointer to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Task_state_segment#I.2FO_port_permissions&quot;&gt;I&#x2F;O port permissions bitmap&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The 64-bit TSS has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field&lt;&#x2F;th&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u32&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Privilege Stack Table&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;[u64; 3]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Interrupt Stack Table&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;[u64; 7]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;I&#x2F;O Map Base Address&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The &lt;em&gt;Privilege Stack Table&lt;&#x2F;em&gt; is used by the CPU when the privilege level changes. For example, if an exception occurs while the CPU is in user mode (privilege level 3), the CPU normally switches to kernel mode (privilege level 0) before invoking the exception handler. In that case, the CPU would switch to the 0th stack in the Privilege Stack Table (since 0 is the target privilege level). We don‚Äôt have any user-mode programs yet, so we will ignore this table for now.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-a-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-tss&quot; aria-label=&quot;Anchor link for: creating-a-tss&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a TSS&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs create a new TSS that contains a separate double fault stack in its interrupt stack table. For that, we need a TSS struct. Fortunately, the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate already contains a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;tss&#x2F;struct.TaskStateSegment.html&quot;&gt;&lt;code&gt;TaskStateSegment&lt;&#x2F;code&gt; struct&lt;&#x2F;a&gt; that we can use.&lt;&#x2F;p&gt;
&lt;p&gt;We create the TSS in a new &lt;code&gt;gdt&lt;&#x2F;code&gt; module (the name will make sense later):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;gdt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::VirtAddr;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::tss::TaskStateSegment;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2F;span&gt;&lt;span&gt;: TaskStateSegment = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tss = TaskStateSegment::new();
&lt;&#x2F;span&gt;&lt;span&gt;        tss.interrupt_stack_table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;] = {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2F;span&gt;&lt;span&gt;] = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_start = VirtAddr::from_ptr(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_end = stack_start + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            stack_end
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        tss
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;code&gt;lazy_static&lt;&#x2F;code&gt; because Rust‚Äôs const evaluator is not yet powerful enough to do this initialization at compile time. We define that the 0th IST entry is the double fault stack (any other IST index would work too). Then we write the top address of a double fault stack to the 0th entry. We write the top address because stacks on x86 grow downwards, i.e., from high addresses to low addresses.&lt;&#x2F;p&gt;
&lt;p&gt;We haven‚Äôt implemented memory management yet, so we don‚Äôt have a proper way to allocate a new stack. Instead, we use a &lt;code&gt;static mut&lt;&#x2F;code&gt; array as stack storage for now. The &lt;code&gt;unsafe&lt;&#x2F;code&gt; is required because the compiler can‚Äôt guarantee race freedom when mutable statics are accessed. It is important that it is a &lt;code&gt;static mut&lt;&#x2F;code&gt; and not an immutable &lt;code&gt;static&lt;&#x2F;code&gt;, because otherwise the bootloader will map it to a read-only page. We will replace this with a proper stack allocation in a later post, then the &lt;code&gt;unsafe&lt;&#x2F;code&gt; will no longer be needed at this place.&lt;&#x2F;p&gt;
&lt;p&gt;Note that this double fault stack has no guard page that protects against stack overflow. This means that we should not do anything stack-intensive in our double fault handler because a stack overflow might corrupt the memory below the stack.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;loading-the-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-tss&quot; aria-label=&quot;Anchor link for: loading-the-tss&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the TSS&lt;&#x2F;h4&gt;
&lt;p&gt;Now that we‚Äôve created a new TSS, we need a way to tell the CPU that it should use it. Unfortunately, this is a bit cumbersome since the TSS uses the segmentation system (for historical reasons). Instead of loading the table directly, we need to add a new segment descriptor to the &lt;a href=&quot;https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190217233448&#x2F;https:&#x2F;&#x2F;www.flingos.co.uk&#x2F;docs&#x2F;reference&#x2F;Global-Descriptor-Table&#x2F;&quot;&gt;Global Descriptor Table&lt;&#x2F;a&gt; (GDT). Then we can load our TSS by invoking the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;ltr&quot;&gt;&lt;code&gt;ltr&lt;&#x2F;code&gt; instruction&lt;&#x2F;a&gt; with the respective GDT index. (This is the reason why we named our module &lt;code&gt;gdt&lt;&#x2F;code&gt;.)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-global-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table&quot;&gt;üîó&lt;&#x2F;a&gt;The Global Descriptor Table&lt;&#x2F;h3&gt;
&lt;p&gt;The Global Descriptor Table (GDT) is a relic that was used for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_memory_segmentation&quot;&gt;memory segmentation&lt;&#x2F;a&gt; before paging became the de facto standard. However, it is still needed in 64-bit mode for various things, such as kernel&#x2F;user mode configuration or TSS loading.&lt;&#x2F;p&gt;
&lt;p&gt;The GDT is a structure that contains the &lt;em&gt;segments&lt;&#x2F;em&gt; of the program. It was used on older architectures to isolate programs from each other before paging became the standard. For more information about segmentation, check out the equally named chapter of the free &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;&quot;&gt;‚ÄúThree Easy Pieces‚Äù book&lt;&#x2F;a&gt;. While segmentation is no longer supported in 64-bit mode, the GDT still exists. It is mostly used for two things: Switching between kernel space and user space, and loading a TSS structure.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;creating-a-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-gdt&quot; aria-label=&quot;Anchor link for: creating-a-gdt&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a GDT&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs create a static &lt;code&gt;GDT&lt;&#x2F;code&gt; that includes a segment for our &lt;code&gt;TSS&lt;&#x2F;code&gt; static:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::gdt::{GlobalDescriptorTable, Descriptor};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;: GlobalDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; gdt = GlobalDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        gdt.add_entry(Descriptor::kernel_code_segment());
&lt;&#x2F;span&gt;&lt;span&gt;        gdt.add_entry(Descriptor::tss_segment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        gdt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As before, we use &lt;code&gt;lazy_static&lt;&#x2F;code&gt; again. We create a new GDT with a code segment and a TSS segment.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the GDT&lt;&#x2F;h4&gt;
&lt;p&gt;To load our GDT, we create a new &lt;code&gt;gdt::init&lt;&#x2F;code&gt; function that we call from our &lt;code&gt;init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    gdt::init();
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init_idt();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now our GDT is loaded (since the &lt;code&gt;_start&lt;&#x2F;code&gt; function calls &lt;code&gt;init&lt;&#x2F;code&gt;), but we still see the boot loop on stack overflow.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-final-steps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-final-steps&quot; aria-label=&quot;Anchor link for: the-final-steps&quot;&gt;üîó&lt;&#x2F;a&gt;The Final Steps&lt;&#x2F;h3&gt;
&lt;p&gt;The problem is that the GDT segments are not yet active because the segment and TSS registers still contain the values from the old GDT. We also need to modify the double fault IDT entry so that it uses the new stack.&lt;&#x2F;p&gt;
&lt;p&gt;In summary, we need to do the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Reload code segment register&lt;&#x2F;strong&gt;: We changed our GDT, so we should reload &lt;code&gt;cs&lt;&#x2F;code&gt;, the code segment register. This is required since the old segment selector could now point to a different GDT descriptor (e.g., a TSS descriptor).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Load the TSS&lt;&#x2F;strong&gt;: We loaded a GDT that contains a TSS selector, but we still need to tell the CPU that it should use that TSS.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Update the IDT entry&lt;&#x2F;strong&gt;: As soon as our TSS is loaded, the CPU has access to a valid interrupt stack table (IST). Then we can tell the CPU that it should use our new double fault stack by modifying our double fault IDT entry.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For the first two steps, we need access to the &lt;code&gt;code_selector&lt;&#x2F;code&gt; and &lt;code&gt;tss_selector&lt;&#x2F;code&gt; variables in our &lt;code&gt;gdt::init&lt;&#x2F;code&gt; function. We can achieve this by making them part of the static through a new &lt;code&gt;Selectors&lt;&#x2F;code&gt; struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;: (GlobalDescriptorTable, Selectors) = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; gdt = GlobalDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; code_selector = gdt.add_entry(Descriptor::kernel_code_segment());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tss_selector = gdt.add_entry(Descriptor::tss_segment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        (gdt, Selectors { code_selector, tss_selector })
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Selectors {
&lt;&#x2F;span&gt;&lt;span&gt;    code_selector: SegmentSelector,
&lt;&#x2F;span&gt;&lt;span&gt;    tss_selector: SegmentSelector,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can use the selectors to reload the &lt;code&gt;cs&lt;&#x2F;code&gt; register and load our &lt;code&gt;TSS&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tables::load_tss;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::segmentation::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;CS&lt;&#x2F;span&gt;&lt;span&gt;, Segment};
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;load();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;CS&lt;&#x2F;span&gt;&lt;span&gt;::set_reg(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.&lt;&#x2F;span&gt;&lt;span&gt;code_selector);
&lt;&#x2F;span&gt;&lt;span&gt;        load_tss(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.&lt;&#x2F;span&gt;&lt;span&gt;tss_selector);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We reload the code segment register using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;segmentation&#x2F;fn.set_cs.html&quot;&gt;&lt;code&gt;set_cs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and load the TSS using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;fn.load_tss.html&quot;&gt;&lt;code&gt;load_tss&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The functions are marked as &lt;code&gt;unsafe&lt;&#x2F;code&gt;, so we need an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block to invoke them. The reason is that it might be possible to break memory safety by loading invalid selectors.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have loaded a valid TSS and interrupt stack table, we can set the stack index for our double fault handler in the IDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::gdt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            idt.double_fault.set_handler_fn(double_fault_handler)
&lt;&#x2F;span&gt;&lt;span&gt;                .set_stack_index(gdt::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;set_stack_index&lt;&#x2F;code&gt; method is unsafe because the caller must ensure that the used index is valid and not already used for another exception.&lt;&#x2F;p&gt;
&lt;p&gt;That‚Äôs it! Now the CPU should switch to the double fault stack whenever a double fault occurs. Thus, we are able to catch &lt;em&gt;all&lt;&#x2F;em&gt; double faults, including kernel stack overflows:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-fault-exceptions&#x2F;qemu-double-fault-on-stack-overflow.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From now on, we should never see a triple fault again! To ensure that we don‚Äôt accidentally break the above, we should add a test for this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-stack-overflow-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-stack-overflow-test&quot; aria-label=&quot;Anchor link for: a-stack-overflow-test&quot;&gt;üîó&lt;&#x2F;a&gt;A Stack Overflow Test&lt;&#x2F;h2&gt;
&lt;p&gt;To test our new &lt;code&gt;gdt&lt;&#x2F;code&gt; module and ensure that the double fault handler is correctly called on a stack overflow, we can add an integration test. The idea is to provoke a double fault in the test function and verify that the double fault handler is called.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs start with a minimal skeleton:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;stack_overflow.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    unimplemented!();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::test_panic_handler(info)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like our &lt;code&gt;panic_handler&lt;&#x2F;code&gt; test, the test will run &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;#no-harness-tests&quot;&gt;without a test harness&lt;&#x2F;a&gt;. The reason is that we can‚Äôt continue execution after a double fault, so more than one test doesn‚Äôt make sense. To disable the test harness for the test, we add the following to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stack_overflow&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;harness &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;cargo test --test stack_overflow&lt;&#x2F;code&gt; should compile successfully. The test fails, of course, since the &lt;code&gt;unimplemented&lt;&#x2F;code&gt; macro panics.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementing-start&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-start&quot; aria-label=&quot;Anchor link for: implementing-start&quot;&gt;üîó&lt;&#x2F;a&gt;Implementing &lt;code&gt;_start&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The implementation of the &lt;code&gt;_start&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;stack_overflow.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::serial_print;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stack_overflow::stack_overflow...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::gdt::init();
&lt;&#x2F;span&gt;&lt;span&gt;    init_test_idt();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a stack overflow
&lt;&#x2F;span&gt;&lt;span&gt;    stack_overflow();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Execution continued after stack overflow&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[allow(unconditional_recursion)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;stack_overflow() {
&lt;&#x2F;span&gt;&lt;span&gt;    stack_overflow(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; for each recursion, the return address is pushed
&lt;&#x2F;span&gt;&lt;span&gt;    volatile::Volatile::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;).read(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prevent tail recursion optimizations
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We call our &lt;code&gt;gdt::init&lt;&#x2F;code&gt; function to initialize a new GDT. Instead of calling our &lt;code&gt;interrupts::init_idt&lt;&#x2F;code&gt; function, we call an &lt;code&gt;init_test_idt&lt;&#x2F;code&gt; function that will be explained in a moment. The reason is that we want to register a custom double fault handler that does an &lt;code&gt;exit_qemu(QemuExitCode::Success)&lt;&#x2F;code&gt; instead of panicking.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;stack_overflow&lt;&#x2F;code&gt; function is almost identical to the function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;. The only difference is that at the end of the function, we perform an additional &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Volatile_(computer_programming)&quot;&gt;volatile&lt;&#x2F;a&gt; read using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;volatile&#x2F;0.2.6&#x2F;volatile&#x2F;struct.Volatile.html&quot;&gt;&lt;code&gt;Volatile&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type to prevent a compiler optimization called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Tail_call&quot;&gt;&lt;em&gt;tail call elimination&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. Among other things, this optimization allows the compiler to transform a function whose last statement is a recursive function call into a normal loop. Thus, no additional stack frame is created for the function call, so the stack usage remains constant.&lt;&#x2F;p&gt;
&lt;p&gt;In our case, however, we want the stack overflow to happen, so we add a dummy volatile read statement at the end of the function, which the compiler is not allowed to remove. Thus, the function is no longer &lt;em&gt;tail recursive&lt;&#x2F;em&gt;, and the transformation into a loop is prevented. We also add the &lt;code&gt;allow(unconditional_recursion)&lt;&#x2F;code&gt; attribute to silence the compiler warning that the function recurses endlessly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-test-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-test-idt&quot; aria-label=&quot;Anchor link for: the-test-idt&quot;&gt;üîó&lt;&#x2F;a&gt;The Test IDT&lt;&#x2F;h3&gt;
&lt;p&gt;As noted above, the test needs its own IDT with a custom double fault handler. The implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;stack_overflow.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::InterruptDescriptorTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TEST_IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            idt.double_fault
&lt;&#x2F;span&gt;&lt;span&gt;                .set_handler_fn(test_double_fault_handler)
&lt;&#x2F;span&gt;&lt;span&gt;                .set_stack_index(blog_os::gdt::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_test_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TEST_IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The implementation is very similar to our normal IDT in &lt;code&gt;interrupts.rs&lt;&#x2F;code&gt;. Like in the normal IDT, we set a stack index in the IST for the double fault handler in order to switch to a separate stack. The &lt;code&gt;init_test_idt&lt;&#x2F;code&gt; function loads the IDT on the CPU through the &lt;code&gt;load&lt;&#x2F;code&gt; method.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-double-fault-handler&quot; aria-label=&quot;Anchor link for: the-double-fault-handler&quot;&gt;üîó&lt;&#x2F;a&gt;The Double Fault Handler&lt;&#x2F;h3&gt;
&lt;p&gt;The only missing piece is our double fault handler. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in tests&#x2F;stack_overflow.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::{exit_qemu, QemuExitCode, serial_println};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::InterruptStackFrame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_double_fault_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    _stack_frame: InterruptStackFrame,
&lt;&#x2F;span&gt;&lt;span&gt;    _error_code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    exit_qemu(QemuExitCode::Success);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the double fault handler is called, we exit QEMU with a success exit code, which marks the test as passed. Since integration tests are completely separate executables, we need to set the &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2F;code&gt; attribute again at the top of our test file.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can run our test through &lt;code&gt;cargo test --test stack_overflow&lt;&#x2F;code&gt; (or &lt;code&gt;cargo test&lt;&#x2F;code&gt; to run all tests). As expected, we see the &lt;code&gt;stack_overflow... [ok]&lt;&#x2F;code&gt; output in the console. Try to comment out the &lt;code&gt;set_stack_index&lt;&#x2F;code&gt; line; it should cause the test to fail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we learned what a double fault is and under which conditions it occurs. We added a basic double fault handler that prints an error message and added an integration test for it.&lt;&#x2F;p&gt;
&lt;p&gt;We also enabled the hardware-supported stack switching on double fault exceptions so that it also works on stack overflow. While implementing it, we learned about the task state segment (TSS), the contained interrupt stack table (IST), and the global descriptor table (GDT), which was used for segmentation on older architectures.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how to handle interrupts from external devices such as timers, keyboards, or network controllers. These hardware interrupts are very similar to exceptions, e.g., they are also dispatched through the IDT. However, unlike exceptions, they don‚Äôt arise directly on the CPU. Instead, an &lt;em&gt;interrupt controller&lt;&#x2F;em&gt; aggregates these interrupts and forwards them to the CPU depending on their priority. In the next post, we will explore the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8259&quot;&gt;Intel 8259&lt;&#x2F;a&gt; (‚ÄúPIC‚Äù) interrupt controller and learn how to implement keyboard support.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>CPU Exceptions</title>
                <pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/cpu-exceptions/</link>
                <guid>https://os.phil-opp.com/cpu-exceptions/</guid>
                <description>&lt;p&gt;CPU exceptions occur in various erroneous situations, for example, when accessing an invalid memory address or when dividing by zero. To react to them, we have to set up an &lt;em&gt;interrupt descriptor table&lt;&#x2F;em&gt; that provides handler functions. At the end of this post, our kernel will be able to catch &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Breakpoint&quot;&gt;breakpoint exceptions&lt;&#x2F;a&gt; and resume normal execution afterward.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;üîó&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2F;p&gt;
&lt;p&gt;On x86, there are about 20 different CPU exception types. The most important are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2F;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2F;strong&gt;: This exception occurs when the current instruction is invalid, for example, when we try to use new &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions&quot;&gt;SSE instructions&lt;&#x2F;a&gt; on an old CPU that does not support them.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;General Protection Fault&lt;&#x2F;strong&gt;: This is the exception with the broadest range of causes. It occurs on various kinds of access violations, such as trying to execute a privileged instruction in user-level code or writing reserved fields in configuration registers.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2F;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2F;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2F;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2F;em&gt;. We can‚Äôt catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For the full list of exceptions, check out the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;OSDev wiki&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Descriptor Table&lt;&#x2F;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2F;em&gt; (IDT). In this table, we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [0:15]&lt;&#x2F;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;GDT selector&lt;&#x2F;td&gt;&lt;td&gt;Selector of a code segment in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Global_Descriptor_Table&quot;&gt;global descriptor table&lt;&#x2F;a&gt;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Options&lt;&#x2F;td&gt;&lt;td&gt;(see below)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [16:31]&lt;&#x2F;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [32:63]&lt;&#x2F;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2&lt;&#x2F;td&gt;&lt;td&gt;Interrupt Stack Table Index&lt;&#x2F;td&gt;&lt;td&gt;0: Don‚Äôt switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate&lt;&#x2F;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;must be one&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;td&gt;must be zero&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;13‚Äë14&lt;&#x2F;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)&lt;&#x2F;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;Present&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example, the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;Exception Table&lt;&#x2F;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the ‚ÄúVector nr.‚Äù column.&lt;&#x2F;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2F;a&gt; register. (We will use these values later in this post.)&lt;&#x2F;li&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14th entry when a page fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;Check if the entry is present and, if not, raise a double fault.&lt;&#x2F;li&gt;
&lt;li&gt;Disable hardware interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2F;li&gt;
&lt;li&gt;Load the specified &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Global_Descriptor_Table&quot;&gt;GDT&lt;&#x2F;a&gt; selector into the CS (code segment).&lt;&#x2F;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Don‚Äôt worry about steps 4 and 5 for now; we will learn about the global descriptor table and hardware interrupts in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-idt-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-idt-type&quot; aria-label=&quot;Anchor link for: an-idt-type&quot;&gt;üîó&lt;&#x2F;a&gt;An IDT Type&lt;&#x2F;h2&gt;
&lt;p&gt;Instead of creating our own IDT type, we will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt; struct&lt;&#x2F;a&gt; of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate, which looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;InterruptDescriptorTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;debug: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;non_maskable_interrupt: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;breakpoint: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;overflow: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;bound_range_exceeded: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;invalid_opcode: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;device_not_available: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;double_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;invalid_tss: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;segment_not_present: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;stack_segment_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;general_protection_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;page_fault: Entry&amp;lt;PageFaultHandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;x87_floating_point: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;alignment_check: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;machine_check: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;simd_floating_point: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;virtualization: Entry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;security_exception: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some fields omitted
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The fields have the type &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.Entry.html&quot;&gt;&lt;code&gt;idt::Entry&amp;lt;F&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which is a struct that represents the fields of an IDT entry (see the table above). The type parameter &lt;code&gt;F&lt;&#x2F;code&gt; defines the expected handler function type. We see that some entries require a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFunc.html&quot;&gt;&lt;code&gt;HandlerFunc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and some entries require a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The page fault even has its own special type: &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.PageFaultHandlerFunc.html&quot;&gt;&lt;code&gt;PageFaultHandlerFunc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs look at the &lt;code&gt;HandlerFunc&lt;&#x2F;code&gt; type first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: InterruptStackFrame);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases&quot;&gt;type alias&lt;&#x2F;a&gt; for an &lt;code&gt;extern &amp;quot;x86-interrupt&amp;quot; fn&lt;&#x2F;code&gt; type. The &lt;code&gt;extern&lt;&#x2F;code&gt; keyword defines a function with a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;ffi.html#foreign-calling-conventions&quot;&gt;foreign calling convention&lt;&#x2F;a&gt; and is often used to communicate with C code (&lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt;). But what is the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-interrupt-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-calling-convention&quot; aria-label=&quot;Anchor link for: the-interrupt-calling-convention&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Calling Convention&lt;&#x2F;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the called function and executes it. Afterwards, the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntarily by a compiler-inserted &lt;code&gt;call&lt;&#x2F;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;Calling conventions&lt;&#x2F;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;x86_64-abi-0.99.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2F;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2F;code&gt; and &lt;code&gt;rdx&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;600&quot;&gt;there isn‚Äôt even a Rust ABI yet&lt;&#x2F;a&gt;), so these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Preserved and Scratch Registers&lt;&#x2F;h3&gt;
&lt;p&gt;The calling convention divides the registers into two parts: &lt;em&gt;preserved&lt;&#x2F;em&gt; and &lt;em&gt;scratch&lt;&#x2F;em&gt; registers.&lt;&#x2F;p&gt;
&lt;p&gt;The values of &lt;em&gt;preserved&lt;&#x2F;em&gt; registers must remain unchanged across function calls. So a called function (the &lt;em&gt;‚Äúcallee‚Äù&lt;&#x2F;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore, these registers are called &lt;em&gt;‚Äúcallee-saved‚Äù&lt;&#x2F;em&gt;. A common pattern is to save these registers to the stack at the function‚Äôs beginning and restore them just before returning.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite &lt;em&gt;scratch&lt;&#x2F;em&gt; registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it before the function call (e.g., by pushing it to the stack). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers&lt;&#x2F;th&gt;&lt;th&gt;scratch registers&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2F;code&gt;, &lt;code&gt;rbx&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;r12&lt;&#x2F;code&gt;, &lt;code&gt;r13&lt;&#x2F;code&gt;, &lt;code&gt;r14&lt;&#x2F;code&gt;, &lt;code&gt;r15&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;, &lt;code&gt;r10&lt;&#x2F;code&gt;, &lt;code&gt;r11&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2F;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2F;code&gt; on the stack (because it‚Äôs a callee-saved register).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preserving-all-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserving-all-registers&quot; aria-label=&quot;Anchor link for: preserving-all-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Preserving all Registers&lt;&#x2F;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In most cases, we don‚Äôt even know at compile time if the generated code will cause an exception. For example, the compiler can‚Äôt know if an instruction causes a stack overflow or a page fault.&lt;&#x2F;p&gt;
&lt;p&gt;Since we don‚Äôt know when an exception occurs, we can‚Äôt backup any registers before. This means we can‚Äôt use a calling convention that relies on caller-saved registers for exception handlers. Instead, we need a calling convention that preserves &lt;em&gt;all registers&lt;&#x2F;em&gt;. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is such a calling convention, so it guarantees that all register values are restored to their original values on function return.&lt;&#x2F;p&gt;
&lt;p&gt;Note that this does not mean all registers are saved to the stack at function entry. Instead, the compiler only backs up the registers that are overwritten by the function. This way, very efficient code can be generated for short functions that only use a few registers.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-interrupt-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-stack-frame&quot; aria-label=&quot;Anchor link for: the-interrupt-stack-frame&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Stack Frame&lt;&#x2F;h3&gt;
&lt;p&gt;On a normal function call (using the &lt;code&gt;call&lt;&#x2F;code&gt; instruction), the CPU pushes the return address before jumping to the target function. On function return (using the &lt;code&gt;ret&lt;&#x2F;code&gt; instruction), the CPU pops this return address and jumps to it. So the stack frame of a normal function call looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For exception and interrupt handlers, however, pushing a return address would not suffice, since interrupt handlers often run in a different context (stack pointer, CPU flags, etc.). Instead, the CPU performs the following steps when an interrupt occurs:&lt;&#x2F;p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;&lt;strong&gt;Saving the old stack pointer&lt;&#x2F;strong&gt;: The CPU reads the stack pointer (&lt;code&gt;rsp&lt;&#x2F;code&gt;) and stack segment (&lt;code&gt;ss&lt;&#x2F;code&gt;) register values and remembers them in an internal buffer.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack pointer&lt;&#x2F;strong&gt;: An interrupt can occur at any instruction, so the stack pointer can have any value, too. However, some CPU instructions (e.g., some SSE instructions) require that the stack pointer be aligned on a 16-byte boundary, so the CPU performs such an alignment right after the interrupt.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Switching stacks&lt;&#x2F;strong&gt; (in some cases): A stack switch occurs when the CPU privilege level changes, for example, when a CPU exception occurs in a user-mode program. It is also possible to configure stack switches for specific interrupts using the so-called &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; (described in the next post).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the old stack pointer&lt;&#x2F;strong&gt;: The CPU pushes the &lt;code&gt;rsp&lt;&#x2F;code&gt; and &lt;code&gt;ss&lt;&#x2F;code&gt; values from step 0 to the stack. This makes it possible to restore the original stack pointer when returning from an interrupt handler.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing and updating the &lt;code&gt;RFLAGS&lt;&#x2F;code&gt; register&lt;&#x2F;strong&gt;: The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;&lt;code&gt;RFLAGS&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; register contains various control and status bits. On interrupt entry, the CPU changes some bits and pushes the old value.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the instruction pointer&lt;&#x2F;strong&gt;: Before jumping to the interrupt handler function, the CPU pushes the instruction pointer (&lt;code&gt;rip&lt;&#x2F;code&gt;) and the code segment (&lt;code&gt;cs&lt;&#x2F;code&gt;). This is comparable to the return address push of a normal function call.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing an error code&lt;&#x2F;strong&gt; (for some exceptions): For some specific exceptions, such as page faults, the CPU pushes an error code, which describes the cause of the exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Invoking the interrupt handler&lt;&#x2F;strong&gt;: The CPU reads the address and the segment descriptor of the interrupt handler function from the corresponding field in the IDT. It then invokes this handler by loading the values into the &lt;code&gt;rip&lt;&#x2F;code&gt; and &lt;code&gt;cs&lt;&#x2F;code&gt; registers.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So the &lt;em&gt;interrupt stack frame&lt;&#x2F;em&gt; looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;exception-stack-frame.svg&quot; alt=&quot;interrupt stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate, the interrupt stack frame is represented by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptStackFrame.html&quot;&gt;&lt;code&gt;InterruptStackFrame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct. It is passed to interrupt handlers as &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; and can be used to retrieve additional information about the exception‚Äôs cause. The struct contains no error code field, since only a few exceptions push an error code. These exceptions use the separate &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function type, which has an additional &lt;code&gt;error_code&lt;&#x2F;code&gt; argument.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;behind-the-scenes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#behind-the-scenes&quot; aria-label=&quot;Anchor link for: behind-the-scenes&quot;&gt;üîó&lt;&#x2F;a&gt;Behind the Scenes&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is a powerful abstraction that hides almost all of the messy details of the exception handling process. However, sometimes it‚Äôs useful to know what‚Äôs happening behind the curtain. Here is a short overview of the things that the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention takes care of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Retrieving the arguments&lt;&#x2F;strong&gt;: Most calling conventions expect that the arguments are passed in registers. This is not possible for exception handlers since we must not overwrite any register values before backing them up on the stack. Instead, the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is aware that the arguments already lie on the stack at a specific offset.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Returning using &lt;code&gt;iretq&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Since the interrupt stack frame completely differs from stack frames of normal function calls, we can‚Äôt return from handler functions through the normal &lt;code&gt;ret&lt;&#x2F;code&gt; instruction. So instead, the &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction must be used.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Handling the error code&lt;&#x2F;strong&gt;: The error code, which is pushed for some exceptions, makes things much more complex. It changes the stack alignment (see the next point) and needs to be popped off the stack before returning. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention handles all that complexity. However, it doesn‚Äôt know which handler function is used for which exception, so it needs to deduce that information from the number of function arguments. That means the programmer is still responsible for using the correct function type for each exception. Luckily, the &lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt; type defined by the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate ensures that the correct function types are used.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack&lt;&#x2F;strong&gt;: Some instructions (especially SSE instructions) require a 16-byte stack alignment. The CPU ensures this alignment whenever an exception occurs, but for some exceptions it destroys it again later when it pushes an error code. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention takes care of this by realigning the stack in this case.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are interested in more details, we also have a series of posts that explain exception handling using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2F;a&gt; linked &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;#too-much-magic&quot;&gt;at the end of this post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we‚Äôve understood the theory, it‚Äôs time to handle CPU exceptions in our kernel. We‚Äôll start by creating a new interrupts module in &lt;code&gt;src&#x2F;interrupts.rs&lt;&#x2F;code&gt;, that first creates an &lt;code&gt;init_idt&lt;&#x2F;code&gt; function that creates a new &lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;interrupts;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::InterruptDescriptorTable;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can add handler functions. We start by adding a handler for the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Breakpoint&quot;&gt;breakpoint exception&lt;&#x2F;a&gt;. The breakpoint exception is the perfect exception to test exception handling. Its only purpose is to temporarily pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2F;code&gt; is executed.&lt;&#x2F;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;01&#x2F;27&#x2F;how-debuggers-work-part-2-breakpoints&quot;&gt;‚Äú&lt;em&gt;How debuggers work&lt;&#x2F;em&gt;‚Äù&lt;&#x2F;a&gt; series.&lt;&#x2F;p&gt;
&lt;p&gt;For our use case, we don‚Äôt need to overwrite any instructions. Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program. So let‚Äôs create a simple &lt;code&gt;breakpoint_handler&lt;&#x2F;code&gt; function and add it to our IDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::{InterruptDescriptorTable, InterruptStackFrame};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2F;span&gt;&lt;span&gt;::println;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;    idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;breakpoint_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    stack_frame: InterruptStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: BREAKPOINT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our handler just outputs a message and pretty-prints the interrupt stack frame.&lt;&#x2F;p&gt;
&lt;p&gt;When we try to compile it, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0658]: x86-interrupt ABI is experimental and subject to change (see issue #40180)
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;main.rs:53:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;53 | &#x2F; extern &amp;quot;x86-interrupt&amp;quot; fn breakpoint_handler(stack_frame: InterruptStackFrame) {
&lt;&#x2F;span&gt;&lt;span&gt;54 | |     println!(&amp;quot;EXCEPTION: BREAKPOINT\n{:#?}&amp;quot;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;55 | | }
&lt;&#x2F;span&gt;&lt;span&gt;   | |_^
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error occurs because the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is still unstable. To use it anyway, we have to explicitly enable it by adding &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2F;code&gt; at the top of our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the IDT&lt;&#x2F;h3&gt;
&lt;p&gt;In order for the CPU to use our new interrupt descriptor table, we need to load it using the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;lgdt:lidt&quot;&gt;&lt;code&gt;lidt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instruction. The &lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt; struct of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate provides a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptDescriptorTable.html#method.load&quot;&gt;&lt;code&gt;load&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method for that. Let‚Äôs try to use it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;    idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;    idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we try to compile it now, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: `idt` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:43:5
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;43 |     idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;   |     ^^^ does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;44 | }
&lt;&#x2F;span&gt;&lt;span&gt;   | - borrowed value only lives until here
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = note: borrowed value must be valid for the static lifetime...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the &lt;code&gt;load&lt;&#x2F;code&gt; method expects a &lt;code&gt;&amp;amp;&#x27;static self&lt;&#x2F;code&gt;, that is, a reference valid for the complete runtime of the program. The reason is that the CPU will access this table on every interrupt until we load a different IDT. So using a shorter lifetime than &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; could lead to use-after-free bugs.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, this is exactly what happens here. Our &lt;code&gt;idt&lt;&#x2F;code&gt; is created on the stack, so it is only valid inside the &lt;code&gt;init&lt;&#x2F;code&gt; function. Afterwards, the stack memory is reused for other functions, so the CPU would interpret random stack memory as IDT. Luckily, the &lt;code&gt;InterruptDescriptorTable::load&lt;&#x2F;code&gt; method encodes this lifetime requirement in its function definition, so that the Rust compiler is able to prevent this possible bug at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;In order to fix this problem, we need to store our &lt;code&gt;idt&lt;&#x2F;code&gt; at a place where it has a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime. To achieve this, we could allocate our IDT on the heap using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and then convert it to a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; reference, but we are writing an OS kernel and thus don‚Äôt have a heap (yet).&lt;&#x2F;p&gt;
&lt;p&gt;As an alternative, we could try to store the IDT as a &lt;code&gt;static&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, there is a problem: Statics are immutable, so we can‚Äôt modify the breakpoint entry from our &lt;code&gt;init&lt;&#x2F;code&gt; function. We could solve this problem by using a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;&lt;code&gt;static mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This variant compiles without errors but it‚Äôs far from idiomatic. &lt;code&gt;static mut&lt;&#x2F;code&gt;s are very prone to data races, so we need an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; block&lt;&#x2F;a&gt; on each access.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;üîó&lt;&#x2F;a&gt;Lazy Statics to the Rescue&lt;&#x2F;h4&gt;
&lt;p&gt;Fortunately, the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; macro exists. Instead of evaluating a &lt;code&gt;static&lt;&#x2F;code&gt; at compile time, the macro performs the initialization when the &lt;code&gt;static&lt;&#x2F;code&gt; is referenced the first time. Thus, we can do almost everything in the initialization block and are even able to read runtime values.&lt;&#x2F;p&gt;
&lt;p&gt;We already imported the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; crate when we &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#lazy-statics&quot;&gt;created an abstraction for the VGA text buffer&lt;&#x2F;a&gt;. So we can directly use the &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro to create our static IDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: InterruptDescriptorTable = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = InterruptDescriptorTable::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note how this solution requires no &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks. The &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro does use &lt;code&gt;unsafe&lt;&#x2F;code&gt; behind the scenes, but it is abstracted away in a safe interface.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;running-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-it&quot; aria-label=&quot;Anchor link for: running-it&quot;&gt;üîó&lt;&#x2F;a&gt;Running it&lt;&#x2F;h3&gt;
&lt;p&gt;The last step for making exceptions work in our kernel is to call the &lt;code&gt;init_idt&lt;&#x2F;code&gt; function from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;. Instead of calling it directly, we introduce a general &lt;code&gt;init&lt;&#x2F;code&gt; function in our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init_idt();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this function, we now have a central place for initialization routines that can be shared between the different &lt;code&gt;_start&lt;&#x2F;code&gt; functions in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, and integration tests.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can update the &lt;code&gt;_start&lt;&#x2F;code&gt; function of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; to call &lt;code&gt;init&lt;&#x2F;code&gt; and then trigger a breakpoint exception:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    blog_os::init(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; invoke a breakpoint exception
&lt;&#x2F;span&gt;&lt;span&gt;    x86_64::instructions::interrupts::int3(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as before
&lt;&#x2F;span&gt;&lt;span&gt;    #[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it in QEMU now (using &lt;code&gt;cargo run&lt;&#x2F;code&gt;), we see the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cpu-exceptions&#x2F;qemu-breakpoint-exception.png&quot; alt=&quot;QEMU printing EXCEPTION: BREAKPOINT and the interrupt stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It works! The CPU successfully invokes our breakpoint handler, which prints the message, and then returns back to the &lt;code&gt;_start&lt;&#x2F;code&gt; function, where the &lt;code&gt;It did not crash!&lt;&#x2F;code&gt; message is printed.&lt;&#x2F;p&gt;
&lt;p&gt;We see that the interrupt stack frame tells us the instruction and stack pointers at the time when the exception occurred. This information is very useful when debugging unexpected exceptions.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;adding-a-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-a-test&quot; aria-label=&quot;Anchor link for: adding-a-test&quot;&gt;üîó&lt;&#x2F;a&gt;Adding a Test&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs create a test that ensures that the above continues to work. First, we update the &lt;code&gt;_start&lt;&#x2F;code&gt; function to also call &lt;code&gt;init&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Entry point for `cargo test`
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    init();      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    test_main();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remember, this &lt;code&gt;_start&lt;&#x2F;code&gt; function is used when running &lt;code&gt;cargo test --lib&lt;&#x2F;code&gt;, since Rust tests the &lt;code&gt;lib.rs&lt;&#x2F;code&gt; completely independently of the &lt;code&gt;main.rs&lt;&#x2F;code&gt;. We need to call &lt;code&gt;init&lt;&#x2F;code&gt; here to set up an IDT before running the tests.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can create a &lt;code&gt;test_breakpoint_exception&lt;&#x2F;code&gt; test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[test_case]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test_breakpoint_exception() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; invoke a breakpoint exception
&lt;&#x2F;span&gt;&lt;span&gt;    x86_64::instructions::interrupts::int3();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test invokes the &lt;code&gt;int3&lt;&#x2F;code&gt; function to trigger a breakpoint exception. By checking that the execution continues afterward, we verify that our breakpoint handler is working correctly.&lt;&#x2F;p&gt;
&lt;p&gt;You can try this new test by running &lt;code&gt;cargo test&lt;&#x2F;code&gt; (all tests) or &lt;code&gt;cargo test --lib&lt;&#x2F;code&gt; (only tests of &lt;code&gt;lib.rs&lt;&#x2F;code&gt; and its modules). You should see the following in the output:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;blog_os::interrupts::test_breakpoint_exception...	[ok]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;too-much-magic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#too-much-magic&quot; aria-label=&quot;Anchor link for: too-much-magic&quot;&gt;üîó&lt;&#x2F;a&gt;Too much Magic?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.14.2&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type made the exception handling process relatively straightforward and painless. If this was too much magic for you and you like to learn all the gory details of exception handling, we‚Äôve got you covered: Our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;extra&#x2F;naked-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions with Naked Functions‚Äù&lt;&#x2F;a&gt; series shows how to handle exceptions without the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and also creates its own IDT type. Historically, these posts were the main exception handling posts before the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate existed. Note that these posts are based on the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;&quot;&gt;first edition&lt;&#x2F;a&gt; of this blog and might be out of date.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;We‚Äôve successfully caught our first exception and returned from it! The next step is to ensure that we catch all exceptions because an uncaught exception causes a fatal &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Triple_Fault&quot;&gt;triple fault&lt;&#x2F;a&gt;, which leads to a system reset. The next post explains how we can avoid this by correctly catching &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Double_Fault#Double_Fault&quot;&gt;double faults&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Integration Tests</title>
                <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/integration-tests/</link>
                <guid>https://os.phil-opp.com/integration-tests/</guid>
                <description>&lt;p&gt;To complete the testing picture we implement a basic integration test framework, which allows us to run tests on the target system. The idea is to run tests inside QEMU and report the results back to the host through the serial port.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;integration-tests&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;üîó&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;p&gt;This post builds upon the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post, so you need to follow it first. Alternatively, consider reading the new &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post instead, which replaces both &lt;em&gt;Unit Testing&lt;&#x2F;em&gt; and this post. The new posts implements similar functionality, but integrates it directly in &lt;code&gt;cargo xtest&lt;&#x2F;code&gt;, so that both unit and integration tests run in a realistic environment inside QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;üîó&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;In the previous post we added support for unit tests. The goal of unit tests is to test small components in isolation to ensure that each of them works as intended. The tests are run on the host machine and thus shouldn‚Äôt rely on architecture specific functionality.&lt;&#x2F;p&gt;
&lt;p&gt;To test the interaction of the components, both with each other and the system environment, we can write &lt;em&gt;integration tests&lt;&#x2F;em&gt;. Compared to unit tests, √¨ntegration tests are more complex, because they need to run in a realistic environment. What this means depends on the application type. For example, for webserver applications it often means to set up a database instance. For an operating system kernel like ours, it means that we run the tests on the target hardware without an underlying operating system.&lt;&#x2F;p&gt;
&lt;p&gt;Running on the target architecture allows us to test all hardware specific code such as the VGA buffer or the effects of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Page_table&quot;&gt;page table&lt;&#x2F;a&gt; modifications. It also allows us to verify that our kernel boots without problems and that no &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;CPU exception&lt;&#x2F;a&gt; occurs.&lt;&#x2F;p&gt;
&lt;p&gt;In this post we will implement a very basic test framework that runs integration tests inside instances of the &lt;a href=&quot;https:&#x2F;&#x2F;www.qemu.org&#x2F;&quot;&gt;QEMU&lt;&#x2F;a&gt; virtual machine. It is not as realistic as running them on real hardware, but it is much simpler and should be sufficient as long as we only use standard hardware that is well supported in QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-serial-port&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-serial-port&quot; aria-label=&quot;Anchor link for: the-serial-port&quot;&gt;üîó&lt;&#x2F;a&gt;The Serial Port&lt;&#x2F;h2&gt;
&lt;p&gt;The naive way of doing an integration test would be to add some assertions in the code, launch QEMU, and manually check if a panic occurred or not. This is very cumbersome and not practical if we have hundreds of integration tests. So we want an automated solution that runs all tests and fails if not all of them pass.&lt;&#x2F;p&gt;
&lt;p&gt;Such an automated test framework needs to know whether a test succeeded or failed. It can‚Äôt look at the screen output of QEMU, so we need a different way of retrieving the test results on the host system. A simple way to achieve this is by using the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Serial_port&quot;&gt;serial port&lt;&#x2F;a&gt;, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host‚Äôs standard output or a file.&lt;&#x2F;p&gt;
&lt;p&gt;The chips implementing a serial interface are called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter&quot;&gt;UARTs&lt;&#x2F;a&gt;. There are &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Universal_asynchronous_receiver-transmitter#UART_models&quot;&gt;lots of UART models&lt;&#x2F;a&gt; on x86, but fortunately the only differences between them are some advanced features we don‚Äôt need. The common UARTs today are all compatible to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;16550_UART&quot;&gt;16550 UART&lt;&#x2F;a&gt;, so we will use that model for our testing framework.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;port-i-o&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#port-i-o&quot; aria-label=&quot;Anchor link for: port-i-o&quot;&gt;üîó&lt;&#x2F;a&gt;Port I&#x2F;O&lt;&#x2F;h3&gt;
&lt;p&gt;There are two different approaches for communicating between the CPU and peripheral hardware on x86, &lt;strong&gt;memory-mapped I&#x2F;O&lt;&#x2F;strong&gt; and &lt;strong&gt;port-mapped I&#x2F;O&lt;&#x2F;strong&gt;. We already used memory-mapped I&#x2F;O for accessing the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;&quot;&gt;VGA text buffer&lt;&#x2F;a&gt; through the memory address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. This address is not mapped to RAM, but to some memory on the GPU.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, port-mapped I&#x2F;O uses a separate I&#x2F;O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I&#x2F;O port there are special CPU instructions called &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt;, which take a port number and a data byte (there are also variations of these commands that allow sending an &lt;code&gt;u16&lt;&#x2F;code&gt; or &lt;code&gt;u32&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;The UART uses port-mapped I&#x2F;O. Fortunately there are already several crates that provide abstractions for I&#x2F;O ports and even UARTs, so we don‚Äôt need to invoke the &lt;code&gt;in&lt;&#x2F;code&gt; and &lt;code&gt;out&lt;&#x2F;code&gt; assembly instructions manually.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;uart_16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;uart_16550 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2F;code&gt; crate contains a &lt;code&gt;SerialPort&lt;&#x2F;code&gt; struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that we create a new &lt;code&gt;serial&lt;&#x2F;code&gt; module with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;serial;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;serial.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;uart_16550::SerialPort;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;SerialPort&amp;gt; = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; serial_port = SerialPort::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x3F8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        serial_port.init();
&lt;&#x2F;span&gt;&lt;span&gt;        Mutex::new(serial_port)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like with the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#lazy-statics&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;, we use &lt;code&gt;lazy_static&lt;&#x2F;code&gt; and a spinlock to create a &lt;code&gt;static&lt;&#x2F;code&gt;. However, this time we use &lt;code&gt;lazy_static&lt;&#x2F;code&gt; to ensure that the &lt;code&gt;init&lt;&#x2F;code&gt; method is called before first use. We‚Äôre using the port address &lt;code&gt;0x3F8&lt;&#x2F;code&gt;, which is the standard port number for the first serial interface.&lt;&#x2F;p&gt;
&lt;p&gt;To make the serial port easily usable, we add &lt;code&gt;serial_print!&lt;&#x2F;code&gt; and &lt;code&gt;serial_println!&lt;&#x2F;code&gt; macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: ::core::fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface.
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! serial_print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        $crate::serial::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Prints to the host through the serial interface, appending a newline.
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! serial_println {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::serial_print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;SerialPort&lt;&#x2F;code&gt; type already implements the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Write.html&quot;&gt;&lt;code&gt;fmt::Write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait, so we don‚Äôt need to provide an implementation.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can print to the serial interface in our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;serial;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;serial_println&lt;&#x2F;code&gt; macro lives directly under the root namespace because we used the &lt;code&gt;#[macro_export]&lt;&#x2F;code&gt; attribute, so importing it through &lt;code&gt;use crate::serial::serial_println&lt;&#x2F;code&gt; will not work.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qemu-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qemu-arguments&quot; aria-label=&quot;Anchor link for: qemu-arguments&quot;&gt;üîó&lt;&#x2F;a&gt;QEMU Arguments&lt;&#x2F;h3&gt;
&lt;p&gt;To see the serial output in QEMU, we can use the &lt;code&gt;-serial&lt;&#x2F;code&gt; argument to redirect the output to stdout:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 \
&lt;&#x2F;span&gt;&lt;span&gt;    -drive format=raw,file=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin \
&lt;&#x2F;span&gt;&lt;span&gt;    -serial mon:stdio
&lt;&#x2F;span&gt;&lt;span&gt;warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
&lt;&#x2F;span&gt;&lt;span&gt;Hello Host!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you chose a different name than &lt;code&gt;blog_os&lt;&#x2F;code&gt;, you need to update the paths of course. Note that you can no longer exit QEMU through &lt;code&gt;Ctrl+c&lt;&#x2F;code&gt;. As an alternative you can use &lt;code&gt;Ctrl+a&lt;&#x2F;code&gt; and then &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As an alternative to this long command, we can pass the argument to &lt;code&gt;bootimage run&lt;&#x2F;code&gt;, with an additional &lt;code&gt;--&lt;&#x2F;code&gt; to separate the build arguments (passed to cargo) from the run arguments (passed to QEMU).&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;bootimage run -- -serial mon:stdio
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of standard output, QEMU supports &lt;a href=&quot;https:&#x2F;&#x2F;qemu.weilnetz.de&#x2F;doc&#x2F;5.2&#x2F;system&#x2F;invocation.html#hxtool-9&quot;&gt;many more target devices&lt;&#x2F;a&gt;. For redirecting the output to a file, the argument is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;-serial file:output-file.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;shutting-down-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shutting-down-qemu&quot; aria-label=&quot;Anchor link for: shutting-down-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Shutting Down QEMU&lt;&#x2F;h2&gt;
&lt;p&gt;Right now we have an endless loop at the end of our &lt;code&gt;_start&lt;&#x2F;code&gt; function and need to close QEMU manually. This does not work for automated tests. We could try to kill QEMU automatically from the host, for example after some special output was sent over serial, but this would be a bit hacky and difficult to get right. The cleaner solution would be to implement a way to shutdown our OS. Unfortunately this is relatively complex, because it requires implementing support for either the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;APM&quot;&gt;APM&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;ACPI&quot;&gt;ACPI&lt;&#x2F;a&gt; power management standard.&lt;&#x2F;p&gt;
&lt;p&gt;Luckily, there is an escape hatch: QEMU supports a special &lt;code&gt;isa-debug-exit&lt;&#x2F;code&gt; device, which provides an easy way to exit QEMU from the guest system. To enable it, we add the following argument to our QEMU command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;-device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;iobase&lt;&#x2F;code&gt; specifies on which port address the device should live (&lt;code&gt;0xf4&lt;&#x2F;code&gt; is a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;I&#x2F;O_Ports#The_list&quot;&gt;generally unused&lt;&#x2F;a&gt; port on the x86‚Äôs IO bus) and the &lt;code&gt;iosize&lt;&#x2F;code&gt; specifies the port size (&lt;code&gt;0x04&lt;&#x2F;code&gt; means four bytes). Now the guest can write a value to the &lt;code&gt;0xf4&lt;&#x2F;code&gt; port and QEMU will exit with &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exit_status&quot;&gt;exit status&lt;&#x2F;a&gt; &lt;code&gt;(passed_value &amp;lt;&amp;lt; 1) | 1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To write to the I&#x2F;O port, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.5.2&#x2F;x86_64&#x2F;&quot;&gt;&lt;code&gt;x86_64&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.2&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;exit_qemu() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    port.write(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We mark the function as &lt;code&gt;unsafe&lt;&#x2F;code&gt; because it relies on the fact that a special QEMU device is attached to the I&#x2F;O port with address &lt;code&gt;0xf4&lt;&#x2F;code&gt;. For the port type we choose &lt;code&gt;u32&lt;&#x2F;code&gt; because the &lt;code&gt;iosize&lt;&#x2F;code&gt; is 4 bytes. As value we write a zero, which causes QEMU to exit with exit status &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we could also use the exit status instead of the serial interface for sending the test results, for example &lt;code&gt;1&lt;&#x2F;code&gt; for success and &lt;code&gt;2&lt;&#x2F;code&gt; for failure. However, this wouldn‚Äôt allow us to send panic messages like the serial interface does and would also prevent us from replacing &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; with a proper shutdown someday. Therefore we continue to use the serial interface and just always write a &lt;code&gt;0&lt;&#x2F;code&gt; to the port.&lt;&#x2F;p&gt;
&lt;p&gt;We can now test the QEMU shutdown by calling &lt;code&gt;exit_qemu&lt;&#x2F;code&gt; from our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ exit_qemu(); }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see that QEMU immediately closes after booting when executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;bootimage run -- -serial mon:stdio -device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hiding-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-qemu&quot; aria-label=&quot;Anchor link for: hiding-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Hiding QEMU&lt;&#x2F;h2&gt;
&lt;p&gt;We are now able to launch a QEMU instance that writes its output to the serial port and automatically exits itself when it‚Äôs done. So we no longer need the VGA buffer output or the graphical representation that still pops up. We can disable it by passing the &lt;code&gt;-display none&lt;&#x2F;code&gt; parameter to QEMU. The full command looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;qemu-system-x86_64 \
&lt;&#x2F;span&gt;&lt;span&gt;    -drive format=raw,file=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin \
&lt;&#x2F;span&gt;&lt;span&gt;    -serial mon:stdio \
&lt;&#x2F;span&gt;&lt;span&gt;    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
&lt;&#x2F;span&gt;&lt;span&gt;    -display none
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or, with &lt;code&gt;bootimage run&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;bootimage run -- \
&lt;&#x2F;span&gt;&lt;span&gt;    -serial mon:stdio \
&lt;&#x2F;span&gt;&lt;span&gt;    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
&lt;&#x2F;span&gt;&lt;span&gt;    -display none
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now QEMU runs completely in the background and no window is opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as &lt;a href=&quot;https:&#x2F;&#x2F;travis-ci.com&#x2F;&quot;&gt;Travis CI&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;test-organization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-organization&quot; aria-label=&quot;Anchor link for: test-organization&quot;&gt;üîó&lt;&#x2F;a&gt;Test Organization&lt;&#x2F;h2&gt;
&lt;p&gt;Right now we‚Äôre doing the serial output and the QEMU exit from the &lt;code&gt;_start&lt;&#x2F;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2F;code&gt; and can no longer run our kernel in a normal way. We could try to fix this by adding an &lt;code&gt;integration-test&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;features.html#the-features-section&quot;&gt;cargo feature&lt;&#x2F;a&gt; and using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;features&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;integration-test &lt;&#x2F;span&gt;&lt;span&gt;= []
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(feature &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; prints to vga buffer
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; normal execution
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(feature &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    run_test_1();
&lt;&#x2F;span&gt;&lt;span&gt;    run_test_2();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; run more tests
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ exit_qemu(); }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, this approach has a big problem: All tests run in the same kernel instance, which means that they can influence each other. For example, if &lt;code&gt;run_test_1&lt;&#x2F;code&gt; misconfigures the system by loading an invalid &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Page_table&quot;&gt;page table&lt;&#x2F;a&gt;, it can cause &lt;code&gt;run_test_2&lt;&#x2F;code&gt; to fail. This isn‚Äôt something that we want because it makes it very difficult to find the actual cause of an error.&lt;&#x2F;p&gt;
&lt;p&gt;Instead, we want our test instances to be as independent as possible. If a test wants to destroy most of the system configuration to ensure that some property still holds in catastrophic situations, it should be able to do so without needing to restore a correct system state afterwards. This means that we need to launch a separate QEMU instance for each test.&lt;&#x2F;p&gt;
&lt;p&gt;With the above conditional compilation we only have two modes: Run the kernel normally or execute &lt;em&gt;all&lt;&#x2F;em&gt; integration tests. To run each test in isolation we would need a separate cargo feature for each test with that approach, which would result in very complex conditional compilation bounds and confusing code.&lt;&#x2F;p&gt;
&lt;p&gt;A better solution is to create an additional executable for each test.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;additional-test-executables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#additional-test-executables&quot; aria-label=&quot;Anchor link for: additional-test-executables&quot;&gt;üîó&lt;&#x2F;a&gt;Additional Test Executables&lt;&#x2F;h3&gt;
&lt;p&gt;Cargo allows to add &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;guide&#x2F;project-layout.html&quot;&gt;additional executables&lt;&#x2F;a&gt; to a project by putting them inside &lt;code&gt;src&#x2F;bin&lt;&#x2F;code&gt;. We can use that feature to create a separate executable for each integration test. For example, a &lt;code&gt;test-something&lt;&#x2F;code&gt; executable could be added like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;bin&#x2F;test-something.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_main)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; run tests
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By providing a new implementation for &lt;code&gt;_start&lt;&#x2F;code&gt; we can create a minimal test case that only tests one specific thing and is independent of the rest. For example, if we don‚Äôt print anything to the VGA buffer, the test still succeeds even if the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module is broken.&lt;&#x2F;p&gt;
&lt;p&gt;We can now run this executable in QEMU by passing a &lt;code&gt;--bin&lt;&#x2F;code&gt; argument to &lt;code&gt;bootimage&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;bootimage run --bin test-something
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should build the &lt;code&gt;test-something.rs&lt;&#x2F;code&gt; executable instead of &lt;code&gt;main.rs&lt;&#x2F;code&gt; and launch an empty QEMU window (since we don‚Äôt print anything). So this approach allows us to create completely independent executables without cargo features or conditional compilation, and without cluttering our &lt;code&gt;main.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is a problem: This is a completely separate executable, which means that we can‚Äôt access any functions from our &lt;code&gt;main.rs&lt;&#x2F;code&gt;, including &lt;code&gt;serial_println&lt;&#x2F;code&gt; and &lt;code&gt;exit_qemu&lt;&#x2F;code&gt;. Duplicating the code would work, but we would also need to copy everything we want to test. This would mean that we no longer test the original function but only a possibly outdated copy.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately there is a way to share most of the code between our &lt;code&gt;main.rs&lt;&#x2F;code&gt; and the testing binaries: We move most of the code from our &lt;code&gt;main.rs&lt;&#x2F;code&gt; to a library that we can include from all executables.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;split-off-a-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#split-off-a-library&quot; aria-label=&quot;Anchor link for: split-off-a-library&quot;&gt;üîó&lt;&#x2F;a&gt;Split Off A Library&lt;&#x2F;h3&gt;
&lt;p&gt;Cargo supports hybrid projects that are both a library and a binary. We only need to create a &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt; file and split the contents of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_std)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t link the Rust standard library
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; NEW: We need to add `pub` here to make them accessible from the outside
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2F;span&gt;&lt;span&gt;serial;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;exit_qemu() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::port::Port;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; port = Port::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    port.write(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_main)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::println;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is the entry point, since the linker looks for a function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; named `_start` by default.
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we move everything except &lt;code&gt;_start&lt;&#x2F;code&gt; and &lt;code&gt;panic&lt;&#x2F;code&gt; to &lt;code&gt;lib.rs&lt;&#x2F;code&gt; and make the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; and &lt;code&gt;serial&lt;&#x2F;code&gt; modules public. Everything should work exactly as before, including &lt;code&gt;bootimage run&lt;&#x2F;code&gt; and &lt;code&gt;cargo test&lt;&#x2F;code&gt;. To run tests only for the library part of our crate and avoid the additional output we can execute &lt;code&gt;cargo test --lib&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;test-basic-boot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-basic-boot&quot; aria-label=&quot;Anchor link for: test-basic-boot&quot;&gt;üîó&lt;&#x2F;a&gt;Test Basic Boot&lt;&#x2F;h3&gt;
&lt;p&gt;We are finally able to create our first integration test executable. We start simple and only test that the basic boot sequence works and the &lt;code&gt;_start&lt;&#x2F;code&gt; function is called:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;bin&#x2F;test-basic-boot.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_main)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; disable all Rust-level entry points
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::{exit_qemu, serial_println};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is the entry point, since the linker looks for a function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; named `_start` by default.
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ exit_qemu(); }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;failed&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ exit_qemu(); }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don‚Äôt do something special here, we just print &lt;code&gt;ok&lt;&#x2F;code&gt; if &lt;code&gt;_start&lt;&#x2F;code&gt; is called and &lt;code&gt;failed&lt;&#x2F;code&gt; with the panic message when a panic occurs. Let‚Äôs try it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; bootimage run --bin test-basic-boot -- \
&lt;&#x2F;span&gt;&lt;span&gt;    -serial mon:stdio -display none \
&lt;&#x2F;span&gt;&lt;span&gt;    -device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2F;span&gt;&lt;span&gt;Building kernel
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
&lt;&#x2F;span&gt;&lt;span&gt;    Updating registry `https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;crates.io-index`
&lt;&#x2F;span&gt;&lt;span&gt;Creating disk image at target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-test-basic-boot.bin
&lt;&#x2F;span&gt;&lt;span&gt;warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
&lt;&#x2F;span&gt;&lt;span&gt;ok
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We got our &lt;code&gt;ok&lt;&#x2F;code&gt;, so it worked! Try inserting a &lt;code&gt;panic!()&lt;&#x2F;code&gt; before the &lt;code&gt;ok&lt;&#x2F;code&gt; printing, you should see output like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;failed
&lt;&#x2F;span&gt;&lt;span&gt;panicked at &amp;#39;explicit panic&amp;#39;, src&#x2F;bin&#x2F;test-basic-boot.rs:19:5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;test-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-panic&quot; aria-label=&quot;Anchor link for: test-panic&quot;&gt;üîó&lt;&#x2F;a&gt;Test Panic&lt;&#x2F;h3&gt;
&lt;p&gt;To test that our panic handler is really invoked on a panic, we create a &lt;code&gt;test-panic&lt;&#x2F;code&gt; test:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;bin&#x2F;test-panic.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_main)]
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;blog_os::{exit_qemu, serial_println};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    panic!();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    serial_println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ exit_qemu(); }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This executable is almost identical to &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt;, the only difference is that we print &lt;code&gt;ok&lt;&#x2F;code&gt; from our panic handler and invoke an explicit &lt;code&gt;panic()&lt;&#x2F;code&gt; in our &lt;code&gt;_start&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-test-runner&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-test-runner&quot; aria-label=&quot;Anchor link for: a-test-runner&quot;&gt;üîó&lt;&#x2F;a&gt;A Test Runner&lt;&#x2F;h2&gt;
&lt;p&gt;The final step is to create a test runner, a program that executes all integration tests and checks their results. The basic steps that it should do are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Look for integration tests in the current project, maybe by some convention (e.g. executables starting with &lt;code&gt;test-&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;Run all integration tests and interpret their results.
&lt;ul&gt;
&lt;li&gt;Use a timeout to ensure that an endless loop does not block the test runner forever.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Report the test results to the user and set a successful or failing exit status.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Such a test runner is useful to many projects, so we decided to add one to the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bootimage-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bootimage-test&quot; aria-label=&quot;Anchor link for: bootimage-test&quot;&gt;üîó&lt;&#x2F;a&gt;Bootimage Test&lt;&#x2F;h3&gt;
&lt;p&gt;The test runner of the &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool can be invoked via &lt;code&gt;bootimage test&lt;&#x2F;code&gt;. It uses the following conventions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;All executables starting with &lt;code&gt;test-&lt;&#x2F;code&gt; are treated as integration tests.&lt;&#x2F;li&gt;
&lt;li&gt;Tests must print either &lt;code&gt;ok&lt;&#x2F;code&gt; or &lt;code&gt;failed&lt;&#x2F;code&gt; over the serial port. When printing &lt;code&gt;failed&lt;&#x2F;code&gt; they can print additional information such as a panic message (in the next lines).&lt;&#x2F;li&gt;
&lt;li&gt;Tests are run with a timeout of 1 minute. If the test has not completed in time, it is reported as ‚Äútimed out‚Äù.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt; and &lt;code&gt;test-panic&lt;&#x2F;code&gt; tests we created above begin with &lt;code&gt;test-&lt;&#x2F;code&gt; and follow the &lt;code&gt;ok&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;failed&lt;&#x2F;code&gt; conventions, so they should work with &lt;code&gt;bootimage test&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; bootimage test
&lt;&#x2F;span&gt;&lt;span&gt;test-panic
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
&lt;&#x2F;span&gt;&lt;span&gt;Ok
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;test-basic-boot
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
&lt;&#x2F;span&gt;&lt;span&gt;Ok
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;test-something
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
&lt;&#x2F;span&gt;&lt;span&gt;Timed Out
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;The following tests failed:
&lt;&#x2F;span&gt;&lt;span&gt;    test-something: TimedOut
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that our &lt;code&gt;test-panic&lt;&#x2F;code&gt; and &lt;code&gt;test-basic-boot&lt;&#x2F;code&gt; succeeded and that the &lt;code&gt;test-something&lt;&#x2F;code&gt; test timed out after one minute. We no longer need &lt;code&gt;test-something&lt;&#x2F;code&gt;, so we delete it (if you haven‚Äôt done already). Now &lt;code&gt;bootimage test&lt;&#x2F;code&gt; should execute successfully.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we learned about the serial port and port-mapped I&#x2F;O and saw how to configure QEMU to print serial output to the command line. We also learned a trick how to exit QEMU without needing to implement a proper shutdown.&lt;&#x2F;p&gt;
&lt;p&gt;We then split our crate into a library and binary part in order to create additional executables for integration tests. We added two example tests for testing that the &lt;code&gt;_start&lt;&#x2F;code&gt; function is correctly called and that a &lt;code&gt;panic&lt;&#x2F;code&gt; invokes our panic handler. Finally, we presented &lt;code&gt;bootimage test&lt;&#x2F;code&gt; as a basic test runner for our integration tests.&lt;&#x2F;p&gt;
&lt;p&gt;We now have a working integration test framework and can finally start to implement functionality in our kernel. We will continue to use the test framework over the next posts to test new components we add.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2F;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called ‚Äúpage fault‚Äù). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Unit Testing</title>
                <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/unit-testing/</link>
                <guid>https://os.phil-opp.com/unit-testing/</guid>
                <description>&lt;p&gt;This post explores unit testing in &lt;code&gt;no_std&lt;&#x2F;code&gt; executables using Rust‚Äôs built-in test framework. We will adjust our code so that &lt;code&gt;cargo test&lt;&#x2F;code&gt; works and add some basic unit tests to our VGA buffer module.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;üîó&lt;&#x2F;a&gt;Requirements&lt;&#x2F;h2&gt;
&lt;p&gt;In this post we explore how to execute &lt;code&gt;cargo test&lt;&#x2F;code&gt; on the host system (as a normal Linux&#x2F;Windows&#x2F;macOS executable). This only works if you don‚Äôt have a &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file that sets a default target. If you followed the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;&quot;&gt;&lt;em&gt;Minimal Rust Kernel&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post before 2019-04-27, you should be fine. If you followed it after that date, you need to remove the &lt;code&gt;build.target&lt;&#x2F;code&gt; key from your &lt;code&gt;.cargo&#x2F;config&lt;&#x2F;code&gt; file and explicitly pass a target argument to &lt;code&gt;cargo xbuild&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Alternatively, consider reading the new &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;testing&#x2F;&quot;&gt;&lt;em&gt;Testing&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post instead. It sets up a similar functionality as this post, but instead of running the tests on your host system, they are run in a realistic environment inside QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unit-tests-for-no-std-binaries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unit-tests-for-no-std-binaries&quot; aria-label=&quot;Anchor link for: unit-tests-for-no-std-binaries&quot;&gt;üîó&lt;&#x2F;a&gt;Unit Tests for &lt;code&gt;no_std&lt;&#x2F;code&gt; Binaries&lt;&#x2F;h2&gt;
&lt;p&gt;Rust has a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-00-testing.html&quot;&gt;built-in test framework&lt;&#x2F;a&gt; that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute to the function header. Then &lt;code&gt;cargo test&lt;&#x2F;code&gt; will automatically find and execute all test functions of your crate.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately it‚Äôs a bit more complicated for &lt;code&gt;no_std&lt;&#x2F;code&gt; applications such as our kernel. If we run &lt;code&gt;cargo test&lt;&#x2F;code&gt; (without adding any test yet), we get the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;error[E0152]: duplicate lang item found: `panic_impl`.
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;main.rs:35:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;35 | &#x2F; fn panic(info: &amp;amp;PanicInfo) -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;36 | |     println!(&amp;quot;{}&amp;quot;, info);
&lt;&#x2F;span&gt;&lt;span&gt;37 | |     loop {}
&lt;&#x2F;span&gt;&lt;span&gt;38 | | }
&lt;&#x2F;span&gt;&lt;span&gt;   | |_^
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = note: first defined in crate `std`.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that unit tests are built for the host machine, with the &lt;code&gt;std&lt;&#x2F;code&gt; library included. This makes sense because they should be able to run as a normal application on the host operating system. Since the standard library has it‚Äôs own &lt;code&gt;panic_handler&lt;&#x2F;code&gt; function, we get the above error. To fix it, we use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2F;a&gt; to include our implementation of the panic handler only in non-test environments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; only compile when the test flag is not set
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only change is the added &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt; attribute. The &lt;code&gt;#[cfg(‚Ä¶)]&lt;&#x2F;code&gt; attribute ensures that the annotated item is only included if the passed condition is met. The &lt;code&gt;test&lt;&#x2F;code&gt; configuration is set when the crate is compiled for unit tests. Through &lt;code&gt;not(‚Ä¶)&lt;&#x2F;code&gt; we negate the condition so that the language item is only compiled for non-test builds.&lt;&#x2F;p&gt;
&lt;p&gt;When we now try &lt;code&gt;cargo test&lt;&#x2F;code&gt; again, we get an ugly linker error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `cc` failed: exit code: 1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;cc&amp;quot; &amp;quot;-Wl,--as-needed&amp;quot; &amp;quot;-Wl,-z,noexecstack&amp;quot; &amp;quot;-m64&amp;quot; &amp;quot;-L&amp;quot; &amp;quot;&#x2F;‚Ä¶&#x2F;lib&#x2F;rustlib&#x2F;x86_64-unknown-linux-gnu&#x2F;lib&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &#x2F;‚Ä¶&#x2F;blog_os-969bdb90d27730ed.2q644ojj2xqxddld.rcgu.o: In function `_start&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;          &#x2F;‚Ä¶&#x2F;blog_os&#x2F;src&#x2F;main.rs:17: multiple definition of `_start&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o:(.text+0x0): first defined here
&lt;&#x2F;span&gt;&lt;span&gt;          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o: In function `_start&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;          (.text+0x20): undefined reference to `main&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;          collect2: error: ld returned 1 exit status
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I shortened the output here because it is extremely verbose. The relevant part is at the bottom, after the second ‚Äúnote:‚Äù. We got two distinct errors here, ‚Äú&lt;em&gt;multiple definition of &lt;code&gt;_start&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;‚Äù and ‚Äú&lt;em&gt;undefined reference to &lt;code&gt;main&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;‚Äù.&lt;&#x2F;p&gt;
&lt;p&gt;The reason for the first error is that the test framework injects its own &lt;code&gt;main&lt;&#x2F;code&gt; and &lt;code&gt;_start&lt;&#x2F;code&gt; functions, which will run the tests when invoked. So we get two functions named &lt;code&gt;_start&lt;&#x2F;code&gt; when compiling in test mode, one from the test framework and the one we defined ourselves. To fix this, we need to exclude our &lt;code&gt;_start&lt;&#x2F;code&gt; function in that case, which we can do by marking it as &lt;code&gt;#[cfg(not(test))]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(not(test))]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{ ‚Ä¶ }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The second problem is that we use the &lt;code&gt;#![no_main]&lt;&#x2F;code&gt; attribute for our crate, which suppresses any &lt;code&gt;main&lt;&#x2F;code&gt; generation, including the test &lt;code&gt;main&lt;&#x2F;code&gt;. To solve this, we use the &lt;a href=&quot;https:&#x2F;&#x2F;chrismorgan.info&#x2F;blog&#x2F;rust-cfg_attr.html&quot;&gt;&lt;code&gt;cfg_attr&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attribute to conditionally enable the &lt;code&gt;no_main&lt;&#x2F;code&gt; attribute only in non-test mode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![cfg_attr(not(test), no_main)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; instead of `#![no_main]`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;cargo test&lt;&#x2F;code&gt; works:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;    [some warnings]
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.98 secs
&lt;&#x2F;span&gt;&lt;span&gt;     Running target&#x2F;debug&#x2F;deps&#x2F;blog_os-1f08396a9eff0aa7
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;running 0 tests
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The test framework seems to work as intended. We don‚Äôt have any tests yet, but we already get a test result summary.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;silencing-the-warnings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#silencing-the-warnings&quot; aria-label=&quot;Anchor link for: silencing-the-warnings&quot;&gt;üîó&lt;&#x2F;a&gt;Silencing the Warnings&lt;&#x2F;h3&gt;
&lt;p&gt;We get a few warnings about unused imports, because we no longer compile our &lt;code&gt;_start&lt;&#x2F;code&gt; function. To silence such unused code warnings, we can add the following to the top of our &lt;code&gt;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like before, the &lt;code&gt;cfg_attr&lt;&#x2F;code&gt; attribute sets the passed attribute if the passed condition holds. Here, we set the &lt;code&gt;allow(‚Ä¶)&lt;&#x2F;code&gt; attribute when compiling in test mode. We use the &lt;code&gt;allow&lt;&#x2F;code&gt; attribute to disable warnings for the &lt;code&gt;unused_import&lt;&#x2F;code&gt; &lt;em&gt;lint&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Lints are classes of warnings, for example &lt;code&gt;dead_code&lt;&#x2F;code&gt; for unused code or &lt;code&gt;missing-docs&lt;&#x2F;code&gt; for missing documentation. Lints can be set to four different states:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow&lt;&#x2F;code&gt;: no errors, no warnings&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;warn&lt;&#x2F;code&gt;: causes a warning&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;deny&lt;&#x2F;code&gt;: causes a compilation error&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;forbid&lt;&#x2F;code&gt;: like &lt;code&gt;deny&lt;&#x2F;code&gt;, but can‚Äôt be overridden&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Some lints are &lt;code&gt;allow&lt;&#x2F;code&gt; by default (such as &lt;code&gt;missing-docs&lt;&#x2F;code&gt;), others are &lt;code&gt;warn&lt;&#x2F;code&gt; by default (such as &lt;code&gt;dead_code&lt;&#x2F;code&gt;), and some few are even &lt;code&gt;deny&lt;&#x2F;code&gt; by default.. The default can be overridden by the &lt;code&gt;allow&lt;&#x2F;code&gt;, &lt;code&gt;warn&lt;&#x2F;code&gt;, &lt;code&gt;deny&lt;&#x2F;code&gt; and &lt;code&gt;forbid&lt;&#x2F;code&gt; attributes. For a list of all lints, see &lt;code&gt;rustc -W help&lt;&#x2F;code&gt;. There is also the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang-nursery&#x2F;rust-clippy&quot;&gt;clippy&lt;&#x2F;a&gt; project, which provides many additional lints.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;including-the-standard-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#including-the-standard-library&quot; aria-label=&quot;Anchor link for: including-the-standard-library&quot;&gt;üîó&lt;&#x2F;a&gt;Including the Standard Library&lt;&#x2F;h3&gt;
&lt;p&gt;Unit tests run on the host machine, so it‚Äôs possible to use the complete standard library inside them. To link the standard library in test mode, we can make the &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; attribute conditional through &lt;code&gt;cfg_attr&lt;&#x2F;code&gt; too:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;-#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;+#![cfg_attr(not(test), no_std)]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;testing-the-vga-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-the-vga-module&quot; aria-label=&quot;Anchor link for: testing-the-vga-module&quot;&gt;üîó&lt;&#x2F;a&gt;Testing the VGA Module&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have set up the test framework, we can add a first unit test for our &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;test {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[test]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;foo() {}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add the test in an inline &lt;code&gt;test&lt;&#x2F;code&gt; submodule. This isn‚Äôt necessary, but a common way to separate test code from the rest of the module. By adding the &lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt; attribute, we ensure that the module is only compiled in test mode. Through &lt;code&gt;use super::*&lt;&#x2F;code&gt;, we import all items of the parent module (the &lt;code&gt;vga_buffer&lt;&#x2F;code&gt; module), so that we can test them easily.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute on the &lt;code&gt;foo&lt;&#x2F;code&gt; function tells the test framework that the function is an unit test. The framework will find it automatically, even if it‚Äôs private and inside a private module as in our case:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo test
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.2.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 2.99 secs
&lt;&#x2F;span&gt;&lt;span&gt;     Running target&#x2F;debug&#x2F;deps&#x2F;blog_os-1f08396a9eff0aa7
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;running 1 test
&lt;&#x2F;span&gt;&lt;span&gt;test vga_buffer::test::foo ... ok
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that the test was found and executed. It didn‚Äôt panic, so it counts as passed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;constructing-a-writer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constructing-a-writer&quot; aria-label=&quot;Anchor link for: constructing-a-writer&quot;&gt;üîó&lt;&#x2F;a&gt;Constructing a Writer&lt;&#x2F;h3&gt;
&lt;p&gt;In order to test the VGA methods, we first need to construct a &lt;code&gt;Writer&lt;&#x2F;code&gt; instance. Since we will need such an instance for other tests too, we create a separate function for it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[cfg(test)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;test {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;construct_writer() -&amp;gt; Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::boxed::Box;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; buffer = construct_buffer();
&lt;&#x2F;span&gt;&lt;span&gt;        Writer {
&lt;&#x2F;span&gt;&lt;span&gt;            column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            color_code: ColorCode::new(Color::Blue, Color::Magenta),
&lt;&#x2F;span&gt;&lt;span&gt;            buffer: Box::leak(Box::new(buffer)),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;construct_buffer() -&amp;gt; Buffer { ‚Ä¶ }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the initial column position to 0 and choose some arbitrary colors for foreground and background color. The difficult part is the buffer construction, it‚Äôs described in detail below. We then use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; to transform the created &lt;code&gt;Buffer&lt;&#x2F;code&gt; into a &lt;code&gt;&amp;amp;&#x27;static mut Buffer&lt;&#x2F;code&gt;, because the &lt;code&gt;buffer&lt;&#x2F;code&gt; field needs to be of that type.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;buffer-construction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buffer-construction&quot; aria-label=&quot;Anchor link for: buffer-construction&quot;&gt;üîó&lt;&#x2F;a&gt;Buffer Construction&lt;&#x2F;h4&gt;
&lt;p&gt;So how do we create a &lt;code&gt;Buffer&lt;&#x2F;code&gt; instance? The naive approach does not work unfortunately:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;construct_buffer() -&amp;gt; Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;        chars: [[Volatile::new(empty_char()); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2F;span&gt;&lt;span&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;empty_char() -&amp;gt; ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;    ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;        ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::Green, Color::Brown),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When running &lt;code&gt;cargo test&lt;&#x2F;code&gt; the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0277]: the trait bound `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;: core::marker::Copy` is not satisfied
&lt;&#x2F;span&gt;&lt;span&gt;   --&amp;gt; src&#x2F;vga_buffer.rs:186:21
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;186 |             chars: [[Volatile::new(empty_char); BUFFER_WIDTH]; BUFFER_HEIGHT],
&lt;&#x2F;span&gt;&lt;span&gt;    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `core::marker::Copy` is not implemented for `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;    = note: the `Copy` trait is required because the repeated element will be copied
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that array construction in Rust requires that the contained type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; is &lt;code&gt;Copy&lt;&#x2F;code&gt;, but the &lt;code&gt;Volatile&lt;&#x2F;code&gt; wrapper is not. There is currently no easy way to circumvent this without using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, but fortunately there is the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;array-init&quot;&gt;&lt;code&gt;array_init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate that provides a safe interface for such operations.&lt;&#x2F;p&gt;
&lt;p&gt;To use that crate, we add the following to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dev-dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;array-init &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.0.3&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we‚Äôre using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html#development-dependencies&quot;&gt;&lt;code&gt;dev-dependencies&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; table instead of the &lt;code&gt;dependencies&lt;&#x2F;code&gt; table, because we only need the crate for &lt;code&gt;cargo test&lt;&#x2F;code&gt; and not for a normal build.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can fix our &lt;code&gt;construct_buffer&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;construct_buffer() -&amp;gt; Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;array_init::array_init;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;        chars: array_init(|_| array_init(|_| Volatile::new(empty_char()))),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;array-init&quot;&gt;documentation of &lt;code&gt;array_init&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for more information about using that crate.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-write-byte&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-write-byte&quot; aria-label=&quot;Anchor link for: testing-write-byte&quot;&gt;üîó&lt;&#x2F;a&gt;Testing &lt;code&gt;write_byte&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now we‚Äôre finally able to write a first unit test that tests the &lt;code&gt;write_byte&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;test {
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[test]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;write_byte() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = construct_writer();
&lt;&#x2F;span&gt;&lt;span&gt;        writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, row) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; writer.buffer.chars.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(j, screen_char) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; row.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; screen_char = screen_char.read();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char, empty_char());
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We construct a &lt;code&gt;Writer&lt;&#x2F;code&gt;, write two bytes to it, and then check that the right screen characters were updated. When we run &lt;code&gt;cargo test&lt;&#x2F;code&gt;, we see that the test is executed and passes:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;running 1 test
&lt;&#x2F;span&gt;&lt;span&gt;test vga_buffer::test::write_byte ... ok
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Try to play around a bit with this function and verify that the test fails if you change something, e.g. if you print a third byte without adjusting the &lt;code&gt;for&lt;&#x2F;code&gt; loop.&lt;&#x2F;p&gt;
&lt;p&gt;(If you‚Äôre getting an ‚Äúbinary operation &lt;code&gt;==&lt;&#x2F;code&gt; cannot be applied to type &lt;code&gt;vga_buffer::ScreenChar&lt;&#x2F;code&gt;‚Äù error, you need to also derive &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cmp&#x2F;trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; and &lt;code&gt;ColorCode&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-strings&quot; aria-label=&quot;Anchor link for: testing-strings&quot;&gt;üîó&lt;&#x2F;a&gt;Testing Strings&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs add a second unit test to test formatted output and newline behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;test {
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[test]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;write_formatted() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = construct_writer();
&lt;&#x2F;span&gt;&lt;span&gt;        writeln!(&amp;amp;mut writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        writeln!(&amp;amp;mut writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, row) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; writer.buffer.chars.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(j, screen_char) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; row.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; screen_char = screen_char.read();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;a&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;b&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; i == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; j == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;c&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; i &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.ascii_character, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char.color_code, writer.color_code);
&lt;&#x2F;span&gt;&lt;span&gt;                } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    assert_eq!(screen_char, empty_char());
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this test we‚Äôre using the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;macro.writeln.html&quot;&gt;&lt;code&gt;writeln!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro to print strings with newlines to the buffer. Most of the for loop is similar to the &lt;code&gt;write_byte&lt;&#x2F;code&gt; test and only verifies if the written characters are at the expected place. The new &lt;code&gt;if i &amp;gt;= BUFFER_HEIGHT - 2&lt;&#x2F;code&gt; case verifies that the empty lines that are shifted in on a newline have the &lt;code&gt;writer.color_code&lt;&#x2F;code&gt;, which is different from the initial color.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-tests&quot; aria-label=&quot;Anchor link for: more-tests&quot;&gt;üîó&lt;&#x2F;a&gt;More Tests&lt;&#x2F;h3&gt;
&lt;p&gt;We only present two basic tests here as an example, but of course many more tests are possible. For example a test that changes the writer color in between writes. Or a test that checks that the top line is correctly shifted off the screen on a newline. Or a test that checks that non-ASCII characters are handled correctly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Unit testing is a very useful technique to ensure that certain components have a desired behavior. Even if they cannot show the absence of bugs, they‚Äôre still an useful tool for finding them and especially for avoiding regressions.&lt;&#x2F;p&gt;
&lt;p&gt;This post explained how to set up unit testing in a Rust kernel. We now have a functioning test framework and can easily add tests by adding functions with a &lt;code&gt;#[test]&lt;&#x2F;code&gt; attribute. To run them, a short &lt;code&gt;cargo test&lt;&#x2F;code&gt; suffices. We also added a few basic tests for our VGA buffer as an example how unit tests could look like.&lt;&#x2F;p&gt;
&lt;p&gt;We also learned a bit about conditional compilation, Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;#silencing-the-warnings&quot;&gt;lint system&lt;&#x2F;a&gt;, how to &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;unit-testing&#x2F;#buffer-construction&quot;&gt;initialize arrays with non-Copy types&lt;&#x2F;a&gt;, and the &lt;code&gt;dev-dependencies&lt;&#x2F;code&gt; section of the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;We now have a working unit testing framework, which gives us the ability to test individual components. However, unit tests have the disadvantage that they run on the host machine and are thus unable to test how components interact with platform specific parts. For example, we can‚Äôt test the &lt;code&gt;println!&lt;&#x2F;code&gt; macro with an unit test because it wants to write at the VGA text buffer at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;, which only exists in the bare metal environment.&lt;&#x2F;p&gt;
&lt;p&gt;The next post will close this gap by creating a basic &lt;em&gt;integration test&lt;&#x2F;em&gt; framework, which runs the tests in QEMU and thus has access to platform specific components. This will allow us to test the full system, for example that our kernel boots correctly or that no deadlock occurs on nested &lt;code&gt;println!&lt;&#x2F;code&gt; invocations.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Writing an OS in pure Rust</title>
                <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/news/pure-rust/</link>
                <guid>https://os.phil-opp.com/news/pure-rust/</guid>
                <description>&lt;p&gt;Over the past six months we‚Äôve been working on a second edition of this blog. Our goals for this new version are &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;360&quot;&gt;numerous&lt;&#x2F;a&gt; and we are still not done yet, but today we reached a major milestone: It is now possible to build the OS natively on Windows, macOS, and Linux &lt;strong&gt;without any non-Rust dependendencies&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;&quot;&gt;first edition&lt;&#x2F;a&gt; required several C-tools for building:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We used the &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;grub&#x2F;&quot;&gt;&lt;code&gt;GRUB&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; bootloader for booting our kernel. To create a bootable disk&#x2F;CD image we used the &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;grub&#x2F;manual&#x2F;grub&#x2F;html_node&#x2F;Invoking-grub_002dmkrescue.html&quot;&gt;&lt;code&gt;grub-mkrescue&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; tool, which is very difficult to get to run on Windows.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;xorriso&#x2F;&quot;&gt;&lt;code&gt;xorriso&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; program was also required, because it is used by &lt;code&gt;grub-mkrescue&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;GRUB only boots to protected mode, so we needed some assembly code for &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;&quot;&gt;entering long mode&lt;&#x2F;a&gt;. For building the assembly code, we used the &lt;a href=&quot;https:&#x2F;&#x2F;www.nasm.us&#x2F;xdoc&#x2F;2.13.03&#x2F;html&#x2F;nasmdoc1.html&quot;&gt;&lt;code&gt;nasm&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; assembler.&lt;&#x2F;li&gt;
&lt;li&gt;We used the GNU linker &lt;a href=&quot;https:&#x2F;&#x2F;ftp.gnu.org&#x2F;old-gnu&#x2F;Manuals&#x2F;ld-2.9.1&#x2F;html_node&#x2F;ld_3.html&quot;&gt;&lt;code&gt;ld&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for linking together the assembly files with the rust code, using a custom &lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;ld&#x2F;Scripts.html&quot;&gt;linker script&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, we used &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;&quot;&gt;&lt;code&gt;make&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for automating the various build steps (assembling, compiling the Rust code, linking, invoking &lt;code&gt;grub-mkrescue&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We got lots of feedback that this setup was difficult to get running &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;55&quot;&gt;under macOS&lt;&#x2F;a&gt; and Windows. As a workaround, we &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;pull&#x2F;373&quot;&gt;added support for docker&lt;&#x2F;a&gt;, but that still required users to install and understand an additional dependency. So when we decided to create a second edition of the blog - originally because the order of posts led to jumps in difficulty - we thought about how we could avoid these C-dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;There are lots of alternatives to &lt;code&gt;make&lt;&#x2F;code&gt;, including some Rust tools such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&quot;&gt;just&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;sagiegurari.github.io&#x2F;cargo-make&#x2F;&quot;&gt;cargo-make&lt;&#x2F;a&gt;. Avoiding &lt;code&gt;nasm&lt;&#x2F;code&gt; is also possible by using Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;arch&#x2F;macro.global_asm.html&quot;&gt;&lt;code&gt;global_asm&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; feature instead. So there are only two problems left: the bootloader and the linker.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-custom-bootloader&quot;&gt;A custom Bootloader&lt;&#x2F;h2&gt;
&lt;p&gt;To avoid the dependency on GRUB and to make things more ergonomic, we decided to write &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootloader&quot;&gt;our own bootloader&lt;&#x2F;a&gt; using Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;arch&#x2F;macro.global_asm.html&quot;&gt;&lt;code&gt;global_asm&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; feature. This way, the kernel can be significantly simplified, since the switch to long mode and the initial page table layout can already be done in the bootloader. Thus, we can avoid the initial assembly level blog posts in the second edition and directly start with high level Rust code.&lt;&#x2F;p&gt;
&lt;p&gt;The bootloader is still an early prototype, but it is already capable of switching to long mode and loading the kernel in form of an 64-bit ELF binary. It also performs the correct page table mapping (with the correct read&#x2F;write&#x2F;execute permissions) as it‚Äôs specified in the ELF file and creates an initial physical memory map.&lt;&#x2F;p&gt;
&lt;p&gt;The plan for the future is to make the bootloader more stable, add documentation, and ultimately add a ‚ÄúWriting a Bootloader‚Äù series to the blog, which explains in detail how the bootloader works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;linking-with-lld&quot;&gt;Linking with LLD&lt;&#x2F;h2&gt;
&lt;p&gt;With our custom bootloader in place, the last remaining problem is platform independent linking. Fortunately there is &lt;a href=&quot;https:&#x2F;&#x2F;lld.llvm.org&#x2F;&quot;&gt;&lt;code&gt;LLD&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, the cross-platform linker from the LLVM project, which is already very stable for the &lt;code&gt;x86&lt;&#x2F;code&gt; architecture. As a bonus, &lt;code&gt;LLD&lt;&#x2F;code&gt; is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;48125&quot;&gt;now shipped with Rust&lt;&#x2F;a&gt;, which means that it can be used without any extra installation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-new-posts&quot;&gt;The new Posts&lt;&#x2F;h2&gt;
&lt;p&gt;The second edition is already live at &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-2&#x2F;&quot;&gt;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;second-edition&lt;&#x2F;a&gt;. Please tell us if you have any feedback on the new posts! We‚Äôre planning to move over the content from the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;&quot;&gt;first edition&lt;&#x2F;a&gt; iteratively, in a different order and with various other improvements.&lt;&#x2F;p&gt;
&lt;p&gt;Many thanks to everyone who helped to make Rust an even better language for OS development!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>VGA Text Mode</title>
                <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/vga-text-mode/</link>
                <guid>https://os.phil-opp.com/vga-text-mode/</guid>
                <description>&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VGA-compatible_text_mode&quot;&gt;VGA text mode&lt;&#x2F;a&gt; is a simple way to print text to the screen. In this post, we create an interface that makes its usage safe and simple by encapsulating all unsafety in a separate module. We also implement support for Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;#related-macros&quot;&gt;formatting macros&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-03&quot;&gt;&lt;code&gt;post-03&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;the-vga-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-vga-text-buffer&quot; aria-label=&quot;Anchor link for: the-vga-text-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;The VGA Text Buffer&lt;&#x2F;h2&gt;
&lt;p&gt;To print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware. The VGA text buffer is a two-dimensional array with typically 25 rows and 80 columns, which is directly rendered to the screen. Each array entry describes a single screen character through the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Value&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-7&lt;&#x2F;td&gt;&lt;td&gt;ASCII code point&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8-11&lt;&#x2F;td&gt;&lt;td&gt;Foreground color&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12-14&lt;&#x2F;td&gt;&lt;td&gt;Background color&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;Blink&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The first byte represents the character that should be printed in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ASCII&quot;&gt;ASCII encoding&lt;&#x2F;a&gt;. To be more specific, it isn‚Äôt exactly ASCII, but a character set named &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Code_page_437&quot;&gt;&lt;em&gt;code page 437&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; with some additional characters and slight modifications. For simplicity, we will proceed to call it an ASCII character in this post.&lt;&#x2F;p&gt;
&lt;p&gt;The second byte defines how the character is displayed. The first four bits define the foreground color, the next three bits the background color, and the last bit whether the character should blink. The following colors are available:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number&lt;&#x2F;th&gt;&lt;th&gt;Color&lt;&#x2F;th&gt;&lt;th&gt;Number + Bright Bit&lt;&#x2F;th&gt;&lt;th&gt;Bright Color&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0x0&lt;&#x2F;td&gt;&lt;td&gt;Black&lt;&#x2F;td&gt;&lt;td&gt;0x8&lt;&#x2F;td&gt;&lt;td&gt;Dark Gray&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x1&lt;&#x2F;td&gt;&lt;td&gt;Blue&lt;&#x2F;td&gt;&lt;td&gt;0x9&lt;&#x2F;td&gt;&lt;td&gt;Light Blue&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x2&lt;&#x2F;td&gt;&lt;td&gt;Green&lt;&#x2F;td&gt;&lt;td&gt;0xa&lt;&#x2F;td&gt;&lt;td&gt;Light Green&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x3&lt;&#x2F;td&gt;&lt;td&gt;Cyan&lt;&#x2F;td&gt;&lt;td&gt;0xb&lt;&#x2F;td&gt;&lt;td&gt;Light Cyan&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x4&lt;&#x2F;td&gt;&lt;td&gt;Red&lt;&#x2F;td&gt;&lt;td&gt;0xc&lt;&#x2F;td&gt;&lt;td&gt;Light Red&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x5&lt;&#x2F;td&gt;&lt;td&gt;Magenta&lt;&#x2F;td&gt;&lt;td&gt;0xd&lt;&#x2F;td&gt;&lt;td&gt;Pink&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x6&lt;&#x2F;td&gt;&lt;td&gt;Brown&lt;&#x2F;td&gt;&lt;td&gt;0xe&lt;&#x2F;td&gt;&lt;td&gt;Yellow&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x7&lt;&#x2F;td&gt;&lt;td&gt;Light Gray&lt;&#x2F;td&gt;&lt;td&gt;0xf&lt;&#x2F;td&gt;&lt;td&gt;White&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Bit 4 is the &lt;em&gt;bright bit&lt;&#x2F;em&gt;, which turns, for example, blue into light blue. For the background color, this bit is repurposed as the blink bit.&lt;&#x2F;p&gt;
&lt;p&gt;The VGA text buffer is accessible via &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory-mapped_I&#x2F;O&quot;&gt;memory-mapped I&#x2F;O&lt;&#x2F;a&gt; to the address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. This means that reads and writes to that address don‚Äôt access the RAM but directly access the text buffer on the VGA hardware. This means we can read and write it through normal memory operations to that address.&lt;&#x2F;p&gt;
&lt;p&gt;Note that memory-mapped hardware might not support all normal RAM operations. For example, a device could only support byte-wise reads and return junk when a &lt;code&gt;u64&lt;&#x2F;code&gt; is read. Fortunately, the text buffer &lt;a href=&quot;https:&#x2F;&#x2F;web.stanford.edu&#x2F;class&#x2F;cs140&#x2F;projects&#x2F;pintos&#x2F;specs&#x2F;freevga&#x2F;vga&#x2F;vgamem.htm#manip&quot;&gt;supports normal reads and writes&lt;&#x2F;a&gt;, so we don‚Äôt have to treat it in a special way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-rust-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-rust-module&quot; aria-label=&quot;Anchor link for: a-rust-module&quot;&gt;üîó&lt;&#x2F;a&gt;A Rust Module&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we know how the VGA buffer works, we can create a Rust module to handle printing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;‚ÄØin src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the content of this module, we create a new &lt;code&gt;src&#x2F;vga_buffer.rs&lt;&#x2F;code&gt; file. All of the code below goes into our new module (unless specified otherwise).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;colors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#colors&quot; aria-label=&quot;Anchor link for: colors&quot;&gt;üîó&lt;&#x2F;a&gt;Colors&lt;&#x2F;h3&gt;
&lt;p&gt;First, we represent the different colors using an enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[allow(dead_code)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u8)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Color {
&lt;&#x2F;span&gt;&lt;span&gt;    Black = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Blue = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Green = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Cyan = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Red = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Magenta = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Brown = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightGray = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    DarkGray = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightBlue = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightGreen = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightCyan = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightRed = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Pink = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Yellow = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    White = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;custom_types&#x2F;enum&#x2F;c_like.html&quot;&gt;C-like enum&lt;&#x2F;a&gt; here to explicitly specify the number for each color. Because of the &lt;code&gt;repr(u8)&lt;&#x2F;code&gt; attribute, each enum variant is stored as a &lt;code&gt;u8&lt;&#x2F;code&gt;. Actually 4 bits would be sufficient, but Rust doesn‚Äôt have a &lt;code&gt;u4&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;Normally the compiler would issue a warning for each unused variant. By using the &lt;code&gt;#[allow(dead_code)]&lt;&#x2F;code&gt; attribute, we disable these warnings for the &lt;code&gt;Color&lt;&#x2F;code&gt; enum.&lt;&#x2F;p&gt;
&lt;p&gt;By &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;trait&#x2F;derive.html&quot;&gt;deriving&lt;&#x2F;a&gt; the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;clone&#x2F;trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Debug.html&quot;&gt;&lt;code&gt;Debug&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cmp&#x2F;trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cmp&#x2F;trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; traits, we enable &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;ownership.html#copy-types&quot;&gt;copy semantics&lt;&#x2F;a&gt; for the type and make it printable and comparable.&lt;&#x2F;p&gt;
&lt;p&gt;To represent a full color code that specifies foreground and background color, we create a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;generics&#x2F;new_types.html&quot;&gt;newtype&lt;&#x2F;a&gt; on top of &lt;code&gt;u8&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(transparent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ColorCode(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ColorCode {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(foreground: Color, background: Color) -&amp;gt; ColorCode {
&lt;&#x2F;span&gt;&lt;span&gt;        ColorCode((background &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(foreground &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;ColorCode&lt;&#x2F;code&gt; struct contains the full color byte, containing foreground and background color. Like before, we derive the &lt;code&gt;Copy&lt;&#x2F;code&gt; and &lt;code&gt;Debug&lt;&#x2F;code&gt; traits for it. To ensure that the &lt;code&gt;ColorCode&lt;&#x2F;code&gt; has the exact same data layout as a &lt;code&gt;u8&lt;&#x2F;code&gt;, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;other-reprs.html#reprtransparent&quot;&gt;&lt;code&gt;repr(transparent)&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attribute.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#text-buffer&quot; aria-label=&quot;Anchor link for: text-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;Text Buffer&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can add structures to represent a screen character and the text buffer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;    ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;25&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;80&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(transparent)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the field ordering in default structs is undefined in Rust, we need the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;nomicon&#x2F;other-reprs.html#reprc&quot;&gt;&lt;code&gt;repr(C)&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; attribute. It guarantees that the struct‚Äôs fields are laid out exactly like in a C struct and thus guarantees the correct field ordering. For the &lt;code&gt;Buffer&lt;&#x2F;code&gt; struct, we use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;other-reprs.html#reprtransparent&quot;&gt;&lt;code&gt;repr(transparent)&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; again to ensure that it has the same memory layout as its single field.&lt;&#x2F;p&gt;
&lt;p&gt;To actually write to screen, we now create a writer type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode,
&lt;&#x2F;span&gt;&lt;span&gt;    buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The writer will always write to the last line and shift lines up when a line is full (or on &lt;code&gt;\n&lt;&#x2F;code&gt;). The &lt;code&gt;column_position&lt;&#x2F;code&gt; field keeps track of the current position in the last row. The current foreground and background colors are specified by &lt;code&gt;color_code&lt;&#x2F;code&gt; and a reference to the VGA buffer is stored in &lt;code&gt;buffer&lt;&#x2F;code&gt;. Note that we need an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html#lifetime-annotation-syntax&quot;&gt;explicit lifetime&lt;&#x2F;a&gt; here to tell the compiler how long the reference is valid. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html#the-static-lifetime&quot;&gt;&lt;code&gt;&#x27;static&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; lifetime specifies that the reference is valid for the whole program run time (which is true for the VGA text buffer).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;printing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing&quot; aria-label=&quot;Anchor link for: printing&quot;&gt;üîó&lt;&#x2F;a&gt;Printing&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can use the &lt;code&gt;Writer&lt;&#x2F;code&gt; to modify the buffer‚Äôs characters. First we create a method to write a single ASCII byte:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, byte: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; byte {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.new_line(),
&lt;&#x2F;span&gt;&lt;span&gt;            byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.column_position &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    self.new_line();
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; row = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; col = self.column_position;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; color_code = self.color_code;
&lt;&#x2F;span&gt;&lt;span&gt;                self.buffer.chars[row][col] = ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;                    ascii_character: byte,
&lt;&#x2F;span&gt;&lt;span&gt;                    color_code,
&lt;&#x2F;span&gt;&lt;span&gt;                };
&lt;&#x2F;span&gt;&lt;span&gt;                self.column_position += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new_line(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* TODO *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the byte is the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Newline&quot;&gt;newline&lt;&#x2F;a&gt; byte &lt;code&gt;\n&lt;&#x2F;code&gt;, the writer does not print anything. Instead, it calls a &lt;code&gt;new_line&lt;&#x2F;code&gt; method, which we‚Äôll implement later. Other bytes get printed to the screen in the second &lt;code&gt;match&lt;&#x2F;code&gt; case.&lt;&#x2F;p&gt;
&lt;p&gt;When printing a byte, the writer checks if the current line is full. In that case, a &lt;code&gt;new_line&lt;&#x2F;code&gt; call is used to wrap the line. Then it writes a new &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; to the buffer at the current position. Finally, the current column position is advanced.&lt;&#x2F;p&gt;
&lt;p&gt;To print whole strings, we can convert them to bytes and print them one-by-one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, s: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.bytes() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; byte {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; printable ASCII byte or newline
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x7e &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.write_byte(byte),
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; not part of printable ASCII range
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xfe&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The VGA text buffer only supports ASCII and the additional bytes of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Code_page_437&quot;&gt;code page 437&lt;&#x2F;a&gt;. Rust strings are &lt;a href=&quot;https:&#x2F;&#x2F;www.fileformat.info&#x2F;info&#x2F;unicode&#x2F;utf8.htm&quot;&gt;UTF-8&lt;&#x2F;a&gt; by default, so they might contain bytes that are not supported by the VGA text buffer. We use a &lt;code&gt;match&lt;&#x2F;code&gt; to differentiate printable ASCII bytes (a newline or anything in between a space character and a &lt;code&gt;~&lt;&#x2F;code&gt; character) and unprintable bytes. For unprintable bytes, we print a &lt;code&gt;‚ñ†&lt;&#x2F;code&gt; character, which has the hex code &lt;code&gt;0xfe&lt;&#x2F;code&gt; on the VGA hardware.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;üîó&lt;&#x2F;a&gt;Try it out!&lt;&#x2F;h4&gt;
&lt;p&gt;To write some characters to the screen, you can create a temporary function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;print_something() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;        buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;W√∂rld!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It first creates a new Writer that points to the VGA buffer at &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. The syntax for this might seem a bit strange: First, we cast the integer &lt;code&gt;0xb8000&lt;&#x2F;code&gt; as a mutable &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2F;a&gt;. Then we convert it to a mutable reference by dereferencing it (through &lt;code&gt;*&lt;&#x2F;code&gt;) and immediately borrowing it again (through &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;). This conversion requires an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; block&lt;&#x2F;a&gt;, since the compiler can‚Äôt guarantee that the raw pointer is valid.&lt;&#x2F;p&gt;
&lt;p&gt;Then it writes the byte &lt;code&gt;b&#x27;H&#x27;&lt;&#x2F;code&gt; to it. The &lt;code&gt;b&lt;&#x2F;code&gt; prefix creates a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;tokens.html#byte-literals&quot;&gt;byte literal&lt;&#x2F;a&gt;, which represents an ASCII character. By writing the strings &lt;code&gt;&amp;quot;ello &amp;quot;&lt;&#x2F;code&gt; and &lt;code&gt;&amp;quot;W√∂rld!&amp;quot;&lt;&#x2F;code&gt;, we test our &lt;code&gt;write_string&lt;&#x2F;code&gt; method and the handling of unprintable characters. To see the output, we need to call the &lt;code&gt;print_something&lt;&#x2F;code&gt; function from our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::print_something();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run our project now, a &lt;code&gt;Hello W‚ñ†‚ñ†rld!&lt;&#x2F;code&gt; should be printed in the &lt;em&gt;lower&lt;&#x2F;em&gt; left corner of the screen in yellow:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;vga-hello.png&quot; alt=&quot;QEMU output with a yellow Hello W‚ñ†‚ñ†rld! in the lower left corner&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Notice that the &lt;code&gt;√∂&lt;&#x2F;code&gt; is printed as two &lt;code&gt;‚ñ†&lt;&#x2F;code&gt; characters. That‚Äôs because &lt;code&gt;√∂&lt;&#x2F;code&gt; is represented by two bytes in &lt;a href=&quot;https:&#x2F;&#x2F;www.fileformat.info&#x2F;info&#x2F;unicode&#x2F;utf8.htm&quot;&gt;UTF-8&lt;&#x2F;a&gt;, which both don‚Äôt fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;volatile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#volatile&quot; aria-label=&quot;Anchor link for: volatile&quot;&gt;üîó&lt;&#x2F;a&gt;Volatile&lt;&#x2F;h3&gt;
&lt;p&gt;We just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that we only write to the &lt;code&gt;Buffer&lt;&#x2F;code&gt; and never read from it again. The compiler doesn‚Äôt know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Volatile_(computer_programming)&quot;&gt;volatile&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;. This tells the compiler that the write has side effects and should not be optimized away.&lt;&#x2F;p&gt;
&lt;p&gt;In order to use volatile writes for the VGA buffer, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;volatile&quot;&gt;volatile&lt;&#x2F;a&gt; library. This &lt;em&gt;crate&lt;&#x2F;em&gt; (this is how packages are called in the Rust world) provides a &lt;code&gt;Volatile&lt;&#x2F;code&gt; wrapper type with &lt;code&gt;read&lt;&#x2F;code&gt; and &lt;code&gt;write&lt;&#x2F;code&gt; methods. These methods internally use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;fn.read_volatile.html&quot;&gt;read_volatile&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;fn.write_volatile.html&quot;&gt;write_volatile&lt;&#x2F;a&gt; functions of the core library and thus guarantee that the reads&#x2F;writes are not optimized away.&lt;&#x2F;p&gt;
&lt;p&gt;We can add a dependency on the &lt;code&gt;volatile&lt;&#x2F;code&gt; crate by adding it to the &lt;code&gt;dependencies&lt;&#x2F;code&gt; section of our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;volatile &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.6&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Make sure to specify &lt;code&gt;volatile&lt;&#x2F;code&gt; version &lt;code&gt;0.2.6&lt;&#x2F;code&gt;. Newer versions of the crate are not compatible with this post.
&lt;code&gt;0.2.6&lt;&#x2F;code&gt; is the &lt;a href=&quot;https:&#x2F;&#x2F;semver.org&#x2F;&quot;&gt;semantic&lt;&#x2F;a&gt; version number. For more information, see the &lt;a href=&quot;https:&#x2F;&#x2F;doc.crates.io&#x2F;specifying-dependencies.html&quot;&gt;Specifying Dependencies&lt;&#x2F;a&gt; guide of the cargo documentation.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs use it to make writes to the VGA buffer volatile. We update our &lt;code&gt;Buffer&lt;&#x2F;code&gt; type as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;volatile::Volatile;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    chars: [[Volatile&amp;lt;ScreenChar&amp;gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;ScreenChar&lt;&#x2F;code&gt;, we‚Äôre now using a &lt;code&gt;Volatile&amp;lt;ScreenChar&amp;gt;&lt;&#x2F;code&gt;. (The &lt;code&gt;Volatile&lt;&#x2F;code&gt; type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-01-syntax.html&quot;&gt;generic&lt;&#x2F;a&gt; and can wrap (almost) any type). This ensures that we can‚Äôt accidentally write to it ‚Äúnormally‚Äù. Instead, we have to use the &lt;code&gt;write&lt;&#x2F;code&gt; method now.&lt;&#x2F;p&gt;
&lt;p&gt;This means that we have to update our &lt;code&gt;Writer::write_byte&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, byte: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; byte {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.new_line(),
&lt;&#x2F;span&gt;&lt;span&gt;            byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                self.buffer.chars[row][col].write(ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;                    ascii_character: byte,
&lt;&#x2F;span&gt;&lt;span&gt;                    color_code,
&lt;&#x2F;span&gt;&lt;span&gt;                });
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of a typical assignment using &lt;code&gt;=&lt;&#x2F;code&gt;, we‚Äôre now using the &lt;code&gt;write&lt;&#x2F;code&gt; method. Now we can guarantee that the compiler will never optimize away this write.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;formatting-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#formatting-macros&quot; aria-label=&quot;Anchor link for: formatting-macros&quot;&gt;üîó&lt;&#x2F;a&gt;Formatting Macros&lt;&#x2F;h3&gt;
&lt;p&gt;It would be nice to support Rust‚Äôs formatting macros, too. That way, we can easily print different types, like integers or floats. To support them, we need to implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Write.html&quot;&gt;&lt;code&gt;core::fmt::Write&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait. The only required method of this trait is &lt;code&gt;write_str&lt;&#x2F;code&gt;, which looks quite similar to our &lt;code&gt;write_string&lt;&#x2F;code&gt; method, just with a &lt;code&gt;fmt::Result&lt;&#x2F;code&gt; return type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;fmt::Write &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, s: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; fmt::Result {
&lt;&#x2F;span&gt;&lt;span&gt;        self.write_string(s);
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Ok(())&lt;&#x2F;code&gt; is just a &lt;code&gt;Ok&lt;&#x2F;code&gt; Result containing the &lt;code&gt;()&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use Rust‚Äôs built-in &lt;code&gt;write!&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;writeln!&lt;&#x2F;code&gt; formatting macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;print_something() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;        buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello! &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    write!(writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;The numbers are &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you should see a &lt;code&gt;Hello! The numbers are 42 and 0.3333333333333333&lt;&#x2F;code&gt; at the bottom of the screen. The &lt;code&gt;write!&lt;&#x2F;code&gt; call returns a &lt;code&gt;Result&lt;&#x2F;code&gt; which causes a warning if not used, so we call the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;enum.Result.html#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function on it, which panics if an error occurs. This isn‚Äôt a problem in our case, since writes to the VGA buffer never fail.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;newlines&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#newlines&quot; aria-label=&quot;Anchor link for: newlines&quot;&gt;üîó&lt;&#x2F;a&gt;Newlines&lt;&#x2F;h3&gt;
&lt;p&gt;Right now, we just ignore newlines and characters that don‚Äôt fit into the line anymore. Instead, we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the &lt;code&gt;new_line&lt;&#x2F;code&gt; method of &lt;code&gt;Writer&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new_line(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; row &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; col &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; character = self.buffer.chars[row][col].read();
&lt;&#x2F;span&gt;&lt;span&gt;                self.buffer.chars[row - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;][col].write(character);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        self.clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        self.column_position = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, row: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* TODO *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We iterate over all the screen characters and move each character one row up. Note that the upper bound of the range notation (&lt;code&gt;..&lt;&#x2F;code&gt;) is exclusive. We also omit the 0th row (the first range starts at &lt;code&gt;1&lt;&#x2F;code&gt;) because it‚Äôs the row that is shifted off screen.&lt;&#x2F;p&gt;
&lt;p&gt;To finish the newline code, we add the &lt;code&gt;clear_row&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, row: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; blank = ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;            ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            color_code: self.color_code,
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; col &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            self.buffer.chars[row][col].write(blank);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This method clears a row by overwriting all of its characters with a space character.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-global-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-global-interface&quot; aria-label=&quot;Anchor link for: a-global-interface&quot;&gt;üîó&lt;&#x2F;a&gt;A Global Interface&lt;&#x2F;h2&gt;
&lt;p&gt;To provide a global writer that can be used as an interface from other modules without carrying a &lt;code&gt;Writer&lt;&#x2F;code&gt; instance around, we try to create a static &lt;code&gt;WRITER&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;: Writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;    buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, if we try to compile it now, the following errors occur:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;vga_buffer.rs:7:17
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[E0396]: raw pointers cannot be dereferenced in statics
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;vga_buffer.rs:8:22
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[E0017]: references in statics may only refer to immutable values
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;vga_buffer.rs:8:22
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[E0017]: references in statics may only refer to immutable values
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;vga_buffer.rs:8:13
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To understand what‚Äôs happening here, we need to know that statics are initialized at compile time, in contrast to normal variables that are initialized at run time. The component of the Rust compiler that evaluates such initialization expressions is called the ‚Äú&lt;a href=&quot;https:&#x2F;&#x2F;rustc-dev-guide.rust-lang.org&#x2F;const-eval.html&quot;&gt;const evaluator&lt;&#x2F;a&gt;‚Äù. Its functionality is still limited, but there is ongoing work to expand it, for example in the ‚Äú&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;2345&quot;&gt;Allow panicking in constants&lt;&#x2F;a&gt;‚Äù RFC.&lt;&#x2F;p&gt;
&lt;p&gt;The issue with &lt;code&gt;ColorCode::new&lt;&#x2F;code&gt; would be solvable by using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;const_eval.html#const-functions&quot;&gt;&lt;code&gt;const&lt;&#x2F;code&gt; functions&lt;&#x2F;a&gt;, but the fundamental problem here is that Rust‚Äôs const evaluator is not able to convert raw pointers to references at compile time. Maybe it will work someday, but until then, we have to find another solution.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lazy-statics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics&quot; aria-label=&quot;Anchor link for: lazy-statics&quot;&gt;üîó&lt;&#x2F;a&gt;Lazy Statics&lt;&#x2F;h3&gt;
&lt;p&gt;The one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lazy_static&#x2F;1.0.1&#x2F;lazy_static&#x2F;&quot;&gt;lazy_static&lt;&#x2F;a&gt;. This crate provides a &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro that defines a lazily initialized &lt;code&gt;static&lt;&#x2F;code&gt;. Instead of computing its value at compile time, the &lt;code&gt;static&lt;&#x2F;code&gt; lazily initializes itself when accessed for the first time. Thus, the initialization happens at runtime, so arbitrarily complex initialization code is possible.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; crate to our project:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2F;code&gt; feature, since we don‚Äôt link the standard library.&lt;&#x2F;p&gt;
&lt;p&gt;With &lt;code&gt;lazy_static&lt;&#x2F;code&gt;, we can define our static &lt;code&gt;WRITER&lt;&#x2F;code&gt; without problems:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;lazy_static::lazy_static;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;: Writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;        buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, this &lt;code&gt;WRITER&lt;&#x2F;code&gt; is pretty useless since it is immutable. This means that we can‚Äôt write anything to it (since all the write methods take &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt;). One possible solution would be to use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;mutable static&lt;&#x2F;a&gt;. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using &lt;code&gt;static mut&lt;&#x2F;code&gt; is highly discouraged. There were even proposals to &lt;a href=&quot;https:&#x2F;&#x2F;internals.rust-lang.org&#x2F;t&#x2F;pre-rfc-remove-static-mut&#x2F;1437&quot;&gt;remove it&lt;&#x2F;a&gt;. But what are the alternatives? We could try to use an immutable static with a cell type like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html#keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&lt;&#x2F;a&gt; or even &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cell&#x2F;struct.UnsafeCell.html&quot;&gt;UnsafeCell&lt;&#x2F;a&gt; that provides &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html&quot;&gt;interior mutability&lt;&#x2F;a&gt;. But these types aren‚Äôt &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Sync.html&quot;&gt;Sync&lt;&#x2F;a&gt; (with good reason), so we can‚Äôt use them in statics.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;spinlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spinlocks&quot; aria-label=&quot;Anchor link for: spinlocks&quot;&gt;üîó&lt;&#x2F;a&gt;Spinlocks&lt;&#x2F;h3&gt;
&lt;p&gt;To get synchronized interior mutability, users of the standard library can use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;sync&#x2F;struct.Mutex.html&quot;&gt;Mutex&lt;&#x2F;a&gt;. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can‚Äôt use it either. However, there is a really basic kind of mutex in computer science that requires no operating system features: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spinlock&quot;&gt;spinlock&lt;&#x2F;a&gt;. Instead of blocking, the threads simply try to lock it again and again in a tight loop, thus burning CPU time until the mutex is free again.&lt;&#x2F;p&gt;
&lt;p&gt;To use a spinning mutex, we can add the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;spin&quot;&gt;spin crate&lt;&#x2F;a&gt; as a dependency:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;spin &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.2&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we can use the spinning mutex to add safe &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html&quot;&gt;interior mutability&lt;&#x2F;a&gt; to our static &lt;code&gt;WRITER&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Writer&amp;gt; = Mutex::new(Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::Yellow, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;        buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer) },
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can delete the &lt;code&gt;print_something&lt;&#x2F;code&gt; function and print directly from our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello again&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    write!(vga_buffer::WRITER.lock(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;, some numbers: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.337&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to import the &lt;code&gt;fmt::Write&lt;&#x2F;code&gt; trait in order to be able to use its functions.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h3&gt;
&lt;p&gt;Note that we only have a single unsafe block in our code, which is needed to create a &lt;code&gt;Buffer&lt;&#x2F;code&gt; reference pointing to &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. Afterwards, all operations are safe. Rust uses bounds checking for array accesses by default, so we can‚Äôt accidentally write outside the buffer. Thus, we encoded the required conditions in the type system and are able to provide a safe interface to the outside.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-println-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-println-macro&quot; aria-label=&quot;Anchor link for: a-println-macro&quot;&gt;üîó&lt;&#x2F;a&gt;A println Macro&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we have a global writer, we can add a &lt;code&gt;println&lt;&#x2F;code&gt; macro that can be used from anywhere in the codebase. Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;book&#x2F;ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;macro syntax&lt;&#x2F;a&gt; is a bit strange, so we won‚Äôt try to write a macro from scratch. Instead, we look at the source of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.println!.html&quot;&gt;&lt;code&gt;println!&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; in the standard library:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! println {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Macros are defined through one or more rules, similar to &lt;code&gt;match&lt;&#x2F;code&gt; arms. The &lt;code&gt;println&lt;&#x2F;code&gt; macro has two rules: The first rule is for invocations without arguments, e.g., &lt;code&gt;println!()&lt;&#x2F;code&gt;, which is expanded to &lt;code&gt;print!(&amp;quot;\n&amp;quot;)&lt;&#x2F;code&gt; and thus just prints a newline. The second rule is for invocations with parameters such as &lt;code&gt;println!(&amp;quot;Hello&amp;quot;)&lt;&#x2F;code&gt; or &lt;code&gt;println!(&amp;quot;Number: {}&amp;quot;, 4)&lt;&#x2F;code&gt;. It is also expanded to an invocation of the &lt;code&gt;print!&lt;&#x2F;code&gt; macro, passing all arguments and an additional newline &lt;code&gt;\n&lt;&#x2F;code&gt; at the end.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;#[macro_export]&lt;&#x2F;code&gt; attribute makes the macro available to the whole crate (not just the module it is defined in) and external crates. It also places the macro at the crate root, which means we have to import the macro through &lt;code&gt;use std::println&lt;&#x2F;code&gt; instead of &lt;code&gt;std::macros::println&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.print!.html&quot;&gt;&lt;code&gt;print!&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; is defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::io::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro expands to a call of the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;29f5c699b11a6a148f097f82eaa05202f8799bbc&#x2F;src&#x2F;libstd&#x2F;io&#x2F;stdio.rs#L698&quot;&gt;&lt;code&gt;_print&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; in the &lt;code&gt;io&lt;&#x2F;code&gt; module. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;macros.html#the-variable-crate&quot;&gt;&lt;code&gt;$crate&lt;&#x2F;code&gt; variable&lt;&#x2F;a&gt; ensures that the macro also works from outside the &lt;code&gt;std&lt;&#x2F;code&gt; crate by expanding to &lt;code&gt;std&lt;&#x2F;code&gt; when it‚Äôs used in other crates.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.format_args.html&quot;&gt;&lt;code&gt;format_args&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; builds a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;struct.Arguments.html&quot;&gt;fmt::Arguments&lt;&#x2F;a&gt; type from the passed arguments, which is passed to &lt;code&gt;_print&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;29f5c699b11a6a148f097f82eaa05202f8799bbc&#x2F;src&#x2F;libstd&#x2F;io&#x2F;stdio.rs#L698&quot;&gt;&lt;code&gt;_print&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; of libstd calls &lt;code&gt;print_to&lt;&#x2F;code&gt;, which is rather complicated because it supports different &lt;code&gt;Stdout&lt;&#x2F;code&gt; devices. We don‚Äôt need that complexity since we just want to print to the VGA buffer.&lt;&#x2F;p&gt;
&lt;p&gt;To print to the VGA buffer, we just copy the &lt;code&gt;println!&lt;&#x2F;code&gt; and &lt;code&gt;print!&lt;&#x2F;code&gt; macros, but modify them to use our own &lt;code&gt;_print&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::vga_buffer::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_export]
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! println {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::print&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[doc(hidden)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;_print(args: fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One thing that we changed from the original &lt;code&gt;println&lt;&#x2F;code&gt; definition is that we prefixed the invocations of the &lt;code&gt;print!&lt;&#x2F;code&gt; macro with &lt;code&gt;$crate&lt;&#x2F;code&gt; too. This ensures that we don‚Äôt need to import the &lt;code&gt;print!&lt;&#x2F;code&gt; macro too if we only want to use &lt;code&gt;println&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Like in the standard library, we add the &lt;code&gt;#[macro_export]&lt;&#x2F;code&gt; attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via &lt;code&gt;use crate::vga_buffer::println&lt;&#x2F;code&gt; does not work. Instead, we have to do &lt;code&gt;use crate::println&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;_print&lt;&#x2F;code&gt; function locks our static &lt;code&gt;WRITER&lt;&#x2F;code&gt; and calls the &lt;code&gt;write_fmt&lt;&#x2F;code&gt; method on it. This method is from the &lt;code&gt;Write&lt;&#x2F;code&gt; trait, which we need to import. The additional &lt;code&gt;unwrap()&lt;&#x2F;code&gt; at the end panics if printing isn‚Äôt successful. But since we always return &lt;code&gt;Ok&lt;&#x2F;code&gt; in &lt;code&gt;write_str&lt;&#x2F;code&gt;, that should not happen.&lt;&#x2F;p&gt;
&lt;p&gt;Since the macros need to be able to call &lt;code&gt;_print&lt;&#x2F;code&gt; from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;rustdoc&#x2F;write-documentation&#x2F;the-doc-attribute.html#hidden&quot;&gt;&lt;code&gt;doc(hidden)&lt;&#x2F;code&gt; attribute&lt;&#x2F;a&gt; to hide it from the generated documentation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;hello-world-using-println&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world-using-println&quot; aria-label=&quot;Anchor link for: hello-world-using-println&quot;&gt;üîó&lt;&#x2F;a&gt;Hello World using &lt;code&gt;println&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can use &lt;code&gt;println&lt;&#x2F;code&gt; in our &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we don‚Äôt have to import the macro in the main function, because it already lives in the root namespace.&lt;&#x2F;p&gt;
&lt;p&gt;As expected, we now see a &lt;em&gt;‚ÄúHello World!‚Äù&lt;&#x2F;em&gt; on the screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;vga-hello-world.png&quot; alt=&quot;QEMU printing ‚ÄúHello World!‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;printing-panic-messages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-panic-messages&quot; aria-label=&quot;Anchor link for: printing-panic-messages&quot;&gt;üîó&lt;&#x2F;a&gt;Printing Panic Messages&lt;&#x2F;h3&gt;
&lt;p&gt;Now that we have a &lt;code&gt;println&lt;&#x2F;code&gt; macro, we can use it in our panic function to print the panic message and the location of the panic:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, info);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we now insert &lt;code&gt;panic!(&amp;quot;Some panic message&amp;quot;);&lt;&#x2F;code&gt; in our &lt;code&gt;_start&lt;&#x2F;code&gt; function, we get the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;vga-text-mode&#x2F;vga-panic.png&quot; alt=&quot;QEMU printing ‚Äúpanicked at ‚ÄòSome panic message‚Äô, src&#x2F;main.rs:28:5&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So we know not only that a panic has occurred, but also the panic message and where in the code it happened.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;In this post, we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. We created a Rust module that encapsulates the unsafety of writing to this memory-mapped buffer and presents a safe and convenient interface to the outside.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks to cargo, we also saw how easy it is to add dependencies on third-party libraries. The two dependencies that we added, &lt;code&gt;lazy_static&lt;&#x2F;code&gt; and &lt;code&gt;spin&lt;&#x2F;code&gt;, are very useful in OS development and we will use them in more places in future posts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The next post explains how to set up Rust‚Äôs built-in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>A Freestanding Rust Binary</title>
                <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/freestanding-rust-binary/</link>
                <guid>https://os.phil-opp.com/freestanding-rust-binary/</guid>
                <description>&lt;p&gt;The first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bare_machine&quot;&gt;bare metal&lt;&#x2F;a&gt; without an underlying operating system.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;freestanding-rust-binary&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-01&quot;&gt;&lt;code&gt;post-01&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;To write an operating system kernel, we need code that does not depend on any operating system features. This means that we can‚Äôt use threads, files, heap memory, the network, random numbers, standard output, or any other features requiring OS abstractions or specific hardware. Which makes sense, since we‚Äôre trying to write our own OS and our own drivers.&lt;&#x2F;p&gt;
&lt;p&gt;This means that we can‚Äôt use most of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;&quot;&gt;Rust standard library&lt;&#x2F;a&gt;, but there are a lot of Rust features that we &lt;em&gt;can&lt;&#x2F;em&gt; use. For example, we can use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch13-02-iterators.html&quot;&gt;iterators&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch13-01-closures.html&quot;&gt;closures&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch06-00-enums.html&quot;&gt;pattern matching&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;option&#x2F;&quot;&gt;option&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;result&#x2F;&quot;&gt;result&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;macro.write.html&quot;&gt;string formatting&lt;&#x2F;a&gt;, and of course the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-00-understanding-ownership.html&quot;&gt;ownership system&lt;&#x2F;a&gt;. These features make it possible to write a kernel in a very expressive, high level way without worrying about &lt;a href=&quot;https:&#x2F;&#x2F;www.nayuki.io&#x2F;page&#x2F;undefined-behavior-in-c-and-cplusplus-programs&quot;&gt;undefined behavior&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;tonyarcieri.com&#x2F;it-s-time-for-a-memory-safety-intervention&quot;&gt;memory safety&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In order to create an OS kernel in Rust, we need to create an executable that can be run without an underlying operating system. Such an executable is often called a ‚Äúfreestanding‚Äù or ‚Äúbare-metal‚Äù executable.&lt;&#x2F;p&gt;
&lt;p&gt;This post describes the necessary steps to create a freestanding Rust binary and explains why the steps are needed. If you‚Äôre just interested in a minimal example, you can &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;freestanding-rust-binary&#x2F;#summary&quot;&gt;jump to the summary&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;disabling-the-standard-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-the-standard-library&quot; aria-label=&quot;Anchor link for: disabling-the-standard-library&quot;&gt;üîó&lt;&#x2F;a&gt;Disabling the Standard Library&lt;&#x2F;h2&gt;
&lt;p&gt;By default, all Rust crates link the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;&quot;&gt;standard library&lt;&#x2F;a&gt;, which depends on the operating system for features such as threads, files, or networking. It also depends on the C standard library &lt;code&gt;libc&lt;&#x2F;code&gt;, which closely interacts with OS services. Since our plan is to write an operating system, we can‚Äôt use any OS-dependent libraries. So we have to disable the automatic inclusion of the standard library through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;using-rust-without-the-standard-library.html&quot;&gt;&lt;code&gt;no_std&lt;&#x2F;code&gt; attribute&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We start by creating a new cargo application project. The easiest way to do this is through the command line:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo new blog_os --bin --edition 2018
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I named the project &lt;code&gt;blog_os&lt;&#x2F;code&gt;, but of course you can choose your own name. The &lt;code&gt;--bin&lt;&#x2F;code&gt; flag specifies that we want to create an executable binary (in contrast to a library) and the &lt;code&gt;--edition 2018&lt;&#x2F;code&gt; flag specifies that we want to use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;edition-guide&#x2F;rust-2018&#x2F;index.html&quot;&gt;2018 edition&lt;&#x2F;a&gt; of Rust for our crate. When we run the command, cargo creates the following directory structure for us:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;blog_os
&lt;&#x2F;span&gt;&lt;span&gt;‚îú‚îÄ‚îÄ Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;‚îî‚îÄ‚îÄ src
&lt;&#x2F;span&gt;&lt;span&gt;    ‚îî‚îÄ‚îÄ main.rs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; contains the crate configuration, for example the crate name, the author, the &lt;a href=&quot;https:&#x2F;&#x2F;semver.org&#x2F;&quot;&gt;semantic version&lt;&#x2F;a&gt; number, and dependencies. The &lt;code&gt;src&#x2F;main.rs&lt;&#x2F;code&gt; file contains the root module of our crate and our &lt;code&gt;main&lt;&#x2F;code&gt; function. You can compile your crate through &lt;code&gt;cargo build&lt;&#x2F;code&gt; and then run the compiled &lt;code&gt;blog_os&lt;&#x2F;code&gt; binary in the &lt;code&gt;target&#x2F;debug&lt;&#x2F;code&gt; subfolder.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-no-std-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-no-std-attribute&quot; aria-label=&quot;Anchor link for: the-no-std-attribute&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;no_std&lt;&#x2F;code&gt; Attribute&lt;&#x2F;h3&gt;
&lt;p&gt;Right now our crate implicitly links the standard library. Let‚Äôs try to disable this by adding the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;using-rust-without-the-standard-library.html&quot;&gt;&lt;code&gt;no_std&lt;&#x2F;code&gt; attribute&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we try to build it now (by running &lt;code&gt;cargo build&lt;&#x2F;code&gt;), the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: cannot find macro `println!` in this scope
&lt;&#x2F;span&gt;&lt;span&gt; --&amp;gt; src&#x2F;main.rs:4:5
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;4 |     println!(&amp;quot;Hello, world!&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;  |     ^^^^^^^
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason for this error is that the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;macro.println.html&quot;&gt;&lt;code&gt;println&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; is part of the standard library, which we no longer include. So we can no longer print things. This makes sense, since &lt;code&gt;println&lt;&#x2F;code&gt; writes to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Standard_streams#Standard_output_.28stdout.29&quot;&gt;standard output&lt;&#x2F;a&gt;, which is a special file descriptor provided by the operating system.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs remove the printing and try again with an empty main function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;main() {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo build
&lt;&#x2F;span&gt;&lt;span&gt;error: `#[panic_handler]` function required, but not found
&lt;&#x2F;span&gt;&lt;span&gt;error: language item required, but not found: `eh_personality`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the compiler is missing a &lt;code&gt;#[panic_handler]&lt;&#x2F;code&gt; function and a &lt;em&gt;language item&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;panic-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#panic-implementation&quot; aria-label=&quot;Anchor link for: panic-implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Panic Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;panic_handler&lt;&#x2F;code&gt; attribute defines the function that the compiler should invoke when a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch09-01-unrecoverable-errors-with-panic.html&quot;&gt;panic&lt;&#x2F;a&gt; occurs. The standard library provides its own panic handler function, but in a &lt;code&gt;no_std&lt;&#x2F;code&gt; environment we need to define it ourselves:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;panic&#x2F;struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;&#x2F;code&gt; parameter&lt;&#x2F;a&gt; contains the file and line where the panic happened and the optional panic message. The function should never return, so it is marked as a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;functions.html#diverging-functions&quot;&gt;diverging function&lt;&#x2F;a&gt; by returning the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;primitive.never.html&quot;&gt;‚Äúnever‚Äù type&lt;&#x2F;a&gt; &lt;code&gt;!&lt;&#x2F;code&gt;. There is not much we can do in this function for now, so we just loop indefinitely.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-eh-personality-language-item&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-eh-personality-language-item&quot; aria-label=&quot;Anchor link for: the-eh-personality-language-item&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;eh_personality&lt;&#x2F;code&gt; Language Item&lt;&#x2F;h2&gt;
&lt;p&gt;Language items are special functions and types that are required internally by the compiler. For example, the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait is a language item that tells the compiler which types have &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;&lt;em&gt;copy semantics&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. When we look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;485397e49a02a3b7ff77c17e4a3f16c653925cb3&#x2F;src&#x2F;libcore&#x2F;marker.rs#L296-L299&quot;&gt;implementation&lt;&#x2F;a&gt;, we see it has the special &lt;code&gt;#[lang = &amp;quot;copy&amp;quot;]&lt;&#x2F;code&gt; attribute that defines it as a language item.&lt;&#x2F;p&gt;
&lt;p&gt;While providing custom implementations of language items is possible, it should only be done as a last resort. The reason is that language items are highly unstable implementation details and not even type checked (so the compiler doesn‚Äôt even check if a function has the right argument types). Fortunately, there is a more stable way to fix the above language item error.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;edb368491551a77d77a48446d4ee88b35490c565&#x2F;src&#x2F;libpanic_unwind&#x2F;gcc.rs#L11-L45&quot;&gt;&lt;code&gt;eh_personality&lt;&#x2F;code&gt; language item&lt;&#x2F;a&gt; marks a function that is used for implementing &lt;a href=&quot;https:&#x2F;&#x2F;www.bogotobogo.com&#x2F;cplusplus&#x2F;stackunwinding.php&quot;&gt;stack unwinding&lt;&#x2F;a&gt;. By default, Rust uses unwinding to run the destructors of all live stack variables in case of a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch09-01-unrecoverable-errors-with-panic.html&quot;&gt;panic&lt;&#x2F;a&gt;. This ensures that all used memory is freed and allows the parent thread to catch the panic and continue execution. Unwinding, however, is a complicated process and requires some OS-specific libraries (e.g. &lt;a href=&quot;https:&#x2F;&#x2F;www.nongnu.org&#x2F;libunwind&#x2F;&quot;&gt;libunwind&lt;&#x2F;a&gt; on Linux or &lt;a href=&quot;https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;windows&#x2F;win32&#x2F;debug&#x2F;structured-exception-handling&quot;&gt;structured exception handling&lt;&#x2F;a&gt; on Windows), so we don‚Äôt want to use it for our operating system.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;disabling-unwinding&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-unwinding&quot; aria-label=&quot;Anchor link for: disabling-unwinding&quot;&gt;üîó&lt;&#x2F;a&gt;Disabling Unwinding&lt;&#x2F;h3&gt;
&lt;p&gt;There are other use cases as well for which unwinding is undesirable, so Rust provides an option to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;32900&quot;&gt;abort on panic&lt;&#x2F;a&gt; instead. This disables the generation of unwinding symbol information and thus considerably reduces binary size. There are multiple places where we can disable unwinding. The easiest way is to add the following lines to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.dev&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.release&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This sets the panic strategy to &lt;code&gt;abort&lt;&#x2F;code&gt; for both the &lt;code&gt;dev&lt;&#x2F;code&gt; profile (used for &lt;code&gt;cargo build&lt;&#x2F;code&gt;) and the &lt;code&gt;release&lt;&#x2F;code&gt; profile (used for &lt;code&gt;cargo build --release&lt;&#x2F;code&gt;). Now the &lt;code&gt;eh_personality&lt;&#x2F;code&gt; language item should no longer be required.&lt;&#x2F;p&gt;
&lt;p&gt;Now we fixed both of the above errors. However, if we try to compile it now, another error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo build
&lt;&#x2F;span&gt;&lt;span&gt;error: requires `start` lang_item
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our program is missing the &lt;code&gt;start&lt;&#x2F;code&gt; language item, which defines the entry point.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-start-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-start-attribute&quot; aria-label=&quot;Anchor link for: the-start-attribute&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;start&lt;&#x2F;code&gt; attribute&lt;&#x2F;h2&gt;
&lt;p&gt;One might think that the &lt;code&gt;main&lt;&#x2F;code&gt; function is the first function called when you run a program. However, most languages have a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Runtime_system&quot;&gt;runtime system&lt;&#x2F;a&gt;, which is responsible for things such as garbage collection (e.g. in Java) or software threads (e.g. goroutines in Go). This runtime needs to be called before &lt;code&gt;main&lt;&#x2F;code&gt;, since it needs to initialize itself.&lt;&#x2F;p&gt;
&lt;p&gt;In a typical Rust binary that links the standard library, execution starts in a C runtime library called &lt;code&gt;crt0&lt;&#x2F;code&gt; (‚ÄúC runtime zero‚Äù), which sets up the environment for a C application. This includes creating a stack and placing the arguments in the right registers. The C runtime then invokes the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;bb4d1491466d8239a7a5fd68bd605e3276e97afb&#x2F;src&#x2F;libstd&#x2F;rt.rs#L32-L73&quot;&gt;entry point of the Rust runtime&lt;&#x2F;a&gt;, which is marked by the &lt;code&gt;start&lt;&#x2F;code&gt; language item. Rust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic. The runtime then finally calls the &lt;code&gt;main&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;Our freestanding executable does not have access to the Rust runtime and &lt;code&gt;crt0&lt;&#x2F;code&gt;, so we need to define our own entry point. Implementing the &lt;code&gt;start&lt;&#x2F;code&gt; language item wouldn‚Äôt help, since it would still require &lt;code&gt;crt0&lt;&#x2F;code&gt;. Instead, we need to overwrite the &lt;code&gt;crt0&lt;&#x2F;code&gt; entry point directly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;overwriting-the-entry-point&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overwriting-the-entry-point&quot; aria-label=&quot;Anchor link for: overwriting-the-entry-point&quot;&gt;üîó&lt;&#x2F;a&gt;Overwriting the Entry Point&lt;&#x2F;h3&gt;
&lt;p&gt;To tell the Rust compiler that we don‚Äôt want to use the normal entry point chain, we add the &lt;code&gt;#![no_main]&lt;&#x2F;code&gt; attribute.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You might notice that we removed the &lt;code&gt;main&lt;&#x2F;code&gt; function. The reason is that a &lt;code&gt;main&lt;&#x2F;code&gt; doesn‚Äôt make sense without an underlying runtime that calls it. Instead, we are now overwriting the operating system entry point with our own &lt;code&gt;_start&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By using the &lt;code&gt;#[no_mangle]&lt;&#x2F;code&gt; attribute, we disable &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Name_mangling&quot;&gt;name mangling&lt;&#x2F;a&gt; to ensure that the Rust compiler really outputs a function with the name &lt;code&gt;_start&lt;&#x2F;code&gt;. Without the attribute, the compiler would generate some cryptic &lt;code&gt;_ZN3blog_os4_start7hb173fedf945531caE&lt;&#x2F;code&gt; symbol to give every function a unique name. The attribute is required because we need to tell the name of the entry point function to the linker in the next step.&lt;&#x2F;p&gt;
&lt;p&gt;We also have to mark the function as &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2F;code&gt; to tell the compiler that it should use the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;C calling convention&lt;&#x2F;a&gt; for this function (instead of the unspecified Rust calling convention). The reason for naming the function &lt;code&gt;_start&lt;&#x2F;code&gt; is that this is the default entry point name for most systems.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;!&lt;&#x2F;code&gt; return type means that the function is diverging, i.e. not allowed to ever return. This is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader. So instead of returning, the entry point should e.g. invoke the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exit_(system_call)&quot;&gt;&lt;code&gt;exit&lt;&#x2F;code&gt; system call&lt;&#x2F;a&gt; of the operating system. In our case, shutting down the machine could be a reasonable action, since there‚Äôs nothing left to do if a freestanding binary returns. For now, we fulfill the requirement by looping endlessly.&lt;&#x2F;p&gt;
&lt;p&gt;When we run &lt;code&gt;cargo build&lt;&#x2F;code&gt; now, we get an ugly &lt;em&gt;linker&lt;&#x2F;em&gt; error.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;linker-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linker-errors&quot; aria-label=&quot;Anchor link for: linker-errors&quot;&gt;üîó&lt;&#x2F;a&gt;Linker Errors&lt;&#x2F;h2&gt;
&lt;p&gt;The linker is a program that combines the generated code into an executable. Since the executable format differs between Linux, Windows, and macOS, each system has its own linker that throws a different error. The fundamental cause of the errors is the same: the default configuration of the linker assumes that our program depends on the C runtime, which it does not.&lt;&#x2F;p&gt;
&lt;p&gt;To solve the errors, we need to tell the linker that it should not include the C runtime. We can do this either by passing a certain set of arguments to the linker or by building for a bare metal target.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;building-for-a-bare-metal-target&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-for-a-bare-metal-target&quot; aria-label=&quot;Anchor link for: building-for-a-bare-metal-target&quot;&gt;üîó&lt;&#x2F;a&gt;Building for a Bare Metal Target&lt;&#x2F;h3&gt;
&lt;p&gt;By default Rust tries to build an executable that is able to run in your current system environment. For example, if you‚Äôre using Windows on &lt;code&gt;x86_64&lt;&#x2F;code&gt;, Rust tries to build an &lt;code&gt;.exe&lt;&#x2F;code&gt; Windows executable that uses &lt;code&gt;x86_64&lt;&#x2F;code&gt; instructions. This environment is called your ‚Äúhost‚Äù system.&lt;&#x2F;p&gt;
&lt;p&gt;To describe different environments, Rust uses a string called &lt;a href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;CrossCompilation.html#target-triple&quot;&gt;&lt;em&gt;target triple&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. You can see the target triple for your host system by running &lt;code&gt;rustc --version --verbose&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;rustc 1.35.0-nightly (474e7a648 2019-04-07)
&lt;&#x2F;span&gt;&lt;span&gt;binary: rustc
&lt;&#x2F;span&gt;&lt;span&gt;commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
&lt;&#x2F;span&gt;&lt;span&gt;commit-date: 2019-04-07
&lt;&#x2F;span&gt;&lt;span&gt;host: x86_64-unknown-linux-gnu
&lt;&#x2F;span&gt;&lt;span&gt;release: 1.35.0-nightly
&lt;&#x2F;span&gt;&lt;span&gt;LLVM version: 8.0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The above output is from a &lt;code&gt;x86_64&lt;&#x2F;code&gt; Linux system. We see that the &lt;code&gt;host&lt;&#x2F;code&gt; triple is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt;, which includes the CPU architecture (&lt;code&gt;x86_64&lt;&#x2F;code&gt;), the vendor (&lt;code&gt;unknown&lt;&#x2F;code&gt;), the operating system (&lt;code&gt;linux&lt;&#x2F;code&gt;), and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Application_binary_interface&quot;&gt;ABI&lt;&#x2F;a&gt; (&lt;code&gt;gnu&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;By compiling for our host triple, the Rust compiler and the linker assume that there is an underlying operating system such as Linux or Windows that uses the C runtime by default, which causes the linker errors. So, to avoid the linker errors, we can compile for a different environment with no underlying operating system.&lt;&#x2F;p&gt;
&lt;p&gt;An example of such a bare metal environment is the &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2F;code&gt; target triple, which describes an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Embedded_system&quot;&gt;embedded&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ARM_architecture&quot;&gt;ARM&lt;&#x2F;a&gt; system. The details are not important, all that matters is that the target triple has no underlying operating system, which is indicated by the &lt;code&gt;none&lt;&#x2F;code&gt; in the target triple. To be able to compile for this target, we need to add it in rustup:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;rustup target add thumbv7em-none-eabihf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This downloads a copy of the standard (and core) library for the system. Now we can build our freestanding executable for this target:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo build --target thumbv7em-none-eabihf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By passing a &lt;code&gt;--target&lt;&#x2F;code&gt; argument we &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Cross_compiler&quot;&gt;cross compile&lt;&#x2F;a&gt; our executable for a bare metal target system. Since the target system has no operating system, the linker does not try to link the C runtime and our build succeeds without any linker errors.&lt;&#x2F;p&gt;
&lt;p&gt;This is the approach that we will use for building our OS kernel. Instead of &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2F;code&gt;, we will use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustc&#x2F;targets&#x2F;custom.html&quot;&gt;custom target&lt;&#x2F;a&gt; that describes a &lt;code&gt;x86_64&lt;&#x2F;code&gt; bare metal environment. The details will be explained in the next post.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;linker-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linker-arguments&quot; aria-label=&quot;Anchor link for: linker-arguments&quot;&gt;üîó&lt;&#x2F;a&gt;Linker Arguments&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of compiling for a bare metal system, it is also possible to resolve the linker errors by passing a certain set of arguments to the linker. This isn‚Äôt the approach that we will use for our kernel, therefore this section is optional and only provided for completeness. Click on &lt;em&gt;‚ÄúLinker Arguments‚Äù&lt;&#x2F;em&gt; below to show the optional content.&lt;&#x2F;p&gt;
&lt;details&gt;
&lt;summary&gt;Linker Arguments&lt;&#x2F;summary&gt;
&lt;p&gt;In this section we discuss the linker errors that occur on Linux, Windows, and macOS, and explain how to solve them by passing additional arguments to the linker. Note that the executable format and the linker differ between operating systems, so that a different set of arguments is required for each system.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;linux&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linux&quot; aria-label=&quot;Anchor link for: linux&quot;&gt;üîó&lt;&#x2F;a&gt;Linux&lt;&#x2F;h4&gt;
&lt;p&gt;On Linux the following linker error occurs (shortened):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `cc` failed: exit code: 1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;cc&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o: In function `_start&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;          (.text+0x12): undefined reference to `__libc_csu_fini&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o: In function `_start&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;          (.text+0x19): undefined reference to `__libc_csu_init&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;          &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;..&#x2F;x86_64-linux-gnu&#x2F;Scrt1.o: In function `_start&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;          (.text+0x25): undefined reference to `__libc_start_main&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;          collect2: error: ld returned 1 exit status
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that the linker includes the startup routine of the C runtime by default, which is also called &lt;code&gt;_start&lt;&#x2F;code&gt;. It requires some symbols of the C standard library &lt;code&gt;libc&lt;&#x2F;code&gt; that we don‚Äôt include due to the &lt;code&gt;no_std&lt;&#x2F;code&gt; attribute, therefore the linker can‚Äôt resolve these references. To solve this, we can tell the linker that it should not link the C startup routine by passing the &lt;code&gt;-nostartfiles&lt;&#x2F;code&gt; flag.&lt;&#x2F;p&gt;
&lt;p&gt;One way to pass linker attributes via cargo is the &lt;code&gt;cargo rustc&lt;&#x2F;code&gt; command. The command behaves exactly like &lt;code&gt;cargo build&lt;&#x2F;code&gt;, but allows to pass options to &lt;code&gt;rustc&lt;&#x2F;code&gt;, the underlying Rust compiler. &lt;code&gt;rustc&lt;&#x2F;code&gt; has the &lt;code&gt;-C link-arg&lt;&#x2F;code&gt; flag, which passes an argument to the linker. Combined, our new build command looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-arg=-nostartfiles
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now our crate builds as a freestanding executable on Linux!&lt;&#x2F;p&gt;
&lt;p&gt;We didn‚Äôt need to specify the name of our entry point function explicitly since the linker looks for a function with the name &lt;code&gt;_start&lt;&#x2F;code&gt; by default.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;windows&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#windows&quot; aria-label=&quot;Anchor link for: windows&quot;&gt;üîó&lt;&#x2F;a&gt;Windows&lt;&#x2F;h4&gt;
&lt;p&gt;On Windows, a different linker error occurs (shortened):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `link.exe` failed: exit code: 1561
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;C:\\Program Files (x86)\\‚Ä¶\\link.exe&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: LINK : fatal error LNK1561: entry point must be defined
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The ‚Äúentry point must be defined‚Äù error means that the linker can‚Äôt find the entry point. On Windows, the default entry point name &lt;a href=&quot;https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;entry-entry-point-symbol&quot;&gt;depends on the used subsystem&lt;&#x2F;a&gt;. For the &lt;code&gt;CONSOLE&lt;&#x2F;code&gt; subsystem, the linker looks for a function named &lt;code&gt;mainCRTStartup&lt;&#x2F;code&gt; and for the &lt;code&gt;WINDOWS&lt;&#x2F;code&gt; subsystem, it looks for a function named &lt;code&gt;WinMainCRTStartup&lt;&#x2F;code&gt;. To override the default and tell the linker to look for our &lt;code&gt;_start&lt;&#x2F;code&gt; function instead, we can pass an &lt;code&gt;&#x2F;ENTRY&lt;&#x2F;code&gt; argument to the linker:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-arg=&#x2F;ENTRY:_start
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;From the different argument format we clearly see that the Windows linker is a completely different program than the Linux linker.&lt;&#x2F;p&gt;
&lt;p&gt;Now a different linker error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `link.exe` failed: exit code: 1221
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;C:\\Program Files (x86)\\‚Ä¶\\link.exe&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: LINK : fatal error LNK1221: a subsystem can&amp;#39;t be inferred and must be
&lt;&#x2F;span&gt;&lt;span&gt;          defined
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error occurs because Windows executables can use different &lt;a href=&quot;https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;build&#x2F;reference&#x2F;entry-entry-point-symbol&quot;&gt;subsystems&lt;&#x2F;a&gt;. For normal programs, they are inferred depending on the entry point name: If the entry point is named &lt;code&gt;main&lt;&#x2F;code&gt;, the &lt;code&gt;CONSOLE&lt;&#x2F;code&gt; subsystem is used, and if the entry point is named &lt;code&gt;WinMain&lt;&#x2F;code&gt;, the &lt;code&gt;WINDOWS&lt;&#x2F;code&gt; subsystem is used. Since our &lt;code&gt;_start&lt;&#x2F;code&gt; function has a different name, we need to specify the subsystem explicitly:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-args=&amp;quot;&#x2F;ENTRY:_start &#x2F;SUBSYSTEM:console&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;code&gt;CONSOLE&lt;&#x2F;code&gt; subsystem here, but the &lt;code&gt;WINDOWS&lt;&#x2F;code&gt; subsystem would work too. Instead of passing &lt;code&gt;-C link-arg&lt;&#x2F;code&gt; multiple times, we use &lt;code&gt;-C link-args&lt;&#x2F;code&gt; which takes a space separated list of arguments.&lt;&#x2F;p&gt;
&lt;p&gt;With this command, our executable should build successfully on Windows.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;macos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#macos&quot; aria-label=&quot;Anchor link for: macos&quot;&gt;üîó&lt;&#x2F;a&gt;macOS&lt;&#x2F;h4&gt;
&lt;p&gt;On macOS, the following linker error occurs (shortened):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `cc` failed: exit code: 1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;cc&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: ld: entry point (_main) undefined. for architecture x86_64
&lt;&#x2F;span&gt;&lt;span&gt;          clang: error: linker command failed with exit code 1 [‚Ä¶]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error message tells us that the linker can‚Äôt find an entry point function with the default name &lt;code&gt;main&lt;&#x2F;code&gt; (for some reason, all functions are prefixed with a &lt;code&gt;_&lt;&#x2F;code&gt; on macOS). To set the entry point to our &lt;code&gt;_start&lt;&#x2F;code&gt; function, we pass the &lt;code&gt;-e&lt;&#x2F;code&gt; linker argument:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-args=&amp;quot;-e __start&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;-e&lt;&#x2F;code&gt; flag specifies the name of the entry point function. Since all functions have an additional &lt;code&gt;_&lt;&#x2F;code&gt; prefix on macOS, we need to set the entry point to &lt;code&gt;__start&lt;&#x2F;code&gt; instead of &lt;code&gt;_start&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now the following linker error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `cc` failed: exit code: 1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;cc&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: ld: dynamic main executables must link with libSystem.dylib
&lt;&#x2F;span&gt;&lt;span&gt;          for architecture x86_64
&lt;&#x2F;span&gt;&lt;span&gt;          clang: error: linker command failed with exit code 1 [‚Ä¶]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;macOS &lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;qa&#x2F;qa1118&#x2F;_index.html&quot;&gt;does not officially support statically linked binaries&lt;&#x2F;a&gt; and requires programs to link the &lt;code&gt;libSystem&lt;&#x2F;code&gt; library by default. To override this and link a static binary, we pass the &lt;code&gt;-static&lt;&#x2F;code&gt; flag to the linker:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-args=&amp;quot;-e __start -static&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This still does not suffice, as a third linker error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: linking with `cc` failed: exit code: 1
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: &amp;quot;cc&amp;quot; [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;  = note: ld: library not found for -lcrt0.o
&lt;&#x2F;span&gt;&lt;span&gt;          clang: error: linker command failed with exit code 1 [‚Ä¶]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error occurs because programs on macOS link to &lt;code&gt;crt0&lt;&#x2F;code&gt; (‚ÄúC runtime zero‚Äù) by default. This is similar to the error we had on Linux and can also be solved by adding the &lt;code&gt;-nostartfiles&lt;&#x2F;code&gt; linker argument:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo rustc -- -C link-args=&amp;quot;-e __start -static -nostartfiles&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now our program should build successfully on macOS.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;unifying-the-build-commands&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unifying-the-build-commands&quot; aria-label=&quot;Anchor link for: unifying-the-build-commands&quot;&gt;üîó&lt;&#x2F;a&gt;Unifying the Build Commands&lt;&#x2F;h4&gt;
&lt;p&gt;Right now we have different build commands depending on the host platform, which is not ideal. To avoid this, we can create a file named &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; that contains the platform-specific arguments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;linux&amp;quot;)&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-arg=-nostartfiles&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;windows&amp;quot;)&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-args=&#x2F;ENTRY:_start &#x2F;SUBSYSTEM:console&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;macos&amp;quot;)&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-args=-e __start -static -nostartfiles&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;rustflags&lt;&#x2F;code&gt; key contains arguments that are automatically added to every invocation of &lt;code&gt;rustc&lt;&#x2F;code&gt;. For more information on the &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; file, check out the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;config.html&quot;&gt;official documentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now our program should be buildable on all three platforms with a simple &lt;code&gt;cargo build&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;should-you-do-this&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#should-you-do-this&quot; aria-label=&quot;Anchor link for: should-you-do-this&quot;&gt;üîó&lt;&#x2F;a&gt;Should You Do This?&lt;&#x2F;h4&gt;
&lt;p&gt;While it‚Äôs possible to build a freestanding executable for Linux, Windows, and macOS, it‚Äôs probably not a good idea. The reason is that our executable still expects various things, for example that a stack is initialized when the &lt;code&gt;_start&lt;&#x2F;code&gt; function is called. Without the C runtime, some of these requirements might not be fulfilled, which might cause our program to fail, e.g. through a segmentation fault.&lt;&#x2F;p&gt;
&lt;p&gt;If you want to create a minimal binary that runs on top of an existing operating system, including &lt;code&gt;libc&lt;&#x2F;code&gt; and setting the &lt;code&gt;#[start]&lt;&#x2F;code&gt; attribute as described &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.16.0&#x2F;book&#x2F;no-stdlib.html&quot;&gt;here&lt;&#x2F;a&gt; is probably a better idea.&lt;&#x2F;p&gt;
&lt;&#x2F;details&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;A minimal freestanding Rust binary looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;src&#x2F;main.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#![no_std] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t link the Rust standard library
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; disable all Rust-level entry points
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; this function is the entry point, since the linker looks for a function
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; named `_start` by default
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;crate_name&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;authors &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Author Name &amp;lt;author@example.com&amp;gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# the profile used for `cargo build`
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.dev&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# disable stack unwinding on panic
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# the profile used for `cargo build --release`
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.release&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# disable stack unwinding on panic
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To build this binary, we need to compile for a bare metal target such as &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo build --target thumbv7em-none-eabihf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Alternatively, we can compile it for the host system by passing additional linker arguments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# Linux
&lt;&#x2F;span&gt;&lt;span&gt;cargo rustc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt; --&lt;&#x2F;span&gt;&lt;span&gt; -C link-arg=-nostartfiles
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# Windows
&lt;&#x2F;span&gt;&lt;span&gt;cargo rustc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt; --&lt;&#x2F;span&gt;&lt;span&gt; -C link-args=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&#x2F;ENTRY:_start &#x2F;SUBSYSTEM:console&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# macOS
&lt;&#x2F;span&gt;&lt;span&gt;cargo rustc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt; --&lt;&#x2F;span&gt;&lt;span&gt; -C link-args=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-e __start -static -nostartfiles&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that this is just a minimal example of a freestanding Rust binary. This binary expects various things, for example, that a stack is initialized when the &lt;code&gt;_start&lt;&#x2F;code&gt; function is called. &lt;strong&gt;So for any real use of such a binary, more steps are required&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; explains the steps needed for turning our freestanding binary into a minimal operating system kernel. This includes creating a custom target, combining our executable with a bootloader, and learning how to print something to the screen.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>A Minimal Rust Kernel</title>
                <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/minimal-rust-kernel/</link>
                <guid>https://os.phil-opp.com/minimal-rust-kernel/</guid>
                <description>&lt;p&gt;In this post, we create a minimal 64-bit Rust kernel for the x86 architecture. We build upon the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;freestanding-rust-binary&#x2F;&quot;&gt;freestanding Rust binary&lt;&#x2F;a&gt; from the previous post to create a bootable disk image that prints something to the screen.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&quot;&gt;GitHub&lt;&#x2F;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#comments&quot;&gt;at the bottom&lt;&#x2F;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;post-02&quot;&gt;&lt;code&gt;post-02&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; branch.&lt;&#x2F;p&gt;
&lt;!-- fix for zola anchor checker (target is in template): &lt;a id=&quot;comments&quot;&gt; --&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;the-boot-process&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-boot-process&quot; aria-label=&quot;Anchor link for: the-boot-process&quot;&gt;üîó&lt;&#x2F;a&gt;The Boot Process&lt;&#x2F;h2&gt;
&lt;p&gt;When you turn on a computer, it begins executing firmware code that is stored in motherboard &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Read-only_memory&quot;&gt;ROM&lt;&#x2F;a&gt;. This code performs a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Power-on_self-test&quot;&gt;power-on self-test&lt;&#x2F;a&gt;, detects available RAM, and pre-initializes the CPU and hardware. Afterwards, it looks for a bootable disk and starts booting the operating system kernel.&lt;&#x2F;p&gt;
&lt;p&gt;On x86, there are two firmware standards: the ‚ÄúBasic Input&#x2F;Output System‚Äú (&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BIOS&quot;&gt;BIOS&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt;) and the newer ‚ÄúUnified Extensible Firmware Interface‚Äù (&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Unified_Extensible_Firmware_Interface&quot;&gt;UEFI&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt;). The BIOS standard is old and outdated, but simple and well-supported on any x86 machine since the 1980s. UEFI, in contrast, is more modern and has much more features, but is more complex to set up (at least in my opinion).&lt;&#x2F;p&gt;
&lt;p&gt;Currently, we only provide BIOS support, but support for UEFI is planned, too. If you‚Äôd like to help us with this, check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;349&quot;&gt;Github issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bios-boot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bios-boot&quot; aria-label=&quot;Anchor link for: bios-boot&quot;&gt;üîó&lt;&#x2F;a&gt;BIOS Boot&lt;&#x2F;h3&gt;
&lt;p&gt;Almost all x86 systems have support for BIOS booting, including newer UEFI-based machines that use an emulated BIOS. This is great, because you can use the same boot logic across all machines from the last century. But this wide compatibility is at the same time the biggest disadvantage of BIOS booting, because it means that the CPU is put into a 16-bit compatibility mode called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real_mode&quot;&gt;real mode&lt;&#x2F;a&gt; before booting so that archaic bootloaders from the 1980s would still work.&lt;&#x2F;p&gt;
&lt;p&gt;But let‚Äôs start from the beginning:&lt;&#x2F;p&gt;
&lt;p&gt;When you turn on a computer, it loads the BIOS from some special flash memory located on the motherboard. The BIOS runs self-test and initialization routines of the hardware, then it looks for bootable disks. If it finds one, control is transferred to its &lt;em&gt;bootloader&lt;&#x2F;em&gt;, which is a 512-byte portion of executable code stored at the disk‚Äôs beginning. Most bootloaders are larger than 512 bytes, so bootloaders are commonly split into a small first stage, which fits into 512 bytes, and a second stage, which is subsequently loaded by the first stage.&lt;&#x2F;p&gt;
&lt;p&gt;The bootloader has to determine the location of the kernel image on the disk and load it into memory. It also needs to switch the CPU from the 16-bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Real_mode&quot;&gt;real mode&lt;&#x2F;a&gt; first to the 32-bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protected_mode&quot;&gt;protected mode&lt;&#x2F;a&gt;, and then to the 64-bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long_mode&quot;&gt;long mode&lt;&#x2F;a&gt;, where 64-bit registers and the complete main memory are available. Its third job is to query certain information (such as a memory map) from the BIOS and pass it to the OS kernel.&lt;&#x2F;p&gt;
&lt;p&gt;Writing a bootloader is a bit cumbersome as it requires assembly language and a lot of non insightful steps like ‚Äúwrite this magic value to this processor register‚Äù. Therefore, we don‚Äôt cover bootloader creation in this post and instead provide a tool named &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&quot;&gt;bootimage&lt;&#x2F;a&gt; that automatically prepends a bootloader to your kernel.&lt;&#x2F;p&gt;
&lt;p&gt;If you are interested in building your own bootloader: Stay tuned, a set of posts on this topic is already planned! &lt;!-- , check out our ‚Äú_[Writing a Bootloader]_‚Äù posts, where we explain in detail how a bootloader is built. --&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-multiboot-standard&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-multiboot-standard&quot; aria-label=&quot;Anchor link for: the-multiboot-standard&quot;&gt;üîó&lt;&#x2F;a&gt;The Multiboot Standard&lt;&#x2F;h4&gt;
&lt;p&gt;To avoid that every operating system implements its own bootloader, which is only compatible with a single OS, the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Free_Software_Foundation&quot;&gt;Free Software Foundation&lt;&#x2F;a&gt; created an open bootloader standard called &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Multiboot&quot;&gt;Multiboot&lt;&#x2F;a&gt; in 1995. The standard defines an interface between the bootloader and the operating system, so that any Multiboot-compliant bootloader can load any Multiboot-compliant operating system. The reference implementation is &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;GNU_GRUB&quot;&gt;GNU GRUB&lt;&#x2F;a&gt;, which is the most popular bootloader for Linux systems.&lt;&#x2F;p&gt;
&lt;p&gt;To make a kernel Multiboot compliant, one just needs to insert a so-called &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;grub&#x2F;manual&#x2F;multiboot&#x2F;multiboot.html#OS-image-format&quot;&gt;Multiboot header&lt;&#x2F;a&gt; at the beginning of the kernel file. This makes it very easy to boot an OS from GRUB. However, GRUB and the Multiboot standard have some problems too:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;They support only the 32-bit protected mode. This means that you still have to do the CPU configuration to switch to the 64-bit long mode.&lt;&#x2F;li&gt;
&lt;li&gt;They are designed to make the bootloader simple instead of the kernel. For example, the kernel needs to be linked with an &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Multiboot#Multiboot_2&quot;&gt;adjusted default page size&lt;&#x2F;a&gt;, because GRUB can‚Äôt find the Multiboot header otherwise. Another example is that the &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;grub&#x2F;manual&#x2F;multiboot&#x2F;multiboot.html#Boot-information-format&quot;&gt;boot information&lt;&#x2F;a&gt;, which is passed to the kernel, contains lots of architecture-dependent structures instead of providing clean abstractions.&lt;&#x2F;li&gt;
&lt;li&gt;Both GRUB and the Multiboot standard are only sparsely documented.&lt;&#x2F;li&gt;
&lt;li&gt;GRUB needs to be installed on the host system to create a bootable disk image from the kernel file. This makes development on Windows or Mac more difficult.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Because of these drawbacks, we decided to not use GRUB or the Multiboot standard. However, we plan to add Multiboot support to our &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&quot;&gt;bootimage&lt;&#x2F;a&gt; tool, so that it‚Äôs possible to load your kernel on a GRUB system too. If you‚Äôre interested in writing a Multiboot compliant kernel, check out the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;&quot;&gt;first edition&lt;&#x2F;a&gt; of this blog series.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;uefi&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#uefi&quot; aria-label=&quot;Anchor link for: uefi&quot;&gt;üîó&lt;&#x2F;a&gt;UEFI&lt;&#x2F;h3&gt;
&lt;p&gt;(We don‚Äôt provide UEFI support at the moment, but we would love to! If you‚Äôd like to help, please tell us in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;349&quot;&gt;Github issue&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-minimal-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-minimal-kernel&quot; aria-label=&quot;Anchor link for: a-minimal-kernel&quot;&gt;üîó&lt;&#x2F;a&gt;A Minimal Kernel&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we roughly know how a computer boots, it‚Äôs time to create our own minimal kernel. Our goal is to create a disk image that prints a ‚ÄúHello World!‚Äù to the screen when booted. We do this by extending the previous post‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;freestanding-rust-binary&#x2F;&quot;&gt;freestanding Rust binary&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As you may remember, we built the freestanding binary through &lt;code&gt;cargo&lt;&#x2F;code&gt;, but depending on the operating system, we needed different entry point names and compile flags. That‚Äôs because &lt;code&gt;cargo&lt;&#x2F;code&gt; builds for the &lt;em&gt;host system&lt;&#x2F;em&gt; by default, i.e., the system you‚Äôre running on. This isn‚Äôt something we want for our kernel, because a kernel that runs on top of, e.g., Windows, does not make much sense. Instead, we want to compile for a clearly defined &lt;em&gt;target system&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;installing-rust-nightly&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#installing-rust-nightly&quot; aria-label=&quot;Anchor link for: installing-rust-nightly&quot;&gt;üîó&lt;&#x2F;a&gt;Installing Rust Nightly&lt;&#x2F;h3&gt;
&lt;p&gt;Rust has three release channels: &lt;em&gt;stable&lt;&#x2F;em&gt;, &lt;em&gt;beta&lt;&#x2F;em&gt;, and &lt;em&gt;nightly&lt;&#x2F;em&gt;. The Rust Book explains the difference between these channels really well, so take a minute and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains&quot;&gt;check it out&lt;&#x2F;a&gt;. For building an operating system, we will need some experimental features that are only available on the nightly channel, so we need to install a nightly version of Rust.&lt;&#x2F;p&gt;
&lt;p&gt;To manage Rust installations, I highly recommend &lt;a href=&quot;https:&#x2F;&#x2F;www.rustup.rs&#x2F;&quot;&gt;rustup&lt;&#x2F;a&gt;. It allows you to install nightly, beta, and stable compilers side-by-side and makes it easy to update them. With rustup, you can use a nightly compiler for the current directory by running &lt;code&gt;rustup override set nightly&lt;&#x2F;code&gt;. Alternatively, you can add a file called &lt;code&gt;rust-toolchain&lt;&#x2F;code&gt; with the content &lt;code&gt;nightly&lt;&#x2F;code&gt; to the project‚Äôs root directory. You can check that you have a nightly version installed by running &lt;code&gt;rustc --version&lt;&#x2F;code&gt;: The version number should contain &lt;code&gt;-nightly&lt;&#x2F;code&gt; at the end.&lt;&#x2F;p&gt;
&lt;p&gt;The nightly compiler allows us to opt-in to various experimental features by using so-called &lt;em&gt;feature flags&lt;&#x2F;em&gt; at the top of our file. For example, we could enable the experimental &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;reference&#x2F;inline-assembly.html&quot;&gt;&lt;code&gt;asm!&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; for inline assembly by adding &lt;code&gt;#![feature(asm)]&lt;&#x2F;code&gt; to the top of our &lt;code&gt;main.rs&lt;&#x2F;code&gt;. Note that such experimental features are completely unstable, which means that future Rust versions might change or remove them without prior warning. For this reason, we will only use them if absolutely necessary.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;target-specification&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specification&quot; aria-label=&quot;Anchor link for: target-specification&quot;&gt;üîó&lt;&#x2F;a&gt;Target Specification&lt;&#x2F;h3&gt;
&lt;p&gt;Cargo supports different target systems through the &lt;code&gt;--target&lt;&#x2F;code&gt; parameter. The target is described by a so-called &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;CrossCompilation.html#target-triple&quot;&gt;target triple&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;, which describes the CPU architecture, the vendor, the operating system, and the &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;2456882&quot;&gt;ABI&lt;&#x2F;a&gt;. For example, the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target triple describes a system with an &lt;code&gt;x86_64&lt;&#x2F;code&gt; CPU, no clear vendor, and a Linux operating system with the GNU ABI. Rust supports &lt;a href=&quot;https:&#x2F;&#x2F;forge.rust-lang.org&#x2F;release&#x2F;platform-support.html&quot;&gt;many different target triples&lt;&#x2F;a&gt;, including &lt;code&gt;arm-linux-androideabi&lt;&#x2F;code&gt; for Android or &lt;a href=&quot;https:&#x2F;&#x2F;www.hellorust.com&#x2F;setup&#x2F;wasm-target&#x2F;&quot;&gt;&lt;code&gt;wasm32-unknown-unknown&lt;&#x2F;code&gt; for WebAssembly&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For our target system, however, we require some special configuration parameters (e.g. no underlying OS), so none of the &lt;a href=&quot;https:&#x2F;&#x2F;forge.rust-lang.org&#x2F;release&#x2F;platform-support.html&quot;&gt;existing target triples&lt;&#x2F;a&gt; fits. Fortunately, Rust allows us to define &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;rustc&#x2F;targets&#x2F;custom.html&quot;&gt;our own target&lt;&#x2F;a&gt; through a JSON file. For example, a JSON file that describes the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linux&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pre-link-args&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-m64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;morestack&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most fields are required by LLVM to generate code for that platform. For example, the &lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#data-layout&quot;&gt;&lt;code&gt;data-layout&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; field defines the size of various integer, floating point, and pointer types. Then there are fields that Rust uses for conditional compilation, such as &lt;code&gt;target-pointer-width&lt;&#x2F;code&gt;. The third kind of field defines how the crate should be built. For example, the &lt;code&gt;pre-link-args&lt;&#x2F;code&gt; field specifies arguments passed to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linker_(computing)&quot;&gt;linker&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We also target &lt;code&gt;x86_64&lt;&#x2F;code&gt; systems with our kernel, so our target specification will look very similar to the one above. Let‚Äôs start by creating an &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; file (choose any name you like) with the common content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we changed the OS in the &lt;code&gt;llvm-target&lt;&#x2F;code&gt; and the &lt;code&gt;os&lt;&#x2F;code&gt; field to &lt;code&gt;none&lt;&#x2F;code&gt;, because we will run on bare metal.&lt;&#x2F;p&gt;
&lt;p&gt;We add the following build-related entries:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ld.lld&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rust-lld&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of using the platform‚Äôs default linker (which might not support Linux targets), we use the cross-platform &lt;a href=&quot;https:&#x2F;&#x2F;lld.llvm.org&#x2F;&quot;&gt;LLD&lt;&#x2F;a&gt; linker that is shipped with Rust for linking our kernel.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This setting specifies that the target doesn‚Äôt support &lt;a href=&quot;https:&#x2F;&#x2F;www.bogotobogo.com&#x2F;cplusplus&#x2F;stackunwinding.php&quot;&gt;stack unwinding&lt;&#x2F;a&gt; on panic, so instead the program should abort directly. This has the same effect as the &lt;code&gt;panic = &amp;quot;abort&amp;quot;&lt;&#x2F;code&gt; option in our Cargo.toml, so we can remove it from there. (Note that, in contrast to the Cargo.toml option, this target option also applies when we recompile the &lt;code&gt;core&lt;&#x2F;code&gt; library later in this post. So, even if you prefer to keep the Cargo.toml option, make sure to include this option.)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We‚Äôre writing a kernel, so we‚Äôll need to handle interrupts at some point. To do that safely, we have to disable a certain stack pointer optimization called the &lt;em&gt;‚Äúred zone‚Äù&lt;&#x2F;em&gt;, because it would cause stack corruption otherwise. For more information, see our separate post about &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;red-zone&#x2F;&quot;&gt;disabling the red zone&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;features&lt;&#x2F;code&gt; field enables&#x2F;disables target features. We disable the &lt;code&gt;mmx&lt;&#x2F;code&gt; and &lt;code&gt;sse&lt;&#x2F;code&gt; features by prefixing them with a minus and enable the &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature by prefixing it with a plus. Note that there must be no spaces between different flags, otherwise LLVM fails to interpret the features string.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;mmx&lt;&#x2F;code&gt; and &lt;code&gt;sse&lt;&#x2F;code&gt; features determine support for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2F;a&gt; instructions, which can often speed up programs significantly. However, using the large SIMD registers in OS kernels leads to performance problems. The reason is that the kernel needs to restore all registers to their original state before continuing an interrupted program. This means that the kernel has to save the complete SIMD state to main memory on each system call or hardware interrupt. Since the SIMD state is very large (512‚Äì1600 bytes) and interrupts can occur very often, these additional save&#x2F;restore operations considerably harm performance. To avoid this, we disable SIMD for our kernel (not for applications running on top!).&lt;&#x2F;p&gt;
&lt;p&gt;A problem with disabling SIMD is that floating point operations on &lt;code&gt;x86_64&lt;&#x2F;code&gt; require SIMD registers by default. To solve this problem, we add the &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature, which emulates all floating point operations through software functions based on normal integers.&lt;&#x2F;p&gt;
&lt;p&gt;For more information, see our post on &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;disable-simd&#x2F;&quot;&gt;disabling SIMD&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;üîó&lt;&#x2F;a&gt;Putting it Together&lt;&#x2F;h4&gt;
&lt;p&gt;Our target specification file now looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ld.lld&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rust-lld&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;building-our-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-our-kernel&quot; aria-label=&quot;Anchor link for: building-our-kernel&quot;&gt;üîó&lt;&#x2F;a&gt;Building our Kernel&lt;&#x2F;h3&gt;
&lt;p&gt;Compiling for our new target will use Linux conventions (I‚Äôm not quite sure why; I assume it‚Äôs just LLVM‚Äôs default). This means that we need an entry point named &lt;code&gt;_start&lt;&#x2F;code&gt; as described in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;freestanding-rust-binary&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;main.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t link the Rust standard library
&lt;&#x2F;span&gt;&lt;span&gt;#![no_main] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; disable all Rust-level entry points
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; This function is called on panic.
&lt;&#x2F;span&gt;&lt;span&gt;#[panic_handler]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;panic(_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;PanicInfo) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; don&amp;#39;t mangle the name of this function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; this function is the entry point, since the linker looks for a function
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; named `_start` by default
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the entry point needs to be called &lt;code&gt;_start&lt;&#x2F;code&gt; regardless of your host OS.&lt;&#x2F;p&gt;
&lt;p&gt;We can now build the kernel for our new target by passing the name of the JSON file as &lt;code&gt;--target&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo build --target x86_64-blog_os.json
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `core`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It fails! The error tells us that the Rust compiler no longer finds the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;index.html&quot;&gt;&lt;code&gt;core&lt;&#x2F;code&gt; library&lt;&#x2F;a&gt;. This library contains basic Rust types such as &lt;code&gt;Result&lt;&#x2F;code&gt;, &lt;code&gt;Option&lt;&#x2F;code&gt;, and iterators, and is implicitly linked to all &lt;code&gt;no_std&lt;&#x2F;code&gt; crates.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2F;em&gt; library. So it is only valid for supported host triples (e.g., &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt;) but not for our custom target. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2F;code&gt; for these targets first.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-build-std-option&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-build-std-option&quot; aria-label=&quot;Anchor link for: the-build-std-option&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;build-std&lt;&#x2F;code&gt; Option&lt;&#x2F;h4&gt;
&lt;p&gt;That‚Äôs where the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;cargo&#x2F;reference&#x2F;unstable.html#build-std&quot;&gt;&lt;code&gt;build-std&lt;&#x2F;code&gt; feature&lt;&#x2F;a&gt; of cargo comes in. It allows to recompile &lt;code&gt;core&lt;&#x2F;code&gt; and other standard library crates on demand, instead of using the precompiled versions shipped with the Rust installation. This feature is very new and still not finished, so it is marked as ‚Äúunstable‚Äù and only available on &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#installing-rust-nightly&quot;&gt;nightly Rust compilers&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To use the feature, we need to create a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;config.html&quot;&gt;cargo configuration&lt;&#x2F;a&gt; file at &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;unstable&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;build-std &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;core&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;compiler_builtins&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells cargo that it should recompile the &lt;code&gt;core&lt;&#x2F;code&gt; and &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; libraries. The latter is required because it is a dependency of &lt;code&gt;core&lt;&#x2F;code&gt;. In order to recompile these libraries, cargo needs access to the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; The &lt;code&gt;unstable.build-std&lt;&#x2F;code&gt; configuration key requires at least the Rust nightly from 2020-07-15.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;After setting the &lt;code&gt;unstable.build-std&lt;&#x2F;code&gt; configuration key and installing the &lt;code&gt;rust-src&lt;&#x2F;code&gt; component, we can rerun our build command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo build --target x86_64-blog_os.json
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling core v0.0.0 (&#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling rustc-std-workspace-core v1.99.0 (&#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;tools&#x2F;rustc-std-workspace-core)
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling compiler_builtins v0.1.32
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (&#x2F;‚Ä¶&#x2F;blog_os)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that &lt;code&gt;cargo build&lt;&#x2F;code&gt; now recompiles the &lt;code&gt;core&lt;&#x2F;code&gt;, &lt;code&gt;rustc-std-workspace-core&lt;&#x2F;code&gt; (a dependency of &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt;), and &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; libraries for our custom target.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;memory-related-intrinsics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-related-intrinsics&quot; aria-label=&quot;Anchor link for: memory-related-intrinsics&quot;&gt;üîó&lt;&#x2F;a&gt;Memory-Related Intrinsics&lt;&#x2F;h4&gt;
&lt;p&gt;The Rust compiler assumes that a certain set of built-in functions is available for all systems. Most of these functions are provided by the &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; crate that we just recompiled. However, there are some memory-related functions in that crate that are not enabled by default because they are normally provided by the C library on the system. These functions include &lt;code&gt;memset&lt;&#x2F;code&gt;, which sets all bytes in a memory block to a given value, &lt;code&gt;memcpy&lt;&#x2F;code&gt;, which copies one memory block to another, and &lt;code&gt;memcmp&lt;&#x2F;code&gt;, which compares two memory blocks. While we didn‚Äôt need any of these functions to compile our kernel right now, they will be required as soon as we add some more code to it (e.g. when copying structs around).&lt;&#x2F;p&gt;
&lt;p&gt;Since we can‚Äôt link to the C library of the operating system, we need an alternative way to provide these functions to the compiler. One possible approach for this could be to implement our own &lt;code&gt;memset&lt;&#x2F;code&gt; etc. functions and apply the &lt;code&gt;#[no_mangle]&lt;&#x2F;code&gt; attribute to them (to avoid the automatic renaming during compilation). However, this is dangerous since the slightest mistake in the implementation of these functions could lead to undefined behavior. For example, implementing &lt;code&gt;memcpy&lt;&#x2F;code&gt; with a &lt;code&gt;for&lt;&#x2F;code&gt; loop may result in an infinite recursion because &lt;code&gt;for&lt;&#x2F;code&gt; loops implicitly call the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;iter&#x2F;trait.IntoIterator.html#tymethod.into_iter&quot;&gt;&lt;code&gt;IntoIterator::into_iter&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; trait method, which may call &lt;code&gt;memcpy&lt;&#x2F;code&gt; again. So it‚Äôs a good idea to reuse existing, well-tested implementations instead.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, the &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; crate already contains implementations for all the needed functions, they are just disabled by default to not collide with the implementations from the C library. We can enable them by setting cargo‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;cargo&#x2F;reference&#x2F;unstable.html#build-std-features&quot;&gt;&lt;code&gt;build-std-features&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; flag to &lt;code&gt;[&amp;quot;compiler-builtins-mem&amp;quot;]&lt;&#x2F;code&gt;. Like the &lt;code&gt;build-std&lt;&#x2F;code&gt; flag, this flag can be either passed on the command line as a &lt;code&gt;-Z&lt;&#x2F;code&gt; flag or configured in the &lt;code&gt;unstable&lt;&#x2F;code&gt; table in the &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt; file. Since we always want to build with this flag, the config file option makes more sense for us:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;unstable&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;build-std-features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;compiler-builtins-mem&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;build-std &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;core&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;compiler_builtins&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Support for the &lt;code&gt;compiler-builtins-mem&lt;&#x2F;code&gt; feature was only &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;77284&quot;&gt;added very recently&lt;&#x2F;a&gt;, so you need at least Rust nightly &lt;code&gt;2020-09-30&lt;&#x2F;code&gt; for it.)&lt;&#x2F;p&gt;
&lt;p&gt;Behind the scenes, this flag enables the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;compiler-builtins&#x2F;blob&#x2F;eff506cd49b637f1ab5931625a33cef7e91fbbf6&#x2F;Cargo.toml#L54-L55&quot;&gt;&lt;code&gt;mem&lt;&#x2F;code&gt; feature&lt;&#x2F;a&gt; of the &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; crate. The effect of this is that the &lt;code&gt;#[no_mangle]&lt;&#x2F;code&gt; attribute is applied to the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;compiler-builtins&#x2F;blob&#x2F;eff506cd49b637f1ab5931625a33cef7e91fbbf6&#x2F;src&#x2F;mem.rs#L12-L69&quot;&gt;&lt;code&gt;memcpy&lt;&#x2F;code&gt; etc. implementations&lt;&#x2F;a&gt; of the crate, which makes them available to the linker.&lt;&#x2F;p&gt;
&lt;p&gt;With this change, our kernel has valid implementations for all compiler-required functions, so it will continue to compile even if our code gets more complex.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;set-a-default-target&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#set-a-default-target&quot; aria-label=&quot;Anchor link for: set-a-default-target&quot;&gt;üîó&lt;&#x2F;a&gt;Set a Default Target&lt;&#x2F;h4&gt;
&lt;p&gt;To avoid passing the &lt;code&gt;--target&lt;&#x2F;code&gt; parameter on every invocation of &lt;code&gt;cargo build&lt;&#x2F;code&gt;, we can override the default target. To do this, we add the following to our &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;config.html&quot;&gt;cargo configuration&lt;&#x2F;a&gt; file at &lt;code&gt;.cargo&#x2F;config.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;target &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-blog_os.json&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells &lt;code&gt;cargo&lt;&#x2F;code&gt; to use our &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; target when no explicit &lt;code&gt;--target&lt;&#x2F;code&gt; argument is passed. This means that we can now build our kernel with a simple &lt;code&gt;cargo build&lt;&#x2F;code&gt;. For more information on cargo configuration options, check out the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;config.html&quot;&gt;official documentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We are now able to build our kernel for a bare metal target with a simple &lt;code&gt;cargo build&lt;&#x2F;code&gt;. However, our &lt;code&gt;_start&lt;&#x2F;code&gt; entry point, which will be called by the boot loader, is still empty. It‚Äôs time that we output something to screen from it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;printing-to-screen&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-to-screen&quot; aria-label=&quot;Anchor link for: printing-to-screen&quot;&gt;üîó&lt;&#x2F;a&gt;Printing to Screen&lt;&#x2F;h3&gt;
&lt;p&gt;The easiest way to print text to the screen at this stage is the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VGA-compatible_text_mode&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;. It is a special memory area mapped to the VGA hardware that contains the contents displayed on screen. It normally consists of 25 lines that each contain 80 character cells. Each character cell displays an ASCII character with some foreground and background colors. The screen output looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;f&#x2F;f8&#x2F;Codepage-437.png&quot; alt=&quot;screen output for common ASCII characters&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We will discuss the exact layout of the VGA buffer in the next post, where we write a first small driver for it. For printing ‚ÄúHello World!‚Äù, we just need to know that the buffer is located at address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; and that each character cell consists of an ASCII byte and a color byte.&lt;&#x2F;p&gt;
&lt;p&gt;The implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HELLO&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;_start() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; vga_buffer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;byte) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HELLO&lt;&#x2F;span&gt;&lt;span&gt;.iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            *vga_buffer.offset(i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as isize &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) = byte;
&lt;&#x2F;span&gt;&lt;span&gt;            *vga_buffer.offset(i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as isize &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we cast the integer &lt;code&gt;0xb8000&lt;&#x2F;code&gt; into a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2F;a&gt;. Then we &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch13-02-iterators.html&quot;&gt;iterate&lt;&#x2F;a&gt; over the bytes of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-03-lifetime-syntax.html#the-static-lifetime&quot;&gt;static&lt;&#x2F;a&gt; &lt;code&gt;HELLO&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;tokens.html#byte-string-literals&quot;&gt;byte string&lt;&#x2F;a&gt;. We use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to additionally get a running variable &lt;code&gt;i&lt;&#x2F;code&gt;. In the body of the for loop, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html#method.offset&quot;&gt;&lt;code&gt;offset&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method to write the string byte and the corresponding color byte (&lt;code&gt;0xb&lt;&#x2F;code&gt; is a light cyan).&lt;&#x2F;p&gt;
&lt;p&gt;Note that there‚Äôs an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; block around all memory writes. The reason is that the Rust compiler can‚Äôt prove that the raw pointers we create are valid. They could point anywhere and lead to data corruption. By putting them into an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block, we‚Äôre basically telling the compiler that we are absolutely sure that the operations are valid. Note that an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block does not turn off Rust‚Äôs safety checks. It only allows you to do &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;five additional things&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I want to emphasize that &lt;strong&gt;this is not the way we want to do things in Rust!&lt;&#x2F;strong&gt; It‚Äôs very easy to mess up when working with raw pointers inside unsafe blocks. For example, we could easily write beyond the buffer‚Äôs end if we‚Äôre not careful.&lt;&#x2F;p&gt;
&lt;p&gt;So we want to minimize the use of &lt;code&gt;unsafe&lt;&#x2F;code&gt; as much as possible. Rust gives us the ability to do this by creating safe abstractions. For example, we could create a VGA buffer type that encapsulates all unsafety and ensures that it is &lt;em&gt;impossible&lt;&#x2F;em&gt; to do anything wrong from the outside. This way, we would only need minimal amounts of &lt;code&gt;unsafe&lt;&#x2F;code&gt; code and can be sure that we don‚Äôt violate &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory_safety&quot;&gt;memory safety&lt;&#x2F;a&gt;. We will create such a safe VGA buffer abstraction in the next post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;running-our-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-our-kernel&quot; aria-label=&quot;Anchor link for: running-our-kernel&quot;&gt;üîó&lt;&#x2F;a&gt;Running our Kernel&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have an executable that does something perceptible, it is time to run it. First, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader. Then we can run the disk image in the &lt;a href=&quot;https:&#x2F;&#x2F;www.qemu.org&#x2F;&quot;&gt;QEMU&lt;&#x2F;a&gt; virtual machine or boot it on real hardware using a USB stick.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-a-bootimage&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-bootimage&quot; aria-label=&quot;Anchor link for: creating-a-bootimage&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a Bootimage&lt;&#x2F;h3&gt;
&lt;p&gt;To turn our compiled kernel into a bootable disk image, we need to link it with a bootloader. As we learned in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;#the-boot-process&quot;&gt;section about booting&lt;&#x2F;a&gt;, the bootloader is responsible for initializing the CPU and loading our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of writing our own bootloader, which is a project on its own, we use the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate. This crate implements a basic BIOS bootloader without any C dependencies, just Rust and inline assembly. To use it for booting our kernel, we need to add a dependency on it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.23&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding the bootloader as a dependency is not enough to actually create a bootable disk image. The problem is that we need to link our kernel with the bootloader after compilation, but cargo has no support for &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;545&quot;&gt;post-build scripts&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To solve this problem, we created a tool named &lt;code&gt;bootimage&lt;&#x2F;code&gt; that first compiles the kernel and bootloader, and then links them together to create a bootable disk image. To install the tool, execute the following command in your terminal:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo install bootimage
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For running &lt;code&gt;bootimage&lt;&#x2F;code&gt; and building the bootloader, you need to have the &lt;code&gt;llvm-tools-preview&lt;&#x2F;code&gt; rustup component installed. You can do so by executing &lt;code&gt;rustup component add llvm-tools-preview&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;After installing &lt;code&gt;bootimage&lt;&#x2F;code&gt; and adding the &lt;code&gt;llvm-tools-preview&lt;&#x2F;code&gt; component, we can create a bootable disk image by executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo bootimage
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that the tool recompiles our kernel using &lt;code&gt;cargo build&lt;&#x2F;code&gt;, so it will automatically pick up any changes you make. Afterwards, it compiles the bootloader, which might take a while. Like all crate dependencies, it is only built once and then cached, so subsequent builds will be much faster. Finally, &lt;code&gt;bootimage&lt;&#x2F;code&gt; combines the bootloader and your kernel into a bootable disk image.&lt;&#x2F;p&gt;
&lt;p&gt;After executing the command, you should see a bootable disk image named &lt;code&gt;bootimage-blog_os.bin&lt;&#x2F;code&gt; in your &lt;code&gt;target&#x2F;x86_64-blog_os&#x2F;debug&lt;&#x2F;code&gt; directory. You can boot it in a virtual machine or copy it to a USB drive to boot it on real hardware. (Note that this is not a CD image, which has a different format, so burning it to a CD doesn‚Äôt work).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-does-it-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-does-it-work&quot; aria-label=&quot;Anchor link for: how-does-it-work&quot;&gt;üîó&lt;&#x2F;a&gt;How does it work?&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;bootimage&lt;&#x2F;code&gt; tool performs the following steps behind the scenes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It compiles our kernel to an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Executable_and_Linkable_Format&quot;&gt;ELF&lt;&#x2F;a&gt; file.&lt;&#x2F;li&gt;
&lt;li&gt;It compiles the bootloader dependency as a standalone executable.&lt;&#x2F;li&gt;
&lt;li&gt;It links the bytes of the kernel ELF file to the bootloader.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;When booted, the bootloader reads and parses the appended ELF file. It then maps the program segments to virtual addresses in the page tables, zeroes the &lt;code&gt;.bss&lt;&#x2F;code&gt; section, and sets up a stack. Finally, it reads the entry point address (our &lt;code&gt;_start&lt;&#x2F;code&gt; function) and jumps to it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;booting-it-in-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#booting-it-in-qemu&quot; aria-label=&quot;Anchor link for: booting-it-in-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Booting it in QEMU&lt;&#x2F;h3&gt;
&lt;p&gt;We can now boot the disk image in a virtual machine. To boot it in &lt;a href=&quot;https:&#x2F;&#x2F;www.qemu.org&#x2F;&quot;&gt;QEMU&lt;&#x2F;a&gt;, execute the following command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 -drive format=raw,file=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This opens a separate window which should look similar to this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;minimal-rust-kernel&#x2F;qemu.png&quot; alt=&quot;QEMU showing ‚ÄúHello World!‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that our ‚ÄúHello World!‚Äù is visible on the screen.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;real-machine&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#real-machine&quot; aria-label=&quot;Anchor link for: real-machine&quot;&gt;üîó&lt;&#x2F;a&gt;Real Machine&lt;&#x2F;h3&gt;
&lt;p&gt;It is also possible to write it to a USB stick and boot it on a real machine, &lt;strong&gt;but be careful&lt;&#x2F;strong&gt; to choose the correct device name, because &lt;strong&gt;everything on that device is overwritten&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; dd if=target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;bootimage-blog_os.bin of=&#x2F;dev&#x2F;sdX &amp;amp;&amp;amp; sync
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Where &lt;code&gt;sdX&lt;&#x2F;code&gt; is the device name of your USB stick. &lt;&#x2F;p&gt;
&lt;p&gt;After writing the image to the USB stick, you can run it on real hardware by booting from it. You probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick. Note that it currently doesn‚Äôt work for UEFI machines, since the &lt;code&gt;bootloader&lt;&#x2F;code&gt; crate has no UEFI support yet.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-cargo-run&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-cargo-run&quot; aria-label=&quot;Anchor link for: using-cargo-run&quot;&gt;üîó&lt;&#x2F;a&gt;Using &lt;code&gt;cargo run&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To make it easier to run our kernel in QEMU, we can set the &lt;code&gt;runner&lt;&#x2F;code&gt; configuration key for cargo:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2F;config.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;none&amp;quot;)&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;runner &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bootimage runner&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;target.&#x27;cfg(target_os = &amp;quot;none&amp;quot;)&#x27;&lt;&#x2F;code&gt; table applies to all targets whose target configuration file‚Äôs &lt;code&gt;&amp;quot;os&amp;quot;&lt;&#x2F;code&gt; field is set to &lt;code&gt;&amp;quot;none&amp;quot;&lt;&#x2F;code&gt;. This includes our &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; target. The &lt;code&gt;runner&lt;&#x2F;code&gt; key specifies the command that should be invoked for &lt;code&gt;cargo run&lt;&#x2F;code&gt;. The command is run after a successful build with the executable path passed as the first argument. See the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;config.html&quot;&gt;cargo documentation&lt;&#x2F;a&gt; for more details.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;bootimage runner&lt;&#x2F;code&gt; command is specifically designed to be usable as a &lt;code&gt;runner&lt;&#x2F;code&gt; executable. It links the given executable with the project‚Äôs bootloader dependency and then launches QEMU. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-osdev&#x2F;bootimage&quot;&gt;Readme of &lt;code&gt;bootimage&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for more details and possible configuration options.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use &lt;code&gt;cargo run&lt;&#x2F;code&gt; to compile our kernel and boot it in QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the &lt;code&gt;println&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Handling Exceptions</title>
                <pubDate>Sun, 26 Mar 2017 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/handling-exceptions/</link>
                <guid>https://os.phil-opp.com/handling-exceptions/</guid>
                <description>&lt;p&gt;In this post, we start exploring CPU exceptions. Exceptions occur in various erroneous situations, for example when accessing an invalid memory address or when dividing by zero. To catch them, we have to set up an &lt;em&gt;interrupt descriptor table&lt;&#x2F;em&gt; that provides handler functions. At the end of this post, our kernel will be able to catch &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Breakpoint&quot;&gt;breakpoint exceptions&lt;&#x2F;a&gt; and to resume normal execution afterwards.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, the complete source code is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_9&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions&quot; aria-label=&quot;Anchor link for: exceptions&quot;&gt;üîó&lt;&#x2F;a&gt;Exceptions&lt;&#x2F;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2F;p&gt;
&lt;p&gt;We‚Äôve already seen several types of exceptions in our kernel:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2F;strong&gt;: This exception occurs when the current instruction is invalid. For example, this exception occurred when we tried to use SSE instructions before enabling SSE. Without SSE, the CPU didn‚Äôt know the &lt;code&gt;movups&lt;&#x2F;code&gt; and &lt;code&gt;movaps&lt;&#x2F;code&gt; instructions, so it throws an exception when it stumbles over them.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2F;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2F;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2F;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2F;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2F;em&gt;. We can‚Äôt catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system. This causes the bootloops we experienced in the previous posts.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For the full list of exceptions check out the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;OSDev wiki&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Descriptor Table&lt;&#x2F;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2F;em&gt; (IDT). In this table we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [0:15]&lt;&#x2F;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;GDT selector&lt;&#x2F;td&gt;&lt;td&gt;Selector of a code segment in the GDT.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Options&lt;&#x2F;td&gt;&lt;td&gt;(see below)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [16:31]&lt;&#x2F;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [32:63]&lt;&#x2F;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2&lt;&#x2F;td&gt;&lt;td&gt;Interrupt Stack Table Index&lt;&#x2F;td&gt;&lt;td&gt;0: Don‚Äôt switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate&lt;&#x2F;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;must be one&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;td&gt;must be zero&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;13‚Äë14&lt;&#x2F;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)&lt;&#x2F;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;Present&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;Exception Table&lt;&#x2F;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the ‚ÄúVector nr.‚Äù column.&lt;&#x2F;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2F;a&gt; register. (We will use these values later in this post.)&lt;&#x2F;li&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14-th entry when a page fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;Check if the entry is present. Raise a double fault if not.&lt;&#x2F;li&gt;
&lt;li&gt;Disable interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2F;li&gt;
&lt;li&gt;Load the specified GDT selector into the CS segment.&lt;&#x2F;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;an-idt-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-idt-type&quot; aria-label=&quot;Anchor link for: an-idt-type&quot;&gt;üîó&lt;&#x2F;a&gt;An IDT Type&lt;&#x2F;h2&gt;
&lt;p&gt;Instead of creating our own IDT type, we will use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2F;code&gt; struct&lt;&#x2F;a&gt; of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate, which looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Idt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;debug: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;non_maskable_interrupt: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;breakpoint: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;overflow: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;bound_range_exceeded: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;invalid_opcode: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;device_not_available: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;double_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;invalid_tss: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;segment_not_present: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;stack_segment_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;general_protection_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;page_fault: IdtEntry&amp;lt;PageFaultHandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;x87_floating_point: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;alignment_check: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;machine_check: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;simd_floating_point: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;virtualization: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;security_exception: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span&gt;interrupts: [IdtEntry&amp;lt;HandlerFunc&amp;gt;; 224],
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; some fields omitted
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The fields have the type &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.IdtEntry.html&quot;&gt;&lt;code&gt;IdtEntry&amp;lt;F&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, which is a struct that represents the fields of an IDT entry (see the table above). The type parameter &lt;code&gt;F&lt;&#x2F;code&gt; defines the expected handler function type. We see that some entries require a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFunc.html&quot;&gt;&lt;code&gt;HandlerFunc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and some entries require a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. The page fault even has its own special type: &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.PageFaultHandlerFunc.html&quot;&gt;&lt;code&gt;PageFaultHandlerFunc&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs look at the &lt;code&gt;HandlerFunc&lt;&#x2F;code&gt; type first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ExceptionStackFrame);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;type-aliases.html&quot;&gt;type alias&lt;&#x2F;a&gt; for an &lt;code&gt;extern &amp;quot;x86-interrupt&amp;quot; fn&lt;&#x2F;code&gt; type. The &lt;code&gt;extern&lt;&#x2F;code&gt; keyword defines a function with a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;ffi.html#foreign-calling-conventions&quot;&gt;foreign calling convention&lt;&#x2F;a&gt; and is often used to communicate with C code (&lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt;). But what is the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-interrupt-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-calling-convention&quot; aria-label=&quot;Anchor link for: the-interrupt-calling-convention&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Calling Convention&lt;&#x2F;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the called function and executes it. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted &lt;code&gt;call&lt;&#x2F;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;Calling conventions&lt;&#x2F;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2F;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2F;code&gt; and &lt;code&gt;rdx&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;600&quot;&gt;there isn‚Äôt even a Rust ABI yet&lt;&#x2F;a&gt;). So these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Preserved and Scratch Registers&lt;&#x2F;h3&gt;
&lt;p&gt;The calling convention divides the registers in two parts: &lt;em&gt;preserved&lt;&#x2F;em&gt; and &lt;em&gt;scratch&lt;&#x2F;em&gt; registers.&lt;&#x2F;p&gt;
&lt;p&gt;The values of &lt;em&gt;preserved&lt;&#x2F;em&gt; registers must remain unchanged across function calls. So a called function (the &lt;em&gt;‚Äúcallee‚Äù&lt;&#x2F;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called &lt;em&gt;‚Äúcallee-saved‚Äù&lt;&#x2F;em&gt;. A common pattern is to save these registers to the stack at the function‚Äôs beginning and restore them just before returning.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite &lt;em&gt;scratch&lt;&#x2F;em&gt; registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it before the function call (e.g. by pushing it to the stack). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers&lt;&#x2F;th&gt;&lt;th&gt;scratch registers&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2F;code&gt;, &lt;code&gt;rbx&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;r12&lt;&#x2F;code&gt;, &lt;code&gt;r13&lt;&#x2F;code&gt;, &lt;code&gt;r14&lt;&#x2F;code&gt;, &lt;code&gt;r15&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;, &lt;code&gt;r10&lt;&#x2F;code&gt;, &lt;code&gt;r11&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2F;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2F;code&gt; on the stack (because it‚Äôs a callee-saved register).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preserving-all-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserving-all-registers&quot; aria-label=&quot;Anchor link for: preserving-all-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Preserving all Registers&lt;&#x2F;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In most cases we don‚Äôt even know at compile time if the generated code will cause an exception. For example, the compiler can‚Äôt know if an instruction causes a stack overflow or a page fault.&lt;&#x2F;p&gt;
&lt;p&gt;Since we don‚Äôt know when an exception occurs, we can‚Äôt backup any registers before. This means that we can‚Äôt use a calling convention that relies on caller-saved registers for exception handlers. Instead, we need a calling convention means that preserves &lt;em&gt;all registers&lt;&#x2F;em&gt;. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is such a calling convention, so it guarantees that all register values are restored to their original values on function return.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-exception-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-exception-stack-frame&quot; aria-label=&quot;Anchor link for: the-exception-stack-frame&quot;&gt;üîó&lt;&#x2F;a&gt;The Exception Stack Frame&lt;&#x2F;h3&gt;
&lt;p&gt;On a normal function call (using the &lt;code&gt;call&lt;&#x2F;code&gt; instruction), the CPU pushes the return address before jumping to the target function. On function return (using the &lt;code&gt;ret&lt;&#x2F;code&gt; instruction), the CPU pops this return address and jumps to it. So the stack frame of a normal function call looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For exception and interrupt handlers, however, pushing a return address would not suffice, since interrupt handlers often run in a different context (stack pointer, CPU flags, etc.). Instead, the CPU performs the following steps when an interrupt occurs:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack pointer&lt;&#x2F;strong&gt;: An interrupt can occur at any instructions, so the stack pointer can have any value, too. However, some CPU instructions (e.g. some SSE instructions) require that the stack pointer is aligned on a 16 byte boundary, therefore the CPU performs such an alignment right after the interrupt.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Switching stacks&lt;&#x2F;strong&gt; (in some cases): A stack switch occurs when the CPU privilege level changes, for example when a CPU exception occurs in an user mode program. It is also possible to configure stack switches for specific interrupts using the so-called &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; (described in the next post).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the old stack pointer&lt;&#x2F;strong&gt;: The CPU pushes the values of the stack pointer (&lt;code&gt;rsp&lt;&#x2F;code&gt;) and the stack segment (&lt;code&gt;ss&lt;&#x2F;code&gt;) registers at the time when the interrupt occurred (before the alignment). This makes it possible to restore the original stack pointer when returning from an interrupt handler.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing and updating the &lt;code&gt;RFLAGS&lt;&#x2F;code&gt; register&lt;&#x2F;strong&gt;: The &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;&lt;code&gt;RFLAGS&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; register contains various control and status bits. On interrupt entry, the CPU changes some bits and pushes the old value.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the instruction pointer&lt;&#x2F;strong&gt;: Before jumping to the interrupt handler function, the CPU pushes the instruction pointer (&lt;code&gt;rip&lt;&#x2F;code&gt;) and the code segment (&lt;code&gt;cs&lt;&#x2F;code&gt;). This is comparable to the return address push of a normal function call.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing an error code&lt;&#x2F;strong&gt; (for some exceptions): For some specific exceptions such as page faults, the CPU pushes an error code, which describes the cause of the exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Invoking the interrupt handler&lt;&#x2F;strong&gt;: The CPU reads the address and the segment descriptor of the interrupt handler function from the corresponding field in the IDT. It then invokes this handler by loading the values into the &lt;code&gt;rip&lt;&#x2F;code&gt; and &lt;code&gt;cs&lt;&#x2F;code&gt; registers.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So the &lt;em&gt;exception stack frame&lt;&#x2F;em&gt; looks like this:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate, the exception stack frame is represented by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.ExceptionStackFrame.html&quot;&gt;&lt;code&gt;ExceptionStackFrame&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct. It is passed to interrupt handlers as &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; and can be used to retrieve additional information about the exception‚Äôs cause. The struct contains no error code field, since only some few exceptions push an error code. These exceptions use the separate &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function type, which has an additional &lt;code&gt;error_code&lt;&#x2F;code&gt; argument.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;behind-the-scenes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#behind-the-scenes&quot; aria-label=&quot;Anchor link for: behind-the-scenes&quot;&gt;üîó&lt;&#x2F;a&gt;Behind the Scenes&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is a powerful abstraction that hides almost all of the messy details of the exception handling process. However, sometimes it‚Äôs useful to know what‚Äôs happening behind the curtain. Here is a short overview of the things that the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention takes care of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Retrieving the arguments&lt;&#x2F;strong&gt;: Most calling conventions expect that the arguments are passed in registers. This is not possible for exception handlers, since we must not overwrite any register values before backing them up on the stack. Instead, the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is aware that the arguments already lie on the stack at a specific offset.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Returning using &lt;code&gt;iretq&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;: Since the exception stack frame completely differs from stack frames of normal function calls, we can‚Äôt return from handlers functions through the normal &lt;code&gt;ret&lt;&#x2F;code&gt; instruction. Instead, the &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction must be used.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Handling the error code&lt;&#x2F;strong&gt;: The error code, which is pushed for some exceptions, makes things much more complex. It changes the stack alignment (see the next point) and needs to be popped off the stack before returning. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention handles all that complexity. However, it doesn‚Äôt know which handler function is used for which exception, so it needs to deduce that information from the number of function arguments. That means that the programmer is still responsible to use the correct function type for each exception. Luckily, the &lt;code&gt;Idt&lt;&#x2F;code&gt; type defined by the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate ensures that the correct function types are used.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack&lt;&#x2F;strong&gt;: There are some instructions (especially SSE instructions) that require a 16-byte stack alignment. The CPU ensures this alignment whenever an exception occurs, but for some exceptions it destroys it again later when it pushes an error code. The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention takes care of this by realigning the stack in this case.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If you are interested in more details: We also have a series of posts that explains exception handling using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2F;a&gt; linked &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;#too-much-magic&quot;&gt;at the end of this post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we‚Äôve understood the theory, it‚Äôs time to handle CPU exceptions in our kernel. We start by creating a new &lt;code&gt;interrupts&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;interrupts;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the new module, we create an &lt;code&gt;init&lt;&#x2F;code&gt; function, that creates a new &lt;code&gt;Idt&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::Idt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can add handler functions. We start by adding a handler for the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Breakpoint&quot;&gt;breakpoint exception&lt;&#x2F;a&gt;. The breakpoint exception is the perfect exception to test exception handling. Its only purpose is to temporary pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2F;code&gt; is executed.&lt;&#x2F;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;01&#x2F;27&#x2F;how-debuggers-work-part-2-breakpoints&quot;&gt;‚Äú&lt;em&gt;How debuggers work&lt;&#x2F;em&gt;‚Äù&lt;&#x2F;a&gt; series.&lt;&#x2F;p&gt;
&lt;p&gt;For our use case, we don‚Äôt need to overwrite any instructions (it wouldn‚Äôt even be possible since we &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#using-the-correct-flags&quot;&gt;set the page table flags&lt;&#x2F;a&gt; to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs create a simple &lt;code&gt;breakpoint_handler&lt;&#x2F;code&gt; function and add it to our IDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::idt::ExceptionStackFrame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;    idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;breakpoint_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ExceptionStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: BREAKPOINT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our handler just outputs a message and pretty-prints the exception stack frame.&lt;&#x2F;p&gt;
&lt;p&gt;When we try to compile it, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: x86-interrupt ABI is experimental and subject to change (see issue #40180)
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts.rs:8:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;8  |   extern &amp;quot;x86-interrupt&amp;quot; fn breakpoint_handler(
&lt;&#x2F;span&gt;&lt;span&gt;   |  _^ starting here...
&lt;&#x2F;span&gt;&lt;span&gt;9  | |     stack_frame: &amp;amp;mut ExceptionStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;10 | | {
&lt;&#x2F;span&gt;&lt;span&gt;11 | |     println!(&amp;quot;EXCEPTION: BREAKPOINT\n{:#?}&amp;quot;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;12 | | }
&lt;&#x2F;span&gt;&lt;span&gt;   | |_^ ...ending here
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This error occurs because the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention is still unstable. To use it anyway, we have to explicitly enable it by adding &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2F;code&gt; on the top of our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the IDT&lt;&#x2F;h3&gt;
&lt;p&gt;In order that the CPU uses our new interrupt descriptor table, we need to load it using the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;lgdt:lidt&quot;&gt;&lt;code&gt;lidt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; instruction. The &lt;code&gt;Idt&lt;&#x2F;code&gt; struct of the &lt;code&gt;x86_64&lt;&#x2F;code&gt; provides a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.Idt.html#method.load&quot;&gt;&lt;code&gt;load&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method function for that. Let‚Äôs try to use it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;    idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;    idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we try to compile it now, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: `idt` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:43:5
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;43 |     idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;   |     ^^^ does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;44 | }
&lt;&#x2F;span&gt;&lt;span&gt;   | - borrowed value only lives until here
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;   = note: borrowed value must be valid for the static lifetime...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the &lt;code&gt;load&lt;&#x2F;code&gt; methods expects a &lt;code&gt;&amp;amp;&#x27;static self&lt;&#x2F;code&gt;, that is a reference that is valid for the complete runtime of the program. The reason is that the CPU will access this table on every interrupt until we load a different IDT. So using a shorter lifetime than &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; could lead to use-after-free bugs.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, this is exactly what happens here. Our &lt;code&gt;idt&lt;&#x2F;code&gt; is created on the stack, so it is only valid inside the &lt;code&gt;init&lt;&#x2F;code&gt; function. Afterwards the stack memory is reused for other functions, so the CPU would interpret random stack memory as IDT. Luckily, the &lt;code&gt;Idt::load&lt;&#x2F;code&gt; method encodes this lifetime requirement in its function definition, so that the Rust compiler is able to prevent this possible bug at compile time.&lt;&#x2F;p&gt;
&lt;p&gt;In order to fix this problem, we need to store our &lt;code&gt;idt&lt;&#x2F;code&gt; at a place where it has a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime. To achieve this, we could either allocate our IDT on the heap using &lt;code&gt;Box&lt;&#x2F;code&gt; and then convert it to a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; reference or we can store the IDT as a &lt;code&gt;static&lt;&#x2F;code&gt;. Let‚Äôs try the latter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: Idt = Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are two problems with this. First, statics are immutable, so we can‚Äôt modify the breakpoint entry from our &lt;code&gt;init&lt;&#x2F;code&gt; function. Second, the &lt;code&gt;Idt::new&lt;&#x2F;code&gt; function is not a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;0911-const-fn.md&quot;&gt;&lt;code&gt;const&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt;, so it can‚Äôt be used to initialize a &lt;code&gt;static&lt;&#x2F;code&gt;. We could solve this problem by using a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;&lt;code&gt;static mut&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; of type &lt;code&gt;Option&amp;lt;Idt&amp;gt;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Idt&amp;gt; = None;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT &lt;&#x2F;span&gt;&lt;span&gt;= Some(Idt::new());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; idt = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.as_mut_ref().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This variant compiles without errors but it‚Äôs far from idiomatic. &lt;code&gt;static mut&lt;&#x2F;code&gt;s are very prone to data races, so we need an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; block&lt;&#x2F;a&gt; on each access. Also, we need to explicitly &lt;code&gt;unwrap&lt;&#x2F;code&gt; the &lt;code&gt;IDT&lt;&#x2F;code&gt; on each use, since might be &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;üîó&lt;&#x2F;a&gt;Lazy Statics to the Rescue&lt;&#x2F;h4&gt;
&lt;p&gt;The one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lazy_static&#x2F;0.2.4&#x2F;lazy_static&#x2F;&quot;&gt;lazy_static&lt;&#x2F;a&gt;. This crate provides a &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro that defines a lazily initialized &lt;code&gt;static&lt;&#x2F;code&gt;. Instead of computing its value at compile time, the &lt;code&gt;static&lt;&#x2F;code&gt; laziliy initializes itself when it‚Äôs accessed the first time. Thus, the initialization happens at runtime so that arbitrarily complex initialization code is possible.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; crate to our project:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; lazy_static;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.4&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2F;code&gt; feature, since we don‚Äôt link the standard library. We also need the &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; attribute on the &lt;code&gt;extern crate&lt;&#x2F;code&gt; line to import the &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can create our static IDT using &lt;code&gt;lazy_static&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note how this solution requires no &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks or &lt;code&gt;unwrap&lt;&#x2F;code&gt; calls.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;aside-how-does-the-lazy-static-macro-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#aside-how-does-the-lazy-static-macro-work&quot; aria-label=&quot;Anchor link for: aside-how-does-the-lazy-static-macro-work&quot;&gt;üîó&lt;&#x2F;a&gt;Aside: How does the &lt;code&gt;lazy_static!&lt;&#x2F;code&gt; macro work?&lt;&#x2F;h5&gt;
&lt;p&gt;The macro generates a &lt;code&gt;static&lt;&#x2F;code&gt; of type &lt;code&gt;Once&amp;lt;Idt&amp;gt;&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html&quot;&gt;&lt;code&gt;Once&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type is provided by the &lt;code&gt;spin&lt;&#x2F;code&gt; crate and allows deferred one-time initialization. It is implemented using an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;struct.AtomicUsize.html&quot;&gt;&lt;code&gt;AtomicUsize&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for synchronization and an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cell&#x2F;struct.UnsafeCell.html&quot;&gt;&lt;code&gt;UnsafeCell&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; for storing the (possibly uninitialized) value. So this solution also uses &lt;code&gt;unsafe&lt;&#x2F;code&gt; behind the scenes, but it is abstracted away in a safe interface.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h3&gt;
&lt;p&gt;Now we should be able to handle breakpoint exceptions! Let‚Äôs try it in our &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(...) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    memory::init(boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; invoke a breakpoint exception
&lt;&#x2F;span&gt;&lt;span&gt;    x86_64::instructions::interrupts::int3();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it in QEMU now (using &lt;code&gt;make run&lt;&#x2F;code&gt;), we see the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;qemu-breakpoint-exception.png&quot; alt=&quot;QEMU printing EXCEPTION: BREAKPOINT and the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It works! The CPU successfully invokes our breakpoint handler, which prints the message, and then returns back to the &lt;code&gt;rust_main&lt;&#x2F;code&gt; function, where the &lt;code&gt;It did not crash!&lt;&#x2F;code&gt; message is printed.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;&#x2F;strong&gt;: If it doesn‚Äôt work and a boot loop occurs, this might be caused by a kernel stack overflow. Try increasing the stack size to at least 16kB (4096 * 4 bytes) in the &lt;code&gt;boot.asm&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;We see that the exception stack frame tells us the instruction and stack pointers at the time when the exception occurred. This information is very useful when debugging unexpected exceptions. For example, we can look at the corresponding assembly line using &lt;code&gt;objdump&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin | grep -B5 &amp;quot;1140a6:&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;00000000001140a0 &amp;lt;x86_64::instructions::interrupts::int3::h015bf61815bb8afe&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  1140a0:	55                   	push   %rbp
&lt;&#x2F;span&gt;&lt;span&gt;  1140a1:	48 89 e5             	mov    %rsp,%rbp
&lt;&#x2F;span&gt;&lt;span&gt;  1140a4:	50                   	push   %rax
&lt;&#x2F;span&gt;&lt;span&gt;  1140a5:	cc                   	int3
&lt;&#x2F;span&gt;&lt;span&gt;  1140a6:	48 83 c4 08          	add    $0x8,%rsp
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;-d&lt;&#x2F;code&gt; flags disassembles the &lt;code&gt;code&lt;&#x2F;code&gt; section and &lt;code&gt;-C&lt;&#x2F;code&gt; flag makes function names more readable by &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Name_mangling&quot;&gt;demangling&lt;&#x2F;a&gt; them. The &lt;code&gt;-B&lt;&#x2F;code&gt; flag of &lt;code&gt;grep&lt;&#x2F;code&gt; specifies the number of preceding lines that should be shown (5 in our case).&lt;&#x2F;p&gt;
&lt;p&gt;We clearly see the &lt;code&gt;int3&lt;&#x2F;code&gt; exception that caused the breakpoint exception at address &lt;code&gt;1140a5&lt;&#x2F;code&gt;. Wait‚Ä¶ the stored instruction pointer was &lt;code&gt;1140a6&lt;&#x2F;code&gt;, which is a normal &lt;code&gt;add&lt;&#x2F;code&gt; operation. What‚Äôs happening here?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;faults-aborts-and-traps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#faults-aborts-and-traps&quot; aria-label=&quot;Anchor link for: faults-aborts-and-traps&quot;&gt;üîó&lt;&#x2F;a&gt;Faults, Aborts, and Traps&lt;&#x2F;h3&gt;
&lt;p&gt;The answer is that the stored instruction pointer only points to the causing instruction for &lt;em&gt;fault&lt;&#x2F;em&gt; type exceptions, but not for &lt;em&gt;trap&lt;&#x2F;em&gt; or &lt;em&gt;abort&lt;&#x2F;em&gt; type exceptions. The difference between these types is the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Faults&lt;&#x2F;strong&gt; are exceptions that can be corrected so that the program can continue as if nothing happened. An example is the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;page fault&lt;&#x2F;a&gt;, which can often be resolved by loading the accessed page from the disk into memory.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Aborts&lt;&#x2F;strong&gt; are fatal exceptions that can‚Äôt be recovered. Examples are &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Machine_Check&quot;&gt;machine check exception&lt;&#x2F;a&gt; or the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Double_Fault&quot;&gt;double fault&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Traps&lt;&#x2F;strong&gt; are only reported to the kernel, but don‚Äôt hinder the continuation of the program. Examples are the breakpoint exception and the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Overflow&quot;&gt;overflow exception&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The reason for the diffent instruction pointer values is that the stored value is also the return address. So for faults, the instruction that caused the exception is restarted and might cause the same exception again if it‚Äôs not resolved. This would not make much sense for traps, since invoking the breakpoint exception again would just cause another breakpoint exception&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-breakpoint-restart-use-cases&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. Thus the instruction pointer points to the &lt;em&gt;next&lt;&#x2F;em&gt; instruction for these exceptions.&lt;&#x2F;p&gt;
&lt;p&gt;In some cases, the distinction between faults and traps is vague. For example, the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Debug&quot;&gt;debug exception&lt;&#x2F;a&gt; behaves like a fault in some cases, but like a trap in others. So to find out the meaning of the saved instruction pointer, it is a good idea to read the official documentation for the exception, which can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;www.amd.com&#x2F;system&#x2F;files&#x2F;TechDocs&#x2F;24593.pdf&quot;&gt;AMD64 manual&lt;&#x2F;a&gt; in Section 8.2. For example, for the breakpoint exception it says:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;#BP&lt;&#x2F;code&gt; is a trap-type exception. The saved instruction pointer points to the byte after the &lt;code&gt;INT3&lt;&#x2F;code&gt; instruction.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The documentation of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; struct and the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;OSDev Wiki&lt;&#x2F;a&gt; also contain this information.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;too-much-magic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#too-much-magic&quot; aria-label=&quot;Anchor link for: too-much-magic&quot;&gt;üîó&lt;&#x2F;a&gt;Too much Magic?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;idt&#x2F;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type made the exception handling process relatively straightforward and painless. If this was too much magic for you and you like to learn all the gory details of exception handling, we got you covered: Our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;extra&#x2F;naked-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions with Naked Functions‚Äù&lt;&#x2F;a&gt; series shows how to handle exceptions without the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and also creates its own &lt;code&gt;Idt&lt;&#x2F;code&gt; type. Historically, these posts were the main exception handling posts before the &lt;code&gt;x86-interrupt&lt;&#x2F;code&gt; calling convention and the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate existed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;We‚Äôve successfully caught our first exception and returned from it! The next step is to add handlers for other common exceptions such as page faults. We also need to make sure that we never cause a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Triple_Fault&quot;&gt;triple fault&lt;&#x2F;a&gt;, since it causes a complete system reset. The next post explains how we can avoid this by correctly catching &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Double_Fault#Double_Fault&quot;&gt;double faults&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-breakpoint-restart-use-cases&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;There are valid use cases for restarting an instruction that caused a breakpoint. The most common use case is a debugger: When setting a breakpoint on some code line, the debugger overwrites the corresponding instruction with an &lt;code&gt;int3&lt;&#x2F;code&gt; instruction, so that the CPU traps when that line is executed. When the user continues execution, the debugger swaps in the original instruction and continues the program from the replaced instruction.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Double Faults</title>
                <pubDate>Mon, 02 Jan 2017 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/double-faults/</link>
                <guid>https://os.phil-opp.com/double-faults/</guid>
                <description>&lt;p&gt;In this post we explore double faults in detail. We also set up an &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; to catch double faults on a separate kernel stack. This way, we can completely prevent triple faults, even on kernel stack overflow.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, the complete source code is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_10&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2F;&#x2F;gitter.im&#x2F;phil-opp&#x2F;blog_os&quot;&gt;gitter chat&lt;&#x2F;a&gt; and a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-double-fault&quot; aria-label=&quot;Anchor link for: what-is-a-double-fault&quot;&gt;üîó&lt;&#x2F;a&gt;What is a Double Fault?&lt;&#x2F;h2&gt;
&lt;p&gt;In simplified terms, a double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered but there is no page fault handler registered in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;Interrupt Descriptor Table&lt;&#x2F;a&gt; (IDT). So it‚Äôs kind of similar to catch-all blocks in programming languages with exceptions, e.g. &lt;code&gt;catch(...)&lt;&#x2F;code&gt; in C++ or &lt;code&gt;catch(Exception e)&lt;&#x2F;code&gt; in Java or C#.&lt;&#x2F;p&gt;
&lt;p&gt;A double fault behaves like a normal exception. It has the vector number &lt;code&gt;8&lt;&#x2F;code&gt; and we can define a normal handler function for it in the IDT. It is really important to provide a double fault handler, because if a double fault is unhandled a fatal &lt;em&gt;triple fault&lt;&#x2F;em&gt; occurs. Triple faults can‚Äôt be caught and most hardware reacts with a system reset.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;triggering-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#triggering-a-double-fault&quot; aria-label=&quot;Anchor link for: triggering-a-double-fault&quot;&gt;üîó&lt;&#x2F;a&gt;Triggering a Double Fault&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs provoke a double fault by triggering an exception for that we didn‚Äôt define a handler function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a page fault
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We try to write to address &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;, but the corresponding page is not present in the page tables. Thus, a page fault occurs. We haven‚Äôt registered a page fault handler in our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;IDT&lt;&#x2F;a&gt;, so a double fault occurs.&lt;&#x2F;p&gt;
&lt;p&gt;When we start our kernel now, we see that it enters an endless boot loop:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-faults&#x2F;boot-loop.gif&quot; alt=&quot;boot loop&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The reason for the boot loop is the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU tries to write to &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;, which causes a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU looks at the corresponding entry in the IDT and sees that the present bit isn‚Äôt set. Thus, it can‚Äôt call the page fault handler and a double fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU looks at the IDT entry of the double fault handler, but this entry is also non-present. Thus, a &lt;em&gt;triple&lt;&#x2F;em&gt; fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;A triple fault is fatal. QEMU reacts to it like most real hardware and issues a system reset.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So in order to prevent this triple fault, we need to either provide a handler function for page faults or a double fault handler. Let‚Äôs start with the latter, since we want to avoid triple faults in all cases.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-double-fault-handler&quot; aria-label=&quot;Anchor link for: a-double-fault-handler&quot;&gt;üîó&lt;&#x2F;a&gt;A Double Fault Handler&lt;&#x2F;h3&gt;
&lt;p&gt;A double fault is a normal exception with an error code, so we can use our &lt;code&gt;handler_with_error_code&lt;&#x2F;code&gt; macro to create a wrapper function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt.breakpoint.set_handler_fn(breakpoint_handler);
&lt;&#x2F;span&gt;&lt;span&gt;        idt.double_fault.set_handler_fn(double_fault_handler);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; our new double fault handler
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;double_fault_handler(
&lt;&#x2F;span&gt;&lt;span&gt;    stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ExceptionStackFrame, _error_code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DOUBLE FAULT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our handler prints a short error message and dumps the exception stack frame. The error code of the double fault handler is always zero, so there‚Äôs no reason to print it.&lt;&#x2F;p&gt;
&lt;p&gt;When we start our kernel now, we should see that the double fault handler is invoked:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-faults&#x2F;qemu-catch-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It worked! Here is what happens this time:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU executes tries to write to &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;, which causes a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;Like before, the CPU looks at the corresponding entry in the IDT and sees that the present bit isn‚Äôt set. Thus, a double fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU jumps to the ‚Äì now present ‚Äì double fault handler.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The triple fault (and the boot-loop) no longer occurs, since the CPU can now call the double fault handler.&lt;&#x2F;p&gt;
&lt;p&gt;That was quite straightforward! So why do we need a whole post for this topic? Well, we‚Äôre now able to catch &lt;em&gt;most&lt;&#x2F;em&gt; double faults, but there are some cases where our current approach doesn‚Äôt suffice.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;causes-of-double-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#causes-of-double-faults&quot; aria-label=&quot;Anchor link for: causes-of-double-faults&quot;&gt;üîó&lt;&#x2F;a&gt;Causes of Double Faults&lt;&#x2F;h2&gt;
&lt;p&gt;Before we look at the special cases, we need to know the exact causes of double faults. Above, we used a pretty vague definition:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A double fault is a special exception that occurs when the CPU fails to invoke an exception handler.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;What does &lt;em&gt;‚Äúfails to invoke‚Äù&lt;&#x2F;em&gt; mean exactly? The handler is not present? The handler is &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;vm-beyondphys.pdf&quot;&gt;swapped out&lt;&#x2F;a&gt;? And what happens if a handler causes exceptions itself?&lt;&#x2F;p&gt;
&lt;p&gt;For example, what happens if‚Ä¶ :&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;a divide-by-zero exception occurs, but the corresponding handler function is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;a page fault occurs, but the page fault handler is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;a divide-by-zero handler causes a breakpoint exception, but the breakpoint handler is swapped out?&lt;&#x2F;li&gt;
&lt;li&gt;our kernel overflows its stack and the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2F;a&gt; is hit?&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Fortunately, the AMD64 manual (&lt;a href=&quot;https:&#x2F;&#x2F;www.amd.com&#x2F;system&#x2F;files&#x2F;TechDocs&#x2F;24593.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) has an exact definition (in Section 8.2.9). According to it, a ‚Äúdouble fault exception &lt;em&gt;can&lt;&#x2F;em&gt; occur when a second exception occurs during the handling of a prior (first) exception handler‚Äù. The &lt;em&gt;‚Äúcan‚Äù&lt;&#x2F;em&gt; is important: Only very specific combinations of exceptions lead to a double fault. These combinations are:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;First Exception&lt;&#x2F;th&gt;&lt;th&gt;Second Exception&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Divide-by-zero_Error&quot;&gt;Divide-by-zero&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2F;a&gt;,&lt;br&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So for example a divide-by-zero fault followed by a page fault is fine (the page fault handler is invoked), but a divide-by-zero fault followed by a general-protection fault leads to a double fault.&lt;&#x2F;p&gt;
&lt;p&gt;With the help of this table, we can answer the first three of the above questions:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;If a divide-by-zero exception occurs and the corresponding handler function is swapped out, a &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;li&gt;If a page fault occurs and the page fault handler is swapped out, a &lt;em&gt;double fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;double fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;li&gt;If a divide-by-zero handler causes a breakpoint exception, the CPU tries to invoke the breakpoint handler. If the breakpoint handler is swapped out, a &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2F;em&gt; is invoked.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In fact, even the case of a non-present handler follows this scheme: A non-present handler causes a &lt;em&gt;segment-not-present&lt;&#x2F;em&gt; exception. We didn‚Äôt define a segment-not-present handler, so another segment-not-present exception occurs. According to the table, this leads to a double fault.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kernel-stack-overflow&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-stack-overflow&quot; aria-label=&quot;Anchor link for: kernel-stack-overflow&quot;&gt;üîó&lt;&#x2F;a&gt;Kernel Stack Overflow&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs look at the fourth question:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What happens if our kernel overflows its stack and the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2F;a&gt; is hit?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;When our kernel overflows its stack and hits the guard page, a &lt;em&gt;page fault&lt;&#x2F;em&gt; occurs. The CPU looks up the page fault handler in the IDT and tries to push the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;#the-exception-stack-frame&quot;&gt;exception stack frame&lt;&#x2F;a&gt; onto the stack. However, our current stack pointer still points to the non-present guard page. Thus, a second page fault occurs, which causes a double fault (according to the above table).&lt;&#x2F;p&gt;
&lt;p&gt;So the CPU tries to call our &lt;em&gt;double fault handler&lt;&#x2F;em&gt; now. However, on a double fault the CPU tries to push the exception stack frame, too. Our stack pointer still points to the guard page, so a &lt;em&gt;third&lt;&#x2F;em&gt; page fault occurs, which causes a &lt;em&gt;triple fault&lt;&#x2F;em&gt; and a system reboot. So our current double fault handler can‚Äôt avoid a triple fault in this case.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs try it ourselves! We can easily provoke a kernel stack overflow by calling a function that recurses endlessly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;stack_overflow() {
&lt;&#x2F;span&gt;&lt;span&gt;        stack_overflow(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; for each recursion, the return address is pushed
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a stack overflow
&lt;&#x2F;span&gt;&lt;span&gt;    stack_overflow();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we try this code in QEMU, we see that the system enters a boot-loop again.&lt;&#x2F;p&gt;
&lt;p&gt;So how can we avoid this problem? We can‚Äôt omit the pushing of the exception stack frame, since the CPU itself does it. So we need to ensure somehow that the stack is always valid when a double fault exception occurs. Fortunately, the x86_64 architecture has a solution to this problem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;switching-stacks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-stacks&quot; aria-label=&quot;Anchor link for: switching-stacks&quot;&gt;üîó&lt;&#x2F;a&gt;Switching Stacks&lt;&#x2F;h2&gt;
&lt;p&gt;The x86_64 architecture is able to switch to a predefined, known-good stack when an exception occurs. This switch happens at hardware level, so it can be performed before the CPU pushes the exception stack frame.&lt;&#x2F;p&gt;
&lt;p&gt;This switching mechanism is implemented as an &lt;em&gt;Interrupt Stack Table&lt;&#x2F;em&gt; (IST). The IST is a table of 7 pointers to known-good stacks. In Rust-like pseudo code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;InterruptStackTable {
&lt;&#x2F;span&gt;&lt;span&gt;    stack_pointers: [Option&amp;lt;StackPointer&amp;gt;; 7],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For each exception handler, we can choose a stack from the IST through the &lt;code&gt;options&lt;&#x2F;code&gt; field in the corresponding &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;#the-interrupt-descriptor-table&quot;&gt;IDT entry&lt;&#x2F;a&gt;. For example, we could use the first stack in the IST for our double fault handler. Then the CPU would automatically switch to this stack whenever a double fault occurs. This switch would happen before anything is pushed, so it would prevent the triple fault.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocating-a-new-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-a-new-stack&quot; aria-label=&quot;Anchor link for: allocating-a-new-stack&quot;&gt;üîó&lt;&#x2F;a&gt;Allocating a new Stack&lt;&#x2F;h3&gt;
&lt;p&gt;In order to fill an Interrupt Stack Table later, we need a way to allocate new stacks. Therefore we extend our &lt;code&gt;memory&lt;&#x2F;code&gt; module with a new &lt;code&gt;stack_allocator&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;stack_allocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we create a new &lt;code&gt;StackAllocator&lt;&#x2F;code&gt; struct and a constructor function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;stack_allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::paging::PageIter;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;StackAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    range: PageIter,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;StackAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(page_range: PageIter) -&amp;gt; StackAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;        StackAllocator { range: page_range }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We create a simple &lt;code&gt;StackAllocator&lt;&#x2F;code&gt; that allocates stacks from a given range of pages (&lt;code&gt;PageIter&lt;&#x2F;code&gt; is an Iterator over a range of pages; we introduced it &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;#mapping-the-heap&quot;&gt;in the kernel heap post&lt;&#x2F;a&gt;.).&lt;&#x2F;p&gt;
&lt;p&gt;We add a &lt;code&gt;alloc_stack&lt;&#x2F;code&gt; method that allocates a new stack:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;stack_allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::paging::{self, Page, ActivePageTable};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;, FrameAllocator};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;StackAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_stack&amp;lt;FA: FrameAllocator&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                                           active_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;                                           frame_allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; FA,
&lt;&#x2F;span&gt;&lt;span&gt;                                           size_in_pages: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                                           -&amp;gt; Option&amp;lt;Stack&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; size_in_pages == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* a zero sized stack makes no sense *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; clone the range, since we only want to change it on success
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; range = self.range.clone();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; try to allocate the stack pages and a guard page
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; guard_page = range.next();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_start = range.next();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_end = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; size_in_pages == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            stack_start
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; choose the (size_in_pages-2)th element, since index
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; starts at 0 and we already allocated the start page
&lt;&#x2F;span&gt;&lt;span&gt;            range.nth(size_in_pages - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;(guard_page, stack_start, stack_end) {
&lt;&#x2F;span&gt;&lt;span&gt;            (Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;), Some(start), Some(end)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; success! write back updated range
&lt;&#x2F;span&gt;&lt;span&gt;                self.range = range;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; map stack pages to physical frames
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; page &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;Page::range_inclusive(start, end) {
&lt;&#x2F;span&gt;&lt;span&gt;                    active_table.map(page, paging::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;, frame_allocator);
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; create a new stack
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; top_of_stack = end.start_address() + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                Some(Stack::new(top_of_stack, start.start_address()))
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;None, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* not enough pages *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method takes mutable references to the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;#page-table-ownership&quot;&gt;ActivePageTable&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#a-frame-allocator&quot;&gt;FrameAllocator&lt;&#x2F;a&gt;, since it needs to map the new virtual stack pages to physical frames. We define that the stack size is a multiple of the page size.&lt;&#x2F;p&gt;
&lt;p&gt;Instead of operating directly on &lt;code&gt;self.range&lt;&#x2F;code&gt;, we &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;clone&#x2F;trait.Clone.html#tymethod.clone&quot;&gt;clone&lt;&#x2F;a&gt; it and only write it back on success. This way, subsequent stack allocations can still succeed if there are pages left (e.g., a call with &lt;code&gt;size_in_pages = 3&lt;&#x2F;code&gt; can still succeed after a failed call with &lt;code&gt;size_in_pages = 100&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;In order to be able to clone &lt;code&gt;PageIter&lt;&#x2F;code&gt;, we add a &lt;code&gt;#[derive(Clone)]&lt;&#x2F;code&gt; to its definition in &lt;code&gt;src&#x2F;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;. We also need to make the &lt;code&gt;start_address&lt;&#x2F;code&gt; method of the &lt;code&gt;Page&lt;&#x2F;code&gt; type public (in the same file).&lt;&#x2F;p&gt;
&lt;p&gt;The actual allocation is straightforward: First, we choose the next page as &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2F;a&gt;. Then we choose the next &lt;code&gt;size_in_pages&lt;&#x2F;code&gt; pages as stack pages using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.nth&quot;&gt;Iterator::nth&lt;&#x2F;a&gt;. If all three variables are &lt;code&gt;Some&lt;&#x2F;code&gt;, the allocation succeeded and we map the stack pages to physical frames using &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;#more-mapping-functions&quot;&gt;ActivePageTable::map&lt;&#x2F;a&gt;. The guard page remains unmapped.&lt;&#x2F;p&gt;
&lt;p&gt;Finally, we create and return a new &lt;code&gt;Stack&lt;&#x2F;code&gt;, which we define as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;stack_allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Stack {
&lt;&#x2F;span&gt;&lt;span&gt;    top: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    bottom: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Stack {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(top: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, bottom: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Stack {
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(top &amp;gt; bottom);
&lt;&#x2F;span&gt;&lt;span&gt;        Stack {
&lt;&#x2F;span&gt;&lt;span&gt;            top: top,
&lt;&#x2F;span&gt;&lt;span&gt;            bottom: bottom,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;top(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.top
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;bottom(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.bottom
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Stack&lt;&#x2F;code&gt; struct describes a stack though its top and bottom addresses.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-memory-controller&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-memory-controller&quot; aria-label=&quot;Anchor link for: the-memory-controller&quot;&gt;üîó&lt;&#x2F;a&gt;The Memory Controller&lt;&#x2F;h4&gt;
&lt;p&gt;Now we‚Äôre able to allocate a new double fault stack. However, we add one more level of abstraction to make things easier. For that we add a new &lt;code&gt;MemoryController&lt;&#x2F;code&gt; type to our &lt;code&gt;memory&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2F;span&gt;&lt;span&gt;self::stack_allocator::Stack;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MemoryController {
&lt;&#x2F;span&gt;&lt;span&gt;    active_table: paging::ActivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator: AreaFrameAllocator,
&lt;&#x2F;span&gt;&lt;span&gt;    stack_allocator: stack_allocator::StackAllocator,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MemoryController {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;alloc_stack(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, size_in_pages: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;Stack&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2F;span&gt;&lt;span&gt; active_table,
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator,
&lt;&#x2F;span&gt;&lt;span&gt;                                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2F;span&gt;&lt;span&gt; stack_allocator } = self;
&lt;&#x2F;span&gt;&lt;span&gt;        stack_allocator.alloc_stack(active_table, frame_allocator,
&lt;&#x2F;span&gt;&lt;span&gt;                                    size_in_pages)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;MemoryController&lt;&#x2F;code&gt; struct holds the three types that are required for &lt;code&gt;alloc_stack&lt;&#x2F;code&gt; and provides a simpler interface (only one argument). The &lt;code&gt;alloc_stack&lt;&#x2F;code&gt; wrapper just takes the tree types as &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; through &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;book&#x2F;patterns.html#destructuring&quot;&gt;destructuring&lt;&#x2F;a&gt; and forwards them to the &lt;code&gt;stack_allocator&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch18-03-pattern-syntax.html#creating-references-in-patterns-with-ref-and-ref-mut&quot;&gt;ref mut&lt;&#x2F;a&gt;-s are needed to take the inner fields by mutable reference. Note that we‚Äôre re-exporting the &lt;code&gt;Stack&lt;&#x2F;code&gt; type since it is returned by &lt;code&gt;alloc_stack&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The last step is to create a &lt;code&gt;StackAllocator&lt;&#x2F;code&gt; and return a &lt;code&gt;MemoryController&lt;&#x2F;code&gt; from &lt;code&gt;memory::init&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation) -&amp;gt; MemoryController {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_allocator = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_alloc_start = heap_end_page + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_alloc_end = stack_alloc_start + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_alloc_range = Page::range_inclusive(stack_alloc_start,
&lt;&#x2F;span&gt;&lt;span&gt;                                                      stack_alloc_end);
&lt;&#x2F;span&gt;&lt;span&gt;        stack_allocator::StackAllocator::new(stack_alloc_range)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    MemoryController {
&lt;&#x2F;span&gt;&lt;span&gt;        active_table: active_table,
&lt;&#x2F;span&gt;&lt;span&gt;        frame_allocator: frame_allocator,
&lt;&#x2F;span&gt;&lt;span&gt;        stack_allocator: stack_allocator,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We create a new &lt;code&gt;StackAllocator&lt;&#x2F;code&gt; with a range of 100 pages starting right after the last heap page.&lt;&#x2F;p&gt;
&lt;p&gt;In order to do arithmetic on pages (e.g. calculate the hundredth page after &lt;code&gt;stack_alloc_start&lt;&#x2F;code&gt;), we implement &lt;code&gt;Add&amp;lt;usize&amp;gt;&lt;&#x2F;code&gt; for &lt;code&gt;Page&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ops::Add;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Add&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Page {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Page;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;add(self, rhs: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Page {
&lt;&#x2F;span&gt;&lt;span&gt;        Page { number: self.number + rhs }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;allocating-a-double-fault-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-a-double-fault-stack&quot; aria-label=&quot;Anchor link for: allocating-a-double-fault-stack&quot;&gt;üîó&lt;&#x2F;a&gt;Allocating a Double Fault Stack&lt;&#x2F;h4&gt;
&lt;p&gt;Now we can allocate a new double fault stack by passing the memory controller to our &lt;code&gt;interrupts::init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; set up guard page and map the heap pages
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; memory_controller = memory::init(boot_info); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new return type
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; memory_controller); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new argument
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::MemoryController;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_controller: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; double_fault_stack = memory_controller.alloc_stack(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We allocate a 4096 bytes stack (one page) for our double fault handler. Now we just need some way to tell the CPU that it should use this stack for handling double faults.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-ist-and-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-ist-and-tss&quot; aria-label=&quot;Anchor link for: the-ist-and-tss&quot;&gt;üîó&lt;&#x2F;a&gt;The IST and TSS&lt;&#x2F;h3&gt;
&lt;p&gt;The Interrupt Stack Table (IST) is part of an old legacy structure called &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Task_state_segment&quot;&gt;Task State Segment&lt;&#x2F;a&gt;&lt;&#x2F;em&gt; (TSS). The TSS used to hold various information (e.g. processor register state) about a task in 32-bit mode and was for example used for &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Context_Switching#Hardware_Context_Switching&quot;&gt;hardware context switching&lt;&#x2F;a&gt;. However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS changed completely.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, the TSS no longer holds any task specific information at all. Instead, it holds two stack tables (the IST is one of them). The only common field between the 32-bit and 64-bit TSS is the pointer to the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Task_state_segment#I.2FO_port_permissions&quot;&gt;I&#x2F;O port permissions bitmap&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The 64-bit TSS has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field&lt;&#x2F;th&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u32&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Privilege Stack Table&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;[u64; 3]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Interrupt Stack Table&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;[u64; 7]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;I&#x2F;O Map Base Address&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The &lt;em&gt;Privilege Stack Table&lt;&#x2F;em&gt; is used by the CPU when the privilege level changes. For example, if an exception occurs while the CPU is in user mode (privilege level 3), the CPU normally switches to kernel mode (privilege level 0) before invoking the exception handler. In that case, the CPU would switch to the 0th stack in the Privilege Stack Table (since 0 is the target privilege level). We don‚Äôt have any user mode programs yet, so we ignore this table for now.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;creating-a-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-tss&quot; aria-label=&quot;Anchor link for: creating-a-tss&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a TSS&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs create a new TSS that contains our double fault stack in its interrupt stack table. For that we need a TSS struct. Fortunately, the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate already contains a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;structures&#x2F;tss&#x2F;struct.TaskStateSegment.html&quot;&gt;&lt;code&gt;TaskStateSegment&lt;&#x2F;code&gt; struct&lt;&#x2F;a&gt; that we can use:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::tss::TaskStateSegment;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs create a new TSS in our &lt;code&gt;interrupts::init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::VirtualAddress;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_controller: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; double_fault_stack = memory_controller.alloc_stack(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tss = TaskStateSegment::new();
&lt;&#x2F;span&gt;&lt;span&gt;    tss.interrupt_stack_table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;] = VirtualAddress(
&lt;&#x2F;span&gt;&lt;span&gt;        double_fault_stack.top());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define that the 0th IST entry is the double fault stack (any other IST index would work too). We create a new TSS through the &lt;code&gt;TaskStateSegment::new&lt;&#x2F;code&gt; function and load the top address (stacks grow downwards) of the double fault stack into the 0th entry.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;loading-the-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-tss&quot; aria-label=&quot;Anchor link for: loading-the-tss&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the TSS&lt;&#x2F;h4&gt;
&lt;p&gt;Now that we created a new TSS, we need a way to tell the CPU that it should use it. Unfortunately, this is a bit cumbersome, since the TSS is a Task State &lt;em&gt;Segment&lt;&#x2F;em&gt; (for historical reasons). So instead of loading the table directly, we need to add a new segment descriptor to the &lt;a href=&quot;https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20190217233448&#x2F;https:&#x2F;&#x2F;www.flingos.co.uk&#x2F;docs&#x2F;reference&#x2F;Global-Descriptor-Table&#x2F;&quot;&gt;Global Descriptor Table&lt;&#x2F;a&gt; (GDT). Then we can load our TSS invoking the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;ltr&quot;&gt;&lt;code&gt;ltr&lt;&#x2F;code&gt; instruction&lt;&#x2F;a&gt; with the respective GDT index.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-global-descriptor-table-again&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table-again&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table-again&quot;&gt;üîó&lt;&#x2F;a&gt;The Global Descriptor Table (again)&lt;&#x2F;h3&gt;
&lt;p&gt;The Global Descriptor Table (GDT) is a relict that was used for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_memory_segmentation&quot;&gt;memory segmentation&lt;&#x2F;a&gt; before paging became the de facto standard. It is still needed in 64-bit mode for various things such as kernel&#x2F;user mode configuration or TSS loading.&lt;&#x2F;p&gt;
&lt;p&gt;We already created a GDT &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;#the-global-descriptor-table&quot;&gt;when switching to long mode&lt;&#x2F;a&gt;. Back then, we used assembly to create valid code and data segment descriptors, which were required to enter 64-bit mode. We could just edit that assembly file and add an additional TSS descriptor. However, we now have the expressiveness of Rust, so let‚Äôs do it in Rust instead.&lt;&#x2F;p&gt;
&lt;p&gt;We start by creating a new &lt;code&gt;interrupts::gdt&lt;&#x2F;code&gt; submodule. For that we need to rename the &lt;code&gt;src&#x2F;interrupts.rs&lt;&#x2F;code&gt; file to &lt;code&gt;src&#x2F;interrupts&#x2F;mod.rs&lt;&#x2F;code&gt;. Then we can create a new submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;gdt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;    table: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;; 8],
&lt;&#x2F;span&gt;&lt;span&gt;    next_free: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;        Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;            table: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;            next_free: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We create a simple &lt;code&gt;Gdt&lt;&#x2F;code&gt; struct with two fields. The &lt;code&gt;table&lt;&#x2F;code&gt; field contains the actual GDT modeled as a &lt;code&gt;[u64; 8]&lt;&#x2F;code&gt;. Theoretically, a GDT can have up to 8192 entries, but this doesn‚Äôt make much sense in 64-bit mode (since there is no real segmentation support). Eight entries should be more than enough for our system.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;next_free&lt;&#x2F;code&gt; field stores the index of the next free entry. We initialize it with &lt;code&gt;1&lt;&#x2F;code&gt; since the 0th entry needs always needs to be 0 in a valid GDT.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;user-and-system-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#user-and-system-segments&quot; aria-label=&quot;Anchor link for: user-and-system-segments&quot;&gt;üîó&lt;&#x2F;a&gt;User and System Segments&lt;&#x2F;h4&gt;
&lt;p&gt;There are two types of GDT entries in long mode: user and system segment descriptors. Descriptors for code and data segment segments are user segment descriptors. They contain no addresses since segments always span the complete address space on x86_64 (real segmentation is no longer supported). Thus, user segment descriptors only contain a few flags (e.g. present or user mode) and fit into a single &lt;code&gt;u64&lt;&#x2F;code&gt; entry.&lt;&#x2F;p&gt;
&lt;p&gt;System descriptors such as TSS descriptors are different. They often contain a base address and a limit (e.g. TSS start and length) and thus need more than 64 bits. Therefore, system segments are 128 bits. They are stored as two consecutive entries in the GDT.&lt;&#x2F;p&gt;
&lt;p&gt;Consequently, we model a &lt;code&gt;Descriptor&lt;&#x2F;code&gt; as an &lt;code&gt;enum&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Descriptor {
&lt;&#x2F;span&gt;&lt;span&gt;    UserSegment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    SystemSegment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The flag bits are common between all descriptor types, so we create a general &lt;code&gt;DescriptorFlags&lt;&#x2F;code&gt; type (using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bitflags&#x2F;0.9.1&#x2F;bitflags&#x2F;macro.bitflags.html&quot;&gt;bitflags&lt;&#x2F;a&gt; macro):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;bitflags! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;DescriptorFlags: u64 {
&lt;&#x2F;span&gt;&lt;span&gt;        const CONFORMING        = 1 &amp;lt;&amp;lt; 42;
&lt;&#x2F;span&gt;&lt;span&gt;        const EXECUTABLE        = 1 &amp;lt;&amp;lt; 43;
&lt;&#x2F;span&gt;&lt;span&gt;        const USER_SEGMENT      = 1 &amp;lt;&amp;lt; 44;
&lt;&#x2F;span&gt;&lt;span&gt;        const PRESENT           = 1 &amp;lt;&amp;lt; 47;
&lt;&#x2F;span&gt;&lt;span&gt;        const LONG_MODE         = 1 &amp;lt;&amp;lt; 53;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We only add flags that are relevant in 64-bit mode. For example, we omit the read&#x2F;write bit, since it is completely ignored by the CPU in 64-bit mode.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;code-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#code-segments&quot; aria-label=&quot;Anchor link for: code-segments&quot;&gt;üîó&lt;&#x2F;a&gt;Code Segments&lt;&#x2F;h4&gt;
&lt;p&gt;We add a function to create kernel mode code segments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Descriptor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;kernel_code_segment() -&amp;gt; Descriptor {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;USER_SEGMENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;EXECUTABLE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LONG_MODE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Descriptor::UserSegment(flags.bits())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the &lt;code&gt;USER_SEGMENT&lt;&#x2F;code&gt; bit to indicate a 64 bit user segment descriptor (otherwise the CPU expects a 128 bit system segment descriptor). The &lt;code&gt;PRESENT&lt;&#x2F;code&gt;, &lt;code&gt;EXECUTABLE&lt;&#x2F;code&gt;, and &lt;code&gt;LONG_MODE&lt;&#x2F;code&gt; bits are also needed for a 64-bit mode code segment.&lt;&#x2F;p&gt;
&lt;p&gt;The data segment registers &lt;code&gt;ds&lt;&#x2F;code&gt;, &lt;code&gt;ss&lt;&#x2F;code&gt;, and &lt;code&gt;es&lt;&#x2F;code&gt; are completely ignored in 64-bit mode, so we don‚Äôt need any data segment descriptors in our GDT.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tss-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tss-segments&quot; aria-label=&quot;Anchor link for: tss-segments&quot;&gt;üîó&lt;&#x2F;a&gt;TSS Segments&lt;&#x2F;h4&gt;
&lt;p&gt;A TSS descriptor is a system segment descriptor with the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-15&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;limit 0-15&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;the first 2 byte of the TSS‚Äôs limit&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;16-39&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;base 0-23&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;the first 3 byte of the TSS‚Äôs base address&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;40-43&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;type&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;must be &lt;code&gt;0b1001&lt;&#x2F;code&gt; for an available 64-bit TSS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;44&lt;&#x2F;td&gt;&lt;td&gt;zero&lt;&#x2F;td&gt;&lt;td&gt;must be 0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;45-46&lt;&#x2F;td&gt;&lt;td&gt;privilege&lt;&#x2F;td&gt;&lt;td&gt;the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Security#Rings&quot;&gt;ring level&lt;&#x2F;a&gt;: 0 for kernel, 3 for user&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;47&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;present&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;must be 1 for valid selectors&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;48-51&lt;&#x2F;td&gt;&lt;td&gt;limit 16-19&lt;&#x2F;td&gt;&lt;td&gt;bits 16 to 19 of the segment‚Äôs limit&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;52&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;freely available to the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;53-54&lt;&#x2F;td&gt;&lt;td&gt;ignored&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;55&lt;&#x2F;td&gt;&lt;td&gt;granularity&lt;&#x2F;td&gt;&lt;td&gt;if it‚Äôs set, the limit is the number of pages, else it‚Äôs a byte number&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;56-63&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;base 24-31&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;the fourth byte of the base address&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;64-95&lt;&#x2F;td&gt;&lt;td&gt;&lt;strong&gt;base 32-63&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;the last four bytes of the base address&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;96-127&lt;&#x2F;td&gt;&lt;td&gt;ignored&#x2F;must be zero&lt;&#x2F;td&gt;&lt;td&gt;bits 104-108 must be zero, the rest is ignored&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;We only need the bold fields for our TSS descriptor. For example, we don‚Äôt need the &lt;code&gt;limit 16-19&lt;&#x2F;code&gt; field since a TSS has a fixed size that is smaller than &lt;code&gt;2^16&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add a function to our descriptor that creates a TSS descriptor for a given TSS:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::tss::TaskStateSegment;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Descriptor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;tss_segment(tss: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; TaskStateSegment) -&amp;gt; Descriptor {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem::size_of;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bit_field::BitField;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = tss &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; low = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;.bits();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; base
&lt;&#x2F;span&gt;&lt;span&gt;        low.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span&gt;, ptr.get_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        low.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;56&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;, ptr.get_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; limit (the `-1` in needed since the bound is inclusive)
&lt;&#x2F;span&gt;&lt;span&gt;        low.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;, (size_of::&amp;lt;TaskStateSegment&amp;gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; type (0b1001 = available 64-bit tss)
&lt;&#x2F;span&gt;&lt;span&gt;        low.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;44&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b1001&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; high = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        high.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;, ptr.get_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Descriptor::SystemSegment(low, high)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;set_bits&lt;&#x2F;code&gt; and &lt;code&gt;get_bits&lt;&#x2F;code&gt; methods are provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bit_field&#x2F;0.6.0&#x2F;bit_field&#x2F;trait.BitField.html#method.get_bit&quot;&gt;&lt;code&gt;BitField&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt; of the &lt;code&gt;bit_fields&lt;&#x2F;code&gt; crate. They allow us to easily get or set specific bits in an integer without using bit masks or shift operations. For example, we can do &lt;code&gt;x.set_bits(8..12, 42)&lt;&#x2F;code&gt; instead of &lt;code&gt;x = (x &amp;amp; 0xfffff0ff) | (42 &amp;lt;&amp;lt; 8)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To link the &lt;code&gt;bit_fields&lt;&#x2F;code&gt; crate, we modify our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bit_field &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.7.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; bit_field;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We require the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime for the &lt;code&gt;TaskStateSegment&lt;&#x2F;code&gt; reference, since the hardware might access it on every interrupt as long as the OS runs.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;adding-descriptors-to-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-descriptors-to-the-gdt&quot; aria-label=&quot;Anchor link for: adding-descriptors-to-the-gdt&quot;&gt;üîó&lt;&#x2F;a&gt;Adding Descriptors to the GDT&lt;&#x2F;h4&gt;
&lt;p&gt;In order to add descriptors to the GDT, we add a &lt;code&gt;add_entry&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::PrivilegeLevel;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;add_entry(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, entry: Descriptor) -&amp;gt; SegmentSelector {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; index = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; entry {
&lt;&#x2F;span&gt;&lt;span&gt;            Descriptor::UserSegment(value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.push(value),
&lt;&#x2F;span&gt;&lt;span&gt;            Descriptor::SystemSegment(value_low, value_high) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; index = self.push(value_low);
&lt;&#x2F;span&gt;&lt;span&gt;                self.push(value_high);
&lt;&#x2F;span&gt;&lt;span&gt;                index
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;        SegmentSelector::new(index &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;, PrivilegeLevel::Ring0)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For an user segment we just push the &lt;code&gt;u64&lt;&#x2F;code&gt; and remember the index. For a system segment, we push the low and high &lt;code&gt;u64&lt;&#x2F;code&gt; and use the index of the low value. We then use this index to return a new &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86&#x2F;0.8.0&#x2F;x86&#x2F;shared&#x2F;segmentation&#x2F;struct.SegmentSelector.html#method.new&quot;&gt;SegmentSelector&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;push&lt;&#x2F;code&gt; method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;push(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.next_free &amp;lt; self.table.len() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; index = self.next_free;
&lt;&#x2F;span&gt;&lt;span&gt;            self.table[index] = value;
&lt;&#x2F;span&gt;&lt;span&gt;            self.next_free += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            index
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;GDT full&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method just writes to the &lt;code&gt;next_free&lt;&#x2F;code&gt; entry and returns the corresponding index. If there is no free entry left, we panic since this likely indicates a programming error (we should never need to create more than two or three GDT entries for our kernel).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the GDT&lt;&#x2F;h4&gt;
&lt;p&gt;To load the GDT, we add a new &lt;code&gt;load&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;gdt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Gdt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;load(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tables::{DescriptorTablePointer, lgdt};
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem::size_of;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = DescriptorTablePointer {
&lt;&#x2F;span&gt;&lt;span&gt;            base: self.table.as_ptr() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            limit: (self.table.len() * size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ lgdt(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ptr) };
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;struct.DescriptorTablePointer.html&quot;&gt;&lt;code&gt;DescriptorTablePointer&lt;&#x2F;code&gt; struct&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.1&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;fn.lgdt.html&quot;&gt;&lt;code&gt;lgdt&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; provided by the &lt;code&gt;x86_64&lt;&#x2F;code&gt; crate to load our GDT. Again, we require a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; reference since the GDT possibly needs to live for the rest of the run time.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;üîó&lt;&#x2F;a&gt;Putting it together&lt;&#x2F;h3&gt;
&lt;p&gt;We now have a double fault stack and are able to create and load a TSS (which contains an IST). So let‚Äôs put everything together to catch kernel stack overflows.&lt;&#x2F;p&gt;
&lt;p&gt;We already created a new TSS in our &lt;code&gt;interrupts::init&lt;&#x2F;code&gt; function. Now we can load this TSS by creating a new GDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_controller: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; double_fault_stack = memory_controller.alloc_stack(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tss = TaskStateSegment::new();
&lt;&#x2F;span&gt;&lt;span&gt;    tss.interrupt_stack_table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;] = VirtualAddress(
&lt;&#x2F;span&gt;&lt;span&gt;        double_fault_stack.top());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; gdt = gdt::Gdt::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; code_selector = gdt.add_entry(gdt::Descriptor::kernel_code_segment());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tss_selector = gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;tss));
&lt;&#x2F;span&gt;&lt;span&gt;    gdt.load();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, when we try to compile it, the following errors occur:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: `tss` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;   --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:118:68
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;118 |    let tss_selector = gdt.add_entry(gdt::Descriptor::tss_segment(&amp;amp;tss));
&lt;&#x2F;span&gt;&lt;span&gt;    |                                         does not live long enough ^^^
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;122 | }
&lt;&#x2F;span&gt;&lt;span&gt;    | - borrowed value only lives until here
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;    = note: borrowed value must be valid for the static lifetime...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error: `gdt` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;   --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:119:5
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;119 |    gdt.load();
&lt;&#x2F;span&gt;&lt;span&gt;    |    ^^^ does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;122 | }
&lt;&#x2F;span&gt;&lt;span&gt;    | - borrowed value only lives until here
&lt;&#x2F;span&gt;&lt;span&gt;    |
&lt;&#x2F;span&gt;&lt;span&gt;    = note: borrowed value must be valid for the static lifetime...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that we require that the TSS and GDT are valid for the rest of the run time (i.e. for the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime). But our created &lt;code&gt;tss&lt;&#x2F;code&gt; and &lt;code&gt;gdt&lt;&#x2F;code&gt; live on the stack and are thus destroyed at the end of the &lt;code&gt;init&lt;&#x2F;code&gt; function. So how do we fix this problem?&lt;&#x2F;p&gt;
&lt;p&gt;We could allocate our TSS and GDT on the heap using &lt;code&gt;Box&lt;&#x2F;code&gt; and use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;boxed&#x2F;struct.Box.html#method.into_raw&quot;&gt;into_raw&lt;&#x2F;a&gt; and a bit of &lt;code&gt;unsafe&lt;&#x2F;code&gt; to convert it to &lt;code&gt;&amp;amp;&#x27;static&lt;&#x2F;code&gt; references (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;1233&quot;&gt;RFC 1233&lt;&#x2F;a&gt; was closed unfortunately).&lt;&#x2F;p&gt;
&lt;p&gt;Alternatively, we could store them in a &lt;code&gt;static&lt;&#x2F;code&gt; somehow. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;lazy_static&#x2F;0.2.2&#x2F;lazy_static&#x2F;&quot;&gt;&lt;code&gt;lazy_static&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; doesn‚Äôt work here, since we need access to the &lt;code&gt;MemoryController&lt;&#x2F;code&gt; for initialization. However, we can use its fundamental building block, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html&quot;&gt;&lt;code&gt;spin::Once&lt;&#x2F;code&gt; type&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;spin-once&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spin-once&quot; aria-label=&quot;Anchor link for: spin-once&quot;&gt;üîó&lt;&#x2F;a&gt;spin::Once&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs try to solve our problem using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html&quot;&gt;&lt;code&gt;spin::Once&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Once;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2F;span&gt;&lt;span&gt;: Once&amp;lt;TaskStateSegment&amp;gt; = Once::new();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;: Once&amp;lt;gdt::Gdt&amp;gt; = Once::new();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Once&lt;&#x2F;code&gt; type allows us to initialize a &lt;code&gt;static&lt;&#x2F;code&gt; at runtime. It is safe because the only way to access the static value is through the provided methods (&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html#method.call_once&quot;&gt;call_once&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html#method.try&quot;&gt;try&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Once.html#method.wait&quot;&gt;wait&lt;&#x2F;a&gt;). Thus, no value can be read before initialization and the value can only be initialized once.&lt;&#x2F;p&gt;
&lt;p&gt;(The &lt;code&gt;Once&lt;&#x2F;code&gt; was added in spin 0.4, so you‚Äôre probably need to update your spin dependency.)&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs rewrite our &lt;code&gt;interrupts::init&lt;&#x2F;code&gt; function to use the static &lt;code&gt;TSS&lt;&#x2F;code&gt; and &lt;code&gt;GDT&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_controller: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; double_fault_stack = memory_controller.alloc_stack(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tss = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2F;span&gt;&lt;span&gt;.call_once(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tss = TaskStateSegment::new();
&lt;&#x2F;span&gt;&lt;span&gt;        tss.interrupt_stack_table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2F;span&gt;&lt;span&gt;] = VirtualAddress(
&lt;&#x2F;span&gt;&lt;span&gt;            double_fault_stack.top());
&lt;&#x2F;span&gt;&lt;span&gt;        tss
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; gdt = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.call_once(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; gdt = gdt::Gdt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; code_selector = gdt.add_entry(gdt::Descriptor::
&lt;&#x2F;span&gt;&lt;span&gt;                            kernel_code_segment());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tss_selector = gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;tss));
&lt;&#x2F;span&gt;&lt;span&gt;        gdt
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    gdt.load();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now it should compile again!&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-final-steps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-final-steps&quot; aria-label=&quot;Anchor link for: the-final-steps&quot;&gt;üîó&lt;&#x2F;a&gt;The final Steps&lt;&#x2F;h4&gt;
&lt;p&gt;We‚Äôre almost done. We successfully loaded our new GDT, which contains a TSS descriptor. Now there are just a few steps left:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;We changed our GDT, so we should reload the &lt;code&gt;cs&lt;&#x2F;code&gt;, the code segment register. This required since the old segment selector could point a different GDT descriptor now (e.g. a TSS descriptor).&lt;&#x2F;li&gt;
&lt;li&gt;We loaded a GDT that contains a TSS selector, but we still need to tell the CPU that it should use that TSS.&lt;&#x2F;li&gt;
&lt;li&gt;As soon as our TSS is loaded, the CPU has access to a valid interrupt stack table (IST). Then we can tell the CPU that it should use our new double fault stack by modifying our double fault IDT entry.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For the first two steps, we need access to the &lt;code&gt;code_selector&lt;&#x2F;code&gt; and &lt;code&gt;tss_selector&lt;&#x2F;code&gt; variables outside of the closure. We can achieve this by moving the &lt;code&gt;let&lt;&#x2F;code&gt; declarations out of the closure:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(memory_controller: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; MemoryController) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::segmentation::set_cs;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tables::load_tss;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; code_selector = SegmentSelector(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tss_selector = SegmentSelector(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; gdt = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2F;span&gt;&lt;span&gt;.call_once(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; gdt = gdt::Gdt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        code_selector = gdt.add_entry(gdt::Descriptor::kernel_code_segment());
&lt;&#x2F;span&gt;&lt;span&gt;        tss_selector = gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;tss));
&lt;&#x2F;span&gt;&lt;span&gt;        gdt
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    gdt.load();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; reload code segment register
&lt;&#x2F;span&gt;&lt;span&gt;        set_cs(code_selector);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; load TSS
&lt;&#x2F;span&gt;&lt;span&gt;        load_tss(tss_selector);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We first set the descriptors to &lt;code&gt;empty&lt;&#x2F;code&gt; and then update them from inside the closure (which implicitly borrows them as &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;). Now we‚Äôre able to reload the code segment register using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.2&#x2F;x86_64&#x2F;instructions&#x2F;segmentation&#x2F;fn.set_cs.html&quot;&gt;&lt;code&gt;set_cs&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; and to load the TSS using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.2&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;fn.load_tss.html&quot;&gt;&lt;code&gt;load_tss&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we loaded a valid TSS and interrupt stack table, we can set the stack index for our double fault handler in the IDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupt&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            idt.double_fault.set_handler_fn(double_fault_handler)
&lt;&#x2F;span&gt;&lt;span&gt;                .set_stack_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;set_stack_index&lt;&#x2F;code&gt; method is unsafe because the the caller must ensure that the used index is valid and not already used for another exception.&lt;&#x2F;p&gt;
&lt;p&gt;That‚Äôs it! Now the CPU should switch to the double fault stack whenever a double fault occurs. Thus, we are able to catch &lt;em&gt;all&lt;&#x2F;em&gt; double faults, including kernel stack overflows:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;double-faults&#x2F;qemu-double-fault-on-stack-overflow.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;From now on we should never see a triple fault again!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we mastered exceptions, it‚Äôs time to explore another kind of interrupts: interrupts from external devices such as timers, keyboards, or network controllers. These hardware interrupts are very similar to exceptions, e.g. they are also dispatched through the IDT.&lt;&#x2F;p&gt;
&lt;p&gt;However, unlike exceptions, they don‚Äôt arise directly on the CPU. Instead, an &lt;em&gt;interrupt controller&lt;&#x2F;em&gt; aggregates these interrupts and forwards them to CPU depending on their priority. In the next posts we will explore the two interrupt controller variants on x86: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Intel_8259&quot;&gt;Intel 8259&lt;&#x2F;a&gt; (‚ÄúPIC‚Äù) and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Advanced_Programmable_Interrupt_Controller&quot;&gt;APIC&lt;&#x2F;a&gt;. This will allow us to react to keyboard and mouse input.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Returning from Exceptions</title>
                <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/returning-from-exceptions/</link>
                <guid>https://os.phil-opp.com/returning-from-exceptions/</guid>
                <description>&lt;p&gt;In this post, we learn how to return from exceptions correctly. In the course of this, we will explore the &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction, the C calling convention, multimedia registers, and the red zone.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;returning_from_exceptions&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2F;&#x2F;gitter.im&#x2F;phil-opp&#x2F;blog_os&quot;&gt;gitter chat&lt;&#x2F;a&gt; and a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2F;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;extra&#x2F;naked-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions with Naked Functions‚Äù&lt;&#x2F;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions‚Äù&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Most exceptions are fatal and can‚Äôt be resolved. For example, we can‚Äôt return from a divide-by-zero exception in a reasonable way. However, there are some exceptions that we can resolve:&lt;&#x2F;p&gt;
&lt;p&gt;Imagine a system that uses &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Memory-mapped_file&quot;&gt;memory mapped files&lt;&#x2F;a&gt;: We map a file into the virtual address space without loading it into memory. Whenever we access a part of the file for the first time, a page fault occurs. However, this page fault is not fatal. We can resolve it by loading the corresponding page from disk into memory and setting the &lt;code&gt;present&lt;&#x2F;code&gt; flag in the page table. Then we can return from the page fault handler and restart the failed instruction, which now successfully accesses the file data.&lt;&#x2F;p&gt;
&lt;p&gt;Memory mapped files are completely out of scope for us right now (we have neither a file concept nor a hard disk driver). So we need an exception that we can resolve easily so that we can return from it in a reasonable way. Fortunately, there is an exception that needs no resolution at all: the breakpoint exception.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-breakpoint-exception&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-breakpoint-exception&quot; aria-label=&quot;Anchor link for: the-breakpoint-exception&quot;&gt;üîó&lt;&#x2F;a&gt;The Breakpoint Exception&lt;&#x2F;h2&gt;
&lt;p&gt;The breakpoint exception is the perfect exception to test our upcoming return-from-exception logic. Its only purpose is to temporary pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2F;code&gt; is executed.&lt;&#x2F;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;01&#x2F;27&#x2F;how-debuggers-work-part-2-breakpoints&quot;&gt;How debuggers work&lt;&#x2F;a&gt; series.&lt;&#x2F;p&gt;
&lt;p&gt;For our use case, we don‚Äôt need to overwrite any instructions (it wouldn‚Äôt even be possible since we &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#using-the-correct-flags&quot;&gt;set the page table flags&lt;&#x2F;a&gt; to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;catching-breakpoints&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#catching-breakpoints&quot; aria-label=&quot;Anchor link for: catching-breakpoints&quot;&gt;üîó&lt;&#x2F;a&gt;Catching Breakpoints&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs start by defining a handler function for the breakpoint exception:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;breakpoint_handler(stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_frame = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*stack_frame };
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: BREAKPOINT at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        stack_frame.instruction_pointer, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We print an error message and also output the instruction pointer and the rest of the stack frame. Note that this function does &lt;em&gt;not&lt;&#x2F;em&gt; return yet, since our &lt;code&gt;handler!&lt;&#x2F;code&gt; macro still requires a diverging function.&lt;&#x2F;p&gt;
&lt;p&gt;We need to register our new handler function in the interrupt descriptor table (IDT):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, handler!(divide_by_zero_handler));
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, handler!(breakpoint_handler)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, handler!(invalid_opcode_handler));
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;, handler_with_error_code!(page_fault_handler));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We set the IDT entry with number 3 since it‚Äôs the vector number of the breakpoint exception.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h4&gt;
&lt;p&gt;In order to test it, we insert an &lt;code&gt;int3&lt;&#x2F;code&gt; instruction in our &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; needed for the `int!` macro
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; x86_64;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(...) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; trigger a breakpoint exception
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ int!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we execute &lt;code&gt;make run&lt;&#x2F;code&gt;, we see the following:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;qemu-breakpoint-handler.png&quot; alt=&quot;QEMU showing EXCEPTION: BREAKPOINT at 0x110970 and a dump of the exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It works! Now we ‚Äújust‚Äù need to return from the breakpoint handler somehow so that we see the &lt;code&gt;It did not crash&lt;&#x2F;code&gt; message again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;returning-from-exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#returning-from-exceptions&quot; aria-label=&quot;Anchor link for: returning-from-exceptions&quot;&gt;üîó&lt;&#x2F;a&gt;Returning from Exceptions&lt;&#x2F;h2&gt;
&lt;p&gt;So how do we return from exceptions? To make it easier, we look at a normal function return first:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;When calling a function, the &lt;code&gt;call&lt;&#x2F;code&gt; instruction pushes the return address on the stack. When the called function is finished, it can return to the parent function through the &lt;code&gt;ret&lt;&#x2F;code&gt; instruction, which pops the return address from the stack and then jumps to it.&lt;&#x2F;p&gt;
&lt;p&gt;The exception stack frame, in contrast, looks a bit different:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Instead of pushing a return address, the CPU pushes the stack and instruction pointers (with their segment descriptors), the RFLAGS register, and an optional error code. It also aligns the stack pointer to a 16 byte boundary before pushing values.&lt;&#x2F;p&gt;
&lt;p&gt;So we can‚Äôt use a normal &lt;code&gt;ret&lt;&#x2F;code&gt; instruction, since it expects a different stack frame layout. Instead, there is a special instruction for returning from exceptions: &lt;code&gt;iretq&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-iretq-instruction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-iretq-instruction&quot; aria-label=&quot;Anchor link for: the-iretq-instruction&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;iretq&lt;&#x2F;code&gt; Instruction&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction is the one and only way to return from exceptions and is specifically designed for this purpose. The AMD64 instruction manual (&lt;a href=&quot;https:&#x2F;&#x2F;www.amd.com&#x2F;system&#x2F;files&#x2F;TechDocs&#x2F;24594.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) even demands that &lt;code&gt;iretq&lt;&#x2F;code&gt; ‚Äú&lt;em&gt;must&lt;&#x2F;em&gt; be used to terminate the exception or interrupt handler associated with the exception‚Äù.&lt;&#x2F;p&gt;
&lt;p&gt;IRETQ restores &lt;code&gt;rip&lt;&#x2F;code&gt;, &lt;code&gt;cs&lt;&#x2F;code&gt;, &lt;code&gt;rflags&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, and &lt;code&gt;ss&lt;&#x2F;code&gt; from the values saved on the stack and thus continues the interrupted program. The instruction does not handle the optional error code, so it must be popped from the stack before.&lt;&#x2F;p&gt;
&lt;p&gt;We see that &lt;code&gt;iretq&lt;&#x2F;code&gt; treats the stored instruction pointer as return address. For most exceptions, the stored &lt;code&gt;rip&lt;&#x2F;code&gt; points to the instruction that caused the fault. So by executing &lt;code&gt;iretq&lt;&#x2F;code&gt;, we restart the failing instruction. This makes sense because we should have resolved the exception when returning from it, so the instruction should no longer fail (e.g. the accessed part of the memory mapped file is now present in memory).&lt;&#x2F;p&gt;
&lt;p&gt;The situation is a bit different for the breakpoint exception, since it needs no resolution. Restarting the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction wouldn‚Äôt make sense, since it would cause a new breakpoint exception and we would enter an endless loop. For this reason the hardware designers decided that the stored &lt;code&gt;rip&lt;&#x2F;code&gt; should point to the next instruction after the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs check this for our breakpoint handler. Remember, the handler printed the following message (see the image above):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;EXCEPTION: BREAKPOINT at 0x110970
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So let‚Äôs disassemble the instruction at &lt;code&gt;0x110970&lt;&#x2F;code&gt; and its predecessor:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;grep -B1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;110970:&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;11096f:	cc                   	int3
&lt;&#x2F;span&gt;&lt;span&gt;110970:	48 c7 01 2a 00 00 00 	movq   $0x2a,(%rcx)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that &lt;code&gt;0x110970&lt;&#x2F;code&gt; indeed points to the next instruction after &lt;code&gt;int3&lt;&#x2F;code&gt;. So we can simply jump to the stored instruction pointer when we want to return from the breakpoint exception.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs update our &lt;code&gt;handler!&lt;&#x2F;code&gt; macro to support non-diverging exception handlers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; no longer diverging
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;add rsp, 8 &#x2F;&#x2F; undo stack pointer alignment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      iretq&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When an exception handler returns from the &lt;code&gt;call&lt;&#x2F;code&gt; instruction, we use the &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction to continue the interrupted program. Note that we need to undo the stack pointer alignment before, so that &lt;code&gt;rsp&lt;&#x2F;code&gt; points to the end of the exception stack frame again.&lt;&#x2F;p&gt;
&lt;p&gt;We‚Äôve changed the handler function type, so we need to adjust our existing exception handlers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;extern &amp;quot;C&amp;quot; fn divide_by_zero_handler(
&lt;&#x2F;span&gt;&lt;span&gt;-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {...}
&lt;&#x2F;span&gt;&lt;span&gt;+   stack_frame: &amp;amp;ExceptionStackFrame) {...}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;extern &amp;quot;C&amp;quot; fn invalid_opcode_handler(
&lt;&#x2F;span&gt;&lt;span&gt;-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {...}
&lt;&#x2F;span&gt;&lt;span&gt;+   stack_frame: &amp;amp;ExceptionStackFrame) {...}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;extern &amp;quot;C&amp;quot; fn breakpoint_handler(
&lt;&#x2F;span&gt;&lt;span&gt;-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;+   stack_frame: &amp;amp;ExceptionStackFrame) {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(...);
&lt;&#x2F;span&gt;&lt;span&gt;-   loop {}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we also removed the &lt;code&gt;loop {}&lt;&#x2F;code&gt; at the end of our &lt;code&gt;breakpoint_handler&lt;&#x2F;code&gt; so that it no longer diverges. The &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; and the &lt;code&gt;invalid_opcode_handler&lt;&#x2F;code&gt; still diverge (albeit the new function type would allow a return).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing&quot; aria-label=&quot;Anchor link for: testing&quot;&gt;üîó&lt;&#x2F;a&gt;Testing&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs try our new &lt;code&gt;iretq&lt;&#x2F;code&gt; logic:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;qemu-breakpoint-return-page-fault.png&quot; alt=&quot;QEMU output with EXCEPTION BREAKPOINT and EXCEPTION PAGE FAULT but no It did not crash&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Instead of the expected &lt;em&gt;‚ÄúIt did not crash‚Äù&lt;&#x2F;em&gt; message after the breakpoint exception, we get a page fault. The strange thing is that our kernel tried to access address &lt;code&gt;0x1&lt;&#x2F;code&gt;, which should never happen. So it seems like we messed up something important.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;üîó&lt;&#x2F;a&gt;Debugging&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs debug it using GDB. For that we execute &lt;code&gt;make debug&lt;&#x2F;code&gt; in one terminal (which starts QEMU with the &lt;code&gt;-s -S&lt;&#x2F;code&gt; flags) and then &lt;code&gt;make gdb&lt;&#x2F;code&gt; (which starts and connects GDB) in a second terminal. For more information about GDB debugging, check out our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-gdb&#x2F;&quot;&gt;Set Up GDB&lt;&#x2F;a&gt; guide.&lt;&#x2F;p&gt;
&lt;p&gt;First we want to check if our &lt;code&gt;iretq&lt;&#x2F;code&gt; was successful. Therefore we set a breakpoint on the &lt;code&gt;println!(&amp;quot;It did not crash line!&amp;quot;)&lt;&#x2F;code&gt; statement in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;. Let‚Äôs assume that it‚Äôs on line 61:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;(gdb) break blog_os&#x2F;src&#x2F;lib.rs:61
&lt;&#x2F;span&gt;&lt;span&gt;Breakpoint 1 at 0x110a95: file &#x2F;home&#x2F;...&#x2F;blog_os&#x2F;src&#x2F;lib.rs, line 61.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This line is after the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction, so we know that the &lt;code&gt;iretq&lt;&#x2F;code&gt; succeeded when the breakpoint is hit. To test this, we continue the execution:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;(gdb) continue
&lt;&#x2F;span&gt;&lt;span&gt;Continuing.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Breakpoint 1, blog_os::rust_main (multiboot_information_address=1539136)
&lt;&#x2F;span&gt;&lt;span&gt;    at &#x2F;home&#x2F;...&#x2F;blog_os&#x2F;src&#x2F;lib.rs:61
&lt;&#x2F;span&gt;&lt;span&gt;61	    println!(&amp;quot;It did not crash!&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It worked! So our kernel successfully returned from the &lt;code&gt;int3&lt;&#x2F;code&gt; instruction, which means that the &lt;code&gt;iretq&lt;&#x2F;code&gt; itself works.&lt;&#x2F;p&gt;
&lt;p&gt;However, when we &lt;code&gt;continue&lt;&#x2F;code&gt; the execution again, we get the page fault. So the exception occurs somewhere in the &lt;code&gt;println&lt;&#x2F;code&gt; logic. This means that it occurs in code generated by the compiler (and not e.g. in inline assembly). But the compiler should never access &lt;code&gt;0x1&lt;&#x2F;code&gt;, so how is this happening?&lt;&#x2F;p&gt;
&lt;p&gt;The answer is that we‚Äôve used the wrong &lt;em&gt;calling convention&lt;&#x2F;em&gt; for our exception handlers. Thus, we violate some compiler invariants so that the code that works fine without intermediate exceptions starts to violate memory safety when it‚Äôs executed after a breakpoint exception.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;calling-conventions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-conventions&quot; aria-label=&quot;Anchor link for: calling-conventions&quot;&gt;üîó&lt;&#x2F;a&gt;Calling Conventions&lt;&#x2F;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the (handler) function and executes the function. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2F;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted &lt;code&gt;call&lt;&#x2F;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;Calling conventions&lt;&#x2F;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2F;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2F;code&gt; and &lt;code&gt;rdx&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;600&quot;&gt;there isn‚Äôt even a Rust ABI yet&lt;&#x2F;a&gt;). So these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Preserved and Scratch Registers&lt;&#x2F;h3&gt;
&lt;p&gt;The calling convention divides the registers in two parts: &lt;em&gt;preserved&lt;&#x2F;em&gt; and &lt;em&gt;scratch&lt;&#x2F;em&gt; registers.&lt;&#x2F;p&gt;
&lt;p&gt;The values of the preserved register must remain unchanged across function calls. So a called function (the &lt;em&gt;‚Äúcallee‚Äù&lt;&#x2F;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called &lt;em&gt;‚Äúcallee-saved‚Äù&lt;&#x2F;em&gt;. A common pattern is to save these registers to the stack at the function‚Äôs beginning and restore them just before returning.&lt;&#x2F;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite scratch registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it (e.g. by pushing it to the stack before the function call). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers&lt;&#x2F;th&gt;&lt;th&gt;scratch registers&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2F;code&gt;, &lt;code&gt;rbx&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;r12&lt;&#x2F;code&gt;, &lt;code&gt;r13&lt;&#x2F;code&gt;, &lt;code&gt;r14&lt;&#x2F;code&gt;, &lt;code&gt;r15&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;, &lt;code&gt;r10&lt;&#x2F;code&gt;, &lt;code&gt;r11&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2F;em&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2F;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2F;code&gt; on the stack (because it‚Äôs a callee-saved register).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-exception-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-exception-calling-convention&quot; aria-label=&quot;Anchor link for: the-exception-calling-convention&quot;&gt;üîó&lt;&#x2F;a&gt;The Exception Calling Convention&lt;&#x2F;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2F;em&gt; instruction. In most cases we don‚Äôt even know at compile time if the generated code will cause an exception. For example, the compiler can‚Äôt know if an instruction causes a stack overflow or an other page fault.&lt;&#x2F;p&gt;
&lt;p&gt;Since we don‚Äôt know when an exception occurs, we can‚Äôt backup any registers before. This means that we can‚Äôt use a calling convention that relies on caller-saved registers for our exception handlers. But we do so at the moment: Our exception handlers are declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2F;code&gt; and thus use the C calling convention.&lt;&#x2F;p&gt;
&lt;p&gt;So here is what happens:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rust_main&lt;&#x2F;code&gt; is executing; it writes some memory address into &lt;code&gt;rax&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;int3&lt;&#x2F;code&gt; instruction causes a breakpoint exception.&lt;&#x2F;li&gt;
&lt;li&gt;Our &lt;code&gt;breakpoint_handler&lt;&#x2F;code&gt; prints to the screen and assumes that it can overwrite &lt;code&gt;rax&lt;&#x2F;code&gt; freely (since it‚Äôs a scratch register). Somehow the value &lt;code&gt;0&lt;&#x2F;code&gt; ends up in &lt;code&gt;rax&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;We return from the breakpoint exception using &lt;code&gt;iretq&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;rust_main&lt;&#x2F;code&gt; continues and accesses the memory address in &lt;code&gt;rax&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU tries to access address &lt;code&gt;0x1&lt;&#x2F;code&gt;, which causes a page fault.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So our exception handler erroneously assumes that the scratch registers were saved by the caller. But the caller (&lt;code&gt;rust_main&lt;&#x2F;code&gt;) couldn‚Äôt save any registers since it didn‚Äôt know that an exception occurs. So nobody saves &lt;code&gt;rax&lt;&#x2F;code&gt; and the other scratch registers, which leads to the page fault.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that we use a calling convention with caller-saved registers for our exception handlers. Instead, we need a calling convention means that preserves &lt;em&gt;all registers&lt;&#x2F;em&gt;. In other words, all registers must be callee-saved:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;all-registers-callee-saved&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;exception_handler() {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately, Rust does not support such a calling convention. It was &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;pull&#x2F;1275&quot;&gt;proposed once&lt;&#x2F;a&gt;, but did not get accepted for various reasons. The primary reason was that such calling conventions can be simulated by writing a naked wrapper function.&lt;&#x2F;p&gt;
&lt;p&gt;(Remember: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1201-naked-fns.md&quot;&gt;Naked functions&lt;&#x2F;a&gt; are functions without prologue and can contain only inline assembly. They were discussed in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;#naked-functions&quot;&gt;previous post&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-naked-wrapper-function&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-naked-wrapper-function&quot; aria-label=&quot;Anchor link for: a-naked-wrapper-function&quot;&gt;üîó&lt;&#x2F;a&gt;A naked wrapper function&lt;&#x2F;h3&gt;
&lt;p&gt;Such a naked wrapper function might look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;calling_convention_wrapper() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push r8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push r9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push r10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            push r11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            &#x2F;&#x2F; TODO: call exception handler with C calling convention
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop r11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop r10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop r9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop r8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            pop rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This wrapper function saves all &lt;em&gt;scratch&lt;&#x2F;em&gt; registers to the stack before calling the exception handler and restores them afterwards. Note that we &lt;code&gt;pop&lt;&#x2F;code&gt; the registers in reverse order.&lt;&#x2F;p&gt;
&lt;p&gt;We don‚Äôt need to backup &lt;em&gt;preserved&lt;&#x2F;em&gt; registers since they are callee-saved in the C calling convention. Thus, the compiler already takes care of preserving their values.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-our-handler-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-our-handler-macro&quot; aria-label=&quot;Anchor link for: fixing-our-handler-macro&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing our Handler Macro&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs update our handler macro to fix the calling convention problem. Therefore we need to backup and restore all scratch registers. For that we create two new macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! save_scratch_registers {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;push rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push r8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push r9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push r10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              push r11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! restore_scratch_registers {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop r11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop r10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop r9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop r8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              pop rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to declare these macros &lt;em&gt;above&lt;&#x2F;em&gt; our &lt;code&gt;handler&lt;&#x2F;code&gt; macro, since macros are only available after their declaration.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use these macros to fix our &lt;code&gt;handler!&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                save_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      add rdi, 9*8 &#x2F;&#x2F; calculate exception stack frame pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      &#x2F;&#x2F; sub rsp, 8 (stack is aligned already)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as
&lt;&#x2F;span&gt;&lt;span&gt;                             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame))
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                restore_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      &#x2F;&#x2F; add rsp, 8 (undo stack alignment; not needed anymore)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      iretq&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs important that we save the registers first, before we modify any of them. After the &lt;code&gt;call&lt;&#x2F;code&gt; instruction (but before &lt;code&gt;iretq&lt;&#x2F;code&gt;) we restore the registers again. Because we‚Äôre now changing &lt;code&gt;rsp&lt;&#x2F;code&gt; (by pushing the register values) before we load it into &lt;code&gt;rdi&lt;&#x2F;code&gt;, we would get a wrong exception stack frame pointer. Therefore we need to adjust it by adding the number of bytes we push. We push 9 registers that are 8 bytes each, so &lt;code&gt;9 * 8&lt;&#x2F;code&gt; bytes in total.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we no longer need to manually align the stack pointer, because we‚Äôre pushing an uneven number of registers in &lt;code&gt;save_scratch_registers&lt;&#x2F;code&gt;. Thus the stack pointer already has the required 16-byte alignment.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-it-again&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it-again&quot; aria-label=&quot;Anchor link for: testing-it-again&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it again&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs test it again with our corrected &lt;code&gt;handler!&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;qemu-breakpoint-return.png&quot; alt=&quot;QEMU output with EXCEPTION BREAKPOINT and It did not crash&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The page fault is gone and we see the &lt;em&gt;‚ÄúIt did not crash‚Äù&lt;&#x2F;em&gt; message again!&lt;&#x2F;p&gt;
&lt;p&gt;So the page fault occurred because our exception handler didn‚Äôt preserve the scratch register &lt;code&gt;rax&lt;&#x2F;code&gt;. Our new &lt;code&gt;handler!&lt;&#x2F;code&gt; macro fixes this problem by saving all scratch registers (including &lt;code&gt;rax&lt;&#x2F;code&gt;) before calling exception handlers. Thus, &lt;code&gt;rax&lt;&#x2F;code&gt; still contains the valid memory address when &lt;code&gt;rust-main&lt;&#x2F;code&gt; continues execution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;multimedia-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multimedia-registers&quot; aria-label=&quot;Anchor link for: multimedia-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Multimedia Registers&lt;&#x2F;h2&gt;
&lt;p&gt;When we discussed calling conventions above, we assumed that a x86_64 CPU only has the following 16 registers: &lt;code&gt;rax&lt;&#x2F;code&gt;, &lt;code&gt;rbx&lt;&#x2F;code&gt;, &lt;code&gt;rcx&lt;&#x2F;code&gt;, &lt;code&gt;rdx&lt;&#x2F;code&gt;, &lt;code&gt;rsi&lt;&#x2F;code&gt;, &lt;code&gt;rdi&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;rbp&lt;&#x2F;code&gt;, &lt;code&gt;r8&lt;&#x2F;code&gt;, &lt;code&gt;r9&lt;&#x2F;code&gt;, &lt;code&gt;r10&lt;&#x2F;code&gt;, &lt;code&gt;r11&lt;&#x2F;code&gt;.&lt;code&gt;r12&lt;&#x2F;code&gt;, &lt;code&gt;r13&lt;&#x2F;code&gt;, &lt;code&gt;r14&lt;&#x2F;code&gt;, and &lt;code&gt;r15&lt;&#x2F;code&gt;. These registers are called &lt;em&gt;general purpose registers&lt;&#x2F;em&gt; since each of them can be used for arithmetic and load&#x2F;store instructions.&lt;&#x2F;p&gt;
&lt;p&gt;However, modern CPUs also have a set of &lt;em&gt;special purpose registers&lt;&#x2F;em&gt;, which can be used to improve performance in several use cases. On x86_64, the most important set of special purpose registers are the &lt;em&gt;multimedia registers&lt;&#x2F;em&gt;. These registers are larger than the general purpose registers and can be used to speed up audio&#x2F;video processing or matrix calculations. For example, we could use them to add two 4-dimensional vectors &lt;em&gt;in a single CPU instruction&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;vector-addition.png&quot; alt=&quot;(1,2,3,4) + (5,6,7,8) = (6,8,10,12)&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Such multimedia instructions are called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2F;a&gt; instructions, because they simultaneously perform an operation (e.g. addition) on multiple data words. Good compilers are able to transform normal loops into such SIMD code automatically. This process is called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automatic_vectorization&quot;&gt;auto-vectorization&lt;&#x2F;a&gt; and can lead to huge performance improvements.&lt;&#x2F;p&gt;
&lt;p&gt;However, auto-vectorization causes a problem for us: Most of the multimedia registers are caller-saved. According to our discussion of calling conventions above, this means that our exception handlers erroneously assume that they are allowed to overwrite them without preserving their values.&lt;&#x2F;p&gt;
&lt;p&gt;We don‚Äôt use any multimedia registers explicitly, but the Rust compiler might auto-vectorize our code (including the exception handlers). Thus we could silently clobber the multimedia registers, which leads to the same problems as above:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;xmm-overwrite.svg&quot; alt=&quot;example: program uses mm0, mm1, and mm2. Then the exception handler clobbers mm1.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This example shows a program that is using the first three multimedia registers (&lt;code&gt;mm0&lt;&#x2F;code&gt; to &lt;code&gt;mm2&lt;&#x2F;code&gt;). At some point, an exception occurs and control is transferred to the exception handler. The exception handler uses &lt;code&gt;mm1&lt;&#x2F;code&gt; for its own data and thus overwrites the previous value. When the exception is resolved, the CPU continues the interrupted program again. However, the program is now corrupt since it relies on the original &lt;code&gt;mm1&lt;&#x2F;code&gt; value.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;saving-and-restoring-multimedia-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#saving-and-restoring-multimedia-registers&quot; aria-label=&quot;Anchor link for: saving-and-restoring-multimedia-registers&quot;&gt;üîó&lt;&#x2F;a&gt;Saving and Restoring Multimedia Registers&lt;&#x2F;h3&gt;
&lt;p&gt;In order to fix this problem, we need to backup all caller-saved multimedia registers before we call the exception handler. The problem is that the set of multimedia registers varies between CPUs. There are different standards:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MMX_(instruction_set)&quot;&gt;MMX&lt;&#x2F;a&gt;: The MMX instruction set was introduced in 1997 and defines eight 64 bit registers called &lt;code&gt;mm0&lt;&#x2F;code&gt; through &lt;code&gt;mm7&lt;&#x2F;code&gt;. These registers are just aliases for the registers of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X87&quot;&gt;x87 floating point unit&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2F;a&gt;: The &lt;em&gt;Streaming SIMD Extensions&lt;&#x2F;em&gt; instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called &lt;code&gt;xmm0&lt;&#x2F;code&gt; through &lt;code&gt;xmm15&lt;&#x2F;code&gt; and are 128 bits each.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Advanced_Vector_Extensions&quot;&gt;AVX&lt;&#x2F;a&gt;: The &lt;em&gt;Advanced Vector Extensions&lt;&#x2F;em&gt; are extensions that further increase the size of the multimedia registers. The new registers are called &lt;code&gt;ymm0&lt;&#x2F;code&gt; through &lt;code&gt;ymm15&lt;&#x2F;code&gt; and are 256 bits each. They extend the &lt;code&gt;xmm&lt;&#x2F;code&gt; registers, so e.g. &lt;code&gt;xmm0&lt;&#x2F;code&gt; is the lower (or upper?) half of &lt;code&gt;ymm0&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The Rust compiler (and LLVM) assume that the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target supports only MMX and SSE, so we don‚Äôt need to save the &lt;code&gt;ymm0&lt;&#x2F;code&gt; through &lt;code&gt;ymm15&lt;&#x2F;code&gt;. But we need to save &lt;code&gt;xmm0&lt;&#x2F;code&gt; through &lt;code&gt;xmm15&lt;&#x2F;code&gt; and also &lt;code&gt;mm0&lt;&#x2F;code&gt; through &lt;code&gt;mm7&lt;&#x2F;code&gt;. There is a special instruction to do this: &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;fxsave&quot;&gt;fxsave&lt;&#x2F;a&gt;. This instruction saves the floating point and multimedia state to a given address. It needs &lt;em&gt;512 bytes&lt;&#x2F;em&gt; to store that state.&lt;&#x2F;p&gt;
&lt;p&gt;In order to save&#x2F;restore the multimedia registers, we &lt;em&gt;could&lt;&#x2F;em&gt; add new macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;macro_rules! save_multimedia_registers {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;sub rsp, 512
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              fxsave [rsp]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! restore_multimedia_registers {
&lt;&#x2F;span&gt;&lt;span&gt;    () &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;fxrstor [rsp]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              add rsp, 512
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;            &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we reserve the 512 bytes on the stack and then we use &lt;code&gt;fxsave&lt;&#x2F;code&gt; to backup the multimedia registers. In order to restore them later, we use the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;fxrstor&quot;&gt;fxrstor&lt;&#x2F;a&gt; instruction. Note that &lt;code&gt;fxsave&lt;&#x2F;code&gt; and &lt;code&gt;fxrstor&lt;&#x2F;code&gt; require a 16 byte aligned memory address.&lt;&#x2F;p&gt;
&lt;p&gt;However, &lt;em&gt;we won‚Äôt do it that way&lt;&#x2F;em&gt;. The problem is the large amount of memory required. We will reuse the same code when we handle hardware interrupts in a future post. So for each mouse click, pressed key, or arrived network package we need to write 512 bytes to memory. This would be a huge performance problem.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, there exists an alternative solution.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;disabling-multimedia-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-multimedia-extensions&quot; aria-label=&quot;Anchor link for: disabling-multimedia-extensions&quot;&gt;üîó&lt;&#x2F;a&gt;Disabling Multimedia Extensions&lt;&#x2F;h3&gt;
&lt;p&gt;We just disable MMX, SSE, and all the other fancy multimedia extensions in our kernel&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-userspace-sse&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. This way, our exception handlers won‚Äôt clobber the multimedia registers because they won‚Äôt use them at all.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-userspace-sse&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Userspace programs will still be able to use the multimedia registers.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;This solution has its own disadvantages, of course. For example, it leads to slower kernel code because the compiler can‚Äôt perform any auto-vectorization optimizations. But it‚Äôs still the faster solution (since we save many memory accesses) and most kernels do it this way (including Linux).&lt;&#x2F;p&gt;
&lt;p&gt;So how do we disable MMX and SSE? Well, we just tell the compiler that our target system doesn‚Äôt support it. Since the very beginning, we‚Äôre compiling our kernel for the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target. This worked fine so far, but now we want a different target without support for multimedia extensions. We can do so by creating a &lt;em&gt;target configuration file&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;target-specifications&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specifications&quot; aria-label=&quot;Anchor link for: target-specifications&quot;&gt;üîó&lt;&#x2F;a&gt;Target Specifications&lt;&#x2F;h3&gt;
&lt;p&gt;In order to disable the multimedia extensions for our kernel, we need to compile for a custom target. We want a target that is equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt;, but without MMX and SSE support. Rust allows us to specify such a target using a JSON configuration file.&lt;&#x2F;p&gt;
&lt;p&gt;A minimal target specification that describes the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;llvm-target&lt;&#x2F;code&gt; field specifies the target triple that is passed to LLVM. We want to derive a 64-bit Linux target, so we choose &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt;. The &lt;code&gt;data-layout&lt;&#x2F;code&gt; field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications separated by a &lt;code&gt;-&lt;&#x2F;code&gt; character. For example, the &lt;code&gt;e&lt;&#x2F;code&gt; means little endian and &lt;code&gt;S128&lt;&#x2F;code&gt; specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the &lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#data-layout&quot;&gt;LLVM documentation&lt;&#x2F;a&gt; but there shouldn‚Äôt be a reason to change this string.&lt;&#x2F;p&gt;
&lt;p&gt;The other fields are used for conditional compilation. This allows crate authors to use &lt;code&gt;cfg&lt;&#x2F;code&gt; variables to write special code for depending on the OS or the architecture. There isn‚Äôt any up-to-date documentation about these fields but the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;c772948b687488a087356cb91432425662e034b9&#x2F;src&#x2F;librustc_back&#x2F;target&#x2F;mod.rs#L194-L214&quot;&gt;corresponding source code&lt;&#x2F;a&gt; is quite readable.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;disabling-mmx-and-sse&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-mmx-and-sse&quot; aria-label=&quot;Anchor link for: disabling-mmx-and-sse&quot;&gt;üîó&lt;&#x2F;a&gt;Disabling MMX and SSE&lt;&#x2F;h4&gt;
&lt;p&gt;In order to disable the multimedia extensions, we create a new target named &lt;code&gt;x86_64-blog_os&lt;&#x2F;code&gt;. To describe this target, we create a file named &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; in the project root with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target but has one additional option: &lt;code&gt;&amp;quot;features&amp;quot;: &amp;quot;-mmx,-sse&amp;quot;&lt;&#x2F;code&gt;. So we added two target &lt;em&gt;features&lt;&#x2F;em&gt;: &lt;code&gt;-mmx&lt;&#x2F;code&gt; and &lt;code&gt;-sse&lt;&#x2F;code&gt;. The minus prefix defines that our target does &lt;em&gt;not&lt;&#x2F;em&gt; support this feature. So by specifying &lt;code&gt;-mmx&lt;&#x2F;code&gt; and &lt;code&gt;-sse&lt;&#x2F;code&gt;, we disable the default &lt;code&gt;mmx&lt;&#x2F;code&gt; and &lt;code&gt;sse&lt;&#x2F;code&gt; features.&lt;&#x2F;p&gt;
&lt;p&gt;In order to compile for the new target, we need to adjust our Makefile:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;# in `Makefile`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt; arch ?= x86_64
&lt;&#x2F;span&gt;&lt;span&gt;-target ?= $(arch)-unknown-linux-gnu
&lt;&#x2F;span&gt;&lt;span&gt;+target ?= $(arch)-blog_os
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The new target name (&lt;code&gt;x86_64-blog_os&lt;&#x2F;code&gt;) is the file name of the JSON configuration file without the &lt;code&gt;.json&lt;&#x2F;code&gt; extension.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cross-compilation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cross-compilation&quot; aria-label=&quot;Anchor link for: cross-compilation&quot;&gt;üîó&lt;&#x2F;a&gt;Cross compilation&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs try if our kernel still works with the new target:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; make run
&lt;&#x2F;span&gt;&lt;span&gt;Compiling raw-cpuid v2.0.1
&lt;&#x2F;span&gt;&lt;span&gt;Compiling rlibc v0.1.5
&lt;&#x2F;span&gt;&lt;span&gt;Compiling x86 v0.7.1
&lt;&#x2F;span&gt;&lt;span&gt;Compiling spin v0.3.5
&lt;&#x2F;span&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `core`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error: aborting due to previous error
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Build failed, waiting for other jobs to finish...
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;Makefile:52: recipe for target &amp;#39;cargo&amp;#39; failed
&lt;&#x2F;span&gt;&lt;span&gt;make: *** [cargo] Error 101
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It doesn‚Äôt compile anymore. The error tells us that the Rust compiler no longer finds the core library.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;index.html&quot;&gt;core library&lt;&#x2F;a&gt; is implicitly linked to all &lt;code&gt;no_std&lt;&#x2F;code&gt; crates and contains things such as &lt;code&gt;Result&lt;&#x2F;code&gt;, &lt;code&gt;Option&lt;&#x2F;code&gt;, and iterators. We‚Äôve used that library without problems since &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-rust&#x2F;&quot;&gt;the very beginning&lt;&#x2F;a&gt;, so why is it no longer available?&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2F;em&gt; library. So it is only valid for the host triple, which is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; in our case. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2F;code&gt; for these targets first.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xargo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#xargo&quot; aria-label=&quot;Anchor link for: xargo&quot;&gt;üîó&lt;&#x2F;a&gt;Xargo&lt;&#x2F;h4&gt;
&lt;p&gt;That‚Äôs where &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;japaric&#x2F;xargo&quot;&gt;xargo&lt;&#x2F;a&gt; comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo install xargo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Xargo depends on the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Xargo is ‚Äúa drop-in replacement for cargo‚Äù, so every cargo command also works with &lt;code&gt;xargo&lt;&#x2F;code&gt;. You can do e.g. &lt;code&gt;xargo --help&lt;&#x2F;code&gt;, &lt;code&gt;xargo clean&lt;&#x2F;code&gt;, or &lt;code&gt;xargo doc&lt;&#x2F;code&gt;. However, the &lt;code&gt;build&lt;&#x2F;code&gt; command gains additional functionality: &lt;code&gt;xargo build&lt;&#x2F;code&gt; will automatically cross compile the &lt;code&gt;core&lt;&#x2F;code&gt; library when compiling for custom targets.&lt;&#x2F;p&gt;
&lt;p&gt;That‚Äôs exactly what we want, so we change one letter in our Makefile:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;# in `Makefile`
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;cargo:
&lt;&#x2F;span&gt;&lt;span&gt;-	@cargo build --target $(target)
&lt;&#x2F;span&gt;&lt;span&gt;+	@xargo build --target $(target)
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the build goes through &lt;code&gt;xargo&lt;&#x2F;code&gt;, which should fix the compilation error. Let‚Äôs try it out:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; make run
&lt;&#x2F;span&gt;&lt;span&gt;Compiling core v0.0.0 (file:&#x2F;&#x2F;&#x2F;home&#x2F;‚Ä¶&#x2F;.rustup&#x2F;toolchains&#x2F;nightly-x86_64-unknown-linux-gnu&#x2F;lib&#x2F;rustlib&#x2F;src&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;LLVM ERROR: SSE register return with SSE disabled
&lt;&#x2F;span&gt;&lt;span&gt;error: Could not compile `core`.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Well, we get a different error now, so it seems like we‚Äôre making progress :). It seems like there is a ‚ÄúSSE register return‚Äù although SSE is disabled. But what‚Äôs an ‚ÄúSSE register return‚Äù?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sse-register-return&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sse-register-return&quot; aria-label=&quot;Anchor link for: sse-register-return&quot;&gt;üîó&lt;&#x2F;a&gt;SSE Register Return&lt;&#x2F;h3&gt;
&lt;p&gt;Remember when we discussed calling conventions above? The calling convention defines which registers are used for return values. Well, the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt; defines that &lt;code&gt;xmm0&lt;&#x2F;code&gt; should be used for returning floating point values. So somewhere in the &lt;code&gt;core&lt;&#x2F;code&gt; library a function returns a float and LLVM doesn‚Äôt know what to do. The ABI says ‚Äúuse &lt;code&gt;xmm0&lt;&#x2F;code&gt;‚Äù but the target specification says ‚Äúdon‚Äôt use &lt;code&gt;xmm&lt;&#x2F;code&gt; registers‚Äù.&lt;&#x2F;p&gt;
&lt;p&gt;In order to fix this problem, we need to change our float ABI. The idea is to avoid normal hardware-supported floats and use a pure software implementation instead. We can do so by enabling the &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature for our target. For that, we edit &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The plus prefix tells LLVM to enable the &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs try &lt;code&gt;make run&lt;&#x2F;code&gt; again:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; make run
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling core v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;.rustup&#x2F;toolchains&#x2F;nightly-x86_64-unknown-linux-gnu&#x2F;lib&#x2F;rustlib&#x2F;src&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized] target(s) in 21.95 secs
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling spin v0.4.5
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling once v0.3.2
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling x86 v0.8.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling bitflags v0.9.1
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling raw-cpuid v2.0.1
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling rlibc v0.1.5
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling linked_list_allocator v0.2.3
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling volatile v0.1.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling bitflags v0.4.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling bit_field v0.5.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling spin v0.3.5
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling multiboot2 v0.1.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling lazy_static v0.2.2
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling hole_list_allocator v0.1.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;libs&#x2F;hole_list_allocator)
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶)
&lt;&#x2F;span&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `alloc`
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;lib.rs:33:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;33 | extern crate alloc;
&lt;&#x2F;span&gt;&lt;span&gt;   | ^^^^^^^^^^^^^^^^^^^ can&amp;#39;t find crate
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;error: aborting due to previous error
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that &lt;code&gt;xargo&lt;&#x2F;code&gt; now compiles the &lt;code&gt;core&lt;&#x2F;code&gt; crate in release mode. Then it starts the normal cargo build. Cargo then recompiles all dependencies, since it needs to generate different code for the new target.&lt;&#x2F;p&gt;
&lt;p&gt;However, the build still fails. The reason is that xargo only installs &lt;code&gt;core&lt;&#x2F;code&gt; by default, but we also need the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate. We can enable it by creating a file named &lt;code&gt;Xargo.toml&lt;&#x2F;code&gt; with the following contents:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# Xargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.x86_64-blog_os.dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;alloc &lt;&#x2F;span&gt;&lt;span&gt;= {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now xargo compiles &lt;code&gt;alloc&lt;&#x2F;code&gt;, too:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; make run
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling core v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;.rustup&#x2F;toolchains&#x2F;nightly-x86_64-unknown-linux-gnu&#x2F;lib&#x2F;rustlib&#x2F;src&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling std_unicode v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;.rustup&#x2F;toolchains&#x2F;nightly-x86_64-unknown-linux-gnu&#x2F;lib&#x2F;rustlib&#x2F;src&#x2F;rust&#x2F;src&#x2F;libstd_unicode)
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling alloc v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;.rustup&#x2F;toolchains&#x2F;nightly-x86_64-unknown-linux-gnu&#x2F;lib&#x2F;rustlib&#x2F;src&#x2F;rust&#x2F;src&#x2F;liballoc)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized] target(s) in 28.84 secs
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;Documents&#x2F;blog_os&#x2F;master)
&lt;&#x2F;span&gt;&lt;span&gt;warning: unused variable: `allocator` [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;warning: unused variable: `frame` [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It worked! Now we have a kernel that never touches the multimedia registers! We can verify this by executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin | grep &amp;quot;mm[0-9]&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the command produces no output, our kernel uses neither MMX (&lt;code&gt;mm0&lt;&#x2F;code&gt; ‚Äì &lt;code&gt;mm7&lt;&#x2F;code&gt;) nor SSE (&lt;code&gt;xmm0&lt;&#x2F;code&gt; ‚Äì &lt;code&gt;xmm15&lt;&#x2F;code&gt;) registers.&lt;&#x2F;p&gt;
&lt;p&gt;So now our return-from-exception logic works without problems in &lt;em&gt;most&lt;&#x2F;em&gt; cases. However, there is still a pitfall hidden in the C calling convention, which might cause hideous bugs in some rare cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-red-zone&quot; aria-label=&quot;Anchor link for: the-red-zone&quot;&gt;üîó&lt;&#x2F;a&gt;The Red Zone&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;09&#x2F;06&#x2F;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2F;a&gt; is an optimization of the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt; that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;red-zone.svg&quot; alt=&quot;stack frame with red zone&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The image shows the stack frame of a function with &lt;code&gt;n&lt;&#x2F;code&gt; local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.&lt;&#x2F;p&gt;
&lt;p&gt;The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that‚Äôs not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).&lt;&#x2F;p&gt;
&lt;p&gt;However, this optimization leads to huge problems with exceptions. Let‚Äôs assume that an exception occurs while a function uses the red zone:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;red-zone-overwrite.svg&quot; alt=&quot;red zone overwritten by exception handler&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won‚Äôt work correctly anymore when we return from the exception handler. It might fail or cause another exception, but it could also lead to strange bugs that &lt;a href=&quot;https:&#x2F;&#x2F;forum.osdev.org&#x2F;viewtopic.php?t=21720&quot;&gt;take weeks to debug&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;adjusting-our-exception-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adjusting-our-exception-handler&quot; aria-label=&quot;Anchor link for: adjusting-our-exception-handler&quot;&gt;üîó&lt;&#x2F;a&gt;Adjusting our Exception Handler?&lt;&#x2F;h3&gt;
&lt;p&gt;The problem is that the &lt;a href=&quot;https:&#x2F;&#x2F;refspecs.linuxbase.org&#x2F;elf&#x2F;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2F;a&gt; demands that the red zone &lt;em&gt;‚Äúshall not be modified by signal or interrupt handlers.‚Äù&lt;&#x2F;em&gt; Our current exception handlers do not respect this. We could try to fix it by subtracting 128 from the stack pointer before pushing anything:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;sub &lt;&#x2F;span&gt;&lt;span&gt;rsp, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;128
&lt;&#x2F;span&gt;&lt;span&gt;save_scratch_registers()
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;restore_scratch_registers()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span&gt;rsp, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;128
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;iretq
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;This will not work.&lt;&#x2F;em&gt; The problem is that the CPU pushes the exception stack frame before even calling our handler function. So the CPU itself will clobber the red zone and there is nothing we can do about that. So our only chance is to disable the red zone.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;disabling-the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-the-red-zone&quot; aria-label=&quot;Anchor link for: disabling-the-red-zone&quot;&gt;üîó&lt;&#x2F;a&gt;Disabling the Red Zone&lt;&#x2F;h3&gt;
&lt;p&gt;The red zone is a property of our target, so in order to disable it we edit our &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; a last time:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add one additional option at the end: &lt;code&gt;&amp;quot;disable-redzone&amp;quot;: true&lt;&#x2F;code&gt;. As you might guess, this option disables the red zone optimization.&lt;&#x2F;p&gt;
&lt;p&gt;Now we have a red zone free kernel!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;exceptions-with-error-codes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-with-error-codes&quot; aria-label=&quot;Anchor link for: exceptions-with-error-codes&quot;&gt;üîó&lt;&#x2F;a&gt;Exceptions with Error Codes&lt;&#x2F;h2&gt;
&lt;p&gt;We‚Äôre now able to correctly return from exceptions without error codes. However, we still can‚Äôt return from exceptions that push an error code (e.g. page faults). Let‚Äôs fix that by updating our &lt;code&gt;handler_with_error_code&lt;&#x2F;code&gt; macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler_with_error_code {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2F;&#x2F; pop error code into rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;iretq&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we change the type of the handler function: no more &lt;code&gt;-&amp;gt; !&lt;&#x2F;code&gt;, so it no longer needs to diverge. We also add an &lt;code&gt;iretq&lt;&#x2F;code&gt; instruction at the end.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can make our &lt;code&gt;page_fault_handler&lt;&#x2F;code&gt; non-diverging:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;diff&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-diff &quot;&gt;&lt;code class=&quot;language-diff&quot; data-lang=&quot;diff&quot;&gt;&lt;span&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt; extern &amp;quot;C&amp;quot; fn page_fault_handler(stack_frame: &amp;amp;ExceptionStackFrame,
&lt;&#x2F;span&gt;&lt;span&gt;-   error_code: u64) -&amp;gt; ! { ... }
&lt;&#x2F;span&gt;&lt;span&gt;+   error_code: u64) { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, now we have the same problem as above: The handler function will overwrite the scratch registers and cause bugs when returning. Let‚Äôs fix this by invoking &lt;code&gt;save_scratch_registers&lt;&#x2F;code&gt; at the beginning:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler_with_error_code {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                save_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2F;&#x2F; pop error code into rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      add rdi, 10*8 &#x2F;&#x2F; calculate exception stack frame pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      add rsp, 8 &#x2F;&#x2F; undo stack pointer alignment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                restore_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;iretq&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we backup the scratch registers to the stack right at the beginning and restore them just before the &lt;code&gt;iretq&lt;&#x2F;code&gt;. Like in the &lt;code&gt;handler&lt;&#x2F;code&gt; macro, we now need to add &lt;code&gt;10*8&lt;&#x2F;code&gt; to &lt;code&gt;rdi&lt;&#x2F;code&gt; in order to get the correct exception stack frame pointer (&lt;code&gt;save_scratch_registers&lt;&#x2F;code&gt; pushes nine 8 byte registers, plus the error code). We also need to undo the stack pointer alignment after the &lt;code&gt;call&lt;&#x2F;code&gt; &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-stack-alignment&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-stack-alignment&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;The stack alignment is actually wrong here, since we additionally pushed an uneven number of registers. However, the &lt;code&gt;pop rsi&lt;&#x2F;code&gt; is wrong too, since the error code is no longer at the top of the stack. When we fix that problem, the stack alignment becomes correct again. So I left it in to keep things simple.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Now we have one last bug: We &lt;code&gt;pop&lt;&#x2F;code&gt; the error code into &lt;code&gt;rsi&lt;&#x2F;code&gt;, but the error code is no longer at the top of the stack (since &lt;code&gt;save_scratch_registers&lt;&#x2F;code&gt; pushed 9 registers on top of it). So we need to do it differently:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler_with_error_code {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                save_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rsi, [rsp + 9*8] &#x2F;&#x2F; load error code into rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      add rdi, 10*8 &#x2F;&#x2F; calculate exception stack frame pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      add rsp, 8 &#x2F;&#x2F; undo stack pointer alignment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      &amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                restore_scratch_registers!();
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;add rsp, 8 &#x2F;&#x2F; pop error code
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      iretq&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;:::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;pop&lt;&#x2F;code&gt;, we‚Äôre calculating the error code address manually (&lt;code&gt;save_scratch_registers&lt;&#x2F;code&gt; pushes nine 8 byte registers) and load it into &lt;code&gt;rsi&lt;&#x2F;code&gt; using a &lt;code&gt;mov&lt;&#x2F;code&gt;. So now the error code stays on the stack. But &lt;code&gt;iretq&lt;&#x2F;code&gt; doesn‚Äôt handle the error code, so we need to pop it before invoking &lt;code&gt;iretq&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Phew! That was a lot of fiddling with assembly. Let‚Äôs test if it still works.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-1&quot; aria-label=&quot;Anchor link for: testing-1&quot;&gt;üîó&lt;&#x2F;a&gt;Testing&lt;&#x2F;h3&gt;
&lt;p&gt;First, we test if the exception stack frame pointer and the error code are still correct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ int!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provoke a page fault
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should cause the following error message:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;EXCEPTION: PAGE FAULT while accessing 0xdeadbeaf
&lt;&#x2F;span&gt;&lt;span&gt;error code: CAUSED_BY_WRITE
&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame {
&lt;&#x2F;span&gt;&lt;span&gt;    instruction_pointer: 1114753,
&lt;&#x2F;span&gt;&lt;span&gt;    code_segment: 8,
&lt;&#x2F;span&gt;&lt;span&gt;    cpu_flags: 2097158,
&lt;&#x2F;span&gt;&lt;span&gt;    stack_pointer: 1171104,
&lt;&#x2F;span&gt;&lt;span&gt;    stack_segment: 16
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error code should still be &lt;code&gt;CAUSED_BY_WRITE&lt;&#x2F;code&gt; and the exception stack frame values should also be correct (e.g. &lt;code&gt;code_segment&lt;&#x2F;code&gt; should be 8 and &lt;code&gt;stack_segment&lt;&#x2F;code&gt; should be 16).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;returning-from-page-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#returning-from-page-faults&quot; aria-label=&quot;Anchor link for: returning-from-page-faults&quot;&gt;üîó&lt;&#x2F;a&gt;Returning from Page Faults&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs see what happens if we comment out the trailing &lt;code&gt;loop&lt;&#x2F;code&gt; in our page fault handler:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;qemu-page-fault-return.png&quot; alt=&quot;QEMU printing the same page fault message again and again&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that the same error message is printed over and over again. Here is what happens:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The CPU executes &lt;code&gt;rust_main&lt;&#x2F;code&gt; and tries to access &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;. This causes a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;The page fault handler prints an error message and returns without fixing the cause of the exception (&lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt; is still unaccessible).&lt;&#x2F;li&gt;
&lt;li&gt;The CPU restarts the instruction that caused the page fault and thus tries to access &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt; again. Of course, this causes a page fault again.&lt;&#x2F;li&gt;
&lt;li&gt;The page fault handler prints the error message and returns.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;‚Ä¶ and so on. Thus, our code indefinitely jumps between the page fault handler and the instruction that accesses &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is a good thing! It means that our &lt;code&gt;iretq&lt;&#x2F;code&gt; logic is working correctly, since it returns to the correct instruction every time. So our &lt;code&gt;handler_with_error_code&lt;&#x2F;code&gt; macro seems to be correct.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;We are now able to catch exceptions and to return from them. However, there are still exceptions that completely crash our kernel by causing a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Triple_fault&quot;&gt;triple fault&lt;&#x2F;a&gt;. In the next post, we will fix this issue by handling a special type of exception: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double_fault&quot;&gt;double fault&lt;&#x2F;a&gt;. Thus, we will be able to avoid random reboots in our kernel.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Better Exception Messages</title>
                <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/better-exception-messages/</link>
                <guid>https://os.phil-opp.com/better-exception-messages/</guid>
                <description>&lt;p&gt;In this post, we explore exceptions in more detail. Our goal is to print additional information when an exception occurs, for example the values of the instruction and stack pointer. In the course of this, we will explore inline assembly and naked functions. We will also add a handler function for page faults and read the associated error code.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;better_exception_messages&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2F;&#x2F;gitter.im&#x2F;phil-opp&#x2F;blog_os&quot;&gt;gitter chat&lt;&#x2F;a&gt; and a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2F;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;extra&#x2F;naked-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions with Naked Functions‚Äù&lt;&#x2F;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions‚Äù&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;exceptions-in-detail&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-in-detail&quot; aria-label=&quot;Anchor link for: exceptions-in-detail&quot;&gt;üîó&lt;&#x2F;a&gt;Exceptions in Detail&lt;&#x2F;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the currently-executed instruction. Whenever an exception occurs, the CPU interrupts its current work and starts an internal exception routine.&lt;&#x2F;p&gt;
&lt;p&gt;This routine involves reading the interrupt descriptor table and invoking the registered handler function. But first, the CPU pushes various information onto the stack, which describe the current state and provide information about the cause of the exception:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The pushed information contain the instruction and stack pointer, the current CPU flags, and (for some exceptions) an error code, which contains further information about the cause of the exception. Let‚Äôs look at the fields in detail:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;First, the CPU aligns the stack pointer on a 16-byte boundary. This allows the handler function to use SSE instructions, which partly expect such an alignment.&lt;&#x2F;li&gt;
&lt;li&gt;After that, the CPU pushes the stack segment descriptor (SS) and the old stack pointer (from before the alignment) onto the stack. This allows us to restore the previous stack pointer when we want to resume the interrupted program.&lt;&#x2F;li&gt;
&lt;li&gt;Then the CPU pushes the contents of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2F;a&gt; register. This register contains various state information of the interrupted program. For example, it indicates if interrupts were enabled and whether the last executed instruction returned zero.&lt;&#x2F;li&gt;
&lt;li&gt;Next the CPU pushes the instruction pointer and its code segment descriptor onto the stack. This tells us the address of the last executed instruction, which caused the exception.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, the CPU pushes an error code for some exceptions. This error code only exists for exceptions such as page faults or general protection faults and provides additional information. For example, it tells us whether a page fault was caused by a read or a write request.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;printing-the-exception-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-the-exception-stack-frame&quot; aria-label=&quot;Anchor link for: printing-the-exception-stack-frame&quot;&gt;üîó&lt;&#x2F;a&gt;Printing the Exception Stack Frame&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs create a struct that represents the exception stack frame:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame {
&lt;&#x2F;span&gt;&lt;span&gt;    instruction_pointer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    code_segment: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    cpu_flags: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    stack_pointer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    stack_segment: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The divide-by-zero fault pushes no error code, so we leave it out for now. Note that the stack grows downwards in memory, so we need to declare the fields in reverse order (compared to the figure above).&lt;&#x2F;p&gt;
&lt;p&gt;Now we need a way to find the memory address of this stack frame. When we look at the above graphic again, we see that the start address of the exception stack frame is the new stack pointer. So we just need to read the value of &lt;code&gt;rsp&lt;&#x2F;code&gt; at the very beginning of our handler function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_handler() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov $0, rsp&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;=r&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;(stack_frame) ::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We‚Äôre using &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;book&#x2F;inline-assembly.html&quot;&gt;inline assembly&lt;&#x2F;a&gt; here to load the value from the &lt;code&gt;rsp&lt;&#x2F;code&gt; register into &lt;code&gt;stack_frame&lt;&#x2F;code&gt;. The syntax is a bit strange, so here‚Äôs a quick explanation:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;asm!&lt;&#x2F;code&gt; macro emits raw assembly instructions. This is the only way to read raw register values in Rust.&lt;&#x2F;li&gt;
&lt;li&gt;We insert a single assembly instruction: &lt;code&gt;mov $0, rsp&lt;&#x2F;code&gt;. It moves the value of &lt;code&gt;rsp&lt;&#x2F;code&gt; to some register (the &lt;code&gt;$0&lt;&#x2F;code&gt; is a placeholder for an arbitrary register, which gets filled by the compiler).&lt;&#x2F;li&gt;
&lt;li&gt;The colons are separators. After the first colon, the &lt;code&gt;asm!&lt;&#x2F;code&gt; macro expects output operands. We‚Äôre specifying our &lt;code&gt;stack_frame&lt;&#x2F;code&gt; variable as a single output operand here. The &lt;code&gt;=r&lt;&#x2F;code&gt; tells the compiler that it should use any register for the first placeholder &lt;code&gt;$0&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;After the second colon, we can specify input operands. We don‚Äôt need any, therefore we leave it empty.&lt;&#x2F;li&gt;
&lt;li&gt;After the third colon, the macro expects so called &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;book&#x2F;inline-assembly.html#clobbers&quot;&gt;clobbers&lt;&#x2F;a&gt;. We don‚Äôt change any register values, so we leave it empty too.&lt;&#x2F;li&gt;
&lt;li&gt;The last block (after the 4th colon) specifies options. The &lt;code&gt;intel&lt;&#x2F;code&gt; option tells the compiler that our code is in Intel assembly syntax (instead of the default AT&amp;amp;T syntax).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So the inline assembly loads the stack pointer value to &lt;code&gt;stack_frame&lt;&#x2F;code&gt; at the very beginning of our function. Thus we have a pointer to the exception stack frame and are able to pretty-print its &lt;code&gt;Debug&lt;&#x2F;code&gt; formatting through the &lt;code&gt;{:#?}&lt;&#x2F;code&gt; argument.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs try it by executing &lt;code&gt;make run&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;qemu-print-stack-frame-try.png&quot; alt=&quot;qemu printing an ExceptionStackFrame with strange values&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Those &lt;code&gt;ExceptionStackFrame&lt;&#x2F;code&gt; values look very wrong. The instruction pointer definitely shouldn‚Äôt be 1 and the code segment should be &lt;code&gt;0x8&lt;&#x2F;code&gt; instead of some big number. So what‚Äôs going on here?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;üîó&lt;&#x2F;a&gt;Debugging&lt;&#x2F;h3&gt;
&lt;p&gt;It seems like we somehow got the pointer wrong. The &lt;code&gt;ExceptionStackFrame&lt;&#x2F;code&gt; type and our inline assembly seem correct, so something must be modifying &lt;code&gt;rsp&lt;&#x2F;code&gt; before we load it into &lt;code&gt;stack_frame&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs see what‚Äôs happening by looking at the disassembly of our function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin | grep -A20 &amp;quot;divide_by_zero_handler&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt; [...]
&lt;&#x2F;span&gt;&lt;span&gt;000000000010ced0 &amp;lt;_ZN7blog_os10interrupts22divide_by_zero_handler17h62189e8E&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt; 10ced0:	55                   	push   %rbp
&lt;&#x2F;span&gt;&lt;span&gt; 10ced1:	48 89 e5             	mov    %rsp,%rbp
&lt;&#x2F;span&gt;&lt;span&gt; 10ced4:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
&lt;&#x2F;span&gt;&lt;span&gt; 10cedb:	48 8d 45 98          	lea    -0x68(%rbp),%rax
&lt;&#x2F;span&gt;&lt;span&gt; 10cedf:	48 b9 1d 1d 1d 1d 1d 	movabs $0x1d1d1d1d1d1d1d1d,%rcx
&lt;&#x2F;span&gt;&lt;span&gt; 10cee6:	1d 1d 1d
&lt;&#x2F;span&gt;&lt;span&gt; 10cee9:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
&lt;&#x2F;span&gt;&lt;span&gt; 10ceed:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
&lt;&#x2F;span&gt;&lt;span&gt; 10cef1:	48 89 e1             	mov    %rsp,%rcx
&lt;&#x2F;span&gt;&lt;span&gt; 10cef4:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
&lt;&#x2F;span&gt;&lt;span&gt; 10cef8:  ...
&lt;&#x2F;span&gt;&lt;span&gt;[...]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; starts at address &lt;code&gt;0x10ced0&lt;&#x2F;code&gt;. Let‚Äôs look at the instruction at address &lt;code&gt;0x10cef1&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;mov %rsp,%rcx
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is our inline assembly instruction, which loads the stack pointer into the &lt;code&gt;stack_frame&lt;&#x2F;code&gt; variable. It just looks a bit different, since it‚Äôs in AT&amp;amp;T syntax and contains &lt;code&gt;rcx&lt;&#x2F;code&gt; instead of our &lt;code&gt;$0&lt;&#x2F;code&gt; placeholder. It moves &lt;code&gt;rsp&lt;&#x2F;code&gt; to &lt;code&gt;rcx&lt;&#x2F;code&gt;, and then the next instruction (&lt;code&gt;mov %rcx,-0x8(%rbp)&lt;&#x2F;code&gt;) moves &lt;code&gt;rcx&lt;&#x2F;code&gt; to the variable on the stack.&lt;&#x2F;p&gt;
&lt;p&gt;We can clearly see the problem here: The compiler inserted various other instructions before our inline assembly. These instructions modify the stack pointer so that we don‚Äôt read the original &lt;code&gt;rsp&lt;&#x2F;code&gt; value and get a wrong pointer. But why is the compiler doing this?&lt;&#x2F;p&gt;
&lt;p&gt;The reason is that we need some place on the stack to store things like variables. Therefore the compiler inserts a so-called &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Function_prologue&quot;&gt;function prologue&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;, which prepares the stack and reserves space for all variables. In our case, the compiler subtracts from the stack pointer to make room for i.a. our &lt;code&gt;stack_frame&lt;&#x2F;code&gt; variable. This prologue is the first thing in every function and comes before every other code.&lt;&#x2F;p&gt;
&lt;p&gt;So in order to correctly load the exception frame pointer, we need some way to circumvent the automatic prologue generation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;naked-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#naked-functions&quot; aria-label=&quot;Anchor link for: naked-functions&quot;&gt;üîó&lt;&#x2F;a&gt;Naked Functions&lt;&#x2F;h3&gt;
&lt;p&gt;Fortunately there is a way to disable the prologue: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2F;a&gt;. A naked function has no prologue and immediately starts with the first instruction of its body. However, most Rust code requires the prologue. Therefore naked functions should only contain inline assembly.&lt;&#x2F;p&gt;
&lt;p&gt;A naked function looks like this (note the &lt;code&gt;#[naked]&lt;&#x2F;code&gt; attribute):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;naked_function_example() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rax, 0x42&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rax&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Naked functions are highly unstable, so we need to add &lt;code&gt;#![feature(naked_functions)]&lt;&#x2F;code&gt; to our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If you want to try it, insert it in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt; and call it from &lt;code&gt;rust_main&lt;&#x2F;code&gt;. When we inspect the disassembly, we see that the function prologue is missing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin | grep -A5 &amp;quot;naked_function_example&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;[...]
&lt;&#x2F;span&gt;&lt;span&gt;000000000010df90 &amp;lt;_ZN7blog_os22naked_function_example17ha9f733dfe42b595dE&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  10df90:	48 c7 c0 2a 00 00 00 	mov    $0x42,%rax
&lt;&#x2F;span&gt;&lt;span&gt;  10df97:	c3                   	retq
&lt;&#x2F;span&gt;&lt;span&gt;  10df98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
&lt;&#x2F;span&gt;&lt;span&gt;  10df9f:	00
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It contains just the specified inline assembly and a return instruction (you can ignore the junk values after the return statement). So let‚Äôs try to use a naked function to retrieve the exception frame pointer.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-naked-exception-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-naked-exception-handler&quot; aria-label=&quot;Anchor link for: a-naked-exception-handler&quot;&gt;üîó&lt;&#x2F;a&gt;A Naked Exception Handler&lt;&#x2F;h3&gt;
&lt;p&gt;We can‚Äôt use Rust code in naked functions, but we still want to use Rust in our exception handler. Therefore we split our handler function in two parts. A main exception handler in Rust and a small naked wrapper function, which just loads the exception frame pointer and then calls the main handler.&lt;&#x2F;p&gt;
&lt;p&gt;Our new two-stage exception handler looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* load exception frame pointer and call main handler *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_handler(stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*stack_frame });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The naked wrapper function retrieves the exception stack frame pointer and then calls the &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; with the pointer as argument. We can‚Äôt use Rust code in naked functions, so we need to do both things in inline assembly.&lt;&#x2F;p&gt;
&lt;p&gt;Retrieving the pointer to the exception stack frame is easy: We just need to load it from the &lt;code&gt;rsp&lt;&#x2F;code&gt; register. Our wrapper function has no prologue (it‚Äôs naked), so we can be sure that nothing modifies the register before.&lt;&#x2F;p&gt;
&lt;p&gt;Calling the main handler is a bit more complicated, since we need to pass the argument correctly. Our main handler uses the C calling convention, which specifies that the the first argument is passed in the &lt;code&gt;rdi&lt;&#x2F;code&gt; register. So we need to load the pointer value into &lt;code&gt;rdi&lt;&#x2F;code&gt; and then use the &lt;code&gt;call&lt;&#x2F;code&gt; instruction to call &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Translated to assembly, it looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_handler
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It moves the exception stack frame pointer from &lt;code&gt;rsp&lt;&#x2F;code&gt; to &lt;code&gt;rdi&lt;&#x2F;code&gt;, where the first argument is expected, and then calls the main handler. Let‚Äôs create the corresponding inline assembly to complete our wrapper function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp; call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;             :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;(divide_by_zero_handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;             : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of &lt;code&gt;call divide_by_zero_handler&lt;&#x2F;code&gt;, we use a placeholder again. The reason is Rust‚Äôs name mangling, which changes the name of the &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; function. To circumvent this, we pass a function pointer as input parameter (after the second colon). The &lt;code&gt;&amp;quot;i&amp;quot;&lt;&#x2F;code&gt; tells the compiler that it is an immediate value, which can be directly inserted for the placeholder. We also specify a clobber after the third colon, which tells the compiler that we change the value of the &lt;code&gt;rdi&lt;&#x2F;code&gt; register.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;intrinsics-unreachable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#intrinsics-unreachable&quot; aria-label=&quot;Anchor link for: intrinsics-unreachable&quot;&gt;üîó&lt;&#x2F;a&gt;Intrinsics::Unreachable&lt;&#x2F;h3&gt;
&lt;p&gt;When we try to compile it, we get the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: computation may converge in a function marked as diverging
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:23:1
&lt;&#x2F;span&gt;&lt;span&gt;   |&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;23 |&amp;gt; extern &amp;quot;C&amp;quot; fn divide_by_zero_wrapper() -&amp;gt; ! {
&lt;&#x2F;span&gt;&lt;span&gt;   |&amp;gt; ^
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason is that we marked our &lt;code&gt;divide_by_zero_wrapper&lt;&#x2F;code&gt; function as diverging (the &lt;code&gt;!&lt;&#x2F;code&gt;). We call another diverging function in inline assembly, so it is clear that the function diverges. However, the Rust compiler doesn‚Äôt understand inline assembly, so it doesn‚Äôt know that. To fix this, we tell the compiler that all code after the &lt;code&gt;asm!&lt;&#x2F;code&gt; macro is unreachable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp; call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;             :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;(divide_by_zero_handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;             : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;intrinsics&#x2F;fn.unreachable.html&quot;&gt;intrinsics::unreachable&lt;&#x2F;a&gt; function is unstable, so we need to add &lt;code&gt;#![feature(core_intrinsics)]&lt;&#x2F;code&gt; to our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;. It is just an annotation for the compiler and produces no real code. (Not to be confused with the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;macro.unreachable!.html&quot;&gt;unreachable!&lt;&#x2F;a&gt; macro, which is completely different!)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;it-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#it-works&quot; aria-label=&quot;Anchor link for: it-works&quot;&gt;üîó&lt;&#x2F;a&gt;It works!&lt;&#x2F;h3&gt;
&lt;p&gt;The last step is to update the interrupt descriptor table (IDT) to use our new wrapper function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, divide_by_zero_wrapper); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; changed
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we see a correct exception stack frame when we execute &lt;code&gt;make run&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;qemu-divide-by-zero-stack-frame.png&quot; alt=&quot;QEMU showing correct divide by zero stack frame&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-on-real-hardware&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-on-real-hardware&quot; aria-label=&quot;Anchor link for: testing-on-real-hardware&quot;&gt;üîó&lt;&#x2F;a&gt;Testing on real Hardware&lt;&#x2F;h2&gt;
&lt;p&gt;Virtual machines such as QEMU are very convenient to quickly test our kernel. However, they might behave a bit different than real hardware in some situations. So we should test our kernel on real hardware, too.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs do it by burning it to an USB stick:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; sudo dd if=build&#x2F;os-x86_64.iso of=&#x2F;dev&#x2F;sdX; and sync
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Replace &lt;code&gt;sdX&lt;&#x2F;code&gt; by the device name of your USB stick. But &lt;strong&gt;be careful&lt;&#x2F;strong&gt;! The command will erase everything on that device.&lt;&#x2F;p&gt;
&lt;p&gt;Now we should be able to boot from this USB stick. When we do it, we see that it works fine on real hardware, too. Great!&lt;&#x2F;p&gt;
&lt;p&gt;However, this section wouldn‚Äôt exist if there weren‚Äôt a problem. To trigger this problem, we add some example code to the start of our &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_handler(...) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y = Some(x);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;).map(|z| (z, z - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is just some garbage code that doesn‚Äôt do anything useful. When we try it in QEMU using &lt;code&gt;make run&lt;&#x2F;code&gt;, it still works fine. However, when we burn it to an USB stick again and boot from it on real hardware, we see that our computer reboots just before printing the exception message.&lt;&#x2F;p&gt;
&lt;p&gt;So our code, which worked well in QEMU, &lt;em&gt;causes a triple fault&lt;&#x2F;em&gt; on real hardware. What‚Äôs happening?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;reproducing-the-bug-in-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reproducing-the-bug-in-qemu&quot; aria-label=&quot;Anchor link for: reproducing-the-bug-in-qemu&quot;&gt;üîó&lt;&#x2F;a&gt;Reproducing the Bug in QEMU&lt;&#x2F;h3&gt;
&lt;p&gt;Debugging on a real machine is difficult. Fortunately there is a way to reproduce this bug in QEMU: We use Linux‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Kernel-based_Virtual_Machine&quot;&gt;Kernel-based Virtual Machine&lt;&#x2F;a&gt; (KVM) by passing the &lt;code&gt;‚Äëenable-kvm&lt;&#x2F;code&gt; flag:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 -cdrom build&#x2F;os-x86_64.iso -enable-kvm
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now QEMU triple faults as well. This should make debugging much easier.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;debugging-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging-1&quot; aria-label=&quot;Anchor link for: debugging-1&quot;&gt;üîó&lt;&#x2F;a&gt;Debugging&lt;&#x2F;h3&gt;
&lt;p&gt;QEMU‚Äôs &lt;code&gt;-d int&lt;&#x2F;code&gt;, which prints every exception, doesn‚Äôt seem to work in KVM mode. However &lt;code&gt;-d cpu_reset&lt;&#x2F;code&gt; still works. It prints the complete CPU state whenever the CPU resets. Let‚Äôs try it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 -cdrom build&#x2F;os-x86_64.iso -enable-kvm -d cpu_reset
&lt;&#x2F;span&gt;&lt;span&gt;CPU Reset (CPU 0)
&lt;&#x2F;span&gt;&lt;span&gt;EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
&lt;&#x2F;span&gt;&lt;span&gt;ESI=00000000 EDI=00000000 EBP=00000000 ESP=00000000
&lt;&#x2F;span&gt;&lt;span&gt;EIP=00000000 EFL=00000000 [-------] CPL=0 II=0 A20=0 SMM=0 HLT=0
&lt;&#x2F;span&gt;&lt;span&gt;[...]
&lt;&#x2F;span&gt;&lt;span&gt;CPU Reset (CPU 0)
&lt;&#x2F;span&gt;&lt;span&gt;EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000663
&lt;&#x2F;span&gt;&lt;span&gt;ESI=00000000 EDI=00000000 EBP=00000000 ESP=00000000
&lt;&#x2F;span&gt;&lt;span&gt;EIP=0000fff0 EFL=00000002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
&lt;&#x2F;span&gt;&lt;span&gt;[...]
&lt;&#x2F;span&gt;&lt;span&gt;CPU Reset (CPU 0)
&lt;&#x2F;span&gt;&lt;span&gt;RAX=0000000000118cb8 RBX=0000000000000800 RCX=1d1d1d1d1d1d1d1d RDX=0..0000000
&lt;&#x2F;span&gt;&lt;span&gt;RSI=0000000000112cd0 RDI=0000000000118d38 RBP=0000000000118d28 RSP=0..0118c68
&lt;&#x2F;span&gt;&lt;span&gt;R8 =0000000000000000 R9 =0000000000000100 R10=0000000000118700 R11=0..0118a00
&lt;&#x2F;span&gt;&lt;span&gt;R12=0000000000000000 R13=0000000000000000 R14=0000000000000000 R15=0..0000000
&lt;&#x2F;span&gt;&lt;span&gt;RIP=000000000010cf08 RFL=00210002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
&lt;&#x2F;span&gt;&lt;span&gt;[...]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first two resets occur while the CPU is still in 32-bit mode (&lt;code&gt;EAX&lt;&#x2F;code&gt; instead of &lt;code&gt;RAX&lt;&#x2F;code&gt;), so we ignore them. The third reset is the interesting one, because it occurs in 64-bit mode. The register dump tells us that the instruction pointer (&lt;code&gt;rip&lt;&#x2F;code&gt;) was &lt;code&gt;0x10cf08&lt;&#x2F;code&gt; just before the reset. This might be the address of the instruction that caused the triple fault.&lt;&#x2F;p&gt;
&lt;p&gt;We can find the corresponding instruction by disassembling our kernel:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;objdump -d build&#x2F;kernel-x86_64.bin | grep &amp;quot;10cf08:&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  10cf08:	0f 29 45 b0          	movaps %xmm0,-0x50(%rbp)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;movaps&quot;&gt;movaps&lt;&#x2F;a&gt; instruction is an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2F;a&gt; instruction that moves aligned 128bit values. It can fail for a number of reasons:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.&lt;&#x2F;li&gt;
&lt;li&gt;For an illegal address in the SS segment.&lt;&#x2F;li&gt;
&lt;li&gt;If a memory operand is not aligned on a 16-byte boundary.&lt;&#x2F;li&gt;
&lt;li&gt;For a page fault.&lt;&#x2F;li&gt;
&lt;li&gt;If TS in CR0 is set.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The segment registers contain no meaningful values in long mode, so they can‚Äôt contain illegal addresses. We did not change the TS bit in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control_register#CR0&quot;&gt;CR0&lt;&#x2F;a&gt; and there is no reason for a page fault either. So it has to be option 3.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;16-byte-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#16-byte-alignment&quot; aria-label=&quot;Anchor link for: 16-byte-alignment&quot;&gt;üîó&lt;&#x2F;a&gt;16-byte Alignment&lt;&#x2F;h3&gt;
&lt;p&gt;Some SSE instructions such as &lt;code&gt;movaps&lt;&#x2F;code&gt; require that memory operands are 16-byte aligned. In our case, the instruction is &lt;code&gt;movaps %xmm0,-0x50(%rbp)&lt;&#x2F;code&gt;, which writes to address &lt;code&gt;rbp - 0x50&lt;&#x2F;code&gt;. Therefore &lt;code&gt;rbp&lt;&#x2F;code&gt; needs to be 16-byte aligned.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs look at the above &lt;code&gt;-d cpu_reset&lt;&#x2F;code&gt; dump again and check the value of &lt;code&gt;rbp&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;CPU Reset (CPU 0)
&lt;&#x2F;span&gt;&lt;span&gt;RAX=[...] RBX=[...] RCX=[...] RDX=[...]
&lt;&#x2F;span&gt;&lt;span&gt;RSI=[...] RDI=[...] RBP=0000000000118d28 RSP=[...]
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;RBP&lt;&#x2F;code&gt; is &lt;code&gt;0x118d28&lt;&#x2F;code&gt;, which is &lt;em&gt;not&lt;&#x2F;em&gt; 16-byte aligned. So this is the reason for the triple fault. (It seems like QEMU doesn‚Äôt check the alignment for &lt;code&gt;movaps&lt;&#x2F;code&gt;, but real hardware of course does.)&lt;&#x2F;p&gt;
&lt;p&gt;But how did we end up with a misaligned &lt;code&gt;rbp&lt;&#x2F;code&gt; register?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-base-pointer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-base-pointer&quot; aria-label=&quot;Anchor link for: the-base-pointer&quot;&gt;üîó&lt;&#x2F;a&gt;The Base Pointer&lt;&#x2F;h3&gt;
&lt;p&gt;In order to solve this mystery, we need to look at the disassembly of the preceding code:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -d build&#x2F;kernel-x86_64.bin | grep -B10 &amp;quot;10cf08:&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;000000000010cee0 &amp;lt;_ZN7blog_os10interrupts22divide_by_zero_handler17hE&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  10cee0:	55                   	push   %rbp
&lt;&#x2F;span&gt;&lt;span&gt;  10cee1:	48 89 e5             	mov    %rsp,%rbp
&lt;&#x2F;span&gt;&lt;span&gt;  10cee4:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
&lt;&#x2F;span&gt;&lt;span&gt;  10ceeb:	48 8d 45 90          	lea    -0x70(%rbp),%rax
&lt;&#x2F;span&gt;&lt;span&gt;  10ceef:	48 b9 1d 1d 1d 1d 1d 	movabs $0x1d1d1d1d1d1d1d1d,%rcx
&lt;&#x2F;span&gt;&lt;span&gt;  10cef6:	1d 1d 1d
&lt;&#x2F;span&gt;&lt;span&gt;  10cef9:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
&lt;&#x2F;span&gt;&lt;span&gt;  10cefd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
&lt;&#x2F;span&gt;&lt;span&gt;  10cf01:	0f 10 05 a8 51 00 00 	movups 0x51a8(%rip),%xmm0
&lt;&#x2F;span&gt;&lt;span&gt;  10cf08:	0f 29 45 b0          	movaps %xmm0,-0x50(%rbp)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At the last line we have the &lt;code&gt;movaps&lt;&#x2F;code&gt; instruction, which caused the triple fault. The exception occurs inside our &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; function. We see that &lt;code&gt;rbp&lt;&#x2F;code&gt; is loaded with the value of &lt;code&gt;rsp&lt;&#x2F;code&gt; at the beginning (at &lt;code&gt;0x10cee1&lt;&#x2F;code&gt;). The &lt;code&gt;rbp&lt;&#x2F;code&gt; register holds the so-called &lt;em&gt;base pointer&lt;&#x2F;em&gt;, which points to the beginning of the stack frame. It is used in the rest of the function to address variables and other values on the stack.&lt;&#x2F;p&gt;
&lt;p&gt;The base pointer is initialized directly from the stack pointer (&lt;code&gt;rsp&lt;&#x2F;code&gt;) after pushing the old base pointer. There is no special alignment code, so the compiler blindly assumes that &lt;code&gt;(rsp - 8)&lt;&#x2F;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-rsp-8&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; is always 16-byte aligned. This seems to be wrong in our case. But why does the compiler assume this?&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-rsp-8&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;By pushing the old base pointer, &lt;code&gt;rsp&lt;&#x2F;code&gt; is updated to &lt;code&gt;rsp-8&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h3 id=&quot;calling-conventions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-conventions&quot; aria-label=&quot;Anchor link for: calling-conventions&quot;&gt;üîó&lt;&#x2F;a&gt;Calling Conventions&lt;&#x2F;h3&gt;
&lt;p&gt;The reason is that our exception handler is defined as &lt;code&gt;extern &amp;quot;C&amp;quot; function&lt;&#x2F;code&gt;, which specifies that it‚Äôs using the C &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_calling_conventions&quot;&gt;calling convention&lt;&#x2F;a&gt;. On x86_64 Linux, the C calling convention is specified by the System V AMD64 ABI (&lt;a href=&quot;https:&#x2F;&#x2F;web.archive.org&#x2F;web&#x2F;20160801075139&#x2F;https:&#x2F;&#x2F;www.x86-64.org&#x2F;documentation&#x2F;abi.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;). Section 3.2.2 defines the following:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The end of the input argument area shall be aligned on a 16 byte boundary. In other words, the value (%rsp + 8) is always a multiple of 16 when control is transferred to the function entry point.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The ‚Äúend of the input argument area‚Äù refers to the last stack-passed argument (in our case there aren‚Äôt any). So the stack pointer must be 16 byte aligned whenever we &lt;code&gt;call&lt;&#x2F;code&gt; a C-compatible function. The &lt;code&gt;call&lt;&#x2F;code&gt; instruction then pushes the return value on the stack so that ‚Äúthe value (%rsp + 8) is a multiple of 16 when control is transferred to the function entry point‚Äù.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Summary&lt;&#x2F;em&gt;: The calling convention requires a 16 byte aligned stack pointer before &lt;code&gt;call&lt;&#x2F;code&gt; instructions. The compiler relies on this requirement, but we broke it somehow. Thus the generated code triple faults due to a misaligned memory address in the &lt;code&gt;movaps&lt;&#x2F;code&gt; instruction.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-the-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-alignment&quot; aria-label=&quot;Anchor link for: fixing-the-alignment&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the Alignment&lt;&#x2F;h3&gt;
&lt;p&gt;In order to fix this bug, we need to make sure that the stack pointer is correctly aligned before calling &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2F;code&gt; functions. Let‚Äôs summarize the stack pointer modifications that occur before the exception handler is called:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU aligns the stack pointer to a 16 byte boundary.&lt;&#x2F;li&gt;
&lt;li&gt;The CPU pushes &lt;code&gt;ss&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;rflags&lt;&#x2F;code&gt;, &lt;code&gt;cs&lt;&#x2F;code&gt;, and &lt;code&gt;rip&lt;&#x2F;code&gt;. So it pushes five 8 byte registers, which makes &lt;code&gt;rsp&lt;&#x2F;code&gt; misaligned.&lt;&#x2F;li&gt;
&lt;li&gt;The wrapper function calls &lt;code&gt;divide_by_zero_handler&lt;&#x2F;code&gt; with a misaligned stack pointer.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The problem is that we‚Äôre pushing an uneven number of 8 byte registers. Thus we need to align the stack pointer again before the &lt;code&gt;call&lt;&#x2F;code&gt; instruction:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[naked]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;              call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;              :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;(divide_by_zero_handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;              : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The additional &lt;code&gt;sub rsp, 8&lt;&#x2F;code&gt; instruction aligns the stack pointer to a 16 byte boundary. Now it should work on real hardware (and in QEMU KVM mode) again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-handler-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-handler-macro&quot; aria-label=&quot;Anchor link for: a-handler-macro&quot;&gt;üîó&lt;&#x2F;a&gt;A Handler Macro&lt;&#x2F;h2&gt;
&lt;p&gt;The next step is to add handlers for other exceptions. However, we would need wrapper functions for them too. To avoid this code duplication, we create a &lt;code&gt;handler&lt;&#x2F;code&gt; macro that creates the wrapper functions for us:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro takes a single Rust identifier (&lt;code&gt;ident&lt;&#x2F;code&gt;) as argument and expands to a &lt;code&gt;{}&lt;&#x2F;code&gt; block (hence the double braces). The block defines a new wrapper function that calls the function &lt;code&gt;$name&lt;&#x2F;code&gt; and passes a pointer to the exception stack frame. Note that we‚Äôre fixing the argument type to &lt;code&gt;&amp;amp;ExceptionStackFrame&lt;&#x2F;code&gt;. If we used a &lt;code&gt;_&lt;&#x2F;code&gt; like before, the passed function could accept an arbitrary argument, which would lead to ugly bugs at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can remove the &lt;code&gt;divide_by_zero_wrapper&lt;&#x2F;code&gt; and use our new &lt;code&gt;handler!&lt;&#x2F;code&gt; macro instead:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, handler!(divide_by_zero_handler)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;handler!&lt;&#x2F;code&gt; macro needs to be defined above the static &lt;code&gt;IDT&lt;&#x2F;code&gt;, because macros are only available after their definition.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;invalid-opcode-exception&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#invalid-opcode-exception&quot; aria-label=&quot;Anchor link for: invalid-opcode-exception&quot;&gt;üîó&lt;&#x2F;a&gt;Invalid Opcode Exception&lt;&#x2F;h3&gt;
&lt;p&gt;With the &lt;code&gt;handler!&lt;&#x2F;code&gt; macro we can create new handler functions easily. For example, we can add a handler for the invalid opcode exception as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, handler!(divide_by_zero_handler));
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, handler!(invalid_opcode_handler)); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;invalid_opcode_handler(stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stack_frame = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*stack_frame };
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: INVALID OPCODE at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        stack_frame.instruction_pointer, stack_frame);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Invalid opcode faults have the vector number 6, so we set the 6th IDT entry. This time we additionally print the address of the invalid instruction.&lt;&#x2F;p&gt;
&lt;p&gt;We can test our new handler with the special &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;ud&quot;&gt;ud2&lt;&#x2F;a&gt; instruction, which generates a invalid opcode:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provoke a invalid opcode exception
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ud2&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;exceptions-with-error-codes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-with-error-codes&quot; aria-label=&quot;Anchor link for: exceptions-with-error-codes&quot;&gt;üîó&lt;&#x2F;a&gt;Exceptions with Error Codes&lt;&#x2F;h2&gt;
&lt;p&gt;When a divide-by-zero exception occurs, we immediately know the reason: Someone tried to divide by zero. In contrast, there are faults with many possible causes. For example, a page fault occurs in many occasions: When accessing a non-present page, when writing to a read-only page, when the page table is malformed, etc. In order to differentiate these causes, the CPU pushes an additional error code onto the stack for such exceptions, which gives additional information.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-new-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-new-macro&quot; aria-label=&quot;Anchor link for: a-new-macro&quot;&gt;üîó&lt;&#x2F;a&gt;A new Macro&lt;&#x2F;h3&gt;
&lt;p&gt;Since the CPU pushes an additional error code, the stack frame is different and our &lt;code&gt;handler!&lt;&#x2F;code&gt; macro is not applicable. Therefore we create a new &lt;code&gt;handler_with_error_code!&lt;&#x2F;code&gt; macro for them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! handler_with_error_code {
&lt;&#x2F;span&gt;&lt;span&gt;    ($name: ident) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{{
&lt;&#x2F;span&gt;&lt;span&gt;        #[naked]
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;wrapper() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2F;&#x2F; pop error code into rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      mov rdi, rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      sub rsp, 8 &#x2F;&#x2F; align the stack pointer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;                      call $0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;                      :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;($name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;                      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                ::core::intrinsics::unreachable();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        wrapper
&lt;&#x2F;span&gt;&lt;span&gt;    }}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The difference to the &lt;code&gt;handler!&lt;&#x2F;code&gt; macro is the additional error code argument. The CPU pushes the error code last, so we pop it right at the beginning of the wrapper function. We pop it into &lt;code&gt;rsi&lt;&#x2F;code&gt; because the C calling convention expects the second argument in it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-page-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-page-fault-handler&quot; aria-label=&quot;Anchor link for: a-page-fault-handler&quot;&gt;üîó&lt;&#x2F;a&gt;A Page Fault Handler&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs write a page fault handler which analyzes and prints the error code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;page_fault_handler(stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame,
&lt;&#x2F;span&gt;&lt;span&gt;                                 error_code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: PAGE FAULT with error code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        error_code, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*stack_frame });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to register our new handler function in the static interrupt descriptor table (IDT):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, handler!(divide_by_zero_handler));
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;, handler!(invalid_opcode_handler));
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;, handler_with_error_code!(page_fault_handler));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Page faults have the vector number 14, so we set the 14th IDT entry.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;testing-it-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it-1&quot; aria-label=&quot;Anchor link for: testing-it-1&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h4&gt;
&lt;p&gt;Let‚Äôs test our new page fault handler by provoking a page fault in our main function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provoke a page fault
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We get the following output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;qemu-page-fault-handler.png&quot; alt=&quot;QEMU: page fault with error code 2 and stack frame dump&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-page-fault-error-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-page-fault-error-code&quot; aria-label=&quot;Anchor link for: the-page-fault-error-code&quot;&gt;üîó&lt;&#x2F;a&gt;The Page Fault Error Code&lt;&#x2F;h3&gt;
&lt;p&gt;‚ÄúError code 2‚Äù is not really an useful error message. Let‚Äôs improve this by creating a &lt;code&gt;PageFaultErrorCode&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;bitflags! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;PageFaultErrorCode: u64 {
&lt;&#x2F;span&gt;&lt;span&gt;        const PROTECTION_VIOLATION = 1 &amp;lt;&amp;lt; 0;
&lt;&#x2F;span&gt;&lt;span&gt;        const CAUSED_BY_WRITE = 1 &amp;lt;&amp;lt; 1;
&lt;&#x2F;span&gt;&lt;span&gt;        const USER_MODE = 1 &amp;lt;&amp;lt; 2;
&lt;&#x2F;span&gt;&lt;span&gt;        const MALFORMED_TABLE = 1 &amp;lt;&amp;lt; 3;
&lt;&#x2F;span&gt;&lt;span&gt;        const INSTRUCTION_FETCH = 1 &amp;lt;&amp;lt; 4;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;When the &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2F;code&gt; flag is set, the page fault was caused e.g. by a write to a read-only page. If it‚Äôs not set, it was caused by accessing a non-present page.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;CAUSED_BY_WRITE&lt;&#x2F;code&gt; flag specifies if the fault was caused by a write (if set) or a read (if not set).&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;USER_MODE&lt;&#x2F;code&gt; flag is set when the fault occurred in non-privileged mode.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;MALFORMED_TABLE&lt;&#x2F;code&gt; flag is set when the page table entry has a 1 in a reserved field.&lt;&#x2F;li&gt;
&lt;li&gt;When the &lt;code&gt;INSTRUCTION_FETCH&lt;&#x2F;code&gt; flag is set, the page fault occurred while fetching the next instruction.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now we can improve our page fault error message by using the new &lt;code&gt;PageFaultErrorCode&lt;&#x2F;code&gt;. We also print the accessed memory address:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;page_fault_handler(stack_frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExceptionStackFrame,
&lt;&#x2F;span&gt;&lt;span&gt;                                 error_code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control_regs;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: PAGE FAULT while accessing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;error code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ control_regs::cr2() },
&lt;&#x2F;span&gt;&lt;span&gt;        PageFaultErrorCode::from_bits(error_code).unwrap(),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*stack_frame });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;from_bits&lt;&#x2F;code&gt; function tries to convert the &lt;code&gt;u64&lt;&#x2F;code&gt; into a &lt;code&gt;PageFaultErrorCode&lt;&#x2F;code&gt;. We use &lt;code&gt;unwrap&lt;&#x2F;code&gt; to panic if the error code has invalid bits set, since this indicates an error in our &lt;code&gt;PageFaultErrorCode&lt;&#x2F;code&gt; definition or a stack corruption. We also print the contents of the &lt;code&gt;cr2&lt;&#x2F;code&gt; register. It contains the accessed memory address, which was the cause of the page fault.&lt;&#x2F;p&gt;
&lt;p&gt;Now we get a useful error message when a page fault occurs, which allows us to debug it more easily:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;better-exception-messages&#x2F;qemu-page-fault-error-code.png&quot; alt=&quot;QEMU: output is now PAGE FAULT with error code CAUSED_BY_WRITE&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As expected, the page fault was caused by write to &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt;. The &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2F;code&gt; flag is not set, so the accessed page was not present.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;Now we‚Äôre able to catch and analyze various exceptions. The next step is to &lt;em&gt;resolve&lt;&#x2F;em&gt; exceptions, if possible. An example is &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Demand_paging&quot;&gt;demand paging&lt;&#x2F;a&gt;: The OS swaps out memory pages to disk so that a page fault occurs when the page is accessed the next time. In that case, the OS can resolve the exception by bringing the page back into memory. Afterwards, the OS resumes the interrupted program as if nothing had happened.&lt;&#x2F;p&gt;
&lt;p&gt;The next post will implement the first portion of demand paging: saving and restoring the complete state of an program. This will allow us to transparently interrupt and resume programs in the future.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Catching Exceptions</title>
                <pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/catching-exceptions/</link>
                <guid>https://os.phil-opp.com/catching-exceptions/</guid>
                <description>&lt;p&gt;In this post, we start exploring exceptions. We set up an interrupt descriptor table and add handler functions. At the end of this post, our kernel will be able to catch divide-by-zero faults.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;catching_exceptions&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2F;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;edition-1&#x2F;extra&#x2F;naked-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions with Naked Functions‚Äù&lt;&#x2F;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions‚Äù&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions&quot; aria-label=&quot;Anchor link for: exceptions&quot;&gt;üîó&lt;&#x2F;a&gt;Exceptions&lt;&#x2F;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2F;p&gt;
&lt;p&gt;We‚Äôve already seen several types of exceptions in our kernel:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2F;strong&gt;: This exception occurs when the current instruction is invalid. For example, this exception occurred when we tried to use SSE instructions before enabling SSE. Without SSE, the CPU didn‚Äôt know the &lt;code&gt;movups&lt;&#x2F;code&gt; and &lt;code&gt;movaps&lt;&#x2F;code&gt; instructions, so it throws an exception when it stumbles over them.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2F;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2F;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2F;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2F;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2F;em&gt;. We can‚Äôt catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system. This causes the bootloops we experienced in the previous posts.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For the full list of exceptions check out the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;OSDev wiki&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;üîó&lt;&#x2F;a&gt;The Interrupt Descriptor Table&lt;&#x2F;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2F;em&gt; (IDT). In this table we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [0:15]&lt;&#x2F;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;GDT selector&lt;&#x2F;td&gt;&lt;td&gt;Selector of a code segment in the GDT.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Options&lt;&#x2F;td&gt;&lt;td&gt;(see below)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [16:31]&lt;&#x2F;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Function Pointer [32:63]&lt;&#x2F;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2&lt;&#x2F;td&gt;&lt;td&gt;Interrupt Stack Table Index&lt;&#x2F;td&gt;&lt;td&gt;0: Don‚Äôt switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7&lt;&#x2F;td&gt;&lt;td&gt;Reserved&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate&lt;&#x2F;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;must be one&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;td&gt;must be zero&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;13‚Äë14&lt;&#x2F;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)&lt;&#x2F;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;Present&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;Exception Table&lt;&#x2F;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the ‚ÄúVector nr.‚Äù column.&lt;&#x2F;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14-th entry when a page fault occurs.&lt;&#x2F;li&gt;
&lt;li&gt;Check if the entry is present. Raise a double fault if not.&lt;&#x2F;li&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;EFLAGS&lt;&#x2F;a&gt; register. (We will use these values in a future post.)&lt;&#x2F;li&gt;
&lt;li&gt;Disable interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2F;li&gt;
&lt;li&gt;Load the specified GDT selector into the CS segment.&lt;&#x2F;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;handling-exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-exceptions&quot; aria-label=&quot;Anchor link for: handling-exceptions&quot;&gt;üîó&lt;&#x2F;a&gt;Handling Exceptions&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs try to catch and handle CPU exceptions. We start by creating a new &lt;code&gt;interrupts&lt;&#x2F;code&gt; module with an &lt;code&gt;idt&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;interrupts;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;idt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we create types for the IDT and its entries:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;interrupts&#x2F;idt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::segmentation;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::PrivilegeLevel;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Idt([Entry; 16]);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(C, packed)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Entry {
&lt;&#x2F;span&gt;&lt;span&gt;    pointer_low: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    gdt_selector: SegmentSelector,
&lt;&#x2F;span&gt;&lt;span&gt;    options: EntryOptions,
&lt;&#x2F;span&gt;&lt;span&gt;    pointer_middle: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    pointer_high: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    reserved: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The IDT is variable sized and can have up to 256 entries. We only need the first 16 entries in this post, so we define the table as &lt;code&gt;[Entry; 16]&lt;&#x2F;code&gt;. The remaining 240 handlers are treated as non-present by the CPU.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Entry&lt;&#x2F;code&gt; type is the translation of the above table to Rust. The &lt;code&gt;repr(C, packed)&lt;&#x2F;code&gt; attribute ensures that the compiler keeps the field ordering and does not add any padding between them. Instead of describing the &lt;code&gt;gdt_selector&lt;&#x2F;code&gt; as a plain &lt;code&gt;u16&lt;&#x2F;code&gt;, we use the &lt;code&gt;SegmentSelector&lt;&#x2F;code&gt; type of the &lt;code&gt;x86&lt;&#x2F;code&gt; crate. We also merge bits 32 to 47 into an &lt;code&gt;option&lt;&#x2F;code&gt; field, because Rust has no &lt;code&gt;u3&lt;&#x2F;code&gt; or &lt;code&gt;u1&lt;&#x2F;code&gt; type. The &lt;code&gt;EntryOptions&lt;&#x2F;code&gt; type is described below:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;entry-options&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#entry-options&quot; aria-label=&quot;Anchor link for: entry-options&quot;&gt;üîó&lt;&#x2F;a&gt;Entry Options&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;EntryOptions&lt;&#x2F;code&gt; type has the following skeleton:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EntryOptions(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;EntryOptions {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_present(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, present: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;disable_interrupts(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, disable: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_privilege_level(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, dpl: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_stack_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The implementations of these methods need to modify the correct bits of the &lt;code&gt;u16&lt;&#x2F;code&gt; without touching the other bits. For example, we would need the following bit-fiddling to set the stack index:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= (self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xfff8&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; stack_index;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or alternatively:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= (self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b111&lt;&#x2F;span&gt;&lt;span&gt;)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; stack_index;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= ((self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; stack_index;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Well, none of these variants is really &lt;em&gt;readable&lt;&#x2F;em&gt; and it‚Äôs very easy to make mistakes somewhere. Therefore I created a &lt;code&gt;BitField&lt;&#x2F;code&gt; trait that provides the following &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ops&#x2F;struct.Range.html&quot;&gt;Range&lt;&#x2F;a&gt;-based API:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, stack_index);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I think it is much more readable, since we abstracted away all bit-masking details. The &lt;code&gt;BitField&lt;&#x2F;code&gt; trait is contained in the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;bit_field&quot;&gt;bit_field&lt;&#x2F;a&gt; crate. (It‚Äôs pretty new, so it might still contain bugs.) To add it as dependency, we run &lt;code&gt;cargo add bit_field&lt;&#x2F;code&gt; and add &lt;code&gt;extern crate bit_field;&lt;&#x2F;code&gt; to our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use the trait to implement the methods of &lt;code&gt;EntryOptions&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;idt.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;bit_field::BitField;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EntryOptions(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;EntryOptions {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;minimal() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; options = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        options.set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b111&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; &amp;#39;must-be-one&amp;#39; bits
&lt;&#x2F;span&gt;&lt;span&gt;        EntryOptions(options)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; options = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::minimal();
&lt;&#x2F;span&gt;&lt;span&gt;        options.set_present(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;).disable_interrupts(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        options
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_present(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, present: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;set_bit(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, present);
&lt;&#x2F;span&gt;&lt;span&gt;        self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;disable_interrupts(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, disable: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;set_bit(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;disable);
&lt;&#x2F;span&gt;&lt;span&gt;        self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_privilege_level(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, dpl: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;, dpl);
&lt;&#x2F;span&gt;&lt;span&gt;        self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_stack_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;set_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, index);
&lt;&#x2F;span&gt;&lt;span&gt;        self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the ranges are &lt;em&gt;exclusive&lt;&#x2F;em&gt; the upper bound. The &lt;code&gt;minimal&lt;&#x2F;code&gt; function creates an &lt;code&gt;EntryOptions&lt;&#x2F;code&gt; type with only the ‚Äúmust-be-one‚Äù bits set. The &lt;code&gt;new&lt;&#x2F;code&gt; function, on the other hand, chooses reasonable defaults: It sets the present bit (why would you want to create a non-present entry?) and disables interrupts (normally we don‚Äôt want that our exception handlers can be interrupted). By returning the self pointer from the &lt;code&gt;set_*&lt;&#x2F;code&gt; methods, we allow easy method chaining such as &lt;code&gt;options.set_present(true).disable_interrupts(true)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-idt-entries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-idt-entries&quot; aria-label=&quot;Anchor link for: creating-idt-entries&quot;&gt;üîó&lt;&#x2F;a&gt;Creating IDT Entries&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can add a function to create new IDT entries:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Entry {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new(gdt_selector: SegmentSelector, handler: HandlerFunc) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pointer = handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Entry {
&lt;&#x2F;span&gt;&lt;span&gt;            gdt_selector: gdt_selector,
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_low: pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_middle: (pointer &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_high: (pointer &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            options: EntryOptions::new(),
&lt;&#x2F;span&gt;&lt;span&gt;            reserved: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We take a GDT selector and a handler function as arguments and create a new IDT entry for it. The &lt;code&gt;HandlerFunc&lt;&#x2F;code&gt; type is described below. It is a function pointer that can be converted to an &lt;code&gt;u64&lt;&#x2F;code&gt;. We choose the lower 16 bits for &lt;code&gt;pointer_low&lt;&#x2F;code&gt;, the next 16 bits for &lt;code&gt;pointer_middle&lt;&#x2F;code&gt; and the remaining 32 bits for &lt;code&gt;pointer_high&lt;&#x2F;code&gt;. For the options field we choose our default options, i.e. present and disabled interrupts.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-handler-function-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-handler-function-type&quot; aria-label=&quot;Anchor link for: the-handler-function-type&quot;&gt;üîó&lt;&#x2F;a&gt;The Handler Function Type&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;HandlerFunc&lt;&#x2F;code&gt; type is a type alias for a function type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It needs to be a function with a defined &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;calling convention&lt;&#x2F;a&gt;, as it called directly by the hardware. The C calling convention is the de facto standard in OS development, so we‚Äôre using it, too. The function takes no arguments, since the hardware doesn‚Äôt supply any arguments when jumping to the handler function.&lt;&#x2F;p&gt;
&lt;p&gt;It is important that the function is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;fn&#x2F;diverging.html&quot;&gt;diverging&lt;&#x2F;a&gt;, i.e. it must never return. The reason is that the hardware doesn‚Äôt &lt;em&gt;call&lt;&#x2F;em&gt; the handler functions, it just &lt;em&gt;jumps&lt;&#x2F;em&gt; to them after pushing some values to the stack. So our stack might look different:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;catching-exceptions&#x2F;normal-vs-interrupt-function-return.svg&quot; alt=&quot;normal function return vs interrupt function return&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If our handler function returned normally, it would try to pop the return address from the stack. But it might get some completely different value then. For example, the CPU pushes an error code for some exceptions. Bad things would happen if we interpreted this error code as return address and jumped to it. Therefore interrupt handler functions must diverge&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-must-diverge&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-must-diverge&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Another reason is that we overwrite the current register values by executing the handler function. Thus, the interrupted function looses its state and can‚Äôt proceed anyway.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h3 id=&quot;idt-methods&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#idt-methods&quot; aria-label=&quot;Anchor link for: idt-methods&quot;&gt;üîó&lt;&#x2F;a&gt;IDT methods&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs add a function to create new interrupt descriptor tables:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Idt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; Idt {
&lt;&#x2F;span&gt;&lt;span&gt;        Idt([Entry::missing(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Entry {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;missing() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Entry {
&lt;&#x2F;span&gt;&lt;span&gt;            gdt_selector: SegmentSelector::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, PrivilegeLevel::Ring0),
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_low: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_middle: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            pointer_high: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            options: EntryOptions::minimal(),
&lt;&#x2F;span&gt;&lt;span&gt;            reserved: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;missing&lt;&#x2F;code&gt; function creates a non-present Entry. We could choose any values for the pointer and GDT selector fields as long as the present bit is not set.&lt;&#x2F;p&gt;
&lt;p&gt;However, a table with non-present entries is not very useful. So we create a &lt;code&gt;set_handler&lt;&#x2F;code&gt; method to add new handler functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Idt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, entry: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;, handler: HandlerFunc)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; EntryOptions
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;[entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;] = Entry::new(segmentation::cs(), handler);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;[entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;].options
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method overwrites the specified entry with the given handler function. We use the &lt;code&gt;segmentation::cs&lt;&#x2F;code&gt; function of the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&quot;&gt;x86_64 crate&lt;&#x2F;a&gt; to get the current code segment descriptor. There‚Äôs no need for different kernel code segments in long mode, so the current &lt;code&gt;cs&lt;&#x2F;code&gt; value should be always the right choice.&lt;&#x2F;p&gt;
&lt;p&gt;By returning a mutual reference to the entry‚Äôs options, we allow the caller to override the default settings. For example, the caller could add a non-present entry by executing: &lt;code&gt;idt.set_handler(11, handler_fn).set_present(false)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the IDT&lt;&#x2F;h3&gt;
&lt;p&gt;Now we‚Äôre able to create new interrupt descriptor tables with registered handler functions. We just need a way to load an IDT, so that the CPU uses it. The x86 architecture uses a special register to store the active IDT and its length. In order to load a new IDT we need to update this register through the &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;lgdt:lidt&quot;&gt;lidt&lt;&#x2F;a&gt; instruction.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;lidt&lt;&#x2F;code&gt; instruction expects a pointer to a special data structure, which specifies the start address of the IDT and its length:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16&lt;&#x2F;td&gt;&lt;td&gt;Limit&lt;&#x2F;td&gt;&lt;td&gt;The maximum addressable byte in the table. Equal to the table size in bytes minus 1.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;u64&lt;&#x2F;td&gt;&lt;td&gt;Offset&lt;&#x2F;td&gt;&lt;td&gt;Virtual start address of the table.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;This structure is already contained &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.0&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;struct.DescriptorTablePointer.html&quot;&gt;in the x86_64 crate&lt;&#x2F;a&gt;, so we don‚Äôt need to create it ourselves. The same is true for the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.0&#x2F;x86_64&#x2F;instructions&#x2F;tables&#x2F;fn.lidt.html&quot;&gt;lidt function&lt;&#x2F;a&gt;. So we just need to put the pieces together to create a &lt;code&gt;load&lt;&#x2F;code&gt;  method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Idt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;load(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tables::{DescriptorTablePointer, lidt};
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::mem::size_of;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ptr = DescriptorTablePointer {
&lt;&#x2F;span&gt;&lt;span&gt;            base: self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            limit: (size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ lidt(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ptr) };
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method does not need to modify the IDT, so it takes &lt;code&gt;self&lt;&#x2F;code&gt; by immutable reference. First, we create a &lt;code&gt;DescriptorTablePointer&lt;&#x2F;code&gt; and then we pass it to &lt;code&gt;lidt&lt;&#x2F;code&gt;. The &lt;code&gt;lidt&lt;&#x2F;code&gt; function expects that the &lt;code&gt;base&lt;&#x2F;code&gt; field has the type &lt;code&gt;u64&lt;&#x2F;code&gt;, therefore we need to cast the &lt;code&gt;self&lt;&#x2F;code&gt; pointer. For calculating the &lt;code&gt;limit&lt;&#x2F;code&gt; we use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;mem&#x2F;fn.size_of.html&quot;&gt;mem::size_of&lt;&#x2F;a&gt;. The additional &lt;code&gt;-1&lt;&#x2F;code&gt; is needed because the limit field has to be the maximum addressable byte (inclusive bound). We need an unsafe block around &lt;code&gt;lidt&lt;&#x2F;code&gt;, because the function assumes that the specified handler addresses are valid.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h4&gt;
&lt;p&gt;But can we really guarantee that handler addresses are always valid? Let‚Äôs see:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Idt::new&lt;&#x2F;code&gt; function creates a new table populated with non-present entries. There‚Äôs no way to set these entries to present from outside of this module, so this function is fine.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;set_handler&lt;&#x2F;code&gt; method allows us to overwrite a specified entry and point it to some handler function. Rust‚Äôs type system guarantees that function pointers are always valid (as long as no &lt;code&gt;unsafe&lt;&#x2F;code&gt; is involved), so this function is fine, too.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There are no other public functions in the &lt;code&gt;idt&lt;&#x2F;code&gt; module (except &lt;code&gt;load&lt;&#x2F;code&gt;), so it should be safe‚Ä¶ right?&lt;&#x2F;p&gt;
&lt;p&gt;Wrong! Imagine the following scenario:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    load_idt();
&lt;&#x2F;span&gt;&lt;span&gt;    cause_page_fault();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;load_idt() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;    idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;, page_fault_handler);
&lt;&#x2F;span&gt;&lt;span&gt;    idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;cause_page_fault() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe&lt;&#x2F;span&gt;&lt;span&gt;{ *(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2F;span&gt;&lt;span&gt;) = x[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;] };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This won‚Äôt work. If we‚Äôre lucky, we get a triple fault and a boot loop. If we‚Äôre unlucky, our kernel does strange things and fails at some completely unrelated place. So what‚Äôs the problem here?&lt;&#x2F;p&gt;
&lt;p&gt;Well, we construct an IDT &lt;em&gt;on the stack&lt;&#x2F;em&gt; and load it. It is perfectly valid until the end of the &lt;code&gt;load_idt&lt;&#x2F;code&gt; function. But as soon as the function returns, its stack frame can be reused by other functions. Thus, the IDT gets overwritten by the stack frame of the &lt;code&gt;cause_page_fault&lt;&#x2F;code&gt; function. So when the page fault occurs and the CPU tries to read the entry, it only sees some garbage values and issues a double fault, which escalates to a triple fault and a CPU reset.&lt;&#x2F;p&gt;
&lt;p&gt;Now imagine that the &lt;code&gt;cause_page_fault&lt;&#x2F;code&gt; function declared an array of pointers instead. If the present was coincidentally set, the CPU would jump to some random pointer and interpret random memory as code. This would be a clear violation of memory safety.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;fixing-the-load-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-load-method&quot; aria-label=&quot;Anchor link for: fixing-the-load-method&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the load method&lt;&#x2F;h4&gt;
&lt;p&gt;So how do we fix it? We could make the load function itself &lt;code&gt;unsafe&lt;&#x2F;code&gt; and push the unsafety to the caller. However, there is a much better solution in this case. In order to see it, we formulate the requirement for the &lt;code&gt;load&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The referenced IDT must be valid until a new IDT is loaded.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;We can‚Äôt know when the next IDT will be loaded. Maybe never. So in the worst case:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The referenced IDT must be valid as long as our kernel runs.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;This is exactly the definition of a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;scope&#x2F;lifetime&#x2F;static_lifetime.html&quot;&gt;static lifetime&lt;&#x2F;a&gt;. So we can easily ensure that the IDT lives long enough by adding a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; requirement to the signature of the &lt;code&gt;load&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;load(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static &lt;&#x2F;span&gt;&lt;span&gt;self) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;           ^^^^^^^ ensure that the IDT reference has the &amp;#39;static lifetime
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That‚Äôs it! Now the Rust compiler ensures that the above error can‚Äôt happen anymore:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: `idt` does not live long enough
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:78:5
&lt;&#x2F;span&gt;&lt;span&gt;78 |&amp;gt;     idt.load();
&lt;&#x2F;span&gt;&lt;span&gt;   |&amp;gt;     ^^^
&lt;&#x2F;span&gt;&lt;span&gt;note: reference must be valid for the static lifetime...
&lt;&#x2F;span&gt;&lt;span&gt;note: ...but borrowed value is only valid for the block suffix following
&lt;&#x2F;span&gt;&lt;span&gt;          statement 0 at 75:34
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;interrupts&#x2F;mod.rs:75:35
&lt;&#x2F;span&gt;&lt;span&gt;75 |&amp;gt;     let mut idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;   |&amp;gt;                                   ^
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;a-static-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-static-idt&quot; aria-label=&quot;Anchor link for: a-static-idt&quot;&gt;üîó&lt;&#x2F;a&gt;A static IDT&lt;&#x2F;h3&gt;
&lt;p&gt;So a valid IDT needs to have the &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; lifetime. We can either create a &lt;code&gt;static&lt;&#x2F;code&gt; IDT or &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html#method.into_raw&quot;&gt;deliberately leak a Box&lt;&#x2F;a&gt;. We will most likely only need a single IDT for the foreseeable future, so let‚Äôs try the &lt;code&gt;static&lt;&#x2F;code&gt; approach:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, divide_by_zero_handler);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    idt
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero_handler() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: DIVIDE BY ZERO&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We register a single handler function for a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Divide-by-zero_Error&quot;&gt;divide by zero error&lt;&#x2F;a&gt; (index 0). Like the name says, this exception occurs when dividing a number by 0. Thus we have an easy way to test our new exception handler.&lt;&#x2F;p&gt;
&lt;p&gt;However, it doesn‚Äôt work this way:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: calls in statics are limited to constant functions, struct and enum
&lt;&#x2F;span&gt;&lt;span&gt;       constructors [E0015]
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;error: blocks in statics are limited to items and tail expressions [E0016]
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;error: references in statics may only refer to immutable values [E0017]
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason is that the Rust compiler is not able to evaluate the value of the &lt;code&gt;static&lt;&#x2F;code&gt; at compile time. Maybe it will work someday when &lt;code&gt;const&lt;&#x2F;code&gt; functions become more powerful. But until then, we have to find another solution.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;üîó&lt;&#x2F;a&gt;Lazy Statics to the Rescue&lt;&#x2F;h4&gt;
&lt;p&gt;Fortunately the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; macro exists. Instead of evaluating a &lt;code&gt;static&lt;&#x2F;code&gt; at compile time, the macro performs the initialization when the &lt;code&gt;static&lt;&#x2F;code&gt; is referenced the first time. Thus, we can do almost everything in the initialization block and are even able to read runtime values.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add the &lt;code&gt;lazy_static&lt;&#x2F;code&gt; crate to our project:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; lazy_static;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.1&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2F;code&gt; feature, since we don‚Äôt link the standard library.&lt;&#x2F;p&gt;
&lt;p&gt;With &lt;code&gt;lazy_static&lt;&#x2F;code&gt;, we can define our IDT without problems:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;lazy_static! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;: idt::Idt = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; idt = idt::Idt::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt.set_handler(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, divide_by_zero_handler);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        idt
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we‚Äôre ready to load our IDT! Therefore we add a &lt;code&gt;interrupts::init&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;interrupts&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2F;span&gt;&lt;span&gt;.load();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don‚Äôt need our &lt;code&gt;assert_has_not_been_called&lt;&#x2F;code&gt; macro here, since nothing bad happens when &lt;code&gt;init&lt;&#x2F;code&gt; is called twice. It just reloads the same IDT again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h2&gt;
&lt;p&gt;Now we should be able to catch page faults! Let‚Äôs try it in our &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(...) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    memory::init(boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize our IDT
&lt;&#x2F;span&gt;&lt;span&gt;    interrupts::init();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provoke a divide-by-zero fault
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, we get a runtime panic:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;PANIC in src&#x2F;lib.rs at line 57:
&lt;&#x2F;span&gt;&lt;span&gt;    attempted to divide by zero
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That‚Äôs a not our exception handler. The reason is that Rust itself checks for a possible division by zero and panics in that case. So in order to raise a divide-by-zero error in the CPU, we need to bypass the Rust compiler somehow.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;inline-assembly&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#inline-assembly&quot; aria-label=&quot;Anchor link for: inline-assembly&quot;&gt;üîó&lt;&#x2F;a&gt;Inline Assembly&lt;&#x2F;h3&gt;
&lt;p&gt;In order to cause a divide-by-zero exception, we need to execute a &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;div&quot;&gt;div&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;www.felixcloutier.com&#x2F;x86&#x2F;idiv&quot;&gt;idiv&lt;&#x2F;a&gt; assembly instruction with operand 0. We could write a small assembly function and call it from our Rust code. An easier way is to use Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;book&#x2F;inline-assembly.html&quot;&gt;inline assembly&lt;&#x2F;a&gt; macro.&lt;&#x2F;p&gt;
&lt;p&gt;Inline assembly allows us to write raw x86 assembly within a Rust function. The feature is unstable, so we need to add &lt;code&gt;#![feature(asm)]&lt;&#x2F;code&gt; to our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;. Then we‚Äôre able to write a &lt;code&gt;divide_by_zero&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;divide_by_zero() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        asm!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov dx, 0; div dx&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;::: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ax&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dx&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs try to decode it:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;asm!&lt;&#x2F;code&gt; macro emits raw assembly instructions, so it‚Äôs &lt;code&gt;unsafe&lt;&#x2F;code&gt; to use it.&lt;&#x2F;li&gt;
&lt;li&gt;We insert two assembly instructions here: &lt;code&gt;mov dx, 0&lt;&#x2F;code&gt; and &lt;code&gt;div dx&lt;&#x2F;code&gt;. The former loads a 0 into the &lt;code&gt;dx&lt;&#x2F;code&gt; register (a subset of &lt;code&gt;rdx&lt;&#x2F;code&gt;) and the latter divides the &lt;code&gt;ax&lt;&#x2F;code&gt; register by &lt;code&gt;dx&lt;&#x2F;code&gt;. (The &lt;code&gt;div&lt;&#x2F;code&gt; instruction always implicitly operates on the &lt;code&gt;ax&lt;&#x2F;code&gt; register).&lt;&#x2F;li&gt;
&lt;li&gt;The colons are separators. After the first &lt;code&gt;:&lt;&#x2F;code&gt; we could specify output operands and after the second &lt;code&gt;:&lt;&#x2F;code&gt; we could specify input operands. We need neither, so we leave these areas empty.&lt;&#x2F;li&gt;
&lt;li&gt;After the third colon, we specify the so-called &lt;em&gt;clobbers&lt;&#x2F;em&gt;. These tell the compiler that our assembly modifies the values of some registers. Otherwise, the compiler assumes that the registers preserve their value. In our case, we clobber &lt;code&gt;dx&lt;&#x2F;code&gt; (we load 0 to it) and &lt;code&gt;ax&lt;&#x2F;code&gt; (the &lt;code&gt;div&lt;&#x2F;code&gt; instruction places the result in it).&lt;&#x2F;li&gt;
&lt;li&gt;The last block (after the 4th colon) specifies some options. The &lt;code&gt;volatile&lt;&#x2F;code&gt; option tells the compiler: ‚ÄúThis code has side effects. Do not delete it and do not move it elsewhere‚Äù. In our case, the ‚Äúside effect‚Äù is the divide-by-zero exception. Finally, the &lt;code&gt;intel&lt;&#x2F;code&gt; option allows us to use the Intel assembly syntax instead of the default AT&amp;amp;T syntax.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let‚Äôs use our new &lt;code&gt;divide_by_zero&lt;&#x2F;code&gt; function to raise a CPU exception:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(...) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; provoke a divide-by-zero fault
&lt;&#x2F;span&gt;&lt;span&gt;    divide_by_zero();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It works! We see a &lt;code&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2F;code&gt; message at the bottom of our screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;catching-exceptions&#x2F;qemu-divide-error-println.png&quot; alt=&quot;QEMU screenshot with EXCEPTION: DIVIDE BY ZERO message&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;We‚Äôve successfully caught our first exception! However, our &lt;code&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2F;code&gt; message doesn‚Äôt contain much information about the cause of the exception. The next post improves the situation by printing i.a. the current stack pointer and address of the causing instruction. We will also explore other exceptions such as page faults, for which the CPU pushes an &lt;em&gt;error code&lt;&#x2F;em&gt; on the stack.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Kernel Heap</title>
                <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/kernel-heap/</link>
                <guid>https://os.phil-opp.com/kernel-heap/</guid>
                <description>&lt;p&gt;In the previous posts we created a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;&quot;&gt;frame allocator&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;page table module&lt;&#x2F;a&gt;. Now we are ready to create a kernel heap and a memory allocator. Thus, we will unlock &lt;code&gt;Box&lt;&#x2F;code&gt;, &lt;code&gt;Vec&lt;&#x2F;code&gt;, &lt;code&gt;BTreeMap&lt;&#x2F;code&gt;, and the rest of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;index.html&quot;&gt;alloc&lt;&#x2F;a&gt; crate.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, you can find the complete source code on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_8&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;issues&lt;&#x2F;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;üîó&lt;&#x2F;a&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;em&gt;heap&lt;&#x2F;em&gt; is the memory area for long-lived allocations. The programmer can access it by using types like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;std&#x2F;box.html&quot;&gt;Box&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;vectors.html&quot;&gt;Vec&lt;&#x2F;a&gt;. Behind the scenes, the compiler manages that memory by inserting calls to some memory allocator. By default, Rust links to the &lt;a href=&quot;http:&#x2F;&#x2F;jemalloc.net&#x2F;&quot;&gt;jemalloc&lt;&#x2F;a&gt; allocator (for binaries) or the system allocator (for libraries). However, both rely on &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;System_call&quot;&gt;system calls&lt;&#x2F;a&gt; such as &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sbrk&quot;&gt;sbrk&lt;&#x2F;a&gt; and are thus unusable in our kernel. So we need to create and link our own allocator.&lt;&#x2F;p&gt;
&lt;p&gt;A good allocator is fast and reliable. It also effectively utilizes the available memory and keeps &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fragmentation_(computing)&quot;&gt;fragmentation&lt;&#x2F;a&gt; low. Furthermore, it works well for concurrent applications and scales to any number of processors. It even optimizes the memory layout with respect to the CPU caches to improve &lt;a href=&quot;https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;locality-of-reference-and-cache-operation-in-cache-memory&#x2F;&quot;&gt;cache locality&lt;&#x2F;a&gt; and avoid &lt;a href=&quot;https:&#x2F;&#x2F;mechanical-sympathy.blogspot.de&#x2F;2011&#x2F;07&#x2F;false-sharing.html&quot;&gt;false sharing&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These requirements make good allocators pretty complex. For example, &lt;a href=&quot;http:&#x2F;&#x2F;jemalloc.net&#x2F;&quot;&gt;jemalloc&lt;&#x2F;a&gt; has over 30.000 lines of code. This complexity is out of scope for our kernel, so we will create a much simpler allocator. Nevertheless, it should suffice for the foreseeable future, since we‚Äôll allocate only when it‚Äôs absolutely necessary.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-allocator-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-interface&quot; aria-label=&quot;Anchor link for: the-allocator-interface&quot;&gt;üîó&lt;&#x2F;a&gt;The Allocator Interface&lt;&#x2F;h2&gt;
&lt;p&gt;The allocator interface in Rust is defined through the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.20.0&#x2F;alloc&#x2F;allocator&#x2F;trait.Alloc.html&quot;&gt;&lt;code&gt;Alloc&lt;&#x2F;code&gt; trait&lt;&#x2F;a&gt;, which looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2F;span&gt;&lt;span&gt;Alloc {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, AllocErr&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout);
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; about 13 methods with default implementations
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;alloc&lt;&#x2F;code&gt; method should allocate a memory block with the size and alignment given through &lt;code&gt;Layout&lt;&#x2F;code&gt; parameter. The &lt;code&gt;deallocate&lt;&#x2F;code&gt; method should free such memory blocks again. Both methods are &lt;code&gt;unsafe&lt;&#x2F;code&gt;, as is the trait itself. This has different reasons:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the &lt;code&gt;Alloc&lt;&#x2F;code&gt; trait is unsafe, because the implementation must satisfy a set of contracts. Among other things, pointers returned by &lt;code&gt;alloc&lt;&#x2F;code&gt; must point to valid memory and adhere to the &lt;code&gt;Layout&lt;&#x2F;code&gt; requirements.&lt;&#x2F;li&gt;
&lt;li&gt;Calling &lt;code&gt;alloc&lt;&#x2F;code&gt; is unsafe because the caller must ensure that the passed layout does not have size zero. I think this is because of compatibility reasons with existing C-allocators, where zero-sized allocations are undefined behavior.&lt;&#x2F;li&gt;
&lt;li&gt;Calling &lt;code&gt;dealloc&lt;&#x2F;code&gt; is unsafe because the caller must guarantee that the passed parameters adhere to the contract. For example, &lt;code&gt;ptr&lt;&#x2F;code&gt; must denote a valid memory block allocated via this allocator.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To set the system allocator, the &lt;code&gt;global_allocator&lt;&#x2F;code&gt; attribute can be added to a &lt;code&gt;static&lt;&#x2F;code&gt; that implements &lt;code&gt;Alloc&lt;&#x2F;code&gt; for a shared reference of itself. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;MY_ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: MyAllocator = MyAllocator {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Alloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;MyAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, AllocErr&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that &lt;code&gt;Alloc&lt;&#x2F;code&gt; needs to be implemented for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2F;code&gt;, not for &lt;code&gt;MyAllocator&lt;&#x2F;code&gt;. The reason is that the &lt;code&gt;alloc&lt;&#x2F;code&gt; and &lt;code&gt;dealloc&lt;&#x2F;code&gt; methods require mutable &lt;code&gt;self&lt;&#x2F;code&gt; references, but there‚Äôs no way to get such a reference safely from a &lt;code&gt;static&lt;&#x2F;code&gt;. By requiring implementations for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2F;code&gt;, the global allocator interface avoids this problem and pushes the burden of synchronization onto the user.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;including-the-alloc-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#including-the-alloc-crate&quot; aria-label=&quot;Anchor link for: including-the-alloc-crate&quot;&gt;üîó&lt;&#x2F;a&gt;Including the alloc crate&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Alloc&lt;&#x2F;code&gt; trait is part of the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate, which like &lt;code&gt;core&lt;&#x2F;code&gt; is a subset of Rust‚Äôs standard library. Apart from the trait, the crate also contains the standard types that require allocations such as &lt;code&gt;Box&lt;&#x2F;code&gt;, &lt;code&gt;Vec&lt;&#x2F;code&gt; and &lt;code&gt;Arc&lt;&#x2F;code&gt;. We can include it through a simple &lt;code&gt;extern crate&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(alloc)] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the alloc crate is still unstable
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; alloc;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don‚Äôt need to add anything to our Cargo.toml, since the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate is part of the standard library and shipped with the Rust compiler. The &lt;code&gt;alloc&lt;&#x2F;code&gt; crate provides the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;macro.format!.html&quot;&gt;format!&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;macro.vec!.html&quot;&gt;vec!&lt;&#x2F;a&gt; macros, so we use &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; to import them.&lt;&#x2F;p&gt;
&lt;p&gt;When we try to compile our crate now, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `alloc`
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;lib.rs:10:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;16 | extern crate alloc;
&lt;&#x2F;span&gt;&lt;span&gt;   | ^^^^^^^^^^^^^^^^^^^ can&amp;#39;t find crate
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The problem is that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;japaric&#x2F;xargo&quot;&gt;&lt;code&gt;xargo&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; only cross compiles &lt;code&gt;libcore&lt;&#x2F;code&gt; by default. To also cross compile the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate, we need to create a file named &lt;code&gt;Xargo.toml&lt;&#x2F;code&gt; in our project root (right next to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;) with the following content:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.x86_64-blog_os.dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;alloc &lt;&#x2F;span&gt;&lt;span&gt;= {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This instructs &lt;code&gt;xargo&lt;&#x2F;code&gt; that we also need &lt;code&gt;alloc&lt;&#x2F;code&gt;. It still doesn‚Äôt compile, since we need to define a global allocator in order to use the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: no #[default_lib_allocator] found but one is required; is libstd not linked?
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;a-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-bump-allocator&quot; aria-label=&quot;Anchor link for: a-bump-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;A Bump Allocator&lt;&#x2F;h2&gt;
&lt;p&gt;For our first allocator, we start simple. We create a &lt;code&gt;memory::heap_allocator&lt;&#x2F;code&gt; module containing a so-called &lt;em&gt;bump allocator&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;heap_allocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;heap_allocator.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::heap::{Alloc, AllocErr, Layout};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A simple allocator that allocates memory linearly and ignores freed memory.
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new(heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ heap_start, heap_end, next: heap_start }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2F;span&gt;&lt;span&gt;Alloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, AllocErr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_start = align_up(self.next, layout.align());
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_end = alloc_start.saturating_add(layout.size());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; alloc_end &amp;lt;= self.heap_end {
&lt;&#x2F;span&gt;&lt;span&gt;            self.next = alloc_end;
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Err(AllocErr::Exhausted{ request: layout })
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; do nothing, leak memory
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We also need to add &lt;code&gt;#![feature(allocator_api)]&lt;&#x2F;code&gt; to our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, since the allocator API is still unstable.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;heap_start&lt;&#x2F;code&gt; and &lt;code&gt;heap_end&lt;&#x2F;code&gt; fields contain the start and end address of our kernel heap. The &lt;code&gt;next&lt;&#x2F;code&gt; field contains the next free address and is increased after every allocation. To &lt;code&gt;allocate&lt;&#x2F;code&gt; a memory block we align the &lt;code&gt;next&lt;&#x2F;code&gt; address using the &lt;code&gt;align_up&lt;&#x2F;code&gt; function (described below). Then we add up the desired &lt;code&gt;size&lt;&#x2F;code&gt; and make sure that we don‚Äôt exceed the end of the heap. We use a saturating add so that the &lt;code&gt;alloc_end&lt;&#x2F;code&gt; cannot overflow, which could lead to an invalid allocation. If everything goes well, we update the &lt;code&gt;next&lt;&#x2F;code&gt; address and return a pointer to the start address of the allocation. Else, we return &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#alignment&quot; aria-label=&quot;Anchor link for: alignment&quot;&gt;üîó&lt;&#x2F;a&gt;Alignment&lt;&#x2F;h3&gt;
&lt;p&gt;In order to simplify alignment, we add &lt;code&gt;align_down&lt;&#x2F;code&gt; and &lt;code&gt;align_up&lt;&#x2F;code&gt; functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Align downwards. Returns the greatest x with alignment `align`
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; so that x &amp;lt;= addr. The alignment must be a power of 2.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;align_down(addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; align.is_power_of_two() {
&lt;&#x2F;span&gt;&lt;span&gt;        addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; !&lt;&#x2F;span&gt;&lt;span&gt;(align - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; align == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        addr
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;`align` must be a power of 2&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Align upwards. Returns the smallest x with alignment `align`
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; so that x &amp;gt;= addr. The alignment must be a power of 2.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;align_up(addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, align: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    align_down(addr + align - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, align)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs start with &lt;code&gt;align_down&lt;&#x2F;code&gt;: If the alignment is a valid power of two (i.e. in &lt;code&gt;{1,2,4,8,‚Ä¶}&lt;&#x2F;code&gt;), we use some bitwise operations to return the aligned address. It works because every power of two has exactly one bit set in its binary representation. For example, the numbers &lt;code&gt;{1,2,4,8,‚Ä¶}&lt;&#x2F;code&gt; are &lt;code&gt;{1,10,100,1000,‚Ä¶}&lt;&#x2F;code&gt; in binary. By subtracting 1 we get &lt;code&gt;{0,01,011,0111,‚Ä¶}&lt;&#x2F;code&gt;. These binary numbers have a &lt;code&gt;1&lt;&#x2F;code&gt; at exactly the positions that need to be zeroed in &lt;code&gt;addr&lt;&#x2F;code&gt;. For example, the last 3 bits need to be zeroed for a alignment of 8.&lt;&#x2F;p&gt;
&lt;p&gt;To align &lt;code&gt;addr&lt;&#x2F;code&gt;, we create a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Mask_(computing)&quot;&gt;bitmask&lt;&#x2F;a&gt; from &lt;code&gt;align-1&lt;&#x2F;code&gt;. We want a &lt;code&gt;0&lt;&#x2F;code&gt; at the position of each &lt;code&gt;1&lt;&#x2F;code&gt;, so we invert it using &lt;code&gt;!&lt;&#x2F;code&gt;. After that, the binary numbers look like this: &lt;code&gt;{‚Ä¶11111,‚Ä¶11110,‚Ä¶11100,‚Ä¶11000,‚Ä¶}&lt;&#x2F;code&gt;. Finally, we zero the correct bits using a binary &lt;code&gt;AND&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Aligning upwards is simple now. We just increase &lt;code&gt;addr&lt;&#x2F;code&gt; by &lt;code&gt;align-1&lt;&#x2F;code&gt; and call &lt;code&gt;align_down&lt;&#x2F;code&gt;. We add &lt;code&gt;align-1&lt;&#x2F;code&gt; instead of &lt;code&gt;align&lt;&#x2F;code&gt; because we would otherwise waste &lt;code&gt;align&lt;&#x2F;code&gt; bytes for already aligned addresses.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;reusing-freed-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reusing-freed-memory&quot; aria-label=&quot;Anchor link for: reusing-freed-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Reusing Freed Memory&lt;&#x2F;h3&gt;
&lt;p&gt;The heap memory is limited, so we should reuse freed memory for new allocations. This sounds simple, but is not so easy in practice since allocations can live arbitrarily long (and can be freed in an arbitrary order). This means that we need some kind of data structure to keep track of which memory areas are free and which are in use. This data structure should be very optimized since it causes overheads in both space (i.e. it needs backing memory) and time (i.e. accessing and organizing it needs CPU cycles).&lt;&#x2F;p&gt;
&lt;p&gt;Our bump allocator only keeps track of the next free memory address, which doesn‚Äôt suffice to keep track of freed memory areas. So our only choice is to ignore deallocations and leak the corresponding memory. Thus our allocator quickly runs out of memory in a real system, but it suffices for simple testing. Later in this post, we will introduce a better allocator that does not leak freed memory.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-it-as-system-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-it-as-system-allocator&quot; aria-label=&quot;Anchor link for: using-it-as-system-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Using it as System Allocator&lt;&#x2F;h3&gt;
&lt;p&gt;Above we saw that we can use a static allocator as system allocator through the &lt;code&gt;global_allocator&lt;&#x2F;code&gt; attribute:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: MyAllocator = MyAllocator {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This requires an implementation of &lt;code&gt;Alloc&lt;&#x2F;code&gt; for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2F;code&gt;, i.e. a shared reference. If we try to add such an implementation for our bump allocator (&lt;code&gt;unsafe impl&amp;lt;&#x27;a&amp;gt; Alloc for &amp;amp;&#x27;a BumpAllocator&lt;&#x2F;code&gt;), we have a problem: Our &lt;code&gt;alloc&lt;&#x2F;code&gt; method requires updating the &lt;code&gt;next&lt;&#x2F;code&gt; field, which is not possible for a shared reference.&lt;&#x2F;p&gt;
&lt;p&gt;One solution could be to put the bump allocator behind a Mutex and wrap it into a new type, for which we can implement &lt;code&gt;Alloc&lt;&#x2F;code&gt; for a shared reference:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;LockedBumpAllocator(Mutex&amp;lt;BumpAllocator&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Alloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;LockedBumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, AllocErr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;lock().alloc(layout)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2F;span&gt;&lt;span&gt;lock().dealloc(ptr, layout)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, there is a more interesting solution for our bump allocator that avoids locking altogether. The idea is to exploit that we only need to update a single &lt;code&gt;usize&lt;&#x2F;code&gt; field byusing an &lt;code&gt;AtomicUsize&lt;&#x2F;code&gt; type. This type uses special synchronized hardware instructions to ensure data race freedom without requiring locks.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;a-lock-free-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-lock-free-bump-allocator&quot; aria-label=&quot;Anchor link for: a-lock-free-bump-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;A lock-free Bump Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;A lock-free implementation looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::sync::atomic::{AtomicUsize, Ordering};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; A simple allocator that allocates memory linearly and ignores freed memory.
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    next: AtomicUsize,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2F;span&gt;&lt;span&gt;new(heap_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, heap_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; NOTE: requires adding #![feature(const_atomic_usize_new)] to lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ heap_start, heap_end, next: AtomicUsize::new(heap_start) }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Alloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;BumpAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;alloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, AllocErr&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; load current state of the `next` field
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; current_next = self.next.load(Ordering::Relaxed);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_start = align_up(current_next, layout.align());
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; alloc_end = alloc_start.saturating_add(layout.size());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; alloc_end &amp;lt;= self.heap_end {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; update the `next` pointer if it still has the value `current_next`
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next_now = self.next.compare_and_swap(current_next, alloc_end,
&lt;&#x2F;span&gt;&lt;span&gt;                    Ordering::Relaxed);
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_now == current_next {
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; next address was successfully updated, allocation succeeded
&lt;&#x2F;span&gt;&lt;span&gt;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Ok(alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Err(AllocErr::Exhausted{ request: layout })
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;dealloc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2F;span&gt;&lt;span&gt;, layout: Layout) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; do nothing, leak memory
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The implementation is a bit more complicated now. First, there is now a &lt;code&gt;loop&lt;&#x2F;code&gt; around the whole method body, since we might need multiple tries until we succeed (e.g. if multiple threads try to allocate at the same time). Also, the loads operation is an explicit method call now, i.e. &lt;code&gt;self.next.load(Ordering::Relaxed)&lt;&#x2F;code&gt; instead of just &lt;code&gt;self.next&lt;&#x2F;code&gt;. The ordering parameter makes it possible to restrict the automatic instruction reordering performed by both the compiler and the CPU itself. For example, it is used when implementing locks to ensure that no write to the locked variable happens before the lock is acquired. We don‚Äôt have such requirements, so we use the less restrictive &lt;code&gt;Relaxed&lt;&#x2F;code&gt; ordering.&lt;&#x2F;p&gt;
&lt;p&gt;The heart of this lock-free method is the &lt;code&gt;compare_and_swap&lt;&#x2F;code&gt; call that updates the &lt;code&gt;next&lt;&#x2F;code&gt; address:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; next_now = self.next.compare_and_swap(current_next, alloc_end,
&lt;&#x2F;span&gt;&lt;span&gt;    Ordering::Relaxed);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; next_now == current_next {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; next address was successfully updated, allocation succeeded
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Ok(alloc_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Compare-and-swap is a special CPU instruction that updates a variable with a given value if it still contains the value we expect. If it doesn‚Äôt, it means that another thread updated the value simultaneously, so we need to try again. The important feature is that this happens in a single uninteruptible operation (thus the name &lt;code&gt;atomic&lt;&#x2F;code&gt;), so no partial updates or intermediate states are possible.&lt;&#x2F;p&gt;
&lt;p&gt;In detail, &lt;code&gt;compare_and_swap&lt;&#x2F;code&gt; works by comparing &lt;code&gt;next&lt;&#x2F;code&gt; with the first argument and, in case they‚Äôre equal, updates &lt;code&gt;next&lt;&#x2F;code&gt; with the second parameter (the previous value is returned). To find out whether a switch happened, we check the returned previous value of &lt;code&gt;next&lt;&#x2F;code&gt;. If it is equal to the first parameter, the values were swapped. Otherwise, we try again in the next loop iteration.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;setting-the-global-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#setting-the-global-allocator&quot; aria-label=&quot;Anchor link for: setting-the-global-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Setting the Global Allocator&lt;&#x2F;h4&gt;
&lt;p&gt;Now we can define a static bump allocator, that we can set as system allocator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_000_001_000_000_0000&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 100 KiB
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: BumpAllocator = BumpAllocator::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;code&gt;0o_000_001_000_000_0000&lt;&#x2F;code&gt; as heap start address, which is the address starting at the second &lt;code&gt;P3&lt;&#x2F;code&gt; entry. It doesn‚Äôt really matter which address we choose here as long as it‚Äôs unused. We use a heap size of 100 KiB, which should be large enough for the near future.&lt;&#x2F;p&gt;
&lt;p&gt;Putting the above in the &lt;code&gt;memory::heap_allocator&lt;&#x2F;code&gt; module would make most sense, but unfortunately there is currently a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;44113&quot;&gt;weird bug&lt;&#x2F;a&gt; in the global allocator implementation that requires putting the global allocator in the root module. I hope it‚Äôs fixed soon, but until then we need to put the above lines in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;. For that, we need to make the &lt;code&gt;memory::heap_allocator&lt;&#x2F;code&gt; module public and add an import for &lt;code&gt;BumpAllocator&lt;&#x2F;code&gt;. We also need to add the &lt;code&gt;#![feature(global_allocator)]&lt;&#x2F;code&gt; at the top of our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, since the &lt;code&gt;global_allocator&lt;&#x2F;code&gt; attribute is still unstable.&lt;&#x2F;p&gt;
&lt;p&gt;That‚Äôs it! We have successfully created and linked a custom system allocator. Now we‚Äôre ready to test it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing&quot; aria-label=&quot;Anchor link for: testing&quot;&gt;üîó&lt;&#x2F;a&gt;Testing&lt;&#x2F;h3&gt;
&lt;p&gt;We should be able to allocate memory on the heap now. Let‚Äôs try it in our &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_test = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run it, a triple fault occurs and causes permanent rebooting. Let‚Äôs try debug it using QEMU and objdump as described &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;#debugging&quot;&gt;in the previous post&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 -d int -no-reboot -cdrom build&#x2F;os-x86_64.iso
&lt;&#x2F;span&gt;&lt;span&gt;‚Ä¶
&lt;&#x2F;span&gt;&lt;span&gt;check_exception old: 0xffffffff new 0xe
&lt;&#x2F;span&gt;&lt;span&gt;     0: v=0e e=0002 i=0 cpl=0 IP=0008:0000000000102860 pc=0000000000102860
&lt;&#x2F;span&gt;&lt;span&gt;        SP=0010:0000000000116af0 CR2=0000000040000000
&lt;&#x2F;span&gt;&lt;span&gt;‚Ä¶
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Aha! It‚Äôs a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Page_Fault&quot;&gt;page fault&lt;&#x2F;a&gt; (&lt;code&gt;v=0e&lt;&#x2F;code&gt;) and was caused by the code at &lt;code&gt;0x102860&lt;&#x2F;code&gt;. The code tried to write (&lt;code&gt;e=0002&lt;&#x2F;code&gt;) to address &lt;code&gt;0x40000000&lt;&#x2F;code&gt;. This address is &lt;code&gt;0o_000_001_000_000_0000&lt;&#x2F;code&gt; in octal, which is the &lt;code&gt;HEAP_START&lt;&#x2F;code&gt; address defined above. Of course it page-faults: We have forgotten to map the heap memory to some physical memory.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;some-refactoring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-refactoring&quot; aria-label=&quot;Anchor link for: some-refactoring&quot;&gt;üîó&lt;&#x2F;a&gt;Some Refactoring&lt;&#x2F;h3&gt;
&lt;p&gt;In order to map the heap cleanly, we do a bit of refactoring first. We move all memory initialization from our &lt;code&gt;rust_main&lt;&#x2F;code&gt; to a new &lt;code&gt;memory::init&lt;&#x2F;code&gt; function. Now our &lt;code&gt;rust_main&lt;&#x2F;code&gt; looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ATTENTION: we have a very small stack and no guard page
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::clear_screen();
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; boot_info = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot2::load(multiboot_information_address)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    enable_nxe_bit();
&lt;&#x2F;span&gt;&lt;span&gt;    enable_write_protect_bit();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; set up guard page and map the heap pages
&lt;&#x2F;span&gt;&lt;span&gt;    memory::init(boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_test = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;memory::init&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;multiboot2::BootInformation;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; memory_map_tag = boot_info.memory_map_tag().expect(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag = boot_info.elf_sections_tag().expect(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf sections tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_start = elf_sections_tag.sections()
&lt;&#x2F;span&gt;&lt;span&gt;        .filter(|s| s.is_allocated()).map(|s| s.addr).min().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_end = elf_sections_tag.sections()
&lt;&#x2F;span&gt;&lt;span&gt;        .filter(|s| s.is_allocated()).map(|s| s.addr + s.size).max()
&lt;&#x2F;span&gt;&lt;span&gt;        .unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, kernel end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;             kernel_start,
&lt;&#x2F;span&gt;&lt;span&gt;             kernel_end);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;multiboot start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, multiboot end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;             boot_info.start_address(),
&lt;&#x2F;span&gt;&lt;span&gt;             boot_info.end_address());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = AreaFrameAllocator::new(
&lt;&#x2F;span&gt;&lt;span&gt;        kernel_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, kernel_end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        boot_info.start_address(), boot_info.end_address(),
&lt;&#x2F;span&gt;&lt;span&gt;        memory_map_tag.memory_areas());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    paging::remap_the_kernel(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator, boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We‚Äôve just moved the code to a new function. However, we‚Äôve sneaked some improvements in:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;An additional &lt;code&gt;.filter(|s| s.is_allocated())&lt;&#x2F;code&gt; in the calculation of &lt;code&gt;kernel_start&lt;&#x2F;code&gt; and &lt;code&gt;kernel_end&lt;&#x2F;code&gt;. This ignores all sections that aren‚Äôt loaded to memory (such as debug sections). Thus, the kernel end address is no longer artificially increased by such sections.&lt;&#x2F;li&gt;
&lt;li&gt;We use the &lt;code&gt;start_address()&lt;&#x2F;code&gt; and &lt;code&gt;end_address()&lt;&#x2F;code&gt; methods of &lt;code&gt;boot_info&lt;&#x2F;code&gt; instead of calculating the addresses manually.&lt;&#x2F;li&gt;
&lt;li&gt;We use the alternate &lt;code&gt;{:#x}&lt;&#x2F;code&gt; form when printing kernel&#x2F;multiboot addresses. Before, we used &lt;code&gt;0x{:x}&lt;&#x2F;code&gt;, which leads to the same result. For a complete list of these ‚Äúalternate‚Äù formatting forms, check out the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;fmt&#x2F;index.html#sign0&quot;&gt;std::fmt documentation&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h3&gt;
&lt;p&gt;It is important that the &lt;code&gt;memory::init&lt;&#x2F;code&gt; function is called only once, because it creates a new frame allocator based on kernel and multiboot start&#x2F;end. When we call it a second time, a new frame allocator is created that reassigns the same frames, even if they are already in use.&lt;&#x2F;p&gt;
&lt;p&gt;In the second call it would use an identical frame allocator to remap the kernel. The &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; function would request a frame from the frame allocator to create a new page table. But the returned frame is already in use, since we used it to create our current page table in the first call. In order to initialize the new table, the function zeroes it. This is the point where everything breaks, since we zero our current page table. The CPU is unable to read the next instruction  and throws a page fault.&lt;&#x2F;p&gt;
&lt;p&gt;So we need to ensure that &lt;code&gt;memory::init&lt;&#x2F;code&gt; can be only called once. We could mark it as &lt;code&gt;unsafe&lt;&#x2F;code&gt;, which would bring it in line with Rust‚Äôs memory safety rules. However, that would just push the unsafety to the caller. The caller can still accidentally call the function twice, the only difference is that the mistake needs to happen inside &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks.&lt;&#x2F;p&gt;
&lt;p&gt;A better solution is to insert a check at the function‚Äôs beginning, that panics if the function is called a second time. This approach has a small runtime cost, but we only call it once, so it‚Äôs negligible. And we avoid two &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks (one at the calling site and one at the function itself), which is always good.&lt;&#x2F;p&gt;
&lt;p&gt;In order to make such checks easy, I created a small crate named &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;once&quot;&gt;once&lt;&#x2F;a&gt;. To add it, we run &lt;code&gt;cargo add once&lt;&#x2F;code&gt; and add the following to our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; once;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The crate provides an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;once&#x2F;0.3.2&#x2F;once&#x2F;macro.assert_has_not_been_called!.html&quot;&gt;assert_has_not_been_called!&lt;&#x2F;a&gt; macro (sorry for the long name :D). We can use it to fix the safety problem easily:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation) {
&lt;&#x2F;span&gt;&lt;span&gt;    assert_has_not_been_called!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;memory::init must be called only once&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; memory_map_tag = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That‚Äôs it. Now our &lt;code&gt;memory::init&lt;&#x2F;code&gt; function can only be called once. The macro works by creating a static &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;sync&#x2F;atomic&#x2F;struct.AtomicBool.html&quot;&gt;AtomicBool&lt;&#x2F;a&gt; named &lt;code&gt;CALLED&lt;&#x2F;code&gt;, which is initialized to &lt;code&gt;false&lt;&#x2F;code&gt;. When the macro is invoked, it checks the value of &lt;code&gt;CALLED&lt;&#x2F;code&gt; and sets it to &lt;code&gt;true&lt;&#x2F;code&gt;. If the value was already &lt;code&gt;true&lt;&#x2F;code&gt; before, the macro panics.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mapping-the-heap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-the-heap&quot; aria-label=&quot;Anchor link for: mapping-the-heap&quot;&gt;üîó&lt;&#x2F;a&gt;Mapping the Heap&lt;&#x2F;h3&gt;
&lt;p&gt;Now we‚Äôre ready to map the heap pages. In order to do it, we need access to the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; or &lt;code&gt;Mapper&lt;&#x2F;code&gt; instance (see the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;page table&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;&quot;&gt;kernel remapping&lt;&#x2F;a&gt; posts). For that we return it from the &lt;code&gt;paging::remap_the_kernel&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A, boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ActivePageTable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;guard page at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, old_p4_page.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    active_table &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have full page table access in the &lt;code&gt;memory::init&lt;&#x2F;code&gt; function. This allows us to map the heap pages to physical frames:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;init(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; below is the new part
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; active_table = paging::remap_the_kernel(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator,
&lt;&#x2F;span&gt;&lt;span&gt;        boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::paging::Page;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_start_page = Page::containing_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_end_page = Page::containing_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; page &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;Page::range_inclusive(heap_start_page, heap_end_page) {
&lt;&#x2F;span&gt;&lt;span&gt;        active_table.map(page, paging::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Page::range_inclusive&lt;&#x2F;code&gt; function is just a copy of the &lt;code&gt;Frame::range_inclusive&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(‚Ä¶, PartialEq, Eq, PartialOrd, Ord)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Page {...}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Page {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;range_inclusive(start: Page, end: Page) -&amp;gt; PageIter {
&lt;&#x2F;span&gt;&lt;span&gt;        PageIter {
&lt;&#x2F;span&gt;&lt;span&gt;            start: start,
&lt;&#x2F;span&gt;&lt;span&gt;            end: end,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;PageIter {
&lt;&#x2F;span&gt;&lt;span&gt;    start: Page,
&lt;&#x2F;span&gt;&lt;span&gt;    end: Page,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;PageIter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2F;span&gt;&lt;span&gt;= Page;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;next(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Page&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.start &amp;lt;= self.end {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page = self.start;
&lt;&#x2F;span&gt;&lt;span&gt;            self.start.number += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            Some(page)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            None
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we map the whole heap to physical pages. This needs some time and might introduce a noticeable delay when we increase the heap size in the future. Another drawback is that we consume a large amount of physical frames even though we might not need the whole heap space. We will fix these problems in a future post by mapping the pages lazily.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;it-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#it-works&quot; aria-label=&quot;Anchor link for: it-works&quot;&gt;üîó&lt;&#x2F;a&gt;It works!&lt;&#x2F;h3&gt;
&lt;p&gt;Now &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt; should work. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;alloc::boxed::Box;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; heap_test = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;*heap_test -= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; heap_test2 = Box::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?} {:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, heap_test, heap_test2);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; vec_test = vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;vec_test[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;vec_test {
&lt;&#x2F;span&gt;&lt;span&gt;    print!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, i);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can also use all other types of the &lt;code&gt;alloc&lt;&#x2F;code&gt; crate, including:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the reference counted pointers &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;alloc&#x2F;rc&#x2F;&quot;&gt;Rc&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;alloc&#x2F;arc&#x2F;&quot;&gt;Arc&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the owned string type &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;string&#x2F;struct.String.html&quot;&gt;String&lt;&#x2F;a&gt; and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;macro.format!.html&quot;&gt;format!&lt;&#x2F;a&gt; macro&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;linked_list&#x2F;struct.LinkedList.html&quot;&gt;Linked List&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the growable ring buffer &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;vec_deque&#x2F;struct.VecDeque.html&quot;&gt;VecDeque&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;binary_heap&#x2F;struct.BinaryHeap.html&quot;&gt;BinaryHeap&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;BTreeMap&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;btree_set&#x2F;struct.BTreeSet.html&quot;&gt;BTreeSet&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;a-better-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-better-allocator&quot; aria-label=&quot;Anchor link for: a-better-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;A better Allocator&lt;&#x2F;h2&gt;
&lt;p&gt;Right now, we leak every freed memory block. Thus, we run out of memory quickly, for example, by creating a new &lt;code&gt;String&lt;&#x2F;code&gt; in each iteration of a loop:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10000 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some String&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To fix this, we need to create an allocator that keeps track of freed memory blocks and reuses them if possible. This introduces some challenges:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We need to keep track of a possibly unlimited number of freed blocks. For example, an application could allocate &lt;code&gt;n&lt;&#x2F;code&gt; one-byte sized blocks and free every second block, which creates &lt;code&gt;n&#x2F;2&lt;&#x2F;code&gt; freed blocks. We can‚Äôt rely on any upper bound of freed block since &lt;code&gt;n&lt;&#x2F;code&gt; could be arbitrarily large.&lt;&#x2F;li&gt;
&lt;li&gt;We can‚Äôt use any of the collections from above, since they rely on allocations themselves. (It might be possible as soon as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1398-kinds-of-allocators.md&quot;&gt;RFC #1398&lt;&#x2F;a&gt; is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;32838&quot;&gt;implemented&lt;&#x2F;a&gt;, which allows user-defined allocators for specific collection instances.)&lt;&#x2F;li&gt;
&lt;li&gt;We need to merge adjacent freed blocks if possible. Otherwise, the freed memory is no longer usable for large allocations. We will discuss this point in more detail below.&lt;&#x2F;li&gt;
&lt;li&gt;Our allocator should search the set of freed blocks quickly and keep fragmentation low.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;creating-a-list-of-freed-blocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-list-of-freed-blocks&quot; aria-label=&quot;Anchor link for: creating-a-list-of-freed-blocks&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a List of freed Blocks&lt;&#x2F;h3&gt;
&lt;p&gt;Where do we store the information about an unlimited number of freed blocks? We can‚Äôt use any fixed size data structure since it could always be too small for some allocation sequences. So we need some kind of dynamically growing set.&lt;&#x2F;p&gt;
&lt;p&gt;One possible solution could be to use an array-like data structure that starts at some unused virtual address. If the array becomes full, we increase its size and map new physical frames as backing storage. This approach would require a large part of the virtual address space since the array could grow significantly. We would need to create a custom implementation of a growable array and manipulate the page tables when deallocating. It would also consume a possibly large number of physical frames as backing storage.&lt;&#x2F;p&gt;
&lt;p&gt;We will choose another solution with different tradoffs. It‚Äôs not clearly ‚Äúbetter‚Äù than the approach above and has significant disadvantages itself. However, it has one big advantage: It does not need any additional physical or virtual memory at all. This makes it less complex since we don‚Äôt need to manipulate any page tables. The idea is the following:&lt;&#x2F;p&gt;
&lt;p&gt;A freed memory block is not used anymore and no one needs the stored information. It is still mapped to a virtual address and backed by a physical page. So we just store the information about the freed block &lt;em&gt;in the block itself&lt;&#x2F;em&gt;.  We keep a pointer to the first block and store a pointer to the next block in each block. Thus, we create a single linked list:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;overview.svg&quot; alt=&quot;Linked List Allocator&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the following, we call a freed block a &lt;em&gt;hole&lt;&#x2F;em&gt;. Each hole stores its size and a pointer to the next hole. If a hole is larger than needed, we leave the remaining memory unused. By storing a pointer to the first hole, we are able to traverse the complete list.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;initialization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#initialization&quot; aria-label=&quot;Anchor link for: initialization&quot;&gt;üîó&lt;&#x2F;a&gt;Initialization&lt;&#x2F;h4&gt;
&lt;p&gt;When the heap is created, all of its memory is unused. Thus, it forms a single large hole:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;initialization.svg&quot; alt=&quot;Heap Initialization&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The optional pointer to the next hole is set to &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;allocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocation&quot; aria-label=&quot;Anchor link for: allocation&quot;&gt;üîó&lt;&#x2F;a&gt;Allocation&lt;&#x2F;h4&gt;
&lt;p&gt;In order to allocate a block of memory, we need to find a hole that satisfies the size and alignment requirements. If the found hole is larger than required, we split it into two smaller holes. For example, when we allocate a 24 byte block right after initialization, we split the single hole into a hole of size 24 and a hole with the remaining size:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;split-hole.svg&quot; alt=&quot;split hole&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Then we use the new 24 byte hole to perform the allocation:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;allocate.svg&quot; alt=&quot;24 bytes allocated&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;To find a suitable hole, we can use several search strategies:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;best fit&lt;&#x2F;strong&gt;: Search the whole list and choose the &lt;em&gt;smallest&lt;&#x2F;em&gt; hole that satisfies the requirements.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;worst fit&lt;&#x2F;strong&gt;: Search the whole list and choose the &lt;em&gt;largest&lt;&#x2F;em&gt; hole that satisfies the requirements.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;first fit&lt;&#x2F;strong&gt;: Search the list from the beginning and choose the &lt;em&gt;first&lt;&#x2F;em&gt; hole that satisfies the requirements.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Each strategy has its advantages and disadvantages. Best fit uses the smallest hole possible and leaves larger holes for large allocations. But splitting the smallest hole might create a tiny hole, which is too small for most allocations. In contrast, the worst fit strategy always chooses the largest hole. Thus, it does not create tiny holes, but it consumes the large block, which might be required for large allocations.&lt;&#x2F;p&gt;
&lt;p&gt;For our use case, the best fit strategy is better than worst fit. The reason is that we have a minimal hole size of 16 bytes, since each hole needs to be able to store a size (8 bytes) and a pointer to the next hole (8 bytes). Thus, even the best fit strategy leads to holes of usable size. Furthermore, we will need to allocate very large blocks occasionally (e.g. for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Direct_memory_access&quot;&gt;DMA&lt;&#x2F;a&gt; buffers).&lt;&#x2F;p&gt;
&lt;p&gt;However, both best fit and worst fit have a significant problem: They need to scan the whole list for each allocation in order to find the optimal block. This leads to long allocation times if the list is long. The first fit strategy does not have this problem, as it returns as soon as it finds a suitable hole. It is fairly fast for small allocations and might only need to scan the whole list for large allocations.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;deallocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deallocation&quot; aria-label=&quot;Anchor link for: deallocation&quot;&gt;üîó&lt;&#x2F;a&gt;Deallocation&lt;&#x2F;h4&gt;
&lt;p&gt;To deallocate a block of memory, we can just insert its corresponding hole somewhere into the list. However, we need to merge adjacent holes. Otherwise, we are unable to reuse the freed memory for larger allocations. For example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;deallocate.svg&quot; alt=&quot;deallocate memory, which leads to adjacent holes&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In order to use these adjacent holes for a large allocation, we need to merge them to a single large hole first:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;merge-holes-and-allocate.svg&quot; alt=&quot;merge adjacent holes and allocate large block&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The easiest way to ensure that adjacent holes are always merged, is to keep the hole list sorted by address. Thus, we only need to check the predecessor and the successor in the list when we free a memory block. If they are adjacent to the freed block, we merge the corresponding holes. Else, we insert the freed block as a new hole at the correct position.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;The detailed implementation would go beyond the scope of this post, since it contains several hidden difficulties. For example:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Several merge cases: Merge with the previous hole, merge with the next hole, merge with both holes.&lt;&#x2F;li&gt;
&lt;li&gt;We need to satisfy the alignment requirements, which requires additional splitting logic.&lt;&#x2F;li&gt;
&lt;li&gt;The minimal hole size of 16 bytes: We must not create smaller holes when splitting a hole.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I created the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;crate&#x2F;linked_list_allocator&#x2F;0.4.1&quot;&gt;linked_list_allocator&lt;&#x2F;a&gt; crate to handle all of these cases. It consists of a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.4.1&#x2F;linked_list_allocator&#x2F;struct.Heap.html&quot;&gt;Heap struct&lt;&#x2F;a&gt; that provides an &lt;code&gt;allocate_first_fit&lt;&#x2F;code&gt; and a &lt;code&gt;deallocate&lt;&#x2F;code&gt; method. It also contains a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;linked_list_allocator&#x2F;0.4.1&#x2F;linked_list_allocator&#x2F;struct.LockedHeap.html&quot;&gt;LockedHeap&lt;&#x2F;a&gt; type that wraps &lt;code&gt;Heap&lt;&#x2F;code&gt; into spinlock so that it‚Äôs usable as a static system allocator. If you are interested in the implementation details, check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;linked-list-allocator&quot;&gt;source code&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We need to add the extern crate to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; and our &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&amp;gt; cargo add linked_list_allocator
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; linked_list_allocator;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can change our global allocator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;linked_list_allocator::LockedHeap;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[global_allocator]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;: LockedHeap = LockedHeap::empty();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can‚Äôt initialize the linked list allocator statically, since it needs to initialize the first hole (like described &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;#initialization&quot;&gt;above&lt;&#x2F;a&gt;). This can‚Äôt be done at compile time, so the function can‚Äôt be a &lt;code&gt;const&lt;&#x2F;code&gt; function. Therefore we can only create an empty heap and initialize it later at runtime. For that, we add the following lines to our &lt;code&gt;rust_main&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; set up guard page and map the heap pages
&lt;&#x2F;span&gt;&lt;span&gt;    memory::init(boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; initialize the heap allocator
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2F;span&gt;&lt;span&gt;.lock().init(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It is important that we initialize the heap &lt;em&gt;after&lt;&#x2F;em&gt; mapping the heap pages, since the init function writes to the heap memory (the first hole).&lt;&#x2F;p&gt;
&lt;p&gt;Our kernel uses the new allocator now, so we can deallocate memory without leaking it. The example from above should work now without causing an OOM situation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10000 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some String&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;performance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#performance&quot; aria-label=&quot;Anchor link for: performance&quot;&gt;üîó&lt;&#x2F;a&gt;Performance&lt;&#x2F;h3&gt;
&lt;p&gt;The linked list based approach has some performance problems. Each allocation or deallocation might need to scan the complete list of holes in the worst case. However, I think it‚Äôs good enough for now, since our heap will stay relatively small for the near future. When our allocator becomes a performance problem eventually, we can just replace it with a faster alternative.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;üîó&lt;&#x2F;a&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Now we‚Äôre able to use heap storage in our kernel without leaking memory. This allows us to effectively process dynamic data such as user supplied strings in the future. We can also use &lt;code&gt;Rc&lt;&#x2F;code&gt; and &lt;code&gt;Arc&lt;&#x2F;code&gt; to create types with shared ownership. And we have access to various data structures such as &lt;code&gt;Vec&lt;&#x2F;code&gt; or &lt;code&gt;Linked List&lt;&#x2F;code&gt;, which will make our lives much easier. We even have some well tested and optimized &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_heap&quot;&gt;binary heap&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;B-tree&quot;&gt;B-tree&lt;&#x2F;a&gt; implementations!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;This post concludes the section about memory management for now. We will revisit this topic eventually, but now it‚Äôs time to explore other topics. The upcoming posts will be about CPU exceptions and interrupts. We will catch all page, double, and triple faults and create a driver to read keyboard input. The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; starts by setting up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Remap the Kernel</title>
                <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/remap-the-kernel/</link>
                <guid>https://os.phil-opp.com/remap-the-kernel/</guid>
                <description>&lt;p&gt;In this post we will create a new page table to map the kernel sections correctly. Therefore we will extend the paging module to support modifications of &lt;em&gt;inactive&lt;&#x2F;em&gt; page tables as well. Then we will switch to the new table and secure our kernel stack by creating a guard page.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;As always, you can find the source code on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_7&quot;&gt;GitHub&lt;&#x2F;a&gt;. Don‚Äôt hesitate to file issues there if you have any problems or improvement suggestions. There is also a comment section at the end of this page. Note that this post requires a current Rust nightly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;motivation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation&quot; aria-label=&quot;Anchor link for: motivation&quot;&gt;üîó&lt;&#x2F;a&gt;Motivation&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt;, we had a strange bug in the &lt;code&gt;unmap&lt;&#x2F;code&gt; function. Its reason was a silent stack overflow, which corrupted the page tables. Fortunately, our kernel stack is right above the page tables so that we noticed the overflow relatively quickly. This won‚Äôt be the case when we add threads with new stacks in the future. Then a silent stack overflow could overwrite some data without us noticing. But eventually some completely unrelated function fails because a variable changed its value.&lt;&#x2F;p&gt;
&lt;p&gt;As you can imagine, these kinds of bugs are horrendous to debug. For that reason we will create a new hierarchical page table in this post, which has &lt;em&gt;guard page&lt;&#x2F;em&gt; below the stack. A guard page is basically an unmapped page that causes a page fault when accessed. Thus we can catch stack overflows right when they happen.&lt;&#x2F;p&gt;
&lt;p&gt;Also, we will use the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#kernel-elf-sections&quot;&gt;information about kernel sections&lt;&#x2F;a&gt; to map the various sections individually instead of blindly mapping the first gigabyte. To improve safety even further, we will set the correct page table flags for the various sections. Thus it won‚Äôt be possible to modify the contents of &lt;code&gt;.text&lt;&#x2F;code&gt; or to execute code from &lt;code&gt;.data&lt;&#x2F;code&gt; anymore.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;preparation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preparation&quot; aria-label=&quot;Anchor link for: preparation&quot;&gt;üîó&lt;&#x2F;a&gt;Preparation&lt;&#x2F;h2&gt;
&lt;p&gt;There are many things that can go wrong when we switch to a new table. Therefore it‚Äôs a good idea to &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-gdb&#x2F;&quot;&gt;set up a debugger&lt;&#x2F;a&gt;. You should not need it when you follow this post, but it‚Äôs good to know how to debug a problem when it occurs&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-debug-notes&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We also update the &lt;code&gt;Page&lt;&#x2F;code&gt; and &lt;code&gt;Frame&lt;&#x2F;code&gt; types to make our lives easier. The &lt;code&gt;Page&lt;&#x2F;code&gt; struct gets some derived traits:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Page {
&lt;&#x2F;span&gt;&lt;span&gt;    number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By making it &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;Copy&lt;&#x2F;a&gt;, we can still use it after passing it to functions such as &lt;code&gt;map_to&lt;&#x2F;code&gt;. We also make the &lt;code&gt;Page::containing_address&lt;&#x2F;code&gt; public (if it isn‚Äôt already).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Frame&lt;&#x2F;code&gt; type gets a &lt;code&gt;clone&lt;&#x2F;code&gt; method too, but it does not implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;clone&#x2F;trait.Clone.html&quot;&gt;Clone trait&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Frame {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clone(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Frame {
&lt;&#x2F;span&gt;&lt;span&gt;        Frame { number: self.number }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The big difference is that this &lt;code&gt;clone&lt;&#x2F;code&gt; method is private. If we implemented the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;clone&#x2F;trait.Clone.html&quot;&gt;Clone trait&lt;&#x2F;a&gt;, it would be public and usable from other modules. For example they could abuse it to free the same frame twice in the frame allocator.&lt;&#x2F;p&gt;
&lt;p&gt;So why do we implement &lt;code&gt;Copy&lt;&#x2F;code&gt; for &lt;code&gt;Page&lt;&#x2F;code&gt; and make even its constructor public, but keep &lt;code&gt;Frame&lt;&#x2F;code&gt; as private as possible? The reason is that we can easily check the status of a &lt;code&gt;Page&lt;&#x2F;code&gt; by looking at the page tables. For example, the &lt;code&gt;map_to&lt;&#x2F;code&gt; function can easily check that the given page is unused.&lt;&#x2F;p&gt;
&lt;p&gt;We can‚Äôt do that for a &lt;code&gt;Frame&lt;&#x2F;code&gt;. If we wanted to be sure that a given frame is unused, we would need to look at all mapped &lt;em&gt;pages&lt;&#x2F;em&gt; and verify that none of them is mapped to the given frame. Since this is impractical, we need to rely on the fact that a passed &lt;code&gt;Frame&lt;&#x2F;code&gt; is always unused. For that reason it must not be possible to create a new &lt;code&gt;Frame&lt;&#x2F;code&gt; or to clone one from other modules. The only valid way to get a frame is to allocate it from a &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recap-the-paging-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recap-the-paging-module&quot; aria-label=&quot;Anchor link for: recap-the-paging-module&quot;&gt;üîó&lt;&#x2F;a&gt;Recap: The Paging Module&lt;&#x2F;h2&gt;
&lt;p&gt;This post builds upon the post about &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;page tables&lt;&#x2F;a&gt;, so let‚Äôs start by quickly recapitulating what we‚Äôve done there.&lt;&#x2F;p&gt;
&lt;p&gt;We created a &lt;code&gt;memory::paging&lt;&#x2F;code&gt; module, which reads and modifies the hierarchical page table through recursive mapping. The owner of the active P4 table and thus all subtables is an &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; struct, which must be instantiated only once.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; struct provides the following interface:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Translates a virtual to the corresponding physical address.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns `None` if the address is not mapped.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;translate(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, virtual_address: VirtualAddress) -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Option&amp;lt;PhysicalAddress&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Maps the page to the frame with the provided flags.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; The `PRESENT` flag is added by default. Needs a
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `FrameAllocator` as it might need to create new page tables.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map_to&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                 page: Page,
&lt;&#x2F;span&gt;&lt;span&gt;                 frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;                 flags: EntryFlags,
&lt;&#x2F;span&gt;&lt;span&gt;                 allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Maps the page to some free frame with the provided flags.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; The free frame is allocated from the given `FrameAllocator`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, page: Page, flags: EntryFlags, allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Identity map the the given frame with the provided flags.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; The `FrameAllocator` is used to create new page tables if needed.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;identity_map&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                       frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;                       flags: EntryFlags,
&lt;&#x2F;span&gt;&lt;span&gt;                       allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Unmaps the given page and adds all freed frames to the given
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; `FrameAllocator`.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;unmap&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, page: Page, allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;üîó&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;Our goal is to use the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; functions to map the kernel sections correctly in a new page table. In pseudo code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel(boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_table = create_new_table();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; boot_info.elf_sections {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; section {
&lt;&#x2F;span&gt;&lt;span&gt;            new_table.identity_map(frame, section.flags);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    new_table.activate();
&lt;&#x2F;span&gt;&lt;span&gt;    create_guard_page_for_stack();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; methods ‚Äì as the name suggests ‚Äì only work for the &lt;em&gt;active table&lt;&#x2F;em&gt;. So we would need to activate &lt;code&gt;new_table&lt;&#x2F;code&gt; &lt;em&gt;before&lt;&#x2F;em&gt; we use &lt;code&gt;identity_map&lt;&#x2F;code&gt;. But this is not possible since it would cause an immediate page fault when the CPU tries to read the next instruction.&lt;&#x2F;p&gt;
&lt;p&gt;So we need a way to use the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; methods on &lt;em&gt;inactive&lt;&#x2F;em&gt; page tables as well.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;inactive-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#inactive-tables&quot; aria-label=&quot;Anchor link for: inactive-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Inactive Tables&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs start by creating a type for inactive page tables. Like an &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt;, an &lt;code&gt;InactivePageTable&lt;&#x2F;code&gt; owns a P4 table. The difference is that the inactive P4 table is not used by the CPU.&lt;&#x2F;p&gt;
&lt;p&gt;We create the struct in &lt;code&gt;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    p4_frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(frame: Frame) -&amp;gt; InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO zero and recursive map the frame
&lt;&#x2F;span&gt;&lt;span&gt;        InactivePageTable { p4_frame: frame }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Without zeroing, the P4 table contains complete garbage and maps random memory. But we can‚Äôt zero it right now because the &lt;code&gt;p4_frame&lt;&#x2F;code&gt; is not mapped to a virtual address.&lt;&#x2F;p&gt;
&lt;p&gt;Well, maybe it‚Äôs still part of the identity mapped first gigabyte. Then we could zero it without problems since the physical address would be a valid virtual address, too. But this ‚Äúsolution‚Äù is hacky and won‚Äôt work after this post anymore (since we will remove all needless identity mapping).&lt;&#x2F;p&gt;
&lt;p&gt;Instead, we will try to temporary map the frame to some virtual address.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;temporary-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#temporary-mapping&quot; aria-label=&quot;Anchor link for: temporary-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Temporary Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;Therefor we add a &lt;code&gt;TemporaryPage&lt;&#x2F;code&gt; struct. We create it in a new &lt;code&gt;temporary_page&lt;&#x2F;code&gt; submodule to keep the paging module clean. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;temporary_page;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; src&#x2F;memory&#x2F;paging&#x2F;temporary_page.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::Page;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;TemporaryPage {
&lt;&#x2F;span&gt;&lt;span&gt;    page: Page,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add methods to temporary map and unmap the page:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::{ActivePageTable, VirtualAddress};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::Frame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TemporaryPage {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Maps the temporary page to the given frame in the active table.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns the start address of the temporary page.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, frame: Frame, active_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; VirtualAddress
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::entry::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(active_table.translate_page(self.page).is_none(),
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;temporary page is already mapped&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        active_table.map_to(self.page, frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;???&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        self.page.start_address()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Unmaps the temporary page in the active table.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;unmap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, active_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable) {
&lt;&#x2F;span&gt;&lt;span&gt;        active_table.unmap(self.page, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;???&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;???&lt;&#x2F;code&gt; needs to be some &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt;. We could just add an additional &lt;code&gt;allocator&lt;&#x2F;code&gt; argument but there is a better solution.&lt;&#x2F;p&gt;
&lt;p&gt;It takes advantage of the fact that we always map the same page. So the allocator only needs to hold 3 frames: one P3, one P2, and one P1 table (the P4 table is always mapped). This allows us to create a tiny allocator and add it as field to the &lt;code&gt;TemporaryPage&lt;&#x2F;code&gt; struct itself:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;TemporaryPage {
&lt;&#x2F;span&gt;&lt;span&gt;    page: Page,
&lt;&#x2F;span&gt;&lt;span&gt;    allocator: TinyAllocator,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TemporaryPage {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; as above, but with `&amp;amp;mut self.allocator` instead of `???`
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TinyAllocator([Option&amp;lt;Frame&amp;gt;; 3]);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our tiny allocator just consists of 3 slots to store frames. It will be empty when the temporary page is mapped and full when all corresponding page tables are unmapped.&lt;&#x2F;p&gt;
&lt;p&gt;To turn &lt;code&gt;TinyAllocator&lt;&#x2F;code&gt; into a frame allocator, we need to add the trait implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::FrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;TinyAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame_option &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; frame_option.is_some() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; frame_option.take();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deallocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, frame: Frame) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame_option &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; frame_option.is_none() {
&lt;&#x2F;span&gt;&lt;span&gt;                *frame_option = Some(frame);
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Tiny allocator can hold only 3 frames.&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On allocation, we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.take&quot;&gt;Option::take&lt;&#x2F;a&gt; function to take an available frame from the first filled slot and on deallocation, we put the frame back into the first free slot.&lt;&#x2F;p&gt;
&lt;p&gt;To finish the &lt;code&gt;TinyAllocator&lt;&#x2F;code&gt;, we add a constructor that fills it from some other allocator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TinyAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A) -&amp;gt; TinyAllocator
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut &lt;&#x2F;span&gt;&lt;span&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;|| allocator.allocate_frame();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frames = [f(), f(), f()];
&lt;&#x2F;span&gt;&lt;span&gt;        TinyAllocator(frames)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use a little closure here that saves us some typing.&lt;&#x2F;p&gt;
&lt;p&gt;Now our &lt;code&gt;TemporaryPage&lt;&#x2F;code&gt; type is nearly complete. We only add one more method for convenience:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::table::{Table, Level1};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; Maps the temporary page to the given page table frame in the active
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;&#x2F; table. Returns a reference to the now mapped table.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map_table_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                       frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;                       active_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable)
&lt;&#x2F;span&gt;&lt;span&gt;                       -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level1&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(self.map(frame, active_table) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level1&amp;gt;) }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function interprets the given frame as a page table frame and returns a &lt;code&gt;Table&lt;&#x2F;code&gt; reference. We return a table of level 1 because it &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;#some-clever-solution&quot;&gt;forbids calling the &lt;code&gt;next_table&lt;&#x2F;code&gt; methods&lt;&#x2F;a&gt;. Calling &lt;code&gt;next_table&lt;&#x2F;code&gt; must not be possible since it‚Äôs not a page of the recursive mapping. To be able to return a &lt;code&gt;Table&amp;lt;Level1&amp;gt;&lt;&#x2F;code&gt;, we need to make the &lt;code&gt;Level1&lt;&#x2F;code&gt; enum in &lt;code&gt;memory&#x2F;paging&#x2F;table.rs&lt;&#x2F;code&gt; public.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;unsafe&lt;&#x2F;code&gt; block is safe since the &lt;code&gt;VirtualAddress&lt;&#x2F;code&gt; returned by the &lt;code&gt;map&lt;&#x2F;code&gt; function is always valid and the type cast just reinterprets the frame‚Äôs content.&lt;&#x2F;p&gt;
&lt;p&gt;To complete the &lt;code&gt;temporary_page&lt;&#x2F;code&gt; module, we add a &lt;code&gt;TemporaryPage::new&lt;&#x2F;code&gt; constructor:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new&amp;lt;A&amp;gt;(page: Page, allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A) -&amp;gt; TemporaryPage
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    TemporaryPage {
&lt;&#x2F;span&gt;&lt;span&gt;        page: page,
&lt;&#x2F;span&gt;&lt;span&gt;        allocator: TinyAllocator::new(allocator),
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zeroing-the-inactivepagetable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#zeroing-the-inactivepagetable&quot; aria-label=&quot;Anchor link for: zeroing-the-inactivepagetable&quot;&gt;üîó&lt;&#x2F;a&gt;Zeroing the InactivePageTable&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can use &lt;code&gt;TemporaryPage&lt;&#x2F;code&gt; to fix our &lt;code&gt;InactivePageTable::new&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::temporary_page::TemporaryPage;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;               active_table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;               temporary_page: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; TemporaryPage)
&lt;&#x2F;span&gt;&lt;span&gt;               -&amp;gt; InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; table = temporary_page.map_table_frame(frame.clone(),
&lt;&#x2F;span&gt;&lt;span&gt;                active_table);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; now we are able to zero the table
&lt;&#x2F;span&gt;&lt;span&gt;            table.zero();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; set up recursive mapping for the table
&lt;&#x2F;span&gt;&lt;span&gt;            table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2F;span&gt;&lt;span&gt;].set(frame.clone(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        temporary_page.unmap(active_table);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        InactivePageTable { p4_frame: frame }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We added two new arguments, &lt;code&gt;active_table&lt;&#x2F;code&gt; and &lt;code&gt;temporary_page&lt;&#x2F;code&gt;. We need an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;variable_bindings&#x2F;scope.html&quot;&gt;inner scope&lt;&#x2F;a&gt; to ensure that the &lt;code&gt;table&lt;&#x2F;code&gt; variable is dropped before we try to unmap the temporary page again. This is required since the &lt;code&gt;table&lt;&#x2F;code&gt; variable exclusively borrows &lt;code&gt;temporary_page&lt;&#x2F;code&gt; as long as it‚Äôs alive.&lt;&#x2F;p&gt;
&lt;p&gt;Now we are able to create valid inactive page tables, which are zeroed and recursively mapped. But we still can‚Äôt modify them. To resolve this problem, we need to look at recursive mapping again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;revisiting-recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#revisiting-recursive-mapping&quot; aria-label=&quot;Anchor link for: revisiting-recursive-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Revisiting Recursive Mapping&lt;&#x2F;h2&gt;
&lt;p&gt;Recursive mapping works by mapping the last P4 entry to the P4 table itself. Thus we can access the page tables by looping one or more times.&lt;&#x2F;p&gt;
&lt;p&gt;For example, accessing a P3 table requires lopping three times:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;recursive_mapping_access_p3.svg&quot; alt=&quot;access active P3 table through recursive mapping&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can use the same mechanism to access inactive tables. The trick is to change the recursive mapping of the active P4 table to point to the inactive P4 table:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;recursive_mapping_access_p3_inactive_table.svg&quot; alt=&quot;access inactive P3 table through recursive mapping&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now the inactive table can be accessed exactly as the active table, even the magic addresses are the same. This allows us to use the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; interface and the existing mapping methods for inactive tables, too. Note that everything besides the recursive mapping continues to work exactly as before since we‚Äôve never changed the active table in the CPU.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation-draft&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-draft&quot; aria-label=&quot;Anchor link for: implementation-draft&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation Draft&lt;&#x2F;h3&gt;
&lt;p&gt;We add a method to &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; that temporary changes the recursive mapping and executes a given closure in the new context:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;with&amp;lt;F&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;               table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; InactivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;               f: F)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; F: FnOnce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; ActivePageTable)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tlb;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; overwrite recursive mapping
&lt;&#x2F;span&gt;&lt;span&gt;    self.p4_mut()[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2F;span&gt;&lt;span&gt;].set(table.p4_frame.clone(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    tlb::flush_all();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; execute f in the new context
&lt;&#x2F;span&gt;&lt;span&gt;    f(self);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO restore recursive mapping to original p4 table
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It overwrites the 511th P4 entry and points it to the inactive table frame. Then it flushes the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;TLB&quot;&gt;translation lookaside buffer (TLB)&lt;&#x2F;a&gt;, which still contains some old translations. We need to flush all pages that are part of the recursive mapping, so the easiest way is to flush the TLB completely.&lt;&#x2F;p&gt;
&lt;p&gt;Now that the recursive mapping points to the given inactive table, we execute the closure in the new context. The closure can call all active table methods such as &lt;code&gt;translate&lt;&#x2F;code&gt; or &lt;code&gt;map_to&lt;&#x2F;code&gt;. It could even call &lt;code&gt;with&lt;&#x2F;code&gt; again and chain another inactive table! Wait‚Ä¶ that would not work:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;recursive_mapping_access_p1_invalid_chaining.svg&quot; alt=&quot;access inactive P3 table through recursive mapping&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here the closure called &lt;code&gt;with&lt;&#x2F;code&gt; again and thus changed the recursive mapping of the inactive table to point to a second inactive table. Now we want to modify the P1 of the &lt;em&gt;second&lt;&#x2F;em&gt; inactive table, but instead we land on the P1 of the &lt;em&gt;first&lt;&#x2F;em&gt; inactive table since we never follow the pointer to the second table. Only when modifying the P2, P3, or P4 table we really access the second inactive table. This inconsistency would break our mapping functions completely.&lt;&#x2F;p&gt;
&lt;p&gt;So we should really prohibit the closure from calling &lt;code&gt;with&lt;&#x2F;code&gt; again. We could add some runtime assertion that panics when the active table is not recursive mapped anymore. But a cleaner solution is to split off the mapping code from &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; into a new &lt;code&gt;Mapper&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;refactoring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#refactoring&quot; aria-label=&quot;Anchor link for: refactoring&quot;&gt;üîó&lt;&#x2F;a&gt;Refactoring&lt;&#x2F;h3&gt;
&lt;p&gt;We start by creating a new &lt;code&gt;memory&#x2F;paging&#x2F;mapper.rs&lt;&#x2F;code&gt; submodule and moving the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; struct and its &lt;code&gt;impl&lt;&#x2F;code&gt; block to it. Then we rename it to &lt;code&gt;Mapper&lt;&#x2F;code&gt; and make all methods public (so we can still use them from the paging module). The &lt;code&gt;with&lt;&#x2F;code&gt; method is removed.&lt;&#x2F;p&gt;
&lt;p&gt;After adjusting the imports, the module should look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;mapper;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; memory&#x2F;paging&#x2F;mapper.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::{VirtualAddress, PhysicalAddress, Page, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::entry::*;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2F;span&gt;&lt;span&gt;::table::{self, Table, Level4, Level1};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;, Frame, FrameAllocator};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::Unique;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Mapper {
&lt;&#x2F;span&gt;&lt;span&gt;    p4: Unique&amp;lt;Table&amp;lt;Level4&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Mapper {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; Mapper {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;p4(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the remaining mapping methods, all public
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we create a new &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; struct in &lt;code&gt;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2F;span&gt;&lt;span&gt;self::mapper::Mapper;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ops::{Deref, DerefMut};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    mapper: Mapper,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Deref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Target &lt;&#x2F;span&gt;&lt;span&gt;= Mapper;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deref(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Mapper {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self.mapper
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;DerefMut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deref_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Mapper {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.mapper
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;        ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;            mapper: Mapper::new(),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;with&amp;lt;F&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                   table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; InactivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;                   f: F)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; F: FnOnce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Mapper) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `Mapper` instead of `ActivePageTable`
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ops&#x2F;trait.Deref.html&quot;&gt;Deref&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ops&#x2F;trait.DerefMut.html&quot;&gt;DerefMut&lt;&#x2F;a&gt; implementations allow us to use the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; exactly as before, for example we still can call &lt;code&gt;map_to&lt;&#x2F;code&gt; on it (because of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;book&#x2F;deref-coercions.html&quot;&gt;deref coercions&lt;&#x2F;a&gt;). But the closure called in the &lt;code&gt;with&lt;&#x2F;code&gt; function can no longer invoke &lt;code&gt;with&lt;&#x2F;code&gt; again. The reason is that we changed the type of the generic &lt;code&gt;F&lt;&#x2F;code&gt; parameter a bit: Instead of an &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt;, the closure just gets a &lt;code&gt;Mapper&lt;&#x2F;code&gt; as argument.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;restoring-the-recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#restoring-the-recursive-mapping&quot; aria-label=&quot;Anchor link for: restoring-the-recursive-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Restoring the Recursive Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;Right now, the &lt;code&gt;with&lt;&#x2F;code&gt; function overwrites the recursive mapping and calls the closure. But it does not restore the previous recursive mapping yet. So let‚Äôs fix that!&lt;&#x2F;p&gt;
&lt;p&gt;To backup the physical P4 frame of the active table, we can either read it from the 511th P4 entry (before we change it) or from the CR3 control register directly. We will do the latter as it should be faster and we already have a external crate that makes it easy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control_regs;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; backup = Frame::containing_address(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ control_regs::cr3() } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Why is it unsafe? Because reading the CR3 register leads to a CPU exception if the processor is not running in kernel mode (&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Security#Low-level_Protection_Mechanisms&quot;&gt;Ring 0&lt;&#x2F;a&gt;). But this code will always run in kernel mode, so the &lt;code&gt;unsafe&lt;&#x2F;code&gt; block is completely safe here.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have a backup of the original P4 frame, we need a way to restore it after the closure has run. So we need to somehow modify the 511th entry of the original P4 frame, which is still the active table in the CPU. But we can‚Äôt access it because the recursive mapping now points to the inactive table:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;recursive_mapping_inactive_table_scheme.svg&quot; alt=&quot;it‚Äôs not possible to access the original P4 through recursive mapping anymore&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It‚Äôs just not possible to access the active P4 entry in 4 steps, so we can‚Äôt reach it through the 4-level page table.&lt;&#x2F;p&gt;
&lt;p&gt;We could try to overwrite the recursive mapping of the &lt;em&gt;inactive&lt;&#x2F;em&gt; P4 table and point it back to the original P4 frame:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;cyclic_mapping_inactive_tables.svg&quot; alt=&quot;cyclic map active and inactive P4 tables&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Now we can reach the active P4 entry in 4 steps and could restore the original mapping in the active table. But this hack has a drawback: The inactive table is now invalid since it is no longer recursive mapped. We would need to fix it by using a temporary page again (as above).&lt;&#x2F;p&gt;
&lt;p&gt;But if we need a temporary page anyway, we can just use it to map the original P4 frame directly. Thus we avoid the above hack and make the code simpler. So let‚Äôs do it that way.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;completing-the-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#completing-the-implementation&quot; aria-label=&quot;Anchor link for: completing-the-implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Completing the Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;with&lt;&#x2F;code&gt; method gets an additional &lt;code&gt;TemporaryPage&lt;&#x2F;code&gt; argument, which we use to backup and restore the original recursive mapping:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;with&amp;lt;F&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                   table: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; InactivePageTable,
&lt;&#x2F;span&gt;&lt;span&gt;                   temporary_page: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;temporary_page::TemporaryPage, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;                   f: F)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; F: FnOnce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Mapper)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tlb;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control_regs;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; backup = Frame::containing_address(
&lt;&#x2F;span&gt;&lt;span&gt;            control_regs::cr3().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; map temporary_page to current p4 table
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p4_table = temporary_page.map_table_frame(backup.clone(), self);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; overwrite recursive mapping
&lt;&#x2F;span&gt;&lt;span&gt;        self.p4_mut()[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2F;span&gt;&lt;span&gt;].set(table.p4_frame.clone(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        tlb::flush_all();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; execute f in the new context
&lt;&#x2F;span&gt;&lt;span&gt;        f(self);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; restore recursive mapping to original p4 table
&lt;&#x2F;span&gt;&lt;span&gt;        p4_table[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2F;span&gt;&lt;span&gt;].set(backup, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        tlb::flush_all();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    temporary_page.unmap(self);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again, the inner scope is needed to end the borrow of &lt;code&gt;temporary_page&lt;&#x2F;code&gt; so that we can unmap it again. Note that we need to flush the TLB another time after we restored the original recursive mapping.&lt;&#x2F;p&gt;
&lt;p&gt;Now the &lt;code&gt;with&lt;&#x2F;code&gt; function is ready to be used!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;remapping-the-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#remapping-the-kernel&quot; aria-label=&quot;Anchor link for: remapping-the-kernel&quot;&gt;üîó&lt;&#x2F;a&gt;Remapping the Kernel&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs tackle the main task of this post: remapping the kernel sections. Therefor we create a &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; function in &lt;code&gt;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;multiboot2::BootInformation;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;, Frame, FrameAllocator};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A, boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page = TemporaryPage::new(Page { number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xcafebabe &lt;&#x2F;span&gt;&lt;span&gt;},
&lt;&#x2F;span&gt;&lt;span&gt;        allocator);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; active_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ActivePageTable::new() };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; new_table = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = allocator.allocate_frame().expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no more frames&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        InactivePageTable::new(frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; active_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    active_table.with(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; new_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page, |mapper| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag = boot_info.elf_sections_tag()
&lt;&#x2F;span&gt;&lt;span&gt;            .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag.sections() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO mapper.identity_map() all pages of `section`
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we create a temporary page at page number &lt;code&gt;0xcafebabe&lt;&#x2F;code&gt;. We could use &lt;code&gt;0xdeadbeaf&lt;&#x2F;code&gt; or &lt;code&gt;0x123456789&lt;&#x2F;code&gt; as well, as long as the page is unused. The &lt;code&gt;active_table&lt;&#x2F;code&gt; and the &lt;code&gt;new_table&lt;&#x2F;code&gt; are created using their constructor functions.&lt;&#x2F;p&gt;
&lt;p&gt;Then we use the &lt;code&gt;with&lt;&#x2F;code&gt; function to temporary change the recursive mapping and execute the closure as if the &lt;code&gt;new_table&lt;&#x2F;code&gt; were active. This allows us to map the sections in the new table without changing the active mapping. To get the kernel sections, we use the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#the-multiboot-information-structure&quot;&gt;Multiboot information structure&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs resolve the above &lt;code&gt;TODO&lt;&#x2F;code&gt; by identity mapping the sections:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag.sections() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::entry::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;section.is_allocated() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; section is not loaded to memory
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(section.start_address() % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;sections need to be page aligned&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping section at addr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        section.addr, section.size);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO use real section flags
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start_frame = Frame::containing_address(section.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; end_frame = Frame::containing_address(section.end_address() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;Frame::range_inclusive(start_frame, end_frame) {
&lt;&#x2F;span&gt;&lt;span&gt;        mapper.identity_map(frame, flags, allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We skip all sections that were not loaded into memory (e.g. debug sections). We require that all sections are page aligned because a page must not contain sections with different flags. For example, we would need to set the &lt;code&gt;EXECUTABLE&lt;&#x2F;code&gt; and &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flags for a page that contains parts of the &lt;code&gt;.code&lt;&#x2F;code&gt; and &lt;code&gt;.data&lt;&#x2F;code&gt; section. Thus we could modify the running code or execute bytes from the &lt;code&gt;.data&lt;&#x2F;code&gt; section as code.&lt;&#x2F;p&gt;
&lt;p&gt;To map a section, we iterate over all of its frames of a section by using a new &lt;code&gt;Frame::range_inclusive&lt;&#x2F;code&gt; function (shown below). Note that the end address is exclusive, so that it‚Äôs not part of the section anymore (it‚Äôs the first byte of the next section). Thus we need to subtract 1 to get the &lt;code&gt;end_frame&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Frame::range_inclusive&lt;&#x2F;code&gt; function looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Frame {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;range_inclusive(start: Frame, end: Frame) -&amp;gt; FrameIter {
&lt;&#x2F;span&gt;&lt;span&gt;        FrameIter {
&lt;&#x2F;span&gt;&lt;span&gt;            start: start,
&lt;&#x2F;span&gt;&lt;span&gt;            end: end,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;FrameIter {
&lt;&#x2F;span&gt;&lt;span&gt;    start: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;    end: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FrameIter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2F;span&gt;&lt;span&gt;= Frame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;next(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.start &amp;lt;= self.end {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = self.start.clone();
&lt;&#x2F;span&gt;&lt;span&gt;            self.start.number += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            Some(frame)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            None
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt; }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of creating a custom iterator, we could have used the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ops&#x2F;struct.Range.html&quot;&gt;Range&lt;&#x2F;a&gt; struct of the standard library. But it requires that we implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;core&#x2F;num&#x2F;trait.One.html&quot;&gt;One&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ops&#x2F;trait.Add.html&quot;&gt;Add&lt;&#x2F;a&gt; traits for &lt;code&gt;Frame&lt;&#x2F;code&gt;. Then every module could perform arithmetic operations on frames, for example &lt;code&gt;let frame3 = frame1 + frame2&lt;&#x2F;code&gt;. This would violate our safety invariants because &lt;code&gt;frame3&lt;&#x2F;code&gt; could be already in use. The &lt;code&gt;range_inclusive&lt;&#x2F;code&gt; function does not have these problems because it is only available inside the &lt;code&gt;memory&lt;&#x2F;code&gt; module.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-align-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-align-sections&quot; aria-label=&quot;Anchor link for: page-align-sections&quot;&gt;üîó&lt;&#x2F;a&gt;Page Align Sections&lt;&#x2F;h3&gt;
&lt;p&gt;Right now our sections aren‚Äôt page aligned, so the assertion in &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; would fail. We can fix this by making the section size a multiple of the page size. To do this, we add an &lt;code&gt;ALIGN&lt;&#x2F;code&gt; statement to all sections in the linker file. For example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;SECTIONS {
&lt;&#x2F;span&gt;&lt;span&gt;  . = 1M;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .text :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.text .text.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;.&lt;&#x2F;code&gt; is the ‚Äúcurrent location counter‚Äù and represents the current virtual address. At the beginning of the &lt;code&gt;SECTIONS&lt;&#x2F;code&gt; tag we set it to &lt;code&gt;1M&lt;&#x2F;code&gt;, so our kernel starts at 1MiB. We use the &lt;a href=&quot;https:&#x2F;&#x2F;www.math.utah.edu&#x2F;docs&#x2F;info&#x2F;ld_3.html#SEC12&quot;&gt;ALIGN&lt;&#x2F;a&gt; function to align the current location counter to the next &lt;code&gt;4K&lt;&#x2F;code&gt; boundary (&lt;code&gt;4K&lt;&#x2F;code&gt; is the page size). Thus the end of the &lt;code&gt;.text&lt;&#x2F;code&gt; section ‚Äì and the beginning of the next section ‚Äì are page aligned.&lt;&#x2F;p&gt;
&lt;p&gt;To put all sections on their own page, we add the &lt;code&gt;ALIGN&lt;&#x2F;code&gt; statement to all of them:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;* src&#x2F;arch&#x2F;x86_64&#x2F;linker.ld *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;ENTRY(start)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;SECTIONS {
&lt;&#x2F;span&gt;&lt;span&gt;  . = 1M;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .rodata :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;* ensure that the multiboot header is at the beginning *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    KEEP(*(.multiboot_header))
&lt;&#x2F;span&gt;&lt;span&gt;    *(.rodata .rodata.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .text :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.text .text.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .data :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.data .data.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .bss :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.bss .bss.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .got :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.got)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .got.plt :
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.got.plt)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .data.rel.ro : ALIGN(4K) {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.data.rel.ro.local*) *(.data.rel.ro .data.rel.ro.*)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  .gcc_except_table : ALIGN(4K) {
&lt;&#x2F;span&gt;&lt;span&gt;    *(.gcc_except_table)
&lt;&#x2F;span&gt;&lt;span&gt;    . = ALIGN(4K);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of page aligning the &lt;code&gt;.multiboot_header&lt;&#x2F;code&gt; section, we merge it into the &lt;code&gt;.rodata&lt;&#x2F;code&gt; section. That way, we don‚Äôt waste a whole page for the few bytes of the Multiboot header. We could merge it into any section, but &lt;code&gt;.rodata&lt;&#x2F;code&gt; fits best because it has the same flags (neither writable nor executable). The Multiboot header still needs to be at the beginning of the file, so &lt;code&gt;.rodata&lt;&#x2F;code&gt; must be our first section now.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h3&gt;
&lt;p&gt;Time to test it! We re-export the &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; function from the memory module and call it from &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2F;span&gt;&lt;span&gt;self::paging::remap_the_kernel;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ATTENTION: we have a very small stack and no guard page
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the same as before
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::clear_screen();
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; boot_info = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot2::load(multiboot_information_address)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; memory_map_tag = boot_info.memory_map_tag()
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag = boot_info.elf_sections_tag()
&lt;&#x2F;span&gt;&lt;span&gt;        .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf sections tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_start = elf_sections_tag.sections().map(|s| s.addr)
&lt;&#x2F;span&gt;&lt;span&gt;        .min().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_end = elf_sections_tag.sections().map(|s| s.addr + s.size)
&lt;&#x2F;span&gt;&lt;span&gt;        .max().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_start = multiboot_information_address;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_end = multiboot_start + (boot_info.total_size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel start: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, kernel end: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        kernel_start, kernel_end);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;multiboot start: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, multiboot end: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot_start, multiboot_end);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = memory::AreaFrameAllocator::new(
&lt;&#x2F;span&gt;&lt;span&gt;        kernel_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, kernel_end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, multiboot_start,
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot_end, memory_map_tag.memory_areas());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; this is the new part
&lt;&#x2F;span&gt;&lt;span&gt;    memory::remap_the_kernel(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator, boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you see the &lt;code&gt;It did not crash&lt;&#x2F;code&gt; message, the kernel survived our page table modifications without causing a CPU exception. But did we map the kernel sections correctly?&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs try it out by switching to the new table! We identity map all kernel sections, so it should work without problems.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;switching-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-tables&quot; aria-label=&quot;Anchor link for: switching-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Switching Tables&lt;&#x2F;h2&gt;
&lt;p&gt;Switching tables is easy. We just need to reload the &lt;code&gt;CR3&lt;&#x2F;code&gt; register with the physical address of the new P4 frame.&lt;&#x2F;p&gt;
&lt;p&gt;We do this in a new &lt;code&gt;ActivePageTable::switch&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl ActivePageTable` in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;switch(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, new_table: InactivePageTable) -&amp;gt; InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::PhysicalAddress;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control_regs;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_table = InactivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;        p4_frame: Frame::containing_address(
&lt;&#x2F;span&gt;&lt;span&gt;            control_regs::cr3().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize
&lt;&#x2F;span&gt;&lt;span&gt;        ),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        control_regs::cr3_write(PhysicalAddress(
&lt;&#x2F;span&gt;&lt;span&gt;            new_table.p4_frame.start_address() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    old_table
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function activates the given inactive table and returns the previous active table as a &lt;code&gt;InactivePageTable&lt;&#x2F;code&gt;. We don‚Äôt need to flush the TLB here, as the CPU does it automatically when the P4 table is switched. In fact, the &lt;code&gt;tlb::flush_all&lt;&#x2F;code&gt; function, which we used above, does nothing more than &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&#x2F;0.1.2&#x2F;src&#x2F;x86_64&#x2F;instructions&#x2F;tlb.rs.html#11-14&quot;&gt;reloading the CR3 register&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now we are finally able to switch to the new table. We do it by adding the following lines to our &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in remap_the_kernel in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;active_table.with(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; new_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page, |mapper| {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_table = active_table.switch(new_table);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs cross our fingers and run it‚Ä¶&lt;&#x2F;p&gt;
&lt;p&gt;‚Ä¶ and it fails with a boot loop.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;üîó&lt;&#x2F;a&gt;Debugging&lt;&#x2F;h3&gt;
&lt;p&gt;A QEMU boot loop indicates that some CPU exception occurred. We can see all thrown CPU exception by starting QEMU with &lt;code&gt;-d int&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&amp;gt; qemu-system-x86_64 -d int -no-reboot -cdrom build&#x2F;os-x86_64.iso
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;check_exception old: 0xffffffff new 0xe
&lt;&#x2F;span&gt;&lt;span&gt;     0: v=0e e=0002 i=0 cpl=0 IP=0008:000000000010ab97 pc=000000000010ab97
&lt;&#x2F;span&gt;&lt;span&gt;        SP=&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;0010:00000000001182d0&lt;&#x2F;span&gt;&lt;span&gt; CR2=&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;00000000000b8f00&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These lines are the important ones. We can read many useful information from them:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;v=0e&lt;&#x2F;code&gt;: An exception with number &lt;code&gt;0xe&lt;&#x2F;code&gt; occurred, which is a page fault according to the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions&quot;&gt;OSDev Wiki&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;e=0002&lt;&#x2F;code&gt;: The CPU set an &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Error_code&quot;&gt;error code&lt;&#x2F;a&gt;, which tells us why the exception occurred. The &lt;code&gt;0x2&lt;&#x2F;code&gt; bit tells us that it was caused by a write operation. And since the &lt;code&gt;0x1&lt;&#x2F;code&gt; bit is not set, the target page was not present.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IP=0008:000000000010ab97&lt;&#x2F;code&gt; or &lt;code&gt;pc=000000000010ab97&lt;&#x2F;code&gt;: The program counter register tells us that the exception occurred when the CPU tried to execute the instruction at &lt;code&gt;0x10ab97&lt;&#x2F;code&gt;. We can disassemble this address to see the corresponding function. The &lt;code&gt;0008:&lt;&#x2F;code&gt; prefix in &lt;code&gt;IP&lt;&#x2F;code&gt; indicates the code &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;#loading-the-gdt&quot;&gt;GDT segment&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SP=0010:00000000001182d0&lt;&#x2F;code&gt;: The stack pointer was &lt;code&gt;0x1182d0&lt;&#x2F;code&gt; (the &lt;code&gt;0010:&lt;&#x2F;code&gt; prefix indicates the data &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;#loading-the-gdt&quot;&gt;GDT segment&lt;&#x2F;a&gt;). This tells us if it the stack overflowed.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CR2=00000000000b8f00&lt;&#x2F;code&gt;: Finally the most useful register. It tells us which virtual address caused the page fault. In our case it‚Äôs &lt;code&gt;0xb8f00&lt;&#x2F;code&gt;, which is part of the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;#the-vga-text-buffer&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So let‚Äôs find out which function caused the exception:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;objdump -d build&#x2F;kernel-x86_64.bin | grep -B100 &amp;quot;10ab97&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We disassemble our kernel and search for &lt;code&gt;10ab97&lt;&#x2F;code&gt;. The &lt;code&gt;-B100&lt;&#x2F;code&gt; option prints the 100 preceding lines too. The output tells us the responsible function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;000000000010aa80 &amp;lt;_ZN10vga_buffer6Writer10write_byte20h4601f5e405b6e89facaE&amp;gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  10aa80:	55                   	push   %rbp
&lt;&#x2F;span&gt;&lt;span&gt;  ...
&lt;&#x2F;span&gt;&lt;span&gt;  10ab93:	66 8b 55 aa          	mov    -0x56(%rbp),%dx
&lt;&#x2F;span&gt;&lt;span&gt;  10ab97:	66 89 14 48          	mov    %dx,(%rax,%rcx,2)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason for the cryptical function name is Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Name_mangling&quot;&gt;name mangling&lt;&#x2F;a&gt;. But we can identity the &lt;code&gt;vga_buffer::Writer::write_byte&lt;&#x2F;code&gt; function nonetheless.&lt;&#x2F;p&gt;
&lt;p&gt;So the reason for the page fault is that the &lt;code&gt;write_byte&lt;&#x2F;code&gt; function tried to write to the VGA text buffer at &lt;code&gt;0xb8f00&lt;&#x2F;code&gt;. Of course this provokes a page fault: We forgot to identity map the VGA buffer in the new page table.&lt;&#x2F;p&gt;
&lt;p&gt;The fix is pretty simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A, boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    active_table.with(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; new_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page, |mapper| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag.sections() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; identity map the VGA text buffer
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; vga_buffer_frame = Frame::containing_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;        mapper.identity_map(vga_buffer_frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;, allocator); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_table = active_table.switch(new_table);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we should see the &lt;code&gt;NEW TABLE!!!&lt;&#x2F;code&gt; message (and also the &lt;code&gt;It did not crash!&lt;&#x2F;code&gt; line again). Congratulations! We successfully switched our kernel to a new page table!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-the-frame-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-frame-allocator&quot; aria-label=&quot;Anchor link for: fixing-the-frame-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the Frame Allocator&lt;&#x2F;h3&gt;
&lt;p&gt;The same problem as above occurs when we try to use our &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#the-allocator&quot;&gt;AreaFrameAllocator&lt;&#x2F;a&gt; again. Try to add the following to &lt;code&gt;rust_main&lt;&#x2F;code&gt; after switching to the new table:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    memory::remap_the_kernel(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator, boot_info);
&lt;&#x2F;span&gt;&lt;span&gt;    frame_allocator.allocate_frame(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new: try to allocate a frame
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This causes the same bootloop as above. The reason is that the &lt;code&gt;AreaFrameAllocator&lt;&#x2F;code&gt; uses the memory map of the Multiboot information structure. But we did not map the Multiboot structure, so it causes a page fault. To fix it, we identity map it as well:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `remap_the_kernel` in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;active_table.with(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; new_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page, |mapper| {
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ‚Ä¶ identity map the allocated kernel sections
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ‚Ä¶ identity map the VGA text buffer
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; new:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; identity map the multiboot info structure
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_start = Frame::containing_address(boot_info.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_end = Frame::containing_address(boot_info.end_address() - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;Frame::range_inclusive(multiboot_start, multiboot_end) {
&lt;&#x2F;span&gt;&lt;span&gt;        mapper.identity_map(frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;, allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Normally the multiboot struct fits on one page. But GRUB can place it anywhere, so it could randomly cross a page boundary. Therefore we use &lt;code&gt;range_inclusive&lt;&#x2F;code&gt; to be on the safe side. Note that we need to subtract 1 to get the address of the last byte because the end address is exclusive.&lt;&#x2F;p&gt;
&lt;p&gt;Now we should be able to allocate frames again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;using-the-correct-flags&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-correct-flags&quot; aria-label=&quot;Anchor link for: using-the-correct-flags&quot;&gt;üîó&lt;&#x2F;a&gt;Using the Correct Flags&lt;&#x2F;h2&gt;
&lt;p&gt;Right now, our new table maps all kernel sections as writable and executable. To fix this, we add a &lt;code&gt;EntryFlags::from_elf_section_flags&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;entry.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;multiboot2::ElfSection;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;EntryFlags {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;from_elf_section_flags(section: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ElfSection) -&amp;gt; EntryFlags {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;multiboot2::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_ALLOCATED&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_EXECUTABLE&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; flags = EntryFlags::empty();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; section.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_ALLOCATED&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; section is loaded to memory
&lt;&#x2F;span&gt;&lt;span&gt;            flags = flags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; section.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            flags = flags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;section.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_EXECUTABLE&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            flags = flags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;NO_EXECUTE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        flags
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It just converts the ELF section flags to page table flags.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use it to fix the &lt;code&gt;TODO&lt;&#x2F;code&gt; in our &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A, boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    active_table.with(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; new_table, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; temporary_page, |mapper| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag.sections() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2F;span&gt;&lt;span&gt;section.is_allocated() {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; section is not loaded to memory
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;continue&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; this is the new part
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; flags = EntryFlags::from_elf_section_flags(section);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; frame &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;Frame::range_inclusive(start_frame, end_frame) {
&lt;&#x2F;span&gt;&lt;span&gt;                mapper.identity_map(frame, flags, allocator);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But when we test it now, we get a page fault again. We can use the same technique as above to get the responsible function. I won‚Äôt bother you with the QEMU output and just tell you the results:&lt;&#x2F;p&gt;
&lt;p&gt;This time the responsible function is &lt;code&gt;control_regs::cr3_write()&lt;&#x2F;code&gt; itself. From the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Exceptions#Error_code&quot;&gt;error code&lt;&#x2F;a&gt; we learn that it was a page protection violation and caused by ‚Äúreading a 1 in a reserved field‚Äù. So the page table had some reserved bit set that should be always 0. It must be the &lt;code&gt;NO_EXECUTE&lt;&#x2F;code&gt; flag, since it‚Äôs the only new bit that we set in the page table.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-nxe-bit&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-nxe-bit&quot; aria-label=&quot;Anchor link for: the-nxe-bit&quot;&gt;üîó&lt;&#x2F;a&gt;The NXE Bit&lt;&#x2F;h3&gt;
&lt;p&gt;The reason is that the &lt;code&gt;NO_EXECUTE&lt;&#x2F;code&gt; bit must only be used when the &lt;code&gt;NXE&lt;&#x2F;code&gt; bit in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control_register#EFER&quot;&gt;Extended Feature Enable Register&lt;&#x2F;a&gt; (EFER) is set. That register is similar to Rust‚Äôs feature gating and can be used to enable all sorts of advanced CPU features. Since the &lt;code&gt;NXE&lt;&#x2F;code&gt; bit is off by default, we caused a page fault when we added the &lt;code&gt;NO_EXECUTE&lt;&#x2F;code&gt; bit to the page table.&lt;&#x2F;p&gt;
&lt;p&gt;So we need to enable the &lt;code&gt;NXE&lt;&#x2F;code&gt; bit. For that we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&quot;&gt;x86_64 crate&lt;&#x2F;a&gt; again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;enable_nxe_bit() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::msr::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2F;span&gt;&lt;span&gt;, rdmsr, wrmsr};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; nxe_bit = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; efer = rdmsr(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        wrmsr(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2F;span&gt;&lt;span&gt;, efer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; nxe_bit);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The unsafe block is needed since accessing the &lt;code&gt;EFER&lt;&#x2F;code&gt; register is only allowed in kernel mode. But we are in kernel mode, so everything is fine.&lt;&#x2F;p&gt;
&lt;p&gt;When we call this function before calling &lt;code&gt;remap_the_kernel&lt;&#x2F;code&gt;, everything should work again.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-write-protect-bit&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-write-protect-bit&quot; aria-label=&quot;Anchor link for: the-write-protect-bit&quot;&gt;üîó&lt;&#x2F;a&gt;The Write Protect Bit&lt;&#x2F;h3&gt;
&lt;p&gt;Right now, we are still able to modify the &lt;code&gt;.code&lt;&#x2F;code&gt; and &lt;code&gt;.rodata&lt;&#x2F;code&gt; sections, even though we did not set the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag for them. The reason is that the CPU ignores this bit in kernel mode by default. To enable write protection for the kernel as well, we need to set the &lt;em&gt;Write Protect&lt;&#x2F;em&gt; bit in the &lt;code&gt;CR0&lt;&#x2F;code&gt; register:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;enable_write_protect_bit() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::registers::control_regs::{cr0, cr0_write, Cr0};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ cr0_write(cr0() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Cr0::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITE_PROTECT&lt;&#x2F;span&gt;&lt;span&gt;) };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;cr0&lt;&#x2F;code&gt; functions are unsafe because accessing the &lt;code&gt;CR0&lt;&#x2F;code&gt; register is only allowed in kernel mode.&lt;&#x2F;p&gt;
&lt;p&gt;If we haven‚Äôt forgotten to set the &lt;code&gt;WRITABLE&lt;&#x2F;code&gt; flag somewhere, it should still work without crashing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-guard-page&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-guard-page&quot; aria-label=&quot;Anchor link for: creating-a-guard-page&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a Guard Page&lt;&#x2F;h2&gt;
&lt;p&gt;The final step is to create a guard page for our kernel stack.&lt;&#x2F;p&gt;
&lt;p&gt;The decision to place the kernel stack right above the page tables was already useful to detect a silent stack overflow in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt;. Now we profit from it again. Let‚Äôs look at our assembly &lt;code&gt;.bss&lt;&#x2F;code&gt; section again to understand why:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;; in src&#x2F;arch&#x2F;x86_64&#x2F;boot.asm
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .bss
&lt;&#x2F;span&gt;&lt;span&gt;align &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p4_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p3_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p2_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;stack_bottom:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span&gt;stack_top:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The old page tables are right below the stack. They are still identity mapped since they are part of the kernel‚Äôs &lt;code&gt;.bss&lt;&#x2F;code&gt; section. We just need to turn the old &lt;code&gt;p4_table&lt;&#x2F;code&gt; into a guard page to secure the kernel stack. That way we even reuse the memory of the old P3 and P2 tables to increase the stack size.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs implement it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;memory&#x2F;paging&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A, boot_info: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BootInformation)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_table = active_table.switch(new_table);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; below is the new part
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; turn the old p4 page into a guard page
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_p4_page = Page::containing_address(
&lt;&#x2F;span&gt;&lt;span&gt;      old_table.p4_frame.start_address()
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;    active_table.unmap(old_p4_page, allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;guard page at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, old_p4_page.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have a very basic guard page: The page below the stack is unmapped, so a stack overflow causes an immediate page fault. Thus, silent stack overflows are no longer possible.&lt;&#x2F;p&gt;
&lt;p&gt;Or to be precise, they are improbable. If we have a function with many big stack variables, it‚Äôs possible that the guard page is missed. For example, the following function could still corrupt memory below the stack:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;stack_overflow() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;99999&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This creates a very big array on the stack, which is currently filled from bottom to top. Therefore it misses the guard page and overwrites some memory below the stack. Eventually it hits the bottom of the guard page and causes a page fault. But before, it messes up memory, which is bad.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, there exists a solution called &lt;em&gt;stack probes&lt;&#x2F;em&gt;. The basic idea is to check all required stack pages at the beginning of each function. For example, a function that needs 9000 bytes on the stack would try to access &lt;code&gt;SP + 0&lt;&#x2F;code&gt;, &lt;code&gt;SP + 4096&lt;&#x2F;code&gt;, and &lt;code&gt;SP + 2 * 4096&lt;&#x2F;code&gt; (&lt;code&gt;SP&lt;&#x2F;code&gt; is the stack pointer). If the stack is not big enough, the guard page is hit and a page fault occurs. The function can‚Äôt mess up memory anymore since the stack check occurs right at its start.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately stack probes require compiler support. They already work on Windows but they don‚Äôt exist on Linux yet. The problem seems to be in LLVM, which Rust uses as backend. Hopefully it gets resolved soon so that our kernel stack becomes safe. For the current status and more information about stack probes check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;16012#issuecomment-160380183&quot;&gt;tracking issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have a (mostly) safe kernel stack and a working page table module, we can add a virtual memory allocator. The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;kernel-heap&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; will explore Rust‚Äôs allocator API and create a very basic allocator. At the end of that post, we will be able to use Rust‚Äôs allocation and collections types such as &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;alloc&#x2F;boxed&#x2F;struct.Box.html&quot;&gt;Box&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;vec&#x2F;struct.Vec.html&quot;&gt;Vec&lt;&#x2F;a&gt;, or even &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;collections&#x2F;btree_map&#x2F;struct.BTreeMap.html&quot;&gt;BTreeMap&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-debug-notes&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;For this post the most useful GDB command is probably &lt;code&gt;p&#x2F;x *((long int*)0xfffffffffffff000)@512&lt;&#x2F;code&gt;. It prints all entries of the recursively mapped P4 table by interpreting it as an array of 512 long ints (the &lt;code&gt;@512&lt;&#x2F;code&gt; is GDB‚Äôs array syntax). Of course you can also print other tables by adjusting the address.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Page Tables</title>
                <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/page-tables/</link>
                <guid>https://os.phil-opp.com/page-tables/</guid>
                <description>&lt;p&gt;In this post we will create a paging module, which allows us to access and modify the 4-level page table. We will explore recursive page table mapping and use some Rust features to make it safe. Finally we will create functions to translate virtual addresses and to map and unmap pages.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;You can find the source code and this post itself on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_6&quot;&gt;GitHub&lt;&#x2F;a&gt;. Please file an issue there if you have any problems or improvement suggestions. There is also a comment section at the end of this page. Note that this post requires a current Rust nightly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;üîó&lt;&#x2F;a&gt;Paging&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Paging&lt;&#x2F;em&gt; is a memory management scheme that separates virtual and physical memory. The address space is split into equal sized &lt;em&gt;pages&lt;&#x2F;em&gt; and &lt;em&gt;page tables&lt;&#x2F;em&gt; specify which virtual page points to which physical frame. For an extensive paging introduction take a look at the paging chapter (&lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;vm-paging.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) of the &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;&quot;&gt;Three Easy Pieces&lt;&#x2F;a&gt; OS book.&lt;&#x2F;p&gt;
&lt;p&gt;The x86 architecture uses a 4-level page table in 64-bit mode. A virtual address has the following structure:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;x86_address_structure.svg&quot; alt=&quot;structure of a virtual address on x86&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The bits 48‚Äì63 are so-called &lt;em&gt;sign extension&lt;&#x2F;em&gt; bits and must be copies of bit 47. The following 36 bits define the page table indexes (9 bits per table) and the last 12 bits specify the offset in the 4KiB page.&lt;&#x2F;p&gt;
&lt;p&gt;Each table has 2^9 = 512 entries and each entry is 8 byte. Thus a page table fits exactly in one page (4 KiB).&lt;&#x2F;p&gt;
&lt;p&gt;To translate an address, the CPU reads the P4 address from the CR3 register. Then it uses the indexes to walk the tables:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;X86_Paging_64bit.svg&quot; alt=&quot;translation of virtual to physical addresses in 64 bit mode&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The P4 entry points to a P3 table, where the next 9 bits of the address are used to select an entry. The P3 entry then points to a P2 table and the P2 entry points to a P1 table. The P1 entry, which is specified through bits 12‚Äì20, finally points to the physical frame.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-basic-paging-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-basic-paging-module&quot; aria-label=&quot;Anchor link for: a-basic-paging-module&quot;&gt;üîó&lt;&#x2F;a&gt;A Basic Paging Module&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs create a basic paging module in &lt;code&gt;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; needed later
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;PhysicalAddress &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;VirtualAddress &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Page {
&lt;&#x2F;span&gt;&lt;span&gt;   number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We import the &lt;code&gt;PAGE_SIZE&lt;&#x2F;code&gt; and define a constant for the number of entries per table. To make future function signatures more expressive, we can use the type aliases &lt;code&gt;PhysicalAddress&lt;&#x2F;code&gt; and &lt;code&gt;VirtualAddress&lt;&#x2F;code&gt;. The &lt;code&gt;Page&lt;&#x2F;code&gt; struct is similar to the &lt;code&gt;Frame&lt;&#x2F;code&gt; struct in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#a-memory-module&quot;&gt;previous post&lt;&#x2F;a&gt;, but represents a virtual page instead of a physical frame.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-table-entries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-entries&quot; aria-label=&quot;Anchor link for: page-table-entries&quot;&gt;üîó&lt;&#x2F;a&gt;Page Table Entries&lt;&#x2F;h3&gt;
&lt;p&gt;To model page table entries, we create a new &lt;code&gt;entry&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::Frame; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; needed later
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Entry(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Entry {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;is_unused(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set_unused(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define that an unused entry is completely 0. That allows us to distinguish unused entries from other non-present entries in the future. For example, we could define one of the available bits as the &lt;code&gt;swapped_out&lt;&#x2F;code&gt; bit for pages that are swapped to disk.&lt;&#x2F;p&gt;
&lt;p&gt;Next we will model the contained physical address and the various flags. Remember, entries have the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;present&lt;&#x2F;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;writable&lt;&#x2F;td&gt;&lt;td&gt;it‚Äôs allowed to write to this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;user accessible&lt;&#x2F;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;write through caching&lt;&#x2F;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;disable cache&lt;&#x2F;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;accessed&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;dirty&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;huge page&#x2F;null&lt;&#x2F;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1GiB page in P3, creates a 2MiB page in P2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;global&lt;&#x2F;td&gt;&lt;td&gt;page isn‚Äôt flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12-51&lt;&#x2F;td&gt;&lt;td&gt;physical address&lt;&#x2F;td&gt;&lt;td&gt;the page aligned 52bit physical address of the frame or the next page table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;63&lt;&#x2F;td&gt;&lt;td&gt;no execute&lt;&#x2F;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;To model the various flags, we will use the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang-nursery&#x2F;bitflags&quot;&gt;bitflags&lt;&#x2F;a&gt; crate. To add it as a dependency, add the following to your &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bitflags &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.1&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To import the macro, we need to use &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; above the &lt;code&gt;extern crate&lt;&#x2F;code&gt; definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; bitflags;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can model the various flags:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bitflags! {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EntryFlags: u64 {
&lt;&#x2F;span&gt;&lt;span&gt;        const PRESENT =         1 &amp;lt;&amp;lt; 0;
&lt;&#x2F;span&gt;&lt;span&gt;        const WRITABLE =        1 &amp;lt;&amp;lt; 1;
&lt;&#x2F;span&gt;&lt;span&gt;        const USER_ACCESSIBLE = 1 &amp;lt;&amp;lt; 2;
&lt;&#x2F;span&gt;&lt;span&gt;        const WRITE_THROUGH =   1 &amp;lt;&amp;lt; 3;
&lt;&#x2F;span&gt;&lt;span&gt;        const NO_CACHE =        1 &amp;lt;&amp;lt; 4;
&lt;&#x2F;span&gt;&lt;span&gt;        const ACCESSED =        1 &amp;lt;&amp;lt; 5;
&lt;&#x2F;span&gt;&lt;span&gt;        const DIRTY =           1 &amp;lt;&amp;lt; 6;
&lt;&#x2F;span&gt;&lt;span&gt;        const HUGE_PAGE =       1 &amp;lt;&amp;lt; 7;
&lt;&#x2F;span&gt;&lt;span&gt;        const GLOBAL =          1 &amp;lt;&amp;lt; 8;
&lt;&#x2F;span&gt;&lt;span&gt;        const NO_EXECUTE =      1 &amp;lt;&amp;lt; 63;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To extract the flags from the entry we create an &lt;code&gt;Entry::flags&lt;&#x2F;code&gt; method that uses &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;bitflags&#x2F;0.9.1&#x2F;bitflags&#x2F;example_generated&#x2F;struct.Flags.html#method.from_bits_truncate&quot;&gt;from_bits_truncate&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;flags(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; EntryFlags {
&lt;&#x2F;span&gt;&lt;span&gt;    EntryFlags::from_bits_truncate(self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows us to check for flags through the &lt;code&gt;contains()&lt;&#x2F;code&gt; function. For example, &lt;code&gt;flags().contains(PRESENT | WRITABLE)&lt;&#x2F;code&gt; returns true if the entry contains &lt;em&gt;both&lt;&#x2F;em&gt; flags.&lt;&#x2F;p&gt;
&lt;p&gt;To extract the physical address, we add a &lt;code&gt;pointed_frame&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;pointed_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        Some(Frame::containing_address(
&lt;&#x2F;span&gt;&lt;span&gt;            self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x000fffff_fffff000
&lt;&#x2F;span&gt;&lt;span&gt;        ))
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the entry is present, we mask bits 12‚Äì51 and return the corresponding frame. If the entry is not present, it does not point to a valid frame so we return &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To modify entries, we add a &lt;code&gt;set&lt;&#x2F;code&gt; method that updates the flags and the pointed frame:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;set(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, frame: Frame, flags: EntryFlags) {
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(frame.start_address() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x000fffff_fffff000 &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;= (frame.start_address() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span&gt; flags.bits();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The start address of a frame should be page aligned and smaller than 2^52 (since x86 uses 52bit physical addresses). Since an invalid address could mess up the entry, we add an assertion. To actually set the entry, we just need to &lt;code&gt;or&lt;&#x2F;code&gt; the start address and the flag bits.&lt;&#x2F;p&gt;
&lt;p&gt;The missing &lt;code&gt;Frame::start_address&lt;&#x2F;code&gt; method is pretty simple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::paging::PhysicalAddress;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;start_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; PhysicalAddress {
&lt;&#x2F;span&gt;&lt;span&gt;    self.number * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add it to the &lt;code&gt;impl Frame&lt;&#x2F;code&gt; block in &lt;code&gt;memory&#x2F;mod.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-tables&quot; aria-label=&quot;Anchor link for: page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Page Tables&lt;&#x2F;h3&gt;
&lt;p&gt;To model page tables, we create a basic &lt;code&gt;Table&lt;&#x2F;code&gt; struct in a new &lt;code&gt;table&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::paging::entry::*;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::paging::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Table {
&lt;&#x2F;span&gt;&lt;span&gt;    entries: [Entry; ENTRY_COUNT],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs just an array of 512 page table entries.&lt;&#x2F;p&gt;
&lt;p&gt;To make the &lt;code&gt;Table&lt;&#x2F;code&gt; indexable itself, we can implement the &lt;code&gt;Index&lt;&#x2F;code&gt; and &lt;code&gt;IndexMut&lt;&#x2F;code&gt; traits:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ops::{Index, IndexMut};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Index&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Table {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= Entry;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Entry {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self.entries[index]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;IndexMut&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Table {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;index_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Entry {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self.entries[index]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now it‚Äôs possible to get the 42th entry through &lt;code&gt;some_table[42]&lt;&#x2F;code&gt;. Of course we could replace &lt;code&gt;usize&lt;&#x2F;code&gt; with &lt;code&gt;u32&lt;&#x2F;code&gt; or even &lt;code&gt;u16&lt;&#x2F;code&gt; here but it would cause more numerical conversions (&lt;code&gt;x as u16&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs add a method that sets all entries to unused. We will need it when we create new page tables in the future. The method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;zero(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;self.entries.iter_mut() {
&lt;&#x2F;span&gt;&lt;span&gt;        entry.set_unused();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can read page tables and retrieve the mapping information. We can also update them through the &lt;code&gt;IndexMut&lt;&#x2F;code&gt; trait and the &lt;code&gt;Entry::set&lt;&#x2F;code&gt; method. But how do we get references to the various page tables?&lt;&#x2F;p&gt;
&lt;p&gt;We could read the &lt;code&gt;CR3&lt;&#x2F;code&gt; register to get the physical address of the P4 table and read its entries to get the P3 addresses. The P3 entries then point to the P2 tables and so on. But this method only works for identity-mapped pages. In the future we will create new page tables, which aren‚Äôt in the identity-mapped area anymore. Since we can‚Äôt access them through their physical address, we need a way to map them to virtual addresses.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mapping-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-page-tables&quot; aria-label=&quot;Anchor link for: mapping-page-tables&quot;&gt;üîó&lt;&#x2F;a&gt;Mapping Page Tables&lt;&#x2F;h2&gt;
&lt;p&gt;So how do we map the page tables itself? We don‚Äôt have that problem for the current P4, P3, and P2 table since they are part of the identity-mapped area, but we need a way to access future tables, too.&lt;&#x2F;p&gt;
&lt;p&gt;One solution is to identity map all page tables. That way we would not need to differentiate virtual and physical addresses and could easily access the tables. But it clutters the virtual address space and increases fragmentation. And it makes creating page tables much more complicated since we need a physical frame whose corresponding page isn‚Äôt already used for something else.&lt;&#x2F;p&gt;
&lt;p&gt;An alternative solution is to map the page tables only temporary. To read&#x2F;write a page table, we would map it to some free virtual address until we‚Äôre done. We could use a small pool of such virtual addresses and reuse them for various tables. This method occupies only few virtual addresses and thus is a good solution for 32-bit systems, which have small address spaces. But it makes things much more complicated since we need to temporary map up to 4 tables to access a single page. And the temporary mapping requires modification of other page tables, which need to be mapped, too.&lt;&#x2F;p&gt;
&lt;p&gt;We will solve the problem in another way using a trick called &lt;em&gt;recursive mapping&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-mapping&quot; aria-label=&quot;Anchor link for: recursive-mapping&quot;&gt;üîó&lt;&#x2F;a&gt;Recursive Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;The trick is to map the P4 table recursively: The last entry doesn‚Äôt point to a P3 table, but to the P4 table itself. We can use this entry to remove a translation level so that we land on a page table instead. For example, we can ‚Äúloop‚Äù once to access a P1 table:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;recursive_mapping_access_p1.svg&quot; alt=&quot;access P1 table through recursive paging&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;By selecting the 511th P4 entry, which points points to the P4 table itself, the P4 table is used as the P3 table. Similarly, the P3 table is used as a P2 table and the P2 table is treated like a P1 table. Thus the P1 table becomes the target page and can be accessed through the offset.&lt;&#x2F;p&gt;
&lt;p&gt;It‚Äôs also possible to access P2 tables by looping twice. And if we select the 511th entry three times, we can access and modify P3 tables:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;recursive_mapping_access_p3.svg&quot; alt=&quot;access P3 table through recursive paging&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So we just need to specify the desired P3 table in the address through the P1 index. By choosing the 511th entry multiple times, we stay on the P4 table until the address‚Äôs P1 index becomes the actual P4 index.&lt;&#x2F;p&gt;
&lt;p&gt;To access the P4 table itself, we loop once more and thus never leave the frame:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;recursive_mapping_access_p4.svg&quot; alt=&quot;access P4 table through recursive paging&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So we can access and modify page tables of all levels by just setting one P4 entry once. Most work is done by the CPU, we just the recursive entry to remove one or more translation levels. It may seem a bit strange at first, but it‚Äôs a clean and simple solution once you wrapped your head around it.&lt;&#x2F;p&gt;
&lt;p&gt;By using recursive mapping, each page table is accessible through an unique virtual address. The math checks out, too: If all page tables are used, there is 1 P4 table, 511 P3 tables (the last entry is used for the recursive mapping), &lt;code&gt;511*512&lt;&#x2F;code&gt; P2 tables, and &lt;code&gt;511*512*512&lt;&#x2F;code&gt; P1 tables. So there are &lt;code&gt;134217728&lt;&#x2F;code&gt; page tables altogether. Each page table occupies 4KiB, so we need &lt;code&gt;134217728 * 4KiB = 512GiB&lt;&#x2F;code&gt; to store them. That‚Äôs exactly the amount of memory that can be accessed through one P4 entry since &lt;code&gt;4KiB per page * 512 P1 entries * 512 P2 entries * 512 P3 entries = 512GiB&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Of course recursive mapping has some disadvantages, too. It occupies a P4 entry and thus 512GiB of the virtual address space. But since we‚Äôre in long mode and have a 48-bit address space, there are still 225.5TiB left. The bigger problem is that only the active table can be modified by default. To access another table, the recursive entry needs to be replaced temporary. We will tackle this problem in the next post when we switch to a new page table.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;üîó&lt;&#x2F;a&gt;Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;To map the P4 table recursively, we just need to point the 511th entry to the table itself. Of course we could do it in Rust, but it would require some fiddling with unsafe pointers. It‚Äôs easier to just add some lines to our boot assembly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, p4_table
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, 0b11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;[p4_table + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;511 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], eax
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I put it right after the &lt;code&gt;set_up_page_tables&lt;&#x2F;code&gt; label, but you can add it wherever you like.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use special virtual addresses to access the page tables. The P4 table is available at &lt;code&gt;0xfffffffffffff000&lt;&#x2F;code&gt;. Let‚Äôs add a P4 constant to the &lt;code&gt;table&lt;&#x2F;code&gt; submodule:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut&lt;&#x2F;span&gt;&lt;span&gt; Table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffffffff_fffff000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs switch to the octal system, since it makes more sense for the other special addresses. The P4 address from above is equivalent to &lt;code&gt;0o177777_777_777_777_777_0000&lt;&#x2F;code&gt; in octal. You can see that is has index &lt;code&gt;777&lt;&#x2F;code&gt; in all tables and offset &lt;code&gt;0000&lt;&#x2F;code&gt;. The &lt;code&gt;177777&lt;&#x2F;code&gt; bits on the left are the sign extension bits, which are copies of the 47th bit. They are required because x86 only uses 48bit virtual addresses.&lt;&#x2F;p&gt;
&lt;p&gt;The other tables can be accessed through the following addresses:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Table&lt;&#x2F;th&gt;&lt;th&gt;Address&lt;&#x2F;th&gt;&lt;th&gt;Indexes&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;P4&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_777_777_0000&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;‚Äì&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;P3&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_777_XXX_0000&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;XXX&lt;&#x2F;code&gt; is the P4 index&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;P2&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_XXX_YYY_0000&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;like above, and &lt;code&gt;YYY&lt;&#x2F;code&gt; is the P3 index&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;P1&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_XXX_YYY_ZZZ_0000&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;like above, and &lt;code&gt;ZZZ&lt;&#x2F;code&gt; is the P2 index&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;If we look closely, we can see that the P3 address is equal to &lt;code&gt;(P4 &amp;lt;&amp;lt; 9) | XXX_0000&lt;&#x2F;code&gt;. And the P2 address is calculated through &lt;code&gt;(P3 &amp;lt;&amp;lt; 9) | YYY_0000&lt;&#x2F;code&gt;. So to get the next address, we need to shift it 9 bits to the left and add the table index. As a formula:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;next_table_address = (table_address &amp;lt;&amp;lt; 9) | (index &amp;lt;&amp;lt; 12)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;the-next-table-methods&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-next-table-methods&quot; aria-label=&quot;Anchor link for: the-next-table-methods&quot;&gt;üîó&lt;&#x2F;a&gt;The &lt;code&gt;next_table&lt;&#x2F;code&gt; Methods&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs add the above formula as a &lt;code&gt;Table&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; entry_flags = self[index].flags();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; entry_flags.contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp; !&lt;&#x2F;span&gt;&lt;span&gt;entry_flags.contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; table_address = self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as usize&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Some((table_address &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(index &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The next table address is only valid if the corresponding entry is present and does not create a huge page. Then we can do some pointer casting to get the table address and use the formula to calculate the next address.&lt;&#x2F;p&gt;
&lt;p&gt;If the index is out of bounds, the function will panic since Rust checks array bounds. The panic is desired here since a wrong index should not be possible and indicates a bug.&lt;&#x2F;p&gt;
&lt;p&gt;To convert the address into references, we add two functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Table&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    self.next_table_address(index)
&lt;&#x2F;span&gt;&lt;span&gt;        .map(|address| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*(address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _&lt;&#x2F;span&gt;&lt;span&gt;) })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Table&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    self.next_table_address(index)
&lt;&#x2F;span&gt;&lt;span&gt;        .map(|address| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*(address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;) })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We convert the address into raw pointers through &lt;code&gt;as&lt;&#x2F;code&gt; casts and then convert them into Rust references through &lt;code&gt;&amp;amp;mut *&lt;&#x2F;code&gt;. The latter is an &lt;code&gt;unsafe&lt;&#x2F;code&gt; operation since Rust can‚Äôt guarantee that the raw pointer is valid.&lt;&#x2F;p&gt;
&lt;p&gt;Note that &lt;code&gt;self&lt;&#x2F;code&gt; stays borrowed as long as the returned reference is valid. This is because of Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;lifetimes.html#lifetime-elision&quot;&gt;lifetime elision&lt;&#x2F;a&gt; rules. Basically, these rules say that the lifetime of an output reference is the same as the lifetime of the input reference by default. So the above function signatures are expanded to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Table&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_mut&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a mut&lt;&#x2F;span&gt;&lt;span&gt; Table&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note the additional lifetime parameters, which are identical for input and output references. That‚Äôs exactly what we want. It ensures that we can‚Äôt modify tables as long as we have references to lower tables. For example, it would be very bad if we could unmap a P3 table if we still write to one of its P2 tables.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h4&gt;
&lt;p&gt;Now we can start at the &lt;code&gt;P4&lt;&#x2F;code&gt; constant and use the &lt;code&gt;next_table&lt;&#x2F;code&gt; functions to access the lower tables. And we don‚Äôt even need &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks to do it! Right now, your alarm bells should be ringing. Thanks to Rust, everything we‚Äôve done before in this post was completely safe. But we just introduced two unsafe blocks to convince Rust that there are valid tables at the specified addresses. Can we really be sure?&lt;&#x2F;p&gt;
&lt;p&gt;First, these addresses are only valid if the P4 table is mapped recursively. Since the paging module will be the only module that modifies page tables, we can introduce an invariant for the module:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The 511th entry of the active P4 table must always be mapped to the active P4 table itself.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So if we switch to another P4 table at some time, it needs to be identity mapped &lt;em&gt;before&lt;&#x2F;em&gt; it becomes active. As long as we obey this invariant, we can safely use the special addresses. But even with this invariant, there is a big problem with the two methods:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;What happens if we call them on a P1 table?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Well, they would calculate the address of the next table (which does not exist) and treat it as a page table. Either they construct an invalid address (if &lt;code&gt;XXX &amp;lt; 400&lt;&#x2F;code&gt;)&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-invalid-address&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; or access the mapped page itself. That way, we could easily corrupt memory or cause CPU exceptions by accident. So these two functions are not &lt;em&gt;safe&lt;&#x2F;em&gt; in Rust terms. Thus we need to make them &lt;code&gt;unsafe&lt;&#x2F;code&gt; functions unless we find some clever solution.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;some-clever-solution&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-clever-solution&quot; aria-label=&quot;Anchor link for: some-clever-solution&quot;&gt;üîó&lt;&#x2F;a&gt;Some Clever Solution&lt;&#x2F;h2&gt;
&lt;p&gt;We can use Rust‚Äôs type system to statically guarantee that the &lt;code&gt;next_table&lt;&#x2F;code&gt; methods can only be called on P4, P3, and P2 tables, but not on a P1 table. The idea is to add a &lt;code&gt;Level&lt;&#x2F;code&gt; parameter to the &lt;code&gt;Table&lt;&#x2F;code&gt; type and implement the &lt;code&gt;next_table&lt;&#x2F;code&gt; methods only for level 4, 3, and 2.&lt;&#x2F;p&gt;
&lt;p&gt;To model the levels we use a trait and empty enums:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TableLevel {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Level4 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Level3 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Level2 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Level1 {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TableLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level4 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TableLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level3 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TableLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level2 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TableLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level1 {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;An empty enum has size zero and disappears completely after compiling. Unlike an empty struct, it‚Äôs not possible to instantiate an empty enum. Since we will use &lt;code&gt;TableLevel&lt;&#x2F;code&gt; and the table levels in exported types, they need to be public.&lt;&#x2F;p&gt;
&lt;p&gt;To differentiate the P1 table from the other tables, we introduce a &lt;code&gt;HierarchicalLevel&lt;&#x2F;code&gt; trait, which is a subtrait of &lt;code&gt;TableLevel&lt;&#x2F;code&gt;. But we implement it only for the levels 4, 3, and 2:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel: TableLevel {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level4 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level3 {}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level2 {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we add the level parameter to the &lt;code&gt;Table&lt;&#x2F;code&gt; type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::marker::PhantomData;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;L: TableLevel&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    entries: [Entry; ENTRY_COUNT],
&lt;&#x2F;span&gt;&lt;span&gt;    level: PhantomData&amp;lt;L&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We need to add a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;marker&#x2F;struct.PhantomData.html#unused-type-parameters&quot;&gt;PhantomData&lt;&#x2F;a&gt; field because unused type parameters are not allowed in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Since we changed the &lt;code&gt;Table&lt;&#x2F;code&gt; type, we need to update every use of it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffffffff_fffff000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;L&amp;gt; Table&amp;lt;L&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; L: TableLevel
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;zero(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;L&amp;gt; Table&amp;lt;L&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; L: HierarchicalLevel
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;??&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;??&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;L&amp;gt; Index&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;L&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; L: TableLevel {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;L&amp;gt; IndexMut&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;L&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; L: TableLevel {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the &lt;code&gt;next_table&lt;&#x2F;code&gt; methods are only available for P4, P3, and P2 tables. But they have the incomplete return type &lt;code&gt;Table&amp;lt;???&amp;gt;&lt;&#x2F;code&gt; now. What should we fill in for the &lt;code&gt;???&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;For a P4 table we would like to return a &lt;code&gt;Table&amp;lt;Level3&amp;gt;&lt;&#x2F;code&gt;, for a P3 table a &lt;code&gt;Table&amp;lt;Level2&amp;gt;&lt;&#x2F;code&gt;, and for a P2 table a &lt;code&gt;Table&amp;lt;Level1&amp;gt;&lt;&#x2F;code&gt;. So we want to return a table of the &lt;em&gt;next level&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can define the next level by adding an associated type to the &lt;code&gt;HierarchicalLevel&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel: TableLevel {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel&lt;&#x2F;span&gt;&lt;span&gt;: TableLevel;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level4 {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2F;span&gt;&lt;span&gt;= Level3;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level3 {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2F;span&gt;&lt;span&gt;= Level2;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;HierarchicalLevel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Level2 {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2F;span&gt;&lt;span&gt;= Level1;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can replace the &lt;code&gt;Table&amp;lt;???&amp;gt;&lt;&#x2F;code&gt; types with &lt;code&gt;Table&amp;lt;L::NextLevel&amp;gt;&lt;&#x2F;code&gt; types and our code works as intended. You can try it with a simple test function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;test() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p4 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    p4.next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      .and_then(|p3| p3.next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1337&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;      .and_then(|p2| p2.next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;      .and_then(|p1| p1.next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xcafebabe&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Most of the indexes are completely out of bounds, so it would panic if it‚Äôs called. But we don‚Äôt need to call it since it already fails at compile time:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error: no method named `next_table` found for type
&lt;&#x2F;span&gt;&lt;span&gt;  `&amp;amp;memory::paging::table::Table&amp;lt;memory::paging::table::Level1&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;  in the current scope
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remember that this is bare metal kernel code. We just used type system magic to make low-level page table manipulations safer. Rust is just awesome!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;üîó&lt;&#x2F;a&gt;Translating Addresses&lt;&#x2F;h2&gt;
&lt;p&gt;Now let‚Äôs do something useful with our new module. We will create a function that translates a virtual address to the corresponding physical address. We add it to the &lt;code&gt;paging&#x2F;mod.rs&lt;&#x2F;code&gt; module:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;translate(virtual_address: VirtualAddress)
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option&amp;lt;PhysicalAddress&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; offset = virtual_address % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    translate_page(Page::containing_address(virtual_address))
&lt;&#x2F;span&gt;&lt;span&gt;        .map(|frame| frame.number * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2F;span&gt;&lt;span&gt;+ offset)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It uses two functions we haven‚Äôt defined yet: &lt;code&gt;translate_page&lt;&#x2F;code&gt; and &lt;code&gt;Page::containing_address&lt;&#x2F;code&gt;. Let‚Äôs start with the latter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;containing_address(address: VirtualAddress) -&amp;gt; Page {
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(address &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0000_8000_0000_0000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;||
&lt;&#x2F;span&gt;&lt;span&gt;        address &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffff_8000_0000_0000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;invalid address: 0x{:x}&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, address);
&lt;&#x2F;span&gt;&lt;span&gt;    Page { number: address &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The assertion is needed because there can be invalid addresses. Addresses on x86 are just 48-bit long and the other bits are just &lt;em&gt;sign extension&lt;&#x2F;em&gt;, i.e. a copy of the most significant bit. For example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;invalid address: 0x0000_8000_0000_0000
&lt;&#x2F;span&gt;&lt;span&gt;valid address:   0xffff_8000_0000_0000
&lt;&#x2F;span&gt;&lt;span&gt;                        ‚îî‚îÄ‚îÄ bit 47
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the address space is split into two halves: the &lt;em&gt;higher half&lt;&#x2F;em&gt; containing addresses with sign extension and the &lt;em&gt;lower half&lt;&#x2F;em&gt; containing addresses without. Everything in between is invalid.&lt;&#x2F;p&gt;
&lt;p&gt;Since we added &lt;code&gt;containing_address&lt;&#x2F;code&gt;, we add the inverse method as well (maybe we need it later):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;start_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    self.number * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The other missing function, &lt;code&gt;translate_page&lt;&#x2F;code&gt;, looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::Frame;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;translate_page(page: Page) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::entry::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p3 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;*table::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2F;span&gt;&lt;span&gt;}.next_table(page.p4_index());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;huge_page &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    p3.and_then(|p3| p3.next_table(page.p3_index()))
&lt;&#x2F;span&gt;&lt;span&gt;      .and_then(|p2| p2.next_table(page.p2_index()))
&lt;&#x2F;span&gt;&lt;span&gt;      .and_then(|p1| p1[page.p1_index()].pointed_frame())
&lt;&#x2F;span&gt;&lt;span&gt;      .or_else(huge_page)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use an unsafe block to convert the raw &lt;code&gt;P4&lt;&#x2F;code&gt; pointer to a reference. Then we use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;option&#x2F;enum.Option.html#method.and_then&quot;&gt;Option::and_then&lt;&#x2F;a&gt; function to go through the four table levels. If some entry along the way is &lt;code&gt;None&lt;&#x2F;code&gt;, we check if the page is a huge page through the (unimplemented) &lt;code&gt;huge_page&lt;&#x2F;code&gt; closure.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Page::p*_index&lt;&#x2F;code&gt; functions return the different table indexes. They look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p4_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    (self.number &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;27&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p3_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    (self.number &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;18&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p2_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    (self.number &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p1_index(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    (self.number &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;safety-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety-1&quot; aria-label=&quot;Anchor link for: safety-1&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h3&gt;
&lt;p&gt;We use an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block to convert the raw &lt;code&gt;P4&lt;&#x2F;code&gt; pointer into a shared reference. It‚Äôs safe because we don‚Äôt create any &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references to the table right now and don‚Äôt switch the P4 table either. But as soon as we do something like that, we have to revisit this method.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;huge-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#huge-pages&quot; aria-label=&quot;Anchor link for: huge-pages&quot;&gt;üîó&lt;&#x2F;a&gt;Huge Pages&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;huge_page&lt;&#x2F;code&gt; closure calculates the corresponding frame if huge pages are used. Its content looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;p3.and_then(|p3| {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p3_entry = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;p3[page.p3_index()];
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 1GiB page?
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(start_frame) = p3_entry.pointed_frame() {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; p3_entry.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; address must be 1GiB aligned
&lt;&#x2F;span&gt;&lt;span&gt;              assert!(start_frame.number % (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2F;span&gt;&lt;span&gt;) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(Frame {
&lt;&#x2F;span&gt;&lt;span&gt;                  number: start_frame.number + page.p2_index() *
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2F;span&gt;&lt;span&gt;+ page.p1_index(),
&lt;&#x2F;span&gt;&lt;span&gt;              });
&lt;&#x2F;span&gt;&lt;span&gt;          }
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(p2) = p3.next_table(page.p3_index()) {
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p2_entry = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;p2[page.p2_index()];
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 2MiB page?
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(start_frame) = p2_entry.pointed_frame() {
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; p2_entry.flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; address must be 2MiB aligned
&lt;&#x2F;span&gt;&lt;span&gt;                  assert!(start_frame.number % &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2F;span&gt;&lt;span&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(Frame {
&lt;&#x2F;span&gt;&lt;span&gt;                      number: start_frame.number + page.p1_index()
&lt;&#x2F;span&gt;&lt;span&gt;                  });
&lt;&#x2F;span&gt;&lt;span&gt;              }
&lt;&#x2F;span&gt;&lt;span&gt;          }
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      None
&lt;&#x2F;span&gt;&lt;span&gt;  })
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function is much longer and more complex than the &lt;code&gt;translate_page&lt;&#x2F;code&gt; function itself. To avoid this complexity in the future, we will only work with standard 4KiB pages from now on.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mapping-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-pages&quot; aria-label=&quot;Anchor link for: mapping-pages&quot;&gt;üîó&lt;&#x2F;a&gt;Mapping Pages&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs add a function that modifies the page tables to map a &lt;code&gt;Page&lt;&#x2F;code&gt; to a &lt;code&gt;Frame&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2F;span&gt;&lt;span&gt;self::entry::*;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::FrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map_to&amp;lt;A&amp;gt;(page: Page, frame: Frame, flags: EntryFlags,
&lt;&#x2F;span&gt;&lt;span&gt;                 allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p4 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; p3 = p4.next_table_create(page.p4_index(), allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; p2 = p3.next_table_create(page.p3_index(), allocator);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; p1 = p2.next_table_create(page.p2_index(), allocator);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(p1[page.p1_index()].is_unused());
&lt;&#x2F;span&gt;&lt;span&gt;    p1[page.p1_index()].set(frame, flags &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add an re-export for all &lt;code&gt;entry&lt;&#x2F;code&gt; types since they are required to call the function. We assert that the page is unmapped and always set the present flag (since it wouldn‚Äôt make sense to map a page without setting it).&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Table::next_table_create&lt;&#x2F;code&gt; method doesn‚Äôt exist yet. It should return the next table if it exists, or create a new one. For the implementation we need the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; from the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;#a-memory-module&quot;&gt;previous post&lt;&#x2F;a&gt; and the &lt;code&gt;Table::zero&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::FrameAllocator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;next_table_create&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                            index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                            allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;                            -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;L::&lt;&#x2F;span&gt;&lt;span&gt;NextLevel&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.next_table(index).is_none() {
&lt;&#x2F;span&gt;&lt;span&gt;        assert!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;self.entries[index].flags().contains(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping code does not support huge pages&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = allocator.allocate_frame().expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no frames available&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        self.entries[index].set(frame, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        self.next_table_mut(index).unwrap().zero();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    self.next_table_mut(index).unwrap()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can use &lt;code&gt;unwrap()&lt;&#x2F;code&gt; here since the next table definitely exists.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;safety-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety-2&quot; aria-label=&quot;Anchor link for: safety-2&quot;&gt;üîó&lt;&#x2F;a&gt;Safety&lt;&#x2F;h3&gt;
&lt;p&gt;We used an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block in &lt;code&gt;map_to&lt;&#x2F;code&gt; to convert the raw &lt;code&gt;P4&lt;&#x2F;code&gt; pointer to a &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference. That‚Äôs bad. It‚Äôs now possible that the &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; reference is not exclusive, which breaks Rust‚Äôs guarantees. It‚Äôs only a matter time before we run into a data race. For example, imagine that one thread maps an entry to &lt;code&gt;frame_A&lt;&#x2F;code&gt; and another thread (on the same core) tries to map the same entry to &lt;code&gt;frame_B&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that there‚Äôs no clear &lt;em&gt;owner&lt;&#x2F;em&gt; for the page tables. So let‚Äôs define page table ownership!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;page-table-ownership&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-ownership&quot; aria-label=&quot;Anchor link for: page-table-ownership&quot;&gt;üîó&lt;&#x2F;a&gt;Page Table Ownership&lt;&#x2F;h3&gt;
&lt;p&gt;We define the following:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A page table owns all of its subtables.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;We already obey this rule: To get a reference to a table, we need to borrow it from its parent table through the &lt;code&gt;next_table&lt;&#x2F;code&gt; method. But who owns the P4 table?&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The recursively mapped P4 table is owned by a &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; struct.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;We just defined some random owner for the P4 table. But it will solve our problems. And it will also provide the interface to other modules.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs create the struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;self::table::{Table, Level4};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::Unique;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    p4: Unique&amp;lt;Table&amp;lt;Level4&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can‚Äôt store the &lt;code&gt;Table&amp;lt;Level4&amp;gt;&lt;&#x2F;code&gt; directly because it needs to be at a special memory location (like the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;#the-text-buffer&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;). We could use a raw pointer or &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; instead of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;core&#x2F;ptr&#x2F;struct.Unique.html&quot;&gt;Unique&lt;&#x2F;a&gt;, but Unique indicates ownership better.&lt;&#x2F;p&gt;
&lt;p&gt;Because the &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; owns the unique recursive mapped P4 table, there must be only one &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt; instance. Thus we make the constructor function unsafe:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;        ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;            p4: Unique::new_unchecked(table::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add some methods to get P4 references:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p4(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ self.p4.as_ref() }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p4_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ self.p4.as_mut() }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we will only create valid P4 pointers, the &lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks are safe. However, we don‚Äôt make these functions public since they can be used to make page tables invalid. Only the higher level functions (such as &lt;code&gt;translate&lt;&#x2F;code&gt; or &lt;code&gt;map_to&lt;&#x2F;code&gt;) should be usable from other modules.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can make the &lt;code&gt;map_to&lt;&#x2F;code&gt; and &lt;code&gt;translate&lt;&#x2F;code&gt; functions safe by making them methods of &lt;code&gt;ActivePageTable&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ActivePageTable {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span&gt;new() -&amp;gt; ActivePageTable {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p4(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;p4_mut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;translate(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, virtual_address: VirtualAddress)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Option&amp;lt;PhysicalAddress&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;        self.translate_page(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;).map(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;translate_page(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;self, page: Page) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p3 = self.p4().next_table(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map_to&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                     page: Page,
&lt;&#x2F;span&gt;&lt;span&gt;                     frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;                     flags: EntryFlags,
&lt;&#x2F;span&gt;&lt;span&gt;                     allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; p3 = self.p4_mut().next_table_create(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the &lt;code&gt;p4()&lt;&#x2F;code&gt; and &lt;code&gt;p4_mut()&lt;&#x2F;code&gt; methods should be the only methods containing an &lt;code&gt;unsafe&lt;&#x2F;code&gt; block in the &lt;code&gt;paging&#x2F;mod.rs&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-mapping-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-mapping-functions&quot; aria-label=&quot;Anchor link for: more-mapping-functions&quot;&gt;üîó&lt;&#x2F;a&gt;More Mapping Functions&lt;&#x2F;h3&gt;
&lt;p&gt;For convenience, we add a &lt;code&gt;map&lt;&#x2F;code&gt; method that just picks a free frame for us:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;map&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, page: Page, flags: EntryFlags, allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = allocator.allocate_frame().expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;out of memory&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    self.map_to(page, frame, flags, allocator)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We also add a &lt;code&gt;identity_map&lt;&#x2F;code&gt; function to make it easier to remap the kernel in the next post:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;identity_map&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self,
&lt;&#x2F;span&gt;&lt;span&gt;                       frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;                       flags: EntryFlags,
&lt;&#x2F;span&gt;&lt;span&gt;                       allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page = Page::containing_address(frame.start_address());
&lt;&#x2F;span&gt;&lt;span&gt;    self.map_to(page, frame, flags, allocator)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;unmapping-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unmapping-pages&quot; aria-label=&quot;Anchor link for: unmapping-pages&quot;&gt;üîó&lt;&#x2F;a&gt;Unmapping Pages&lt;&#x2F;h3&gt;
&lt;p&gt;To unmap a page, we set the corresponding P1 entry to unused:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;unmap&amp;lt;A&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, page: Page, allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    assert!(self.translate(page.start_address()).is_some());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p1 = self.p4_mut()
&lt;&#x2F;span&gt;&lt;span&gt;                 .next_table_mut(page.p4_index())
&lt;&#x2F;span&gt;&lt;span&gt;                 .and_then(|p3| p3.next_table_mut(page.p3_index()))
&lt;&#x2F;span&gt;&lt;span&gt;                 .and_then(|p2| p2.next_table_mut(page.p2_index()))
&lt;&#x2F;span&gt;&lt;span&gt;                 .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping code does not support huge pages&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = p1[page.p1_index()].pointed_frame().unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    p1[page.p1_index()].set_unused();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO free p(1,2,3) table if empty
&lt;&#x2F;span&gt;&lt;span&gt;    allocator.deallocate_frame(frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The assertion ensures that the page is mapped. Thus the corresponding P1 table and frame must exist for a standard 4KiB page. We set the entry to unused and free the associated frame in the supplied frame allocator.&lt;&#x2F;p&gt;
&lt;p&gt;We can also free the P1, P2, or even P3 table when the last entry is freed. But checking the whole table on every &lt;code&gt;unmap&lt;&#x2F;code&gt; would be very expensive. So we leave the &lt;code&gt;TODO&lt;&#x2F;code&gt; in place until we find a good solution. I‚Äôm open for suggestions :).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Spoiler&lt;&#x2F;em&gt;: There is an ugly bug in this function, which we will find in the next section.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-and-bugfixing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-and-bugfixing&quot; aria-label=&quot;Anchor link for: testing-and-bugfixing&quot;&gt;üîó&lt;&#x2F;a&gt;Testing and Bugfixing&lt;&#x2F;h2&gt;
&lt;p&gt;To test it, we add a &lt;code&gt;test_paging&lt;&#x2F;code&gt; function in &lt;code&gt;memory&#x2F;paging&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;test_paging&amp;lt;A&amp;gt;(allocator: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; A)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2F;span&gt;&lt;span&gt; A: FrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; page_table = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ ActivePageTable::new() };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; test it
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We borrow the frame allocator since we will need it for the mapping functions. To be able to call that function from main, we need to re-export it in &lt;code&gt;memory&#x2F;mod.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in memory&#x2F;mod.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2F;span&gt;&lt;span&gt;self::paging::test_paging;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;memory::test_paging(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;map-to&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-to&quot; aria-label=&quot;Anchor link for: map-to&quot;&gt;üîó&lt;&#x2F;a&gt;map_to&lt;&#x2F;h3&gt;
&lt;p&gt;Let‚Äôs test the &lt;code&gt;map_to&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; addr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; 42th P3 entry
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; page = Page::containing_address(addr);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = allocator.allocate_frame().expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no more frames&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;None = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, map to &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;         page_table.translate(addr),
&lt;&#x2F;span&gt;&lt;span&gt;         frame);
&lt;&#x2F;span&gt;&lt;span&gt;page_table.map_to(page, frame, EntryFlags::empty(), allocator);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, page_table.translate(addr));
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;next free frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, allocator.allocate_frame());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We just map some random page to a free frame. To be able to borrow the page table as &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;, we need to make it mutable.&lt;&#x2F;p&gt;
&lt;p&gt;You should see output similar to this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;None = None, map to Frame { number: 0 }
&lt;&#x2F;span&gt;&lt;span&gt;Some = Some(0)
&lt;&#x2F;span&gt;&lt;span&gt;next free frame: Some(Frame { number: 3 })
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs frame 0 because it‚Äôs the first frame returned by the frame allocator. Since we map the 42th P3 entry, the mapping code needs to create a P2 and a P1 table. So the next free frame returned by the allocator is frame 3.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;unmap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unmap&quot; aria-label=&quot;Anchor link for: unmap&quot;&gt;üîó&lt;&#x2F;a&gt;unmap&lt;&#x2F;h3&gt;
&lt;p&gt;To test the &lt;code&gt;unmap&lt;&#x2F;code&gt; function, we unmap the test page so that it translates to &lt;code&gt;None&lt;&#x2F;code&gt; again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;page_table.unmap(Page::containing_address(addr), allocator);
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;None = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, page_table.translate(addr));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It causes a panic since we call the unimplemented &lt;code&gt;deallocate_frame&lt;&#x2F;code&gt; method in &lt;code&gt;unmap&lt;&#x2F;code&gt;. If we comment this call out, it works without problems. But there is some bug in this function nevertheless.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs read something from the mapped page (of course before we unmap it again):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    *(Page::containing_address(addr).start_address() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const u64&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we don‚Äôt zero the mapped pages, the output is random. For me, it‚Äôs &lt;code&gt;0xf000ff53f000ff53&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If &lt;code&gt;unmap&lt;&#x2F;code&gt; worked correctly, reading it again after unmapping should cause a page fault. But it doesn‚Äôt. Instead, it just prints the same number again. When we remove the first read, we get the desired page fault (i.e. QEMU reboots again and again). So this seems to be some cache issue.&lt;&#x2F;p&gt;
&lt;p&gt;An x86 processor has many different caches because always accessing the main memory would be very slow. Most of these caches are completely &lt;em&gt;transparent&lt;&#x2F;em&gt;. That means everything works exactly the same as without them, it‚Äôs just much faster. But there is one cache, that needs to be updated manually: the &lt;em&gt;translation lookaside buffer&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The translation lookaside buffer, or TLB, caches the translation of virtual to physical addresses. It‚Äôs filled automatically when a page is accessed. But it‚Äôs not updated transparently when the mapping of a page changes. This is the reason that we still can access the page even through we unmapped it in the page table.&lt;&#x2F;p&gt;
&lt;p&gt;So to fix our &lt;code&gt;unmap&lt;&#x2F;code&gt; function, we need to remove the cached translation from the TLB. We can use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;x86_64&quot;&gt;x86_64&lt;&#x2F;a&gt; crate to do this easily. To add it, we append the following to our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.2&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can use it to fix &lt;code&gt;unmap&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    p1[page.p1_index()].set_unused();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::instructions::tlb;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;x86_64::VirtualAddress;
&lt;&#x2F;span&gt;&lt;span&gt;    tlb::flush(VirtualAddress(page.start_address()));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO free p(1,2,3) table if empty
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;allocator.deallocate_frame(frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the desired page fault occurs even when we access the page before.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;üîó&lt;&#x2F;a&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;This post has become pretty long. So let‚Äôs summarize what we‚Äôve done:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;we created a paging module and modeled page tables plus entries&lt;&#x2F;li&gt;
&lt;li&gt;we mapped the P4 page recursively and created &lt;code&gt;next_table&lt;&#x2F;code&gt; methods&lt;&#x2F;li&gt;
&lt;li&gt;we used empty enums and associated types to make the &lt;code&gt;next_table&lt;&#x2F;code&gt; functions safe&lt;&#x2F;li&gt;
&lt;li&gt;we wrote a function to translate virtual to physical addresses&lt;&#x2F;li&gt;
&lt;li&gt;we created safe functions to map and unmap pages&lt;&#x2F;li&gt;
&lt;li&gt;and we fixed stack overflow and TLB related bugs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;remap-the-kernel&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; we will extend this module and add a function to modify inactive page tables. Through that function, we will create a new page table hierarchy that maps the kernel correctly using 4KiB pages. Then we will switch to the new table to get a safer kernel environment.&lt;&#x2F;p&gt;
&lt;p&gt;Afterwards, we will use this paging module to build a heap allocator. This will allow us to use allocation and collection types such as &lt;code&gt;Box&lt;&#x2F;code&gt; and &lt;code&gt;Vec&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;small&gt;Image sources: &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#virtual_physical_translation_source&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-invalid-address&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;If the &lt;code&gt;XXX&lt;&#x2F;code&gt; part of the address is smaller than &lt;code&gt;0o400&lt;&#x2F;code&gt;, it‚Äôs binary representation doesn‚Äôt start with &lt;code&gt;1&lt;&#x2F;code&gt;. But the sign extension bits, which should be a copy of that bit, are &lt;code&gt;1&lt;&#x2F;code&gt; instead of &lt;code&gt;0&lt;&#x2F;code&gt;. Thus the address is not valid.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;virtual_physical_translation_source&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Image sources: Modified versions of an image from  &lt;a href=&quot;https:&#x2F;&#x2F;commons.wikimedia.org&#x2F;wiki&#x2F;File:X86_Paging_64bit.svg&quot;&gt;Wikipedia&lt;&#x2F;a&gt;. The modified files are licensed under the Creative Commons Attribution-Share Alike 3.0 Unported license.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Allocating Frames</title>
                <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/allocating-frames/</link>
                <guid>https://os.phil-opp.com/allocating-frames/</guid>
                <description>&lt;p&gt;In this post we create an allocator that provides free physical frames for a future paging module. To get the required information about available and used memory we use the Multiboot information structure. Additionally, we improve the &lt;code&gt;panic&lt;&#x2F;code&gt; handler to print the corresponding message and source line.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;The full source code is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_5&quot;&gt;GitHub&lt;&#x2F;a&gt;. Feel free to open issues there if you have any problems or improvements. You can also leave a comment at the bottom.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;preparation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preparation&quot; aria-label=&quot;Anchor link for: preparation&quot;&gt;üîó&lt;&#x2F;a&gt;Preparation&lt;&#x2F;h2&gt;
&lt;p&gt;We still have a really tiny stack of 64 bytes, which won‚Äôt suffice for this post. So we increase it to 16kB (four pages) in &lt;code&gt;boot.asm&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span&gt;section .bss
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;stack_bottom:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span&gt;stack_top:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-multiboot-information-structure&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-multiboot-information-structure&quot; aria-label=&quot;Anchor link for: the-multiboot-information-structure&quot;&gt;üîó&lt;&#x2F;a&gt;The Multiboot Information Structure&lt;&#x2F;h2&gt;
&lt;p&gt;When a Multiboot compliant bootloader loads a kernel, it passes a pointer to a boot information structure in the &lt;code&gt;ebx&lt;&#x2F;code&gt; register. We can use it to get information about available memory and loaded kernel sections.&lt;&#x2F;p&gt;
&lt;p&gt;First, we need to pass this pointer to our kernel as an argument to &lt;code&gt;rust_main&lt;&#x2F;code&gt;. To find out how arguments are passed to functions, we can look at the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86_calling_conventions#System_V_AMD64_ABI&quot;&gt;calling convention of Linux&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So to pass the pointer to our kernel, we need to move it to &lt;code&gt;rdi&lt;&#x2F;code&gt; before calling the kernel. Since we‚Äôre not using the &lt;code&gt;rdi&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;edi&lt;&#x2F;code&gt; register in our bootstrap code, we can simply set the &lt;code&gt;edi&lt;&#x2F;code&gt; register right after booting (in &lt;code&gt;boot.asm&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;esp, stack_top
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;edi, ebx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; Move Multiboot info pointer to edi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can add the argument to our &lt;code&gt;rust_main&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main(multiboot_information_address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of writing an own Multiboot module, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;multiboot2&quot;&gt;multiboot2&lt;&#x2F;a&gt; crate. It gives us some basic information about mapped kernel sections and available memory. I just wrote it for this blog post since I could not find any other Multiboot 2 crate. It‚Äôs still incomplete, but it does its job.&lt;&#x2F;p&gt;
&lt;p&gt;So let‚Äôs add a dependency on the git repository:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;multiboot2 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; multiboot2;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can use it to print available memory areas.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;available-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#available-memory&quot; aria-label=&quot;Anchor link for: available-memory&quot;&gt;üîó&lt;&#x2F;a&gt;Available Memory&lt;&#x2F;h3&gt;
&lt;p&gt;The boot information structure consists of various &lt;em&gt;tags&lt;&#x2F;em&gt;. See section 3.4 of the Multiboot specification (&lt;a href=&quot;https:&#x2F;&#x2F;nongnu.askapache.com&#x2F;grub&#x2F;phcoder&#x2F;multiboot.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) for a complete list. The &lt;em&gt;memory map&lt;&#x2F;em&gt; tag contains a list of all available RAM areas. Special areas such as the VGA text buffer at &lt;code&gt;0xb8000&lt;&#x2F;code&gt; are not available. Note that some of the available memory is already used by our kernel and by the multiboot information structure itself.&lt;&#x2F;p&gt;
&lt;p&gt;To print all available memory areas, we can use the &lt;code&gt;multiboot2&lt;&#x2F;code&gt; crate in our &lt;code&gt;rust_main&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; boot_info = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe&lt;&#x2F;span&gt;&lt;span&gt;{ multiboot2::load(multiboot_information_address) };
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; memory_map_tag = boot_info.memory_map_tag()
&lt;&#x2F;span&gt;&lt;span&gt;    .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;memory areas:&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; area &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; memory_map_tag.memory_areas() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    start: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, length: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        area.base_addr, area.length);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;load&lt;&#x2F;code&gt; function is &lt;code&gt;unsafe&lt;&#x2F;code&gt; because it relies on a valid address. Since the memory tag is not required by the Multiboot specification, the &lt;code&gt;memory_map_tag()&lt;&#x2F;code&gt; function returns an &lt;code&gt;Option&lt;&#x2F;code&gt;. The &lt;code&gt;memory_areas()&lt;&#x2F;code&gt; function returns the desired memory area iterator.&lt;&#x2F;p&gt;
&lt;p&gt;The output looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;Hello World!
&lt;&#x2F;span&gt;&lt;span&gt;memory areas:
&lt;&#x2F;span&gt;&lt;span&gt;    start: 0x0, length: 0x9fc00
&lt;&#x2F;span&gt;&lt;span&gt;    start: 0x100000, length: 0x7ee0000
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we have one area from &lt;code&gt;0x0&lt;&#x2F;code&gt; to &lt;code&gt;0x9fc00&lt;&#x2F;code&gt;, which is a bit below the 1MiB mark. The second, bigger area starts at 1MiB and contains the rest of available memory. The area from &lt;code&gt;0x9fc00&lt;&#x2F;code&gt; to 1MiB is not available since it contains for example the VGA text buffer at &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. This is the reason for putting our kernel at 1MiB and not somewhere below.&lt;&#x2F;p&gt;
&lt;p&gt;If you give QEMU more than 4GiB of memory by passing &lt;code&gt;-m 5G&lt;&#x2F;code&gt;, you get another unusable area below the 4GiB mark. This memory is normally mapped to some hardware devices. See the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Memory_Map_(x86)&quot;&gt;OSDev Wiki&lt;&#x2F;a&gt; for more information.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;handling-panics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-panics&quot; aria-label=&quot;Anchor link for: handling-panics&quot;&gt;üîó&lt;&#x2F;a&gt;Handling Panics&lt;&#x2F;h3&gt;
&lt;p&gt;We used &lt;code&gt;expect&lt;&#x2F;code&gt; in the code above, which will panic if there is no memory map tag. But our current panic handler just loops without printing any error message. Of course we could replace &lt;code&gt;expect&lt;&#x2F;code&gt; by a &lt;code&gt;match&lt;&#x2F;code&gt;, but we should fix the panic handler nonetheless:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[lang &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;panic_fmt() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;PANIC&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we get a &lt;code&gt;PANIC&lt;&#x2F;code&gt; message. But we can do even better. The &lt;code&gt;panic_fmt&lt;&#x2F;code&gt; function has actually some arguments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[lang &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;panic_fmt(fmt: core::fmt::Arguments, file: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static str&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    line: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;PANIC in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; at line &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;:&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, file, line);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, fmt);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Be careful with these arguments as the compiler does not check the function signature for &lt;code&gt;lang_items&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now we get the panic message and the causing source line. You can try it by inserting a &lt;code&gt;panic&lt;&#x2F;code&gt; somewhere.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kernel-elf-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-elf-sections&quot; aria-label=&quot;Anchor link for: kernel-elf-sections&quot;&gt;üîó&lt;&#x2F;a&gt;Kernel ELF Sections&lt;&#x2F;h3&gt;
&lt;p&gt;To read and print the sections of our kernel ELF file, we can use the &lt;em&gt;Elf-sections&lt;&#x2F;em&gt; tag:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag = boot_info.elf_sections_tag()
&lt;&#x2F;span&gt;&lt;span&gt;    .expect(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf-sections tag required&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel sections:&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; section &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; elf_sections_tag.sections() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    addr: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, size: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, flags: 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        section.addr, section.size, section.flags);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This should print out the start address and size of all kernel sections. If the section is writable, the &lt;code&gt;0x1&lt;&#x2F;code&gt; bit is set in &lt;code&gt;flags&lt;&#x2F;code&gt;. The &lt;code&gt;0x4&lt;&#x2F;code&gt; bit marks an executable section and the &lt;code&gt;0x2&lt;&#x2F;code&gt; bit indicates that the section was loaded in memory. For example, the &lt;code&gt;.text&lt;&#x2F;code&gt; section is executable but not writable and the &lt;code&gt;.data&lt;&#x2F;code&gt; section just the opposite.&lt;&#x2F;p&gt;
&lt;p&gt;But when we execute it, tons of really small sections are printed. We can use the &lt;code&gt;objdump -h build&#x2F;kernel-x86_64.bin&lt;&#x2F;code&gt; command to list the sections with name. There seem to be over 200 sections and many of them start with &lt;code&gt;.text.*&lt;&#x2F;code&gt; or &lt;code&gt;.data.rel.ro.local.*&lt;&#x2F;code&gt;. This is because the Rust compiler puts e.g. each function in its own &lt;code&gt;.text&lt;&#x2F;code&gt; subsection. That way, unused functions are removed when the linker omits unused sections.&lt;&#x2F;p&gt;
&lt;p&gt;To merge these subsections, we need to update our linker script:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;ENTRY(start)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;SECTIONS {
&lt;&#x2F;span&gt;&lt;span&gt;    . = 1M;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .boot :
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        KEEP(*(.multiboot_header))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .text :
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        *(.text .text.*)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .rodata : {
&lt;&#x2F;span&gt;&lt;span&gt;        *(.rodata .rodata.*)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .data.rel.ro : {
&lt;&#x2F;span&gt;&lt;span&gt;        *(.data.rel.ro.local*) *(.data.rel.ro .data.rel.ro.*)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These lines are taken from the default linker script of &lt;code&gt;ld&lt;&#x2F;code&gt;, which can be obtained through &lt;code&gt;ld¬†‚Äëverbose&lt;&#x2F;code&gt;. The &lt;code&gt;.text&lt;&#x2F;code&gt; &lt;em&gt;output&lt;&#x2F;em&gt; section contains now all &lt;code&gt;.text.*&lt;&#x2F;code&gt; &lt;em&gt;input&lt;&#x2F;em&gt; sections of the static library (and the same applies for the &lt;code&gt;.rodata&lt;&#x2F;code&gt; and &lt;code&gt;.data.rel.ro&lt;&#x2F;code&gt; sections).&lt;&#x2F;p&gt;
&lt;p&gt;Now there are only 12 sections left and we get a much more useful output:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;qemu-memory-areas-and-kernel-sections.png&quot; alt=&quot;qemu output&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you like, you can compare this output to the &lt;code&gt;objdump -h build&#x2F;kernel-x86_64.bin&lt;&#x2F;code&gt; output. You will see that the start addresses and sizes match exactly for each section. The sections with flags &lt;code&gt;0x0&lt;&#x2F;code&gt; are mostly debug sections, so they don‚Äôt need to be loaded. And the last few sections of the QEMU output aren‚Äôt in the &lt;code&gt;objdump&lt;&#x2F;code&gt; output because they are special sections such as string tables.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;start-and-end-of-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#start-and-end-of-kernel&quot; aria-label=&quot;Anchor link for: start-and-end-of-kernel&quot;&gt;üîó&lt;&#x2F;a&gt;Start and End of Kernel&lt;&#x2F;h3&gt;
&lt;p&gt;We can now use the ELF section tag to calculate the start and end address of our loaded kernel:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_start = elf_sections_tag.sections().map(|s| s.addr)
&lt;&#x2F;span&gt;&lt;span&gt;    .min().unwrap();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; kernel_end = elf_sections_tag.sections().map(|s| s.addr + s.size)
&lt;&#x2F;span&gt;&lt;span&gt;    .max().unwrap();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The other used memory area is the Multiboot Information structure:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_start = multiboot_information_address;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; multiboot_end = multiboot_start + (boot_info.total_size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Printing these numbers gives us:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;kernel_start: 0x100000, kernel_end: 0x11a168
&lt;&#x2F;span&gt;&lt;span&gt;multiboot_start: 0x11d400, multiboot_end: 0x11d9c8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the kernel starts at 1MiB (like expected) and is about 105 KiB in size. The multiboot information structure was placed at &lt;code&gt;0x11d400&lt;&#x2F;code&gt; by GRUB and needs 1480 bytes. Of course your numbers could be a bit different due to different versions of Rust or GRUB (or some differences in the source code).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-frame-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-frame-allocator&quot; aria-label=&quot;Anchor link for: a-frame-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;A frame allocator&lt;&#x2F;h2&gt;
&lt;p&gt;When using paging, the physical memory is split into equally sized chunks (normally 4096 bytes) Such a chunk is called ‚Äúphysical page‚Äù or ‚Äúframe‚Äù. These frames can be mapped to any virtual page through page tables. For more information about paging take a peek at the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We will need a free frame in many cases. For example when want to increase the size of our future kernel heap. Or when we create a new page table. Or when we add a new kernel thread and thus need to allocate a new stack. So we need some kind of allocator that keeps track of physical frames and gives us a free one when needed.&lt;&#x2F;p&gt;
&lt;p&gt;There are various ways to write such a frame allocator:&lt;&#x2F;p&gt;
&lt;p&gt;We could create some kind of linked list from the free frames. For example, each frame could begin with a pointer to the next free frame. Since the frames are free, this would not overwrite any data. Our allocator would just save the head of the list and could easily allocate and deallocate frames by updating pointers. Unfortunately, this approach has a problem: It requires reading and writing these free frames. So we would need to map all physical frames to some virtual address, at least temporary. Another disadvantage is that we need to create this linked list at startup. That implies that we need to set over one million pointers at startup if the machine has 4GiB of RAM.&lt;&#x2F;p&gt;
&lt;p&gt;Another approach is to create some kind of data structure such as a &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Page_Frame_Allocation#Physical_Memory_Allocators&quot;&gt;bitmap or a stack&lt;&#x2F;a&gt; to manage free frames. We could place it in the already identity mapped area right behind the kernel or multiboot structure. That way we would not need to (temporary) map each free frame. But it has the same problem of the slow initial creating&#x2F;filling. In fact, we will use this approach in a future post to manage frames that are freed again. But for the initial management of free frames, we use a different method.&lt;&#x2F;p&gt;
&lt;p&gt;In the following, we will use Multiboot‚Äôs memory map directly. The idea is to maintain a simple counter that starts at frame 0 and is increased constantly. If the current frame is available (part of an available area in the memory map) and not used by the kernel or the multiboot structure (we know their start and end addresses), we know that it‚Äôs free and return it. Else, we increase the counter to the next possibly free frame. That way, we don‚Äôt need to create a data structure when booting and the physical frames can remain unmapped. The only problem is that we cannot reasonably free frames again, but we will solve that problem in a future post (by adding an intermediate frame stack that saves freed frames).&lt;&#x2F;p&gt;
&lt;!--- TODO link future post --&gt;
&lt;p&gt;So let‚Äôs start implementing our memory map based frame allocator.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-memory-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-memory-module&quot; aria-label=&quot;Anchor link for: a-memory-module&quot;&gt;üîó&lt;&#x2F;a&gt;A Memory Module&lt;&#x2F;h3&gt;
&lt;p&gt;First we create a memory module with a &lt;code&gt;Frame&lt;&#x2F;code&gt; type (&lt;code&gt;src&#x2F;memory&#x2F;mod.rs&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Frame {
&lt;&#x2F;span&gt;&lt;span&gt;    number: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Don‚Äôt forget to add the &lt;code&gt;mod memory&lt;&#x2F;code&gt; line to &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;.) Instead of e.g. the start address, we just store the frame number. We use &lt;code&gt;usize&lt;&#x2F;code&gt; here since the number of frames depends on the memory size. The long &lt;code&gt;derive&lt;&#x2F;code&gt; line makes frames printable and comparable.&lt;&#x2F;p&gt;
&lt;p&gt;To make it easy to get the corresponding frame for a physical address, we add a &lt;code&gt;containing_address&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Frame {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;containing_address(address: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Frame {
&lt;&#x2F;span&gt;&lt;span&gt;        Frame{ number: address &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We also add a &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deallocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, frame: Frame);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows us to create another, more advanced frame allocator in the future.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator&quot; aria-label=&quot;Anchor link for: the-allocator&quot;&gt;üîó&lt;&#x2F;a&gt;The Allocator&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can put everything together and create the actual frame allocator. Therefor we create a &lt;code&gt;src&#x2F;memory&#x2F;area_frame_allocator.rs&lt;&#x2F;code&gt; submodule. The allocator struct looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;memory::{Frame, FrameAllocator};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;multiboot2::{MemoryAreaIter, MemoryArea};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AreaFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    next_free_frame: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;    current_area: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt; MemoryArea&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    areas: MemoryAreaIter,
&lt;&#x2F;span&gt;&lt;span&gt;    kernel_start: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;    kernel_end: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;    multiboot_start: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;    multiboot_end: Frame,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;next_free_frame&lt;&#x2F;code&gt; field is a simple counter that is increased every time we return a frame. It‚Äôs initialized to &lt;code&gt;0&lt;&#x2F;code&gt; and every frame below it counts as used. The &lt;code&gt;current_area&lt;&#x2F;code&gt; field holds the memory area that contains &lt;code&gt;next_free_frame&lt;&#x2F;code&gt;. If &lt;code&gt;next_free_frame&lt;&#x2F;code&gt; leaves this area, we will look for the next one in &lt;code&gt;areas&lt;&#x2F;code&gt;. When there are no areas left, all frames are used and &lt;code&gt;current_area&lt;&#x2F;code&gt; becomes &lt;code&gt;None&lt;&#x2F;code&gt;. The &lt;code&gt;{kernel, multiboot}_{start, end}&lt;&#x2F;code&gt; fields are used to avoid returning already used fields.&lt;&#x2F;p&gt;
&lt;p&gt;To implement the &lt;code&gt;FrameAllocator&lt;&#x2F;code&gt; trait, we need to implement the allocation and deallocation methods:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AreaFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO (see below)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deallocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, frame: Frame) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; TODO (see below)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;allocate_frame&lt;&#x2F;code&gt; method looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `allocate_frame` in `impl FrameAllocator for AreaFrameAllocator`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(area) = self.current_area {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; &amp;quot;Clone&amp;quot; the frame to return it if it&amp;#39;s free. Frame doesn&amp;#39;t
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; implement Clone, but we can construct an identical frame.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; frame = Frame{ number: self.next_free_frame.number };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; the last frame of the current area
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; current_area_last_frame = {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; address = area.base_addr + area.length - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Frame::containing_address(address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; frame &amp;gt; current_area_last_frame {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; all frames of current area are used, switch to next area
&lt;&#x2F;span&gt;&lt;span&gt;        self.choose_next_area();
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; frame &amp;gt;= self.kernel_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; frame &amp;lt;= self.kernel_end {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `frame` is used by the kernel
&lt;&#x2F;span&gt;&lt;span&gt;        self.next_free_frame = Frame {
&lt;&#x2F;span&gt;&lt;span&gt;            number: self.kernel_end.number + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; frame &amp;gt;= self.multiboot_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; frame &amp;lt;= self.multiboot_end {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `frame` is used by the multiboot information structure
&lt;&#x2F;span&gt;&lt;span&gt;        self.next_free_frame = Frame {
&lt;&#x2F;span&gt;&lt;span&gt;            number: self.multiboot_end.number + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; frame is unused, increment `next_free_frame` and return it
&lt;&#x2F;span&gt;&lt;span&gt;        self.next_free_frame.number += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;Some(frame);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; `frame` was not valid, try it again with the updated `next_free_frame`
&lt;&#x2F;span&gt;&lt;span&gt;    self.allocate_frame()
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    None &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; no free frames left
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;choose_next_area&lt;&#x2F;code&gt; method isn‚Äôt part of the trait and thus goes into a new &lt;code&gt;impl¬†AreaFrameAllocator&lt;&#x2F;code&gt; block:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl AreaFrameAllocator`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;choose_next_area(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;    self.current_area = self.areas.clone().filter(|area| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; address = area.base_addr + area.length - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Frame::containing_address(address &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;) &amp;gt;= self.next_free_frame
&lt;&#x2F;span&gt;&lt;span&gt;    }).min_by_key(|area| area.base_addr);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(area) = self.current_area {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start_frame = Frame::containing_address(area.base_addr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.next_free_frame &amp;lt; start_frame {
&lt;&#x2F;span&gt;&lt;span&gt;            self.next_free_frame = start_frame;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function chooses the area with the minimal base address that still has free frames, i.e. &lt;code&gt;next_free_frame&lt;&#x2F;code&gt; is smaller than its last frame. Note that we need to clone the iterator because the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.min_by_key&quot;&gt;min_by_key&lt;&#x2F;a&gt; function consumes it. If there are no areas with free frames left, &lt;code&gt;min_by_key&lt;&#x2F;code&gt; automatically returns the desired &lt;code&gt;None&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If the &lt;code&gt;next_free_frame&lt;&#x2F;code&gt; is below the new &lt;code&gt;current_area&lt;&#x2F;code&gt;, it needs to be updated to the area‚Äôs start frame. Else, the &lt;code&gt;allocate_frame&lt;&#x2F;code&gt; call could return an unavailable frame.&lt;&#x2F;p&gt;
&lt;p&gt;We don‚Äôt have a data structure to store free frames, so we can‚Äôt implement &lt;code&gt;deallocate_frame&lt;&#x2F;code&gt; reasonably. Thus we use the &lt;code&gt;unimplemented&lt;&#x2F;code&gt; macro, which just panics when the method is called:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FrameAllocator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AreaFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;allocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; described above
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;deallocate_frame(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, _frame: Frame) {
&lt;&#x2F;span&gt;&lt;span&gt;        unimplemented!()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we only need a constructor function to make the allocator usable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;new(kernel_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, kernel_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      multiboot_start: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, multiboot_end: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      memory_areas: MemoryAreaIter) -&amp;gt; AreaFrameAllocator
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; allocator = AreaFrameAllocator {
&lt;&#x2F;span&gt;&lt;span&gt;        next_free_frame: Frame::containing_address(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        current_area: None,
&lt;&#x2F;span&gt;&lt;span&gt;        areas: memory_areas,
&lt;&#x2F;span&gt;&lt;span&gt;        kernel_start: Frame::containing_address(kernel_start),
&lt;&#x2F;span&gt;&lt;span&gt;        kernel_end: Frame::containing_address(kernel_end),
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot_start: Frame::containing_address(multiboot_start),
&lt;&#x2F;span&gt;&lt;span&gt;        multiboot_end: Frame::containing_address(multiboot_end),
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    allocator.choose_next_area();
&lt;&#x2F;span&gt;&lt;span&gt;    allocator
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we call &lt;code&gt;choose_next_area&lt;&#x2F;code&gt; manually here because &lt;code&gt;allocate_frame&lt;&#x2F;code&gt; returns &lt;code&gt;None&lt;&#x2F;code&gt; as soon as &lt;code&gt;current_area&lt;&#x2F;code&gt; is &lt;code&gt;None&lt;&#x2F;code&gt;. So by calling &lt;code&gt;choose_next_area&lt;&#x2F;code&gt; we initialize it to the area with the minimal base address.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;üîó&lt;&#x2F;a&gt;Testing it&lt;&#x2F;h3&gt;
&lt;p&gt;In order to test it in main, we need to &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;crates-and-modules.html#re-exporting-with-pub-use&quot;&gt;re-export&lt;&#x2F;a&gt; the &lt;code&gt;AreaFrameAllocator&lt;&#x2F;code&gt; in the &lt;code&gt;memory&lt;&#x2F;code&gt; module. Then we can create a new allocator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; frame_allocator = memory::AreaFrameAllocator::new(
&lt;&#x2F;span&gt;&lt;span&gt;    kernel_start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, kernel_end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;, multiboot_start,
&lt;&#x2F;span&gt;&lt;span&gt;    multiboot_end, memory_map_tag.memory_areas());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can test it by adding some frame allocations:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, frame_allocator.allocate_frame());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You will see that the frame number starts at &lt;code&gt;0&lt;&#x2F;code&gt; and increases steadily, but the kernel and Multiboot frames are left out (you need to allocate many frames to see this since the kernel starts at frame 256).&lt;&#x2F;p&gt;
&lt;p&gt;The following &lt;code&gt;for&lt;&#x2F;code&gt; loop allocates all frames and prints out the total number of allocated frames:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;.. &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;None = frame_allocator.allocate_frame() {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;allocated &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; frames&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, i);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can try different amounts of memory by passing e.g. &lt;code&gt;-m 500M&lt;&#x2F;code&gt; to QEMU. To compare these numbers, &lt;a href=&quot;https:&#x2F;&#x2F;www.wolframalpha.com&#x2F;input&#x2F;?i=%2832605+*+4096%29+bytes+in+MiB&quot;&gt;WolframAlpha&lt;&#x2F;a&gt; can be very helpful.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;üîó&lt;&#x2F;a&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Now we have a working frame allocator. It is a bit rudimentary and cannot free frames, but it also is very fast since it reuses the Multiboot memory map and does not need any costly initialization. A future post will build upon this allocator and add a stack-like data structure for freed frames.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;page-tables&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; will be about paging again. We will use the frame allocator to create a safe module that allows us to switch page tables and map pages. Then we will use this module and the information from the Elf-sections tag to remap the kernel correctly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recommended-posts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recommended-posts&quot; aria-label=&quot;Anchor link for: recommended-posts&quot;&gt;üîó&lt;&#x2F;a&gt;Recommended Posts&lt;&#x2F;h2&gt;
&lt;p&gt;Eric Kidd started the &lt;a href=&quot;http:&#x2F;&#x2F;www.randomhacks.net&#x2F;bare-metal-rust&#x2F;&quot;&gt;Bare Metal Rust&lt;&#x2F;a&gt; series last week. Like this post, it builds upon the code from &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;&quot;&gt;Printing to Screen&lt;&#x2F;a&gt;, but tries to support keyboard input instead of wrestling through memory management details.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Printing to Screen</title>
                <pubDate>Fri, 23 Oct 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/printing-to-screen/</link>
                <guid>https://os.phil-opp.com/printing-to-screen/</guid>
                <description>&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-rust&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; we switched from assembly to &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt;, a systems programming language that provides great safety. But so far we are using unsafe features like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;raw-pointers.html&quot;&gt;raw pointers&lt;&#x2F;a&gt; whenever we want to print to screen. In this post we will create a Rust module that provides a safe and easy-to-use interface for the VGA text buffer. It will support Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;#related-macros&quot;&gt;formatting macros&lt;&#x2F;a&gt;, too.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This post uses recent unstable features, so you need an up-to-date nighly compiler. If you have any questions, problems, or suggestions please &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;file an issue&lt;&#x2F;a&gt; or create a comment at the bottom. The code from this post is also available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_4&quot;&gt;GitHub&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-vga-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-vga-text-buffer&quot; aria-label=&quot;Anchor link for: the-vga-text-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;The VGA Text Buffer&lt;&#x2F;h2&gt;
&lt;p&gt;The text buffer starts at physical address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; and contains the characters displayed on screen. It has 25 rows and 80 columns. Each screen character has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Value&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-7&lt;&#x2F;td&gt;&lt;td&gt;ASCII code point&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8-11&lt;&#x2F;td&gt;&lt;td&gt;Foreground color&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;12-14&lt;&#x2F;td&gt;&lt;td&gt;Background color&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;td&gt;Blink&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The following colors are available:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number&lt;&#x2F;th&gt;&lt;th&gt;Color&lt;&#x2F;th&gt;&lt;th&gt;Number + Bright Bit&lt;&#x2F;th&gt;&lt;th&gt;Bright Color&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0x0&lt;&#x2F;td&gt;&lt;td&gt;Black&lt;&#x2F;td&gt;&lt;td&gt;0x8&lt;&#x2F;td&gt;&lt;td&gt;Dark Gray&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x1&lt;&#x2F;td&gt;&lt;td&gt;Blue&lt;&#x2F;td&gt;&lt;td&gt;0x9&lt;&#x2F;td&gt;&lt;td&gt;Light Blue&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x2&lt;&#x2F;td&gt;&lt;td&gt;Green&lt;&#x2F;td&gt;&lt;td&gt;0xa&lt;&#x2F;td&gt;&lt;td&gt;Light Green&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x3&lt;&#x2F;td&gt;&lt;td&gt;Cyan&lt;&#x2F;td&gt;&lt;td&gt;0xb&lt;&#x2F;td&gt;&lt;td&gt;Light Cyan&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x4&lt;&#x2F;td&gt;&lt;td&gt;Red&lt;&#x2F;td&gt;&lt;td&gt;0xc&lt;&#x2F;td&gt;&lt;td&gt;Light Red&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x5&lt;&#x2F;td&gt;&lt;td&gt;Magenta&lt;&#x2F;td&gt;&lt;td&gt;0xd&lt;&#x2F;td&gt;&lt;td&gt;Pink&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x6&lt;&#x2F;td&gt;&lt;td&gt;Brown&lt;&#x2F;td&gt;&lt;td&gt;0xe&lt;&#x2F;td&gt;&lt;td&gt;Yellow&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0x7&lt;&#x2F;td&gt;&lt;td&gt;Light Gray&lt;&#x2F;td&gt;&lt;td&gt;0xf&lt;&#x2F;td&gt;&lt;td&gt;White&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Bit 4 is the &lt;em&gt;bright bit&lt;&#x2F;em&gt;, which turns for example blue into light blue. It is unavailable in background color as the bit is used to control if the text should blink. If you want to use a light background color (e.g. white) you have to disable blinking through a &lt;a href=&quot;http:&#x2F;&#x2F;www.ctyme.com&#x2F;intr&#x2F;rb-0117.htm&quot;&gt;BIOS function&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-basic-rust-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-basic-rust-module&quot; aria-label=&quot;Anchor link for: a-basic-rust-module&quot;&gt;üîó&lt;&#x2F;a&gt;A basic Rust Module&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we know how the VGA buffer works, we can create a Rust module to handle printing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F;‚ÄØin src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The content of this module can live either in &lt;code&gt;src&#x2F;vga_buffer.rs&lt;&#x2F;code&gt; or &lt;code&gt;src&#x2F;vga_buffer&#x2F;mod.rs&lt;&#x2F;code&gt;. The latter supports submodules while the former does not. But our module does not need any submodules so we create it as &lt;code&gt;src&#x2F;vga_buffer.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;All of the code below goes into our new module (unless specified otherwise).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;colors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#colors&quot; aria-label=&quot;Anchor link for: colors&quot;&gt;üîó&lt;&#x2F;a&gt;Colors&lt;&#x2F;h3&gt;
&lt;p&gt;First, we represent the different colors using an enum:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[allow(dead_code)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u8)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Color {
&lt;&#x2F;span&gt;&lt;span&gt;    Black      = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Blue       = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Green      = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Cyan       = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Red        = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Magenta    = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Brown      = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightGray  = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    DarkGray   = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightBlue  = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightGreen = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightCyan  = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    LightRed   = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Pink       = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    Yellow     = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    White      = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;custom_types&#x2F;enum&#x2F;c_like.html&quot;&gt;C-like enum&lt;&#x2F;a&gt; here to explicitly specify the number for each color. Because of the &lt;code&gt;repr(u8)&lt;&#x2F;code&gt; attribute each enum variant is stored as an &lt;code&gt;u8&lt;&#x2F;code&gt;. Actually 4 bits would be sufficient, but Rust doesn‚Äôt have an &lt;code&gt;u4&lt;&#x2F;code&gt; type.&lt;&#x2F;p&gt;
&lt;p&gt;Normally the compiler would issue a warning for each unused variant. By using the &lt;code&gt;#[allow(dead_code)]&lt;&#x2F;code&gt; attribute we disable these warnings for the &lt;code&gt;Color&lt;&#x2F;code&gt; enum.&lt;&#x2F;p&gt;
&lt;p&gt;To represent a full color code that specifies foreground and background color, we create a newtype on top of &lt;code&gt;u8&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ColorCode(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ColorCode {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const fn &lt;&#x2F;span&gt;&lt;span&gt;new(foreground: Color, background: Color) -&amp;gt; ColorCode {
&lt;&#x2F;span&gt;&lt;span&gt;        ColorCode((background &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(foreground &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;ColorCode&lt;&#x2F;code&gt; contains the full color byte, containing foreground and background color. Blinking is enabled implicitly by using a bright background color (soon we will disable blinking anyway). The &lt;code&gt;new&lt;&#x2F;code&gt; function is a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;0911-const-fn.md&quot;&gt;const function&lt;&#x2F;a&gt; to allow it in static initializers. As &lt;code&gt;const&lt;&#x2F;code&gt; functions are unstable we need to add the &lt;code&gt;const_fn&lt;&#x2F;code&gt; feature in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-text-buffer&quot; aria-label=&quot;Anchor link for: the-text-buffer&quot;&gt;üîó&lt;&#x2F;a&gt;The Text Buffer&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can add structures to represent a screen character and the text buffer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;    ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;25&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;80&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the field ordering in default structs is undefined in Rust, we need the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;nomicon&#x2F;other-reprs.html#reprc&quot;&gt;repr(C)&lt;&#x2F;a&gt; attribute. It guarantees that the struct‚Äôs fields are laid out exactly like in a C struct and thus guarantees the correct field ordering.&lt;&#x2F;p&gt;
&lt;p&gt;To actually write to screen, we now create a writer type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::ptr::Unique;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode,
&lt;&#x2F;span&gt;&lt;span&gt;    buffer: Unique&amp;lt;Buffer&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The writer will always write to the last line and shift lines up when a line is full (or on &lt;code&gt;\n&lt;&#x2F;code&gt;). The &lt;code&gt;column_position&lt;&#x2F;code&gt; field keeps track of the current position in the last row. The current foreground and background colors are specified by &lt;code&gt;color_code&lt;&#x2F;code&gt; and a pointer to the VGA buffer is stored in &lt;code&gt;buffer&lt;&#x2F;code&gt;. To make it possible to create a &lt;code&gt;static&lt;&#x2F;code&gt; Writer later, the &lt;code&gt;buffer&lt;&#x2F;code&gt; field stores an &lt;code&gt;Unique&amp;lt;Buffer&amp;gt;&lt;&#x2F;code&gt; instead of a plain &lt;code&gt;*mut Buffer&lt;&#x2F;code&gt;. &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;core&#x2F;ptr&#x2F;struct.Unique.html&quot;&gt;Unique&lt;&#x2F;a&gt; is a wrapper that implements Send&#x2F;Sync and is thus usable as a &lt;code&gt;static&lt;&#x2F;code&gt;. Since it‚Äôs unstable, you may need to add the &lt;code&gt;unique&lt;&#x2F;code&gt; feature to &lt;code&gt;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;#![feature(unique)]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;printing-characters&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-characters&quot; aria-label=&quot;Anchor link for: printing-characters&quot;&gt;üîó&lt;&#x2F;a&gt;Printing Characters&lt;&#x2F;h2&gt;
&lt;p&gt;Now we can use the &lt;code&gt;Writer&lt;&#x2F;code&gt; to modify the buffer‚Äôs characters. First we create a method to write a single ASCII byte (it doesn‚Äôt compile yet):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, byte: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; byte {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.new_line(),
&lt;&#x2F;span&gt;&lt;span&gt;            byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;self.column_position &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                    self.new_line();
&lt;&#x2F;span&gt;&lt;span&gt;                }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; row = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; col = self.column_position;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; color_code = self.color_code;
&lt;&#x2F;span&gt;&lt;span&gt;                self.buffer().chars[row][col] = ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;                    ascii_character: byte,
&lt;&#x2F;span&gt;&lt;span&gt;                    color_code: color_code,
&lt;&#x2F;span&gt;&lt;span&gt;                };
&lt;&#x2F;span&gt;&lt;span&gt;                self.column_position += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;buffer(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe&lt;&#x2F;span&gt;&lt;span&gt;{ self.buffer.as_mut() }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new_line(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* TODO *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the byte is the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Newline&quot;&gt;newline&lt;&#x2F;a&gt; byte &lt;code&gt;\n&lt;&#x2F;code&gt;, the writer does not print anything. Instead it calls a &lt;code&gt;new_line&lt;&#x2F;code&gt; method, which we‚Äôll implement later. Other bytes get printed to the screen in the second match case.&lt;&#x2F;p&gt;
&lt;p&gt;When printing a byte, the writer checks if the current line is full. In that case, a &lt;code&gt;new_line&lt;&#x2F;code&gt; call is required before to wrap the line. Then it writes a new &lt;code&gt;ScreenChar&lt;&#x2F;code&gt; to the buffer at the current position. Finally, the current column position is advanced.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;buffer()&lt;&#x2F;code&gt; auxiliary method converts the raw pointer in the &lt;code&gt;buffer&lt;&#x2F;code&gt; field into a safe mutable buffer reference. The unsafe block is needed because the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.26.0&#x2F;core&#x2F;ptr&#x2F;struct.Unique.html#method.as_mut&quot;&gt;as_mut()&lt;&#x2F;a&gt; method of &lt;code&gt;Unique&lt;&#x2F;code&gt; is unsafe. But our &lt;code&gt;buffer()&lt;&#x2F;code&gt; method itself isn‚Äôt marked as unsafe, so it must not introduce any unsafety (e.g. cause segfaults). To guarantee that, it‚Äôs very important that the &lt;code&gt;buffer&lt;&#x2F;code&gt; field always points to a valid &lt;code&gt;Buffer&lt;&#x2F;code&gt;. It‚Äôs like a contract that we must stand to every time we create a &lt;code&gt;Writer&lt;&#x2F;code&gt;. To ensure that it‚Äôs not possible to create an invalid &lt;code&gt;Writer&lt;&#x2F;code&gt; from outside of the module, the struct must have at least one private field and public creation functions are not allowed either.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cannot-move-out-of-borrowed-content&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cannot-move-out-of-borrowed-content&quot; aria-label=&quot;Anchor link for: cannot-move-out-of-borrowed-content&quot;&gt;üîó&lt;&#x2F;a&gt;Cannot Move out of Borrowed Content&lt;&#x2F;h3&gt;
&lt;p&gt;When we try to compile it, we get the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0507]: cannot move out of borrowed content
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; src&#x2F;vga_buffer.rs:79:34
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;79 | let color_code = self.color_code;
&lt;&#x2F;span&gt;&lt;span&gt;   |                  ^^^^ cannot move out of borrowed content
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason it that Rust &lt;em&gt;moves&lt;&#x2F;em&gt; values by default instead of copying them like other languages. And we cannot move &lt;code&gt;color_code&lt;&#x2F;code&gt; out of &lt;code&gt;self&lt;&#x2F;code&gt; because we only borrowed &lt;code&gt;self&lt;&#x2F;code&gt;. For more information check out the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ownership.html&quot;&gt;ownership section&lt;&#x2F;a&gt; in the Rust book.&lt;&#x2F;p&gt;
&lt;p&gt;To fix it, we can implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;Copy&lt;&#x2F;a&gt; trait for the &lt;code&gt;ColorCode&lt;&#x2F;code&gt; type. The easiest way to do this is to use the built-in &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;custom_types&#x2F;enum&#x2F;c_like.html&quot;&gt;derive macro&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ColorCode(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We also derive the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;clone&#x2F;trait.Clone.html&quot;&gt;Clone&lt;&#x2F;a&gt; trait, since it‚Äôs a requirement for &lt;code&gt;Copy&lt;&#x2F;code&gt;, and the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Debug.html&quot;&gt;Debug&lt;&#x2F;a&gt; trait, which allows us to print this field for debugging purposes.&lt;&#x2F;p&gt;
&lt;p&gt;Now our project should compile again.&lt;&#x2F;p&gt;
&lt;p&gt;However, the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;core&#x2F;marker&#x2F;trait.Copy.html#when-should-my-type-be-copy&quot;&gt;documentation for Copy&lt;&#x2F;a&gt; says: &lt;em&gt;‚Äúif your type can implement Copy, it should‚Äù&lt;&#x2F;em&gt;. Therefore we also derive Copy for &lt;code&gt;Color&lt;&#x2F;code&gt; and &lt;code&gt;ScreenChar&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[allow(dead_code)]
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(u8)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Color {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2F;span&gt;&lt;span&gt;#[repr(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;ScreenChar {...}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;üîó&lt;&#x2F;a&gt;Try it out!&lt;&#x2F;h3&gt;
&lt;p&gt;To write some characters to the screen, you can create a temporary function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;print_something() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;        column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: ColorCode::new(Color::LightGreen, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;        buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Unique::new_unchecked(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;) },
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It just creates a new Writer that points to the VGA buffer at &lt;code&gt;0xb8000&lt;&#x2F;code&gt;. To use the unstable &lt;code&gt;Unique::new_unchecked&lt;&#x2F;code&gt; function, we need to add the feature flag &lt;code&gt;#![feature(const_unique_new)]&lt;&#x2F;code&gt; to the top of our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Then it writes the byte &lt;code&gt;b&#x27;H&#x27;&lt;&#x2F;code&gt; to it. The &lt;code&gt;b&lt;&#x2F;code&gt; prefix creates a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;tokens.html#characters-and-strings&quot;&gt;byte character&lt;&#x2F;a&gt;, which represents an ASCII code point. When we call &lt;code&gt;vga_buffer::print_something&lt;&#x2F;code&gt; in main, a &lt;code&gt;H&lt;&#x2F;code&gt; should be printed in the &lt;em&gt;lower&lt;&#x2F;em&gt; left corner of the screen in light green:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;vga-H-lower-left.png&quot; alt=&quot;QEMU output with a green H in the lower left corner&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;volatile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#volatile&quot; aria-label=&quot;Anchor link for: volatile&quot;&gt;üîó&lt;&#x2F;a&gt;Volatile&lt;&#x2F;h3&gt;
&lt;p&gt;We just saw that our &lt;code&gt;H&lt;&#x2F;code&gt; was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that we only write to the &lt;code&gt;Buffer&lt;&#x2F;code&gt; and never read from it again. The compiler doesn‚Äôt know about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid this erroneous optimization, we need to specify these writes as &lt;em&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Volatile_(computer_programming)&quot;&gt;volatile&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;. This tells the compiler that the write has side effects and should not be optimized away.&lt;&#x2F;p&gt;
&lt;p&gt;In order to use volatile writes for the VGA buffer, we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;volatile&quot;&gt;volatile&lt;&#x2F;a&gt; library. This &lt;em&gt;crate&lt;&#x2F;em&gt; (this is how packages are called in the Rust world) provides a &lt;code&gt;Volatile&lt;&#x2F;code&gt; wrapper type with &lt;code&gt;read&lt;&#x2F;code&gt; and &lt;code&gt;write&lt;&#x2F;code&gt; methods. These methods internally use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;fn.read_volatile.html&quot;&gt;read_volatile&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;ptr&#x2F;fn.write_volatile.html&quot;&gt;write_volatile&lt;&#x2F;a&gt; functions of the standard library and thus guarantee that the reads&#x2F;writes are not optimized away.&lt;&#x2F;p&gt;
&lt;p&gt;We can add a dependency on the &lt;code&gt;volatile&lt;&#x2F;code&gt; crate by adding it to the &lt;code&gt;dependencies&lt;&#x2F;code&gt; section of our &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;volatile &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;0.1.0&lt;&#x2F;code&gt; is the &lt;a href=&quot;https:&#x2F;&#x2F;semver.org&#x2F;&quot;&gt;semantic&lt;&#x2F;a&gt; version number. For more information, see the &lt;a href=&quot;https:&#x2F;&#x2F;doc.crates.io&#x2F;specifying-dependencies.html&quot;&gt;Specifying Dependencies&lt;&#x2F;a&gt; guide of the cargo documentation.&lt;&#x2F;p&gt;
&lt;p&gt;Now we‚Äôve declared that our project depends on the &lt;code&gt;volatile&lt;&#x2F;code&gt; crate and are able to import it in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; volatile;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs use it to make writes to the VGA buffer volatile. We update our &lt;code&gt;Buffer&lt;&#x2F;code&gt; type as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;volatile::Volatile;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Buffer {
&lt;&#x2F;span&gt;&lt;span&gt;    chars: [[Volatile&amp;lt;ScreenChar&amp;gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;ScreenChar&lt;&#x2F;code&gt;, we‚Äôre now using a &lt;code&gt;Volatile&amp;lt;ScreenChar&amp;gt;&lt;&#x2F;code&gt;. (The &lt;code&gt;Volatile&lt;&#x2F;code&gt; type is &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;second-edition&#x2F;ch10-00-generics.html&quot;&gt;generic&lt;&#x2F;a&gt; and can wrap (almost) any type). This ensures that we can‚Äôt accidentally write to it through a ‚Äúnormal‚Äù write. Instead, we have to use the &lt;code&gt;write&lt;&#x2F;code&gt; method now.&lt;&#x2F;p&gt;
&lt;p&gt;This means that we have to update our &lt;code&gt;Writer::write_byte&lt;&#x2F;code&gt; method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, byte: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; byte {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;self.new_line(),
&lt;&#x2F;span&gt;&lt;span&gt;            byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;                self.buffer().chars[row][col].write(ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;                    ascii_character: byte,
&lt;&#x2F;span&gt;&lt;span&gt;                    color_code: color_code,
&lt;&#x2F;span&gt;&lt;span&gt;                });
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of a normal assignment using &lt;code&gt;=&lt;&#x2F;code&gt;, we‚Äôre now using the &lt;code&gt;write&lt;&#x2F;code&gt; method. This guarantees that the compiler will never optimize away this write.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;printing-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-strings&quot; aria-label=&quot;Anchor link for: printing-strings&quot;&gt;üîó&lt;&#x2F;a&gt;Printing Strings&lt;&#x2F;h2&gt;
&lt;p&gt;To print whole strings, we can convert them to bytes and print them one-by-one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl Writer`
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, s: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.bytes() {
&lt;&#x2F;span&gt;&lt;span&gt;      self.write_byte(byte)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can try it yourself in the &lt;code&gt;print_something&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;When you print strings with some special characters like &lt;code&gt;√§&lt;&#x2F;code&gt; or &lt;code&gt;Œª&lt;&#x2F;code&gt;, you‚Äôll notice that they cause weird symbols on screen. That‚Äôs because they are represented by multiple bytes in &lt;a href=&quot;https:&#x2F;&#x2F;www.fileformat.info&#x2F;info&#x2F;unicode&#x2F;utf8.htm&quot;&gt;UTF-8&lt;&#x2F;a&gt;. By converting them to bytes, we of course get strange results. But since the VGA buffer doesn‚Äôt support UTF-8, it‚Äôs not possible to display these characters anyway.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;support-formatting-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#support-formatting-macros&quot; aria-label=&quot;Anchor link for: support-formatting-macros&quot;&gt;üîó&lt;&#x2F;a&gt;Support Formatting Macros&lt;&#x2F;h3&gt;
&lt;p&gt;It would be nice to support Rust‚Äôs formatting macros, too. That way, we can easily print different types like integers or floats. To support them, we need to implement the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;trait.Write.html&quot;&gt;core::fmt::Write&lt;&#x2F;a&gt; trait. The only required method of this trait is &lt;code&gt;write_str&lt;&#x2F;code&gt; that looks quite similar to our &lt;code&gt;write_str&lt;&#x2F;code&gt; method. To implement the trait, we just need to move it into an &lt;code&gt;impl fmt::Write for Writer&lt;&#x2F;code&gt; block and add a return type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;fmt::Write &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, s: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; fmt::Result {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; byte &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; s.bytes() {
&lt;&#x2F;span&gt;&lt;span&gt;          self.write_byte(byte)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Ok(())&lt;&#x2F;code&gt; is just a &lt;code&gt;Ok&lt;&#x2F;code&gt; Result containing the &lt;code&gt;()&lt;&#x2F;code&gt; type. We can drop the &lt;code&gt;pub&lt;&#x2F;code&gt; because trait methods are always public.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use Rust‚Äôs built-in &lt;code&gt;write!&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;writeln!&lt;&#x2F;code&gt; formatting macros:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in the `print_something` function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = Writer {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;writer.write_byte(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;writer.write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello! &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;write!(writer, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;The numbers are &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you should see a &lt;code&gt;Hello! The numbers are 42 and 0.3333333333333333&lt;&#x2F;code&gt; at the bottom of the screen.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;newlines&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#newlines&quot; aria-label=&quot;Anchor link for: newlines&quot;&gt;üîó&lt;&#x2F;a&gt;Newlines&lt;&#x2F;h3&gt;
&lt;p&gt;Right now, we just ignore newlines and characters that don‚Äôt fit into the line anymore. Instead we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the &lt;code&gt;new_line&lt;&#x2F;code&gt; method of &lt;code&gt;Writer&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl Writer`
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;new_line(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; row &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; col &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; buffer = self.buffer();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; character = buffer.chars[row][col].read();
&lt;&#x2F;span&gt;&lt;span&gt;            buffer.chars[row - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;][col].write(character);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    self.clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    self.column_position = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, row: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* TODO *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We iterate over all screen characters and move each characters one row up. Note that the range notation (&lt;code&gt;..&lt;&#x2F;code&gt;) is exclusive the upper bound. We also omit the 0th row (the first range starts at &lt;code&gt;1&lt;&#x2F;code&gt;) because it‚Äôs the row that is shifted off screen.&lt;&#x2F;p&gt;
&lt;p&gt;Now we only need to implement the &lt;code&gt;clear_row&lt;&#x2F;code&gt; method to finish the newline code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in `impl Writer`
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span&gt;clear_row(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span&gt;self, row: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; blank = ScreenChar {
&lt;&#x2F;span&gt;&lt;span&gt;        ascii_character: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        color_code: self.color_code,
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; col &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        self.buffer().chars[row][col].write(blank);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This method clears a row by overwriting all of its characters with a space character.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;providing-an-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#providing-an-interface&quot; aria-label=&quot;Anchor link for: providing-an-interface&quot;&gt;üîó&lt;&#x2F;a&gt;Providing an Interface&lt;&#x2F;h2&gt;
&lt;p&gt;To provide a global writer that can used as an interface from other modules, we can add a &lt;code&gt;static&lt;&#x2F;code&gt; writer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;: Writer = Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode::new(Color::LightGreen, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;    buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Unique::new_unchecked(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;) },
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But we can‚Äôt use it to print anything! You can try it yourself in the &lt;code&gt;print_something&lt;&#x2F;code&gt; function. The reason is that we try to take a mutable reference (&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;) to a immutable &lt;code&gt;static&lt;&#x2F;code&gt; when calling &lt;code&gt;WRITER.print_byte&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To resolve it, we could use a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;second-edition&#x2F;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;mutable static&lt;&#x2F;a&gt;. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using &lt;code&gt;static mut&lt;&#x2F;code&gt; is highly discouraged, there are even proposals to &lt;a href=&quot;https:&#x2F;&#x2F;internals.rust-lang.org&#x2F;t&#x2F;pre-rfc-remove-static-mut&#x2F;1437&quot;&gt;remove it&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But what are the alternatives? We could try to use a cell type like &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cell&#x2F;struct.RefCell.html&quot;&gt;RefCell&lt;&#x2F;a&gt; or even &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;cell&#x2F;struct.UnsafeCell.html&quot;&gt;UnsafeCell&lt;&#x2F;a&gt; to provide &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;mutability.html#interior-vs-exterior-mutability&quot;&gt;interior mutability&lt;&#x2F;a&gt;. But these types aren‚Äôt &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;marker&#x2F;trait.Sync.html&quot;&gt;Sync&lt;&#x2F;a&gt; (with good reason), so we can‚Äôt use them in statics.&lt;&#x2F;p&gt;
&lt;p&gt;To get synchronized interior mutability, users of the standard library can use &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;sync&#x2F;struct.Mutex.html&quot;&gt;Mutex&lt;&#x2F;a&gt;. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can‚Äôt use it either. However there is a really basic kind of mutex in computer science that requires no operating system features: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Spinlock&quot;&gt;spinlock&lt;&#x2F;a&gt;. Instead of blocking, the threads simply try to lock it again and again in a tight loop and thus burn CPU time until the mutex is free again.&lt;&#x2F;p&gt;
&lt;p&gt;To use a spinning mutex, we can add the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;spin&quot;&gt;spin crate&lt;&#x2F;a&gt; as a dependency:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rlibc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.4&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;spin &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.4.5&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; spin;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we can use the spinning Mutex to add interior mutability to our static writer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs again
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;spin::Mutex;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Writer&amp;gt; = Mutex::new(Writer {
&lt;&#x2F;span&gt;&lt;span&gt;    column_position: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    color_code: ColorCode::new(Color::LightGreen, Color::Black),
&lt;&#x2F;span&gt;&lt;span&gt;    buffer: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ Unique::new_unchecked(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;) },
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;spin&#x2F;0.4.5&#x2F;spin&#x2F;struct.Mutex.html#method.new&quot;&gt;Mutex::new&lt;&#x2F;a&gt; is a const function, too, so it can be used in statics.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can easily print from our main function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello again&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    write!(vga_buffer::WRITER.lock(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;, some numbers: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.337&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that we need to import the &lt;code&gt;Write&lt;&#x2F;code&gt; trait if we want to use its functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-println-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-println-macro&quot; aria-label=&quot;Anchor link for: a-println-macro&quot;&gt;üîó&lt;&#x2F;a&gt;A println macro&lt;&#x2F;h2&gt;
&lt;p&gt;Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;book&#x2F;second-edition&#x2F;appendix-04-macros.html&quot;&gt;macro syntax&lt;&#x2F;a&gt; is a bit strange, so we won‚Äôt try to write a macro from scratch. Instead we look at the source of the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.println!.html&quot;&gt;&lt;code&gt;println!&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; in the standard library:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;macro_rules! println {
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(print!(concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)));
&lt;&#x2F;span&gt;&lt;span&gt;    ($fmt:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(print!(concat!($fmt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Macros are defined through one or more rules, which are similar to &lt;code&gt;match&lt;&#x2F;code&gt; arms. The &lt;code&gt;println&lt;&#x2F;code&gt; macro has two rules: The first rule is for invocations with a single argument (e.g. &lt;code&gt;println!(&amp;quot;Hello&amp;quot;)&lt;&#x2F;code&gt;) and the second rule is for invocations with additional parameters (e.g. &lt;code&gt;println!(&amp;quot;{}{}&amp;quot;, 4, 2)&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Both rules simply append a newline character (&lt;code&gt;\n&lt;&#x2F;code&gt;) to the format string and then invoke the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.print!.html&quot;&gt;&lt;code&gt;print!&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt;, which is defined as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;($crate::io::_print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro expands to a call of the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;46d39f3329487115e7d7dcd37bc64eea6ef9ba4e&#x2F;src&#x2F;libstd&#x2F;io&#x2F;stdio.rs#L631&quot;&gt;&lt;code&gt;_print&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; in the &lt;code&gt;io&lt;&#x2F;code&gt; module. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.30.0&#x2F;book&#x2F;first-edition&#x2F;macros.html#the-variable-crate&quot;&gt;&lt;code&gt;$crate&lt;&#x2F;code&gt; variable&lt;&#x2F;a&gt; ensures that the macro also works from outside the &lt;code&gt;std&lt;&#x2F;code&gt; crate. For example, it expands to &lt;code&gt;::std&lt;&#x2F;code&gt; when it‚Äôs used in other crates.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;std&#x2F;macro.format_args.html&quot;&gt;&lt;code&gt;format_args&lt;&#x2F;code&gt; macro&lt;&#x2F;a&gt; builds a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;fmt&#x2F;struct.Arguments.html&quot;&gt;fmt::Arguments&lt;&#x2F;a&gt; type from the passed arguments, which is passed to &lt;code&gt;_print&lt;&#x2F;code&gt;. The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;46d39f3329487115e7d7dcd37bc64eea6ef9ba4e&#x2F;src&#x2F;libstd&#x2F;io&#x2F;stdio.rs#L631&quot;&gt;&lt;code&gt;_print&lt;&#x2F;code&gt; function&lt;&#x2F;a&gt; of libstd is rather complicated, as it supports different &lt;code&gt;Stdout&lt;&#x2F;code&gt; devices. We don‚Äôt need that complexity since we just want to print to the VGA buffer.&lt;&#x2F;p&gt;
&lt;p&gt;To print to the VGA buffer, we just copy the &lt;code&gt;println!&lt;&#x2F;code&gt; macro and modify the &lt;code&gt;print!&lt;&#x2F;code&gt; macro to use our static &lt;code&gt;WRITER&lt;&#x2F;code&gt; instead of &lt;code&gt;_print&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;({
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = $crate::vga_buffer::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock();
&lt;&#x2F;span&gt;&lt;span&gt;        writer.write_fmt(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;_print&lt;&#x2F;code&gt; function, we call the &lt;code&gt;write_fmt&lt;&#x2F;code&gt; method of our static &lt;code&gt;Writer&lt;&#x2F;code&gt;. Since we‚Äôre using a method from the &lt;code&gt;Write&lt;&#x2F;code&gt; trait, we need to import it before. The additional &lt;code&gt;unwrap()&lt;&#x2F;code&gt; at the end panics if printing isn‚Äôt successful. But since we always return &lt;code&gt;Ok&lt;&#x2F;code&gt; in &lt;code&gt;write_str&lt;&#x2F;code&gt;, that should not happen.&lt;&#x2F;p&gt;
&lt;p&gt;Note the additional &lt;code&gt;{}&lt;&#x2F;code&gt; scope around the macro: We write &lt;code&gt;=&amp;gt; ({‚Ä¶})&lt;&#x2F;code&gt; instead of &lt;code&gt;=&amp;gt; (‚Ä¶)&lt;&#x2F;code&gt;. The additional &lt;code&gt;{}&lt;&#x2F;code&gt; avoids that the &lt;code&gt;Write&lt;&#x2F;code&gt; trait is silently imported to the parent scope when &lt;code&gt;print&lt;&#x2F;code&gt; is used.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;clearing-the-screen&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#clearing-the-screen&quot; aria-label=&quot;Anchor link for: clearing-the-screen&quot;&gt;üîó&lt;&#x2F;a&gt;Clearing the screen&lt;&#x2F;h3&gt;
&lt;p&gt;We can now use &lt;code&gt;println!&lt;&#x2F;code&gt; to add a rather trivial function to clear the screen:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;clear_screen() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for _ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;hello-world-using-println&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world-using-println&quot; aria-label=&quot;Anchor link for: hello-world-using-println&quot;&gt;üîó&lt;&#x2F;a&gt;Hello World using &lt;code&gt;println&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;To use &lt;code&gt;println&lt;&#x2F;code&gt; in &lt;code&gt;lib.rs&lt;&#x2F;code&gt;, we need to import the macros of the VGA buffer module first. Therefore we add a &lt;code&gt;#[macro_use]&lt;&#x2F;code&gt; attribute to the module declaration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[macro_use]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span&gt;vga_buffer;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ATTENTION: we have a very small stack and no guard page
&lt;&#x2F;span&gt;&lt;span&gt;    vga_buffer::clear_screen();
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since we imported the macros at crate level, they are available in all modules and thus provide an easy and safe interface to the VGA buffer.&lt;&#x2F;p&gt;
&lt;p&gt;As expected, we now see a &lt;em&gt;‚ÄúHello World!‚Äù&lt;&#x2F;em&gt; on a cleared screen:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;vga-hello-world.png&quot; alt=&quot;QEMU printing ‚ÄúHello World!‚Äù on a cleared screen&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;deadlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deadlocks&quot; aria-label=&quot;Anchor link for: deadlocks&quot;&gt;üîó&lt;&#x2F;a&gt;Deadlocks&lt;&#x2F;h3&gt;
&lt;p&gt;Whenever we use locks, we must be careful to not accidentally introduce &lt;em&gt;deadlocks&lt;&#x2F;em&gt;. A &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Deadlock&quot;&gt;deadlock&lt;&#x2F;a&gt; occurs when a thread&#x2F;program waits for a lock that will never be released. Normally, this happens when multiple threads access multiple locks. For example, when thread A holds lock 1 and tries to acquire lock 2 and ‚Äì at the same time ‚Äì thread B holds lock 2 and tries to acquire lock 1.&lt;&#x2F;p&gt;
&lt;p&gt;However, a deadlock can also occur when a thread tries to acquire the same lock twice. This way we can trigger a deadlock in our VGA driver:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in rust_main in src&#x2F;lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, { println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;inner&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;outer&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The argument passed to &lt;code&gt;println&lt;&#x2F;code&gt; is new block that resolves to the string &lt;em&gt;‚Äúouter‚Äù&lt;&#x2F;em&gt; (a block always returns the result of the last expression). But before returning ‚Äúouter‚Äù, the block tries to print the string &lt;em&gt;‚Äúinner‚Äù&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;When we try this code in QEMU, we see that neither of the strings are printed. To understand what‚Äôs happening, we take a look at our &lt;code&gt;print&lt;&#x2F;code&gt; macro again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;({
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; writer = $crate::vga_buffer::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock();
&lt;&#x2F;span&gt;&lt;span&gt;        writer.write_fmt(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*)).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we &lt;em&gt;first&lt;&#x2F;em&gt; lock the &lt;code&gt;WRITER&lt;&#x2F;code&gt; and then we evaluate the arguments using &lt;code&gt;format_args&lt;&#x2F;code&gt;. The problem is that the argument in our code example contains another &lt;code&gt;println&lt;&#x2F;code&gt;, which tries to lock the &lt;code&gt;WRITER&lt;&#x2F;code&gt; again. So now the inner &lt;code&gt;println&lt;&#x2F;code&gt; waits for the outer &lt;code&gt;println&lt;&#x2F;code&gt; and vice versa. Thus, a deadlock occurs and the CPU spins endlessly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-the-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-deadlock&quot; aria-label=&quot;Anchor link for: fixing-the-deadlock&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing the Deadlock&lt;&#x2F;h3&gt;
&lt;p&gt;In order to fix the deadlock, we need to evaluate the arguments &lt;em&gt;before&lt;&#x2F;em&gt; locking the &lt;code&gt;WRITER&lt;&#x2F;code&gt;. We can do so by moving the locking and printing logic into a new &lt;code&gt;print&lt;&#x2F;code&gt; function (like it‚Äôs done in the standard library):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; in src&#x2F;vga_buffer.rs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;macro_rules! print {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;tt&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;({
&lt;&#x2F;span&gt;&lt;span&gt;        $crate::vga_buffer::print(format_args!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;($arg)*));
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span&gt;print(args: fmt::Arguments) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Write;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2F;span&gt;&lt;span&gt;.lock().write_fmt(args).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the macro only evaluates the arguments (through &lt;code&gt;format_args!&lt;&#x2F;code&gt;) and passes them to the new &lt;code&gt;print&lt;&#x2F;code&gt; function. The &lt;code&gt;print&lt;&#x2F;code&gt; function then locks the &lt;code&gt;WRITER&lt;&#x2F;code&gt; and prints the formatting arguments using &lt;code&gt;write_fmt&lt;&#x2F;code&gt;. So now the arguments are evaluated before locking the &lt;code&gt;WRITER&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Thus, we fixed the deadlock:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;fixed-println-deadlock.png&quot; alt=&quot;QEMU printing ‚Äúinner‚Äù and then ‚Äúouter‚Äù&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We see that both ‚Äúinner‚Äù and ‚Äúouter‚Äù are printed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the next posts we will map the kernel pages correctly so that accessing &lt;code&gt;0x0&lt;&#x2F;code&gt; or writing to &lt;code&gt;.rodata&lt;&#x2F;code&gt; is not possible anymore. To obtain the loaded kernel sections we will read the Multiboot information structure. Then we will create a paging module and use it to switch to a new page table where the kernel sections are mapped correctly.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;allocating-frames&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; describes the Multiboot information structure and creates a frame allocator using the information about memory areas.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;other-rust-os-projects&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#other-rust-os-projects&quot; aria-label=&quot;Anchor link for: other-rust-os-projects&quot;&gt;üîó&lt;&#x2F;a&gt;Other Rust OS Projects&lt;&#x2F;h2&gt;
&lt;p&gt;Now that you know the very basics of OS development in Rust, you should also check out the following projects:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thepowersgang&#x2F;rust-barebones-kernel&quot;&gt;Rust Bare-Bones Kernel&lt;&#x2F;a&gt;: A basic kernel with roughly the same functionality as ours. Writes output to the serial port instead of the VGA buffer and maps the kernel to the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Higher_Half_Kernel&quot;&gt;higher half&lt;&#x2F;a&gt; (instead of our identity mapping).
&lt;em&gt;Note&lt;&#x2F;em&gt;: You need to &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cross-compile-binutils&#x2F;&quot;&gt;cross compile binutils&lt;&#x2F;a&gt; to build it (or you create some symbolic links&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-symlink&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; if you‚Äôre on x86_64).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;RustOS-Fork-Holding-Ground&#x2F;RustOS&quot;&gt;RustOS&lt;&#x2F;a&gt;: More advanced kernel that supports allocation, keyboard inputs, and threads. It also has a scheduler and a basic network driver.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;thepowersgang&#x2F;rust_os&quot;&gt;‚ÄúTifflin‚Äù Experimental Kernel&lt;&#x2F;a&gt;: Big kernel project by thepowersgang, that is actively developed and has over 650 commits. It has a separate userspace and supports multiple file systems, even a GUI is included. Needs a cross compiler.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;redox-os&#x2F;redox&quot;&gt;Redox&lt;&#x2F;a&gt;: Probably the most complete Rust OS today. It has an active community and over 1000 Github stars. File systems, network, an audio player, a picture viewer, and much more. Just take a look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;redox-os&#x2F;redox#what-it-looks-like&quot;&gt;screenshots&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-symlink&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;You will need to symlink &lt;code&gt;x86_64-none_elf-XXX&lt;&#x2F;code&gt; to &lt;code&gt;&#x2F;usr&#x2F;bin&#x2F;XXX&lt;&#x2F;code&gt; where &lt;code&gt;XXX&lt;&#x2F;code&gt; is in {&lt;code&gt;as&lt;&#x2F;code&gt;, &lt;code&gt;ld&lt;&#x2F;code&gt;, &lt;code&gt;objcopy&lt;&#x2F;code&gt;, &lt;code&gt;objdump&lt;&#x2F;code&gt;, &lt;code&gt;strip&lt;&#x2F;code&gt;}. The &lt;code&gt;x86_64-none_elf-XXX&lt;&#x2F;code&gt; files must be in some folder that is in your &lt;code&gt;$PATH&lt;&#x2F;code&gt;. But then you can only build for your x86_64 host architecture, so use this hack only for testing.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>Set Up Rust</title>
                <pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/set-up-rust/</link>
                <guid>https://os.phil-opp.com/set-up-rust/</guid>
                <description>&lt;p&gt;In the previous posts we created a &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;multiboot-kernel&#x2F;&quot;&gt;minimal Multiboot kernel&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;&quot;&gt;switched to Long Mode&lt;&#x2F;a&gt;. Now we can finally switch to &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; code. Rust is a high-level language without runtime. It allows us to not link the standard library and write bare metal code. Unfortunately the setup is not quite hassle-free yet.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This blog post tries to set up Rust step-by-step and point out the different problems. If you have any questions, problems, or suggestions please &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;file an issue&lt;&#x2F;a&gt; or create a comment at the bottom. The code from this post is in a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_3&quot;&gt;Github repository&lt;&#x2F;a&gt;, too.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installing-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#installing-rust&quot; aria-label=&quot;Anchor link for: installing-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Installing Rust&lt;&#x2F;h2&gt;
&lt;p&gt;We need a nightly compiler, as we will use many unstable features. To manage Rust installations I highly recommend &lt;a href=&quot;https:&#x2F;&#x2F;www.rustup.rs&#x2F;&quot;&gt;rustup&lt;&#x2F;a&gt;. It allows you to install nightly, beta, and stable compilers side-by-side and makes it easy to update them. To use a nightly compiler for the current directory, you can run &lt;code&gt;rustup override add nightly&lt;&#x2F;code&gt;. Alternatively, you can add a file called &lt;code&gt;rust-toolchain&lt;&#x2F;code&gt; to the project‚Äôs root directory:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;nightly
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The code from this post (and all following) is &lt;a href=&quot;https:&#x2F;&#x2F;travis-ci.org&#x2F;phil-opp&#x2F;blog_os&quot;&gt;automatically tested&lt;&#x2F;a&gt; every day and should always work for the newest nightly. If it doesn‚Äôt, please &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;file an issue&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-a-cargo-project&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-cargo-project&quot; aria-label=&quot;Anchor link for: creating-a-cargo-project&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a Cargo project&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.crates.io&#x2F;guide.html&quot;&gt;Cargo&lt;&#x2F;a&gt; is Rust‚Äôs excellent package manager. Normally you would call &lt;code&gt;cargo new&lt;&#x2F;code&gt; when you want to create a new project folder. We can‚Äôt use it because our folder already exists, so we need to do it manually. Fortunately we only need to add a cargo configuration file named &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;blog_os&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;authors &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Philipp Oppermann &amp;lt;dev@phil-opp.com&amp;gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;lib&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;crate-type &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;staticlib&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;package&lt;&#x2F;code&gt; section contains required project metadata such as the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html#the-package-section&quot;&gt;semantic crate version&lt;&#x2F;a&gt;. The &lt;code&gt;lib&lt;&#x2F;code&gt; section specifies that we want to build a static library, i.e. a library that contains all of its dependencies. This is required to link the Rust project with our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;Now we place our root source file in &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#![feature(lang_items)]
&lt;&#x2F;span&gt;&lt;span&gt;#![no_std]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[lang &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;eh_personality&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] #[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;eh_personality() {}
&lt;&#x2F;span&gt;&lt;span&gt;#[lang &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] #[no_mangle] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;panic_fmt() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs break it down:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#!&lt;&#x2F;code&gt; defines an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;attributes.html&quot;&gt;attribute&lt;&#x2F;a&gt; of the current module. Since we are at the root module, the attributes apply to the crate itself.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;feature&lt;&#x2F;code&gt; attribute is used to allow the specified &lt;em&gt;feature-gated&lt;&#x2F;em&gt; attributes in this crate. You can‚Äôt do that in a stable&#x2F;beta compiler, so this is one reason we need a Rust nighly.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;no_std&lt;&#x2F;code&gt; attribute prevents the automatic linking of the standard library. We can‚Äôt use &lt;code&gt;std&lt;&#x2F;code&gt; because it relies on operating system features like files, system calls, and various device drivers. Remember that currently the only ‚Äúfeature‚Äù of our OS is printing &lt;code&gt;OKAY&lt;&#x2F;code&gt; :).&lt;&#x2F;li&gt;
&lt;li&gt;A &lt;code&gt;#&lt;&#x2F;code&gt; without a &lt;code&gt;!&lt;&#x2F;code&gt; afterwards defines an attribute for the &lt;em&gt;following&lt;&#x2F;em&gt; item (a function in our case).&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;no_mangle&lt;&#x2F;code&gt; attribute disables the automatic &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Name_mangling&quot;&gt;name mangling&lt;&#x2F;a&gt; that Rust uses to get unique function names. We want to do a &lt;code&gt;call rust_main&lt;&#x2F;code&gt; from our assembly code, so this function name must stay as it is.&lt;&#x2F;li&gt;
&lt;li&gt;We mark our main function as &lt;code&gt;extern&lt;&#x2F;code&gt; to make it compatible to the standard C &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;calling convention&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;lang&lt;&#x2F;code&gt; attribute defines a Rust &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;book&#x2F;lang-items.html&quot;&gt;language item&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;eh_personality&lt;&#x2F;code&gt; function is used for Rust‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;unwinding.html&quot;&gt;unwinding&lt;&#x2F;a&gt; on &lt;code&gt;panic!&lt;&#x2F;code&gt;. We can leave it empty since we don‚Äôt have any unwinding support in our OS yet.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;panic_fmt&lt;&#x2F;code&gt; function is the entry point on panic. Right now we can‚Äôt do anything useful, so we just make sure that it doesn‚Äôt return (required by the &lt;code&gt;!&lt;&#x2F;code&gt; return type).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;building-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-rust&quot; aria-label=&quot;Anchor link for: building-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Building Rust&lt;&#x2F;h2&gt;
&lt;p&gt;We can now build it using &lt;code&gt;cargo build&lt;&#x2F;code&gt;, which creates a static library at &lt;code&gt;target&#x2F;debug&#x2F;libblog_os.a&lt;&#x2F;code&gt;. However, the resulting library is specific to our &lt;em&gt;host&lt;&#x2F;em&gt; operating system. This is undesirable, because our target system might be different.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs define some properties of our target system:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;x86_64&lt;&#x2F;strong&gt;: Our target CPU is a recent &lt;code&gt;x86_64&lt;&#x2F;code&gt; CPU.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No operating system&lt;&#x2F;strong&gt;: Our target does not run any operating system (we‚Äôre currently writing it), so the compiler should not assume any OS-specific functionality.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Handles hardware interrupts&lt;&#x2F;strong&gt;: We‚Äôre writing a kernel, so we‚Äôll need to handle asynchronous hardware interrupts at some point. This means that we have to disable a certain stack pointer optimization (the so-called &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;09&#x2F;06&#x2F;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2F;a&gt;), because it would cause stack corruptions otherwise.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No SSE&lt;&#x2F;strong&gt;: Our target might not have &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2F;a&gt; support. Even if it does, we probably don‚Äôt want to use SSE instructions in our kernel, because it makes interrupt handling much slower. We will explain this in detail in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions‚Äù&lt;&#x2F;a&gt; post.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No hardware floats&lt;&#x2F;strong&gt;: The &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture uses SSE instructions for floating point operations, which we don‚Äôt want to use (see the previous point). So we also need to avoid hardware floating point operations in our kernel. Instead, we will use &lt;em&gt;soft floats&lt;&#x2F;em&gt;, which are basically software functions that emulate floating point operations using normal integers.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;target-specifications&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specifications&quot; aria-label=&quot;Anchor link for: target-specifications&quot;&gt;üîó&lt;&#x2F;a&gt;Target Specifications&lt;&#x2F;h3&gt;
&lt;p&gt;Rust allows us to define &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.1.0&#x2F;rustc_back&#x2F;target&#x2F;&quot;&gt;custom targets&lt;&#x2F;a&gt; through a JSON configuration file. A minimal target specification equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; (the default 64-bit Linux target) looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linux&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;llvm-target&lt;&#x2F;code&gt; field specifies the target triple that is passed to LLVM. &lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#target-triple&quot;&gt;Target triples&lt;&#x2F;a&gt; are a naming convention that define the CPU architecture (e.g., &lt;code&gt;x86_64&lt;&#x2F;code&gt; or &lt;code&gt;arm&lt;&#x2F;code&gt;), the vendor (e.g., &lt;code&gt;apple&lt;&#x2F;code&gt; or &lt;code&gt;unknown&lt;&#x2F;code&gt;), the operating system (e.g., &lt;code&gt;windows&lt;&#x2F;code&gt; or &lt;code&gt;linux&lt;&#x2F;code&gt;), and the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Application_binary_interface&quot;&gt;ABI&lt;&#x2F;a&gt; (e.g., &lt;code&gt;gnu&lt;&#x2F;code&gt; or &lt;code&gt;msvc&lt;&#x2F;code&gt;). For example, the target triple for 64-bit Linux is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; and for 32-bit Windows the target triple is &lt;code&gt;i686-pc-windows-msvc&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;data-layout&lt;&#x2F;code&gt; field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications separated by a &lt;code&gt;-&lt;&#x2F;code&gt; character. For example, the &lt;code&gt;e&lt;&#x2F;code&gt; means little endian and &lt;code&gt;S128&lt;&#x2F;code&gt; specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the &lt;a href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LangRef.html#data-layout&quot;&gt;LLVM documentation&lt;&#x2F;a&gt; but there shouldn‚Äôt be a reason to change this string.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;linker-flavor&lt;&#x2F;code&gt; field was recently introduced in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;40018&quot;&gt;#40018&lt;&#x2F;a&gt; with the intention to add support for the LLVM linker &lt;a href=&quot;https:&#x2F;&#x2F;lld.llvm.org&#x2F;&quot;&gt;LLD&lt;&#x2F;a&gt;, which is platform independent. In the future, this might allow easy cross compilation without the need to install a gcc cross compiler for linking.&lt;&#x2F;p&gt;
&lt;p&gt;The other fields are used for conditional compilation. This allows crate authors to use &lt;code&gt;cfg&lt;&#x2F;code&gt; variables to write special code for depending on the OS or the architecture. There isn‚Äôt any up-to-date documentation about these fields but the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;c772948b687488a087356cb91432425662e034b9&#x2F;src&#x2F;librustc_back&#x2F;target&#x2F;mod.rs#L194-L214&quot;&gt;corresponding source code&lt;&#x2F;a&gt; is quite readable.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-kernel-target-specification&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-kernel-target-specification&quot; aria-label=&quot;Anchor link for: a-kernel-target-specification&quot;&gt;üîó&lt;&#x2F;a&gt;A Kernel Target Specification&lt;&#x2F;h3&gt;
&lt;p&gt;For our target system, we define the following JSON configuration in a file named &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As &lt;code&gt;llvm-target&lt;&#x2F;code&gt; we use &lt;code&gt;x86_64-unknown-none&lt;&#x2F;code&gt;, which defines the &lt;code&gt;x86_64&lt;&#x2F;code&gt; architecture, an &lt;code&gt;unknown&lt;&#x2F;code&gt; vendor, and no operating system (&lt;code&gt;none&lt;&#x2F;code&gt;). The ABI doesn‚Äôt matter for us, so we just leave it off. The &lt;code&gt;data-layout&lt;&#x2F;code&gt; field is just copied from the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt; target. We also use the same values for the &lt;code&gt;target-endian&lt;&#x2F;code&gt;, &lt;code&gt;target-pointer-width&lt;&#x2F;code&gt;, &lt;code&gt;target-c-int-width&lt;&#x2F;code&gt;, and &lt;code&gt;arch&lt;&#x2F;code&gt; fields. For the &lt;code&gt;os&lt;&#x2F;code&gt; field we choose &lt;code&gt;none&lt;&#x2F;code&gt;, since our kernel runs on bare metal.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-red-zone&quot; aria-label=&quot;Anchor link for: the-red-zone&quot;&gt;üîó&lt;&#x2F;a&gt;The Red Zone&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2011&#x2F;09&#x2F;06&#x2F;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2F;a&gt; is an optimization of the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;System_V_ABI&quot;&gt;System V ABI&lt;&#x2F;a&gt; that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-rust&#x2F;red-zone.svg&quot; alt=&quot;stack frame with red zone&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The image shows the stack frame of a function with &lt;code&gt;n&lt;&#x2F;code&gt; local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.&lt;&#x2F;p&gt;
&lt;p&gt;The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that‚Äôs not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).&lt;&#x2F;p&gt;
&lt;p&gt;However, this optimization leads to huge problems with exceptions or hardware interrupts. Let‚Äôs assume that an exception occurs while a function uses the red zone:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-rust&#x2F;red-zone-overwrite.svg&quot; alt=&quot;red zone overwritten by exception handler&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won‚Äôt work correctly anymore when we return from the exception handler. This might lead to strange bugs that &lt;a href=&quot;https:&#x2F;&#x2F;forum.osdev.org&#x2F;viewtopic.php?t=21720&quot;&gt;take weeks to debug&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid such bugs when we implement exception handling in the future, we disable the red zone right from the beginning. This is achieved by adding the &lt;code&gt;&amp;quot;disable-redzone&amp;quot;: true&lt;&#x2F;code&gt; line to our target configuration file.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;simd-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simd-extensions&quot; aria-label=&quot;Anchor link for: simd-extensions&quot;&gt;üîó&lt;&#x2F;a&gt;SIMD Extensions&lt;&#x2F;h4&gt;
&lt;p&gt;The &lt;code&gt;features&lt;&#x2F;code&gt; field enables&#x2F;disables target features. We disable the &lt;code&gt;mmx&lt;&#x2F;code&gt; and &lt;code&gt;sse&lt;&#x2F;code&gt; features by prefixing them with a minus and enable the &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature by prefixing it with a plus.  The &lt;code&gt;mmx&lt;&#x2F;code&gt; and &lt;code&gt;sse&lt;&#x2F;code&gt; features determine support for &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2F;a&gt; instructions, which simultaneously perform an operation (e.g. addition) on multiple data words. The &lt;code&gt;x86&lt;&#x2F;code&gt; architecture supports the following standards:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;MMX_(instruction_set)&quot;&gt;MMX&lt;&#x2F;a&gt;: The &lt;em&gt;Multi Media Extension&lt;&#x2F;em&gt; instruction set was introduced in 1997 and defines eight 64 bit registers called &lt;code&gt;mm0&lt;&#x2F;code&gt; through &lt;code&gt;mm7&lt;&#x2F;code&gt;. These registers are just aliases for the registers of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X87&quot;&gt;x87 floating point unit&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2F;a&gt;: The &lt;em&gt;Streaming SIMD Extensions&lt;&#x2F;em&gt; instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called &lt;code&gt;xmm0&lt;&#x2F;code&gt; through &lt;code&gt;xmm15&lt;&#x2F;code&gt; and are 128 bits each.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Advanced_Vector_Extensions&quot;&gt;AVX&lt;&#x2F;a&gt;: The &lt;em&gt;Advanced Vector Extensions&lt;&#x2F;em&gt; are extensions that further increase the size of the multimedia registers. The new registers are called &lt;code&gt;ymm0&lt;&#x2F;code&gt; through &lt;code&gt;ymm15&lt;&#x2F;code&gt; and are 256 bits each. They extend the &lt;code&gt;xmm&lt;&#x2F;code&gt; registers, so e.g. &lt;code&gt;xmm0&lt;&#x2F;code&gt; is the lower half of &lt;code&gt;ymm0&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;By using such SIMD standards, programs can often speed up significantly. Good compilers are able to transform normal loops into such SIMD code automatically through a process called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Automatic_vectorization&quot;&gt;auto-vectorization&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;However, the large SIMD registers lead to problems in OS kernels. The reason is that the kernel has to backup all registers that it uses on each hardware interrupt (we will look into this in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;handling-exceptions&#x2F;&quot;&gt;‚ÄúHandling Exceptions‚Äù&lt;&#x2F;a&gt; post). So if the kernel uses SIMD registers, it has to backup a lot more data, which noticeably decreases performance. To avoid this performance loss, we disable the &lt;code&gt;sse&lt;&#x2F;code&gt; and &lt;code&gt;mmx&lt;&#x2F;code&gt; features (the &lt;code&gt;avx&lt;&#x2F;code&gt; feature is disabled by default).&lt;&#x2F;p&gt;
&lt;p&gt;As noted above, floating point operations on &lt;code&gt;x86_64&lt;&#x2F;code&gt; use SSE registers, so floats are no longer usable without SSE. Unfortunately, the Rust core library already uses floats (e.g., it implements traits for &lt;code&gt;f32&lt;&#x2F;code&gt; and &lt;code&gt;f64&lt;&#x2F;code&gt;), so we need an alternative way to implement float operations. The &lt;code&gt;soft-float&lt;&#x2F;code&gt; feature solves this problem by emulating all floating point operations through software functions based on normal integers.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;compiling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#compiling&quot; aria-label=&quot;Anchor link for: compiling&quot;&gt;üîó&lt;&#x2F;a&gt;Compiling&lt;&#x2F;h3&gt;
&lt;p&gt;To build our kernel for our new target, we pass the configuration file‚Äôs name as &lt;code&gt;--target&lt;&#x2F;code&gt; argument. There is currently an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;4905&quot;&gt;open bug&lt;&#x2F;a&gt; for custom target specifications, so you also need to set the &lt;code&gt;RUST_TARGET_PATH&lt;&#x2F;code&gt; environment variable to the current directory, otherwise Rust doesn‚Äôt find your target. The full command is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;RUST_TARGET_PATH=$(pwd) cargo build --target x86_64-blog_os
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, the following error occurs:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `core`
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: the `x86_64-blog_os` target may not be installed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error tells us that the Rust compiler no longer finds the core library. The &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;index.html&quot;&gt;core library&lt;&#x2F;a&gt; is implicitly linked to all &lt;code&gt;no_std&lt;&#x2F;code&gt; crates and contains things such as &lt;code&gt;Result&lt;&#x2F;code&gt;, &lt;code&gt;Option&lt;&#x2F;code&gt;, and iterators.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2F;em&gt; library. So it is only valid for the host triple (e.g., &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2F;code&gt;) but not for our custom target. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2F;code&gt; for these targets first.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;xargo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#xargo&quot; aria-label=&quot;Anchor link for: xargo&quot;&gt;üîó&lt;&#x2F;a&gt;Xargo&lt;&#x2F;h4&gt;
&lt;p&gt;That‚Äôs where &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;japaric&#x2F;xargo&quot;&gt;xargo&lt;&#x2F;a&gt; comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo install xargo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Xargo depends on the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Xargo is ‚Äúa drop-in replacement for cargo‚Äù, so every cargo command also works with &lt;code&gt;xargo&lt;&#x2F;code&gt;. You can do e.g. &lt;code&gt;xargo --help&lt;&#x2F;code&gt;, &lt;code&gt;xargo clean&lt;&#x2F;code&gt;, or &lt;code&gt;xargo doc&lt;&#x2F;code&gt;. However, the &lt;code&gt;build&lt;&#x2F;code&gt; command gains additional functionality: &lt;code&gt;xargo build&lt;&#x2F;code&gt; will automatically cross compile the &lt;code&gt;core&lt;&#x2F;code&gt; library when compiling for custom targets.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs try it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&amp;gt; RUST_TARGET_PATH=$(pwd) xargo build --target=x86_64-blog_os
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling core v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;optimized&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; target(s) in 22.87 secs
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;blog_os&#x2F;tags)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;unoptimized + debuginfo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; target(s) in 0.29 secs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It worked! We see that &lt;code&gt;xargo&lt;&#x2F;code&gt; cross-compiled the &lt;code&gt;core&lt;&#x2F;code&gt; library for our new custom target and then continued to compile our &lt;code&gt;blog_os&lt;&#x2F;code&gt; crate. After compilation, we can find a static library at &lt;code&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a&lt;&#x2F;code&gt;, which can be linked with our assembly kernel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integrating-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#integrating-rust&quot; aria-label=&quot;Anchor link for: integrating-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Integrating Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Let‚Äôs try to integrate our Rust library into our assembly kernel so that we can call the &lt;code&gt;rust_main&lt;&#x2F;code&gt; function. For that we need to pass the &lt;code&gt;libblog_os.a&lt;&#x2F;code&gt; file to the linker, together with the assembly object files.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;adjusting-the-makefile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adjusting-the-makefile&quot; aria-label=&quot;Anchor link for: adjusting-the-makefile&quot;&gt;üîó&lt;&#x2F;a&gt;Adjusting the Makefile&lt;&#x2F;h3&gt;
&lt;p&gt;To build and link the rust library on &lt;code&gt;make&lt;&#x2F;code&gt;, we extend our &lt;code&gt;Makefile&lt;&#x2F;code&gt;(&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;blob&#x2F;first_edition_post_3&#x2F;Makefile&quot;&gt;full file&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;make&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-make &quot;&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;target ?= &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;-blog_os&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;rust_os := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;target&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;debug&#x2F;libblog_os.a&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;.PHONY: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;all clean run iso kernel&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;kernel &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;ld -n -T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; -o &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span&gt;rust_os&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;kernel:
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;RUST_TARGET_PATH=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;shell pwd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;xargo build --target &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;target&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We add a new &lt;code&gt;kernel&lt;&#x2F;code&gt; target that just executes &lt;code&gt;xargo build&lt;&#x2F;code&gt; and modify the &lt;code&gt;$(kernel)&lt;&#x2F;code&gt; target to link the created static lib. We also add the new &lt;code&gt;kernel&lt;&#x2F;code&gt; target to the &lt;code&gt;.PHONY&lt;&#x2F;code&gt; list, since it does not belong to a file with that name.&lt;&#x2F;p&gt;
&lt;p&gt;But now &lt;code&gt;xargo build&lt;&#x2F;code&gt; is executed on every &lt;code&gt;make&lt;&#x2F;code&gt;, even if no source file was changed. And the ISO is recreated on every &lt;code&gt;make iso&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;make run&lt;&#x2F;code&gt;, too. We could try to avoid this by adding dependencies on all rust source and cargo configuration files to the &lt;code&gt;kernel&lt;&#x2F;code&gt; target, but the ISO creation takes only half a second on my machine and most of the time we will have changed a Rust file when we run &lt;code&gt;make&lt;&#x2F;code&gt;. So we keep it simple for now and let cargo do the bookkeeping of changed files (it does it anyway).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;calling-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-rust&quot; aria-label=&quot;Anchor link for: calling-rust&quot;&gt;üîó&lt;&#x2F;a&gt;Calling Rust&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can call the main method in &lt;code&gt;long_mode_start&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;bits 64
&lt;&#x2F;span&gt;&lt;span&gt;long_mode_start:
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; call the rust main
&lt;&#x2F;span&gt;&lt;span&gt;    extern rust_main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;     ; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;rust_main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OKAY` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;rax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f592f412f4b2f4f
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;qword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;], rax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By defining &lt;code&gt;rust_main&lt;&#x2F;code&gt; as &lt;code&gt;extern&lt;&#x2F;code&gt; we tell nasm that the function is defined in another file. As the linker takes care of linking them together, we‚Äôll get a linker error if we have a typo in the name or forget to mark the rust function as &lt;code&gt;pub extern&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If we‚Äôve done everything right, we should still see the green &lt;code&gt;OKAY&lt;&#x2F;code&gt; when executing &lt;code&gt;make run&lt;&#x2F;code&gt;. That means that we successfully called the Rust function and returned back to assembly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fixing-linker-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-linker-errors&quot; aria-label=&quot;Anchor link for: fixing-linker-errors&quot;&gt;üîó&lt;&#x2F;a&gt;Fixing Linker Errors&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can try some Rust code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;World&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; y = x;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we test it using &lt;code&gt;make run&lt;&#x2F;code&gt;, it fails with &lt;code&gt;undefined reference to &#x27;memcpy&#x27;&lt;&#x2F;code&gt;. The &lt;code&gt;memcpy&lt;&#x2F;code&gt; function is one of the basic functions of the C library (&lt;code&gt;libc&lt;&#x2F;code&gt;). Usually the &lt;code&gt;libc&lt;&#x2F;code&gt; crate is linked to every Rust program together with the standard library, but we opted out through &lt;code&gt;#![no_std]&lt;&#x2F;code&gt;. We could try to fix this by adding the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;1.10.0&#x2F;libc&#x2F;index.html&quot;&gt;libc crate&lt;&#x2F;a&gt; as &lt;code&gt;extern crate&lt;&#x2F;code&gt;. But &lt;code&gt;libc&lt;&#x2F;code&gt; is just a wrapper for the system &lt;code&gt;libc&lt;&#x2F;code&gt;, for example &lt;code&gt;glibc&lt;&#x2F;code&gt; on Linux, so this won‚Äôt work for us. Instead we need to recreate the basic &lt;code&gt;libc&lt;&#x2F;code&gt; functions such as &lt;code&gt;memcpy&lt;&#x2F;code&gt;, &lt;code&gt;memmove&lt;&#x2F;code&gt;, &lt;code&gt;memset&lt;&#x2F;code&gt;, and &lt;code&gt;memcmp&lt;&#x2F;code&gt; in Rust.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;rlibc&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rlibc&quot; aria-label=&quot;Anchor link for: rlibc&quot;&gt;üîó&lt;&#x2F;a&gt;rlibc&lt;&#x2F;h4&gt;
&lt;p&gt;Fortunately there already is a crate for that: &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;rlibc&quot;&gt;rlibc&lt;&#x2F;a&gt;. When we look at its &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alexcrichton&#x2F;rlibc&#x2F;blob&#x2F;defb486e765846417a8e73329e8c5196f1dca49a&#x2F;src&#x2F;lib.rs&quot;&gt;source code&lt;&#x2F;a&gt; we see that it contains no magic, just some &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;raw-pointers.html&quot;&gt;raw pointer&lt;&#x2F;a&gt; operations in a while loop. To add &lt;code&gt;rlibc&lt;&#x2F;code&gt; as a dependency we just need to add two lines to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rlibc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1.0&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and an &lt;code&gt;extern crate&lt;&#x2F;code&gt; definition in our &lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span&gt; rlibc;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;make run&lt;&#x2F;code&gt; doesn‚Äôt complain about &lt;code&gt;memcpy&lt;&#x2F;code&gt; anymore. Instead it will show a pile of new ugly linker errors:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(core-92335f822fa6c9a6.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `_$LT$f32$u20$as$u20$core..num..dec2flt..
&lt;&#x2F;span&gt;&lt;span&gt;        rawfp..RawFloat$GT$::from_int::h50f7952efac3fdca&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;    core.cgu-0.rs:(.text._ZN59_$LT$f32$u20$as$u20$core..num..dec2flt..
&lt;&#x2F;span&gt;&lt;span&gt;        rawfp..RawFloat$GT$8from_int17h50f7952efac3fdcaE+0x2):
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `__floatundisf&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(core-92335f822fa6c9a6.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `_$LT$f64$u20$as$u20$core..num..dec2flt..rawfp..
&lt;&#x2F;span&gt;&lt;span&gt;        RawFloat$GT$::from_int::h12a81f175246914a&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;    core.cgu-0.rs:(.text._ZN59_$LT$f64$u20$as$u20$core..num..dec2flt..rawfp..
&lt;&#x2F;span&gt;&lt;span&gt;        RawFloat$GT$8from_int17h12a81f175246914aE+0x2):
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `__floatundidf&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(core-92335f822fa6c9a6.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `core::num::from_str_radix::h09b12650704e0508&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;    core.cgu-0.rs:(.text._ZN4core3num14from_str_radix
&lt;&#x2F;span&gt;&lt;span&gt;        17h09b12650704e0508E+0xcf):
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `__muloti4&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;gc-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#gc-sections&quot; aria-label=&quot;Anchor link for: gc-sections&quot;&gt;üîó&lt;&#x2F;a&gt;‚Äìgc-sections&lt;&#x2F;h4&gt;
&lt;p&gt;The new errors are linker errors about various missing functions such as &lt;code&gt;__floatundisf&lt;&#x2F;code&gt; or &lt;code&gt;__muloti4&lt;&#x2F;code&gt;. These functions are part of LLVM‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;compiler-rt.llvm.org&#x2F;&quot;&gt;&lt;code&gt;compiler-rt&lt;&#x2F;code&gt; builtins&lt;&#x2F;a&gt; and are normally linked by the standard library. For &lt;code&gt;no_std&lt;&#x2F;code&gt; crates like ours, one has to link the &lt;code&gt;compiler-rt&lt;&#x2F;code&gt; library manually. Unfortunately, this library is implemented in C and the build process is a bit cumbersome. Alternatively, there is the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang-nursery&#x2F;compiler-builtins&quot;&gt;compiler-builtins&lt;&#x2F;a&gt; crate that tries to port the library to Rust, but it isn‚Äôt complete yet.&lt;&#x2F;p&gt;
&lt;p&gt;In our case, there is a much simpler solution, since our kernel doesn‚Äôt really need any of those functions yet. So we can just tell the linker to remove unused program sections and hopefully all references to these functions will disappear. Removing unused sections is generally a good idea as it reduces kernel size. The magic linker flag for this is &lt;code&gt;--gc-sections&lt;&#x2F;code&gt;, which stands for ‚Äúgarbage collect sections‚Äù. Let‚Äôs add it to the &lt;code&gt;$(kernel)&lt;&#x2F;code&gt; target in our &lt;code&gt;Makefile&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;make&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-make &quot;&gt;&lt;code class=&quot;language-make&quot; data-lang=&quot;make&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;xargo &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;ld -n --gc-sections -T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; -o &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span&gt;rust_os&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can do a &lt;code&gt;make run&lt;&#x2F;code&gt; again and it compiles without errors again. However, it doesn‚Äôt boot anymore:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;GRUB error: no multiboot header found.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What happened? Well, the linker removed unused sections. And since we don‚Äôt use the Multiboot section anywhere, &lt;code&gt;ld&lt;&#x2F;code&gt; removes it, too. So we need to tell the linker explicitly that it should keep this section. The &lt;code&gt;KEEP&lt;&#x2F;code&gt; command does exactly that, so we add it to the linker script (&lt;code&gt;linker.ld&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;.boot :
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;* ensure that the multiboot header is at the beginning *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    KEEP(*(.multiboot_header))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now everything should work again (the green &lt;code&gt;OKAY&lt;&#x2F;code&gt;). But there is another linking issue, which is triggered by some other example code.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;panic-abort&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#panic-abort&quot; aria-label=&quot;Anchor link for: panic-abort&quot;&gt;üîó&lt;&#x2F;a&gt;panic = ‚Äúabort‚Äù&lt;&#x2F;h4&gt;
&lt;p&gt;The following snippet still fails:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; test = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;).flat_map(|x| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;x).zip(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error is a linker error again (hence the ugly error message):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `core::ptr::drop_in_place&amp;lt;core::iter::Zip&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        core::iter::FlatMap&amp;lt;core::ops::Range&amp;lt;i32&amp;gt;, core::ops::Range&amp;lt;i32&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        closure&amp;gt;, core::ops::RangeFrom&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;        &#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;libcore&#x2F;ptr.rs:66:
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `_Unwind_Resume&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `core::iter::iterator::Iterator::zip&amp;lt;core::iter::FlatMap&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;        core::ops::Range&amp;lt;i32&amp;gt;, core::ops::Range&amp;lt;i32&amp;gt;, closure&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        core::ops::RangeFrom&amp;lt;i32&amp;gt;&amp;gt;&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;        &#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;libcore&#x2F;iter&#x2F;iterator.rs:389:
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `_Unwind_Resume&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So the linker can‚Äôt find a function named &lt;code&gt;_Unwind_Resume&lt;&#x2F;code&gt; that is referenced e.g. in &lt;code&gt;iter&#x2F;iterator.rs:389&lt;&#x2F;code&gt; in libcore. This reference is not really there at &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;blob&#x2F;c58c928e658d2e45f816fd05796a964aa83759da&#x2F;src&#x2F;libcore&#x2F;iter&#x2F;iterator.rs#L389&quot;&gt;line 389&lt;&#x2F;a&gt; of libcore‚Äôs &lt;code&gt;iterator.rs&lt;&#x2F;code&gt;. Instead, it is a compiler inserted &lt;em&gt;landing pad&lt;&#x2F;em&gt;, which is used for panic handling.&lt;&#x2F;p&gt;
&lt;p&gt;By default, the destructors of all stack variables are run when a &lt;code&gt;panic&lt;&#x2F;code&gt; occurs. This is called &lt;em&gt;unwinding&lt;&#x2F;em&gt; and allows parent threads to recover from panics. However, it requires a platform specific gcc library, which isn‚Äôt available in our kernel.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately, Rust allows us to disable unwinding for our target. For that we add the following line to our &lt;code&gt;x86_64-blog_os.json&lt;&#x2F;code&gt; file:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;...&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By setting the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nox&#x2F;rust-rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1513-less-unwinding.md&quot;&gt;panic strategy&lt;&#x2F;a&gt; to &lt;code&gt;abort&lt;&#x2F;code&gt; instead of the default &lt;code&gt;unwind&lt;&#x2F;code&gt;, we disable all unwinding in our kernel. Let‚Äôs try &lt;code&gt;make run&lt;&#x2F;code&gt; again:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;   Compiling core v0.0.0 (file:&#x2F;&#x2F;&#x2F;‚Ä¶&#x2F;rust&#x2F;src&#x2F;libcore)
&lt;&#x2F;span&gt;&lt;span&gt;    Finished release [optimized] target(s) in 22.24 secs
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.5 secs
&lt;&#x2F;span&gt;&lt;span&gt;target&#x2F;x86_64-blog_os&#x2F;debug&#x2F;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
&lt;&#x2F;span&gt;&lt;span&gt;    In function `core::ptr::drop_in_place&amp;lt;‚Ä¶&amp;gt;&amp;#39;:
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;‚Ä¶&#x2F;src&#x2F;libcore&#x2F;ptr.rs:66:
&lt;&#x2F;span&gt;&lt;span&gt;    undefined reference to `_Unwind_Resume&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We see that &lt;code&gt;xargo&lt;&#x2F;code&gt; recompiles the &lt;code&gt;core&lt;&#x2F;code&gt; crate, but the &lt;code&gt;_Unwind_Resume&lt;&#x2F;code&gt; error still occurs. This is because our &lt;code&gt;blog_os&lt;&#x2F;code&gt; crate was not recompiled somehow and thus still references the unwinding function. To fix this, we need to force a recompile using &lt;code&gt;cargo clean&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; cargo clean
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; make run
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling rlibc v1.0.0
&lt;&#x2F;span&gt;&lt;span&gt;   Compiling blog_os v0.1.0 (file:&#x2F;&#x2F;&#x2F;home&#x2F;philipp&#x2F;Documents&#x2F;blog_os&#x2F;tags)
&lt;&#x2F;span&gt;&lt;span&gt;warning: unused variable: `test` [‚Ä¶]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It worked! We no longer see linker errors and our kernel prints &lt;code&gt;OKAY&lt;&#x2F;code&gt; again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world&quot; aria-label=&quot;Anchor link for: hello-world&quot;&gt;üîó&lt;&#x2F;a&gt;Hello World!&lt;&#x2F;h2&gt;
&lt;p&gt;Finally, it‚Äôs time for a &lt;code&gt;Hello World!&lt;&#x2F;code&gt; from Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[no_mangle]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2F;span&gt;&lt;span&gt;rust_main() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; ATTENTION: we have a very small stack and no guard page
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; hello = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; color_byte = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1f&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; white foreground, blue background
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; hello_colored = [color_byte; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(i, char_byte) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; hello.into_iter().enumerate() {
&lt;&#x2F;span&gt;&lt;span&gt;        hello_colored[i*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] = *char_byte;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; write `Hello World!` to the center of the VGA text buffer
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; buffer_ptr = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1988&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ *buffer_ptr = hello_colored };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Some notes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;b&lt;&#x2F;code&gt; prefix creates a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;tokens.html#characters-and-strings&quot;&gt;byte string&lt;&#x2F;a&gt;, which is just an array of &lt;code&gt;u8&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nightly&#x2F;core&#x2F;iter&#x2F;trait.Iterator.html#method.enumerate&quot;&gt;enumerate&lt;&#x2F;a&gt; is an &lt;code&gt;Iterator&lt;&#x2F;code&gt; method that adds the current index &lt;code&gt;i&lt;&#x2F;code&gt; to elements&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;buffer_ptr&lt;&#x2F;code&gt; is a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;raw-pointers.html&quot;&gt;raw pointer&lt;&#x2F;a&gt; that points to the center of the VGA text buffer&lt;&#x2F;li&gt;
&lt;li&gt;Rust doesn‚Äôt know the VGA buffer and thus can‚Äôt guarantee that writing to the &lt;code&gt;buffer_ptr&lt;&#x2F;code&gt; is safe (it could point to important data). So we need to tell Rust that we know what we are doing by using an &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;unsafe.html&quot;&gt;unsafe block&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;stack-overflows&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#stack-overflows&quot; aria-label=&quot;Anchor link for: stack-overflows&quot;&gt;üîó&lt;&#x2F;a&gt;Stack Overflows&lt;&#x2F;h3&gt;
&lt;p&gt;Since we still use the small 64 byte &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;#creating-a-stack&quot;&gt;stack from the last post&lt;&#x2F;a&gt;, we must be careful not to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Stack_overflow&quot;&gt;overflow&lt;&#x2F;a&gt; it. Normally, Rust tries to avoid stack overflows through &lt;em&gt;guard pages&lt;&#x2F;em&gt;: The page below the stack isn‚Äôt mapped and such a stack overflow triggers a page fault (instead of silently overwriting random memory). But we can‚Äôt unmap the page below our stack right now since we currently use only a single big page. Fortunately the stack is located just above the page tables. So some important page table entry would probably get overwritten on stack overflow and then a page fault occurs, too.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;Until now we write magic bits to some memory location when we want to print something to screen. In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; we create a abstraction for the VGA text buffer that allows us to print strings in different colors and provides a simple interface.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Entering Long Mode</title>
                <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/entering-longmode/</link>
                <guid>https://os.phil-opp.com/entering-longmode/</guid>
                <description>&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;multiboot-kernel&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; we created a minimal multiboot kernel. It just prints &lt;code&gt;OK&lt;&#x2F;code&gt; and hangs. The goal is to extend it and call 64-bit &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; code. But the CPU is currently in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protected_mode&quot;&gt;protected mode&lt;&#x2F;a&gt; and allows only 32-bit instructions and up to 4GiB memory. So we need to set up &lt;em&gt;Paging&lt;&#x2F;em&gt; and switch to the 64-bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long_mode&quot;&gt;long mode&lt;&#x2F;a&gt; first.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;I tried to explain everything in detail and to keep the code as simple as possible. If you have any questions, suggestions, or issues, please leave a comment or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;create an issue&lt;&#x2F;a&gt; on Github. The source code is available in a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_2&#x2F;src&#x2F;arch&#x2F;x86_64&quot;&gt;repository&lt;&#x2F;a&gt;, too.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;some-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-tests&quot; aria-label=&quot;Anchor link for: some-tests&quot;&gt;üîó&lt;&#x2F;a&gt;Some Tests&lt;&#x2F;h2&gt;
&lt;p&gt;To avoid bugs and strange errors on old CPUs we should check if the processor supports every needed feature. If not, the kernel should abort and display an error message. To handle errors easily, we create an error procedure in &lt;code&gt;boot.asm&lt;&#x2F;code&gt;. It prints a rudimentary &lt;code&gt;ERR: X&lt;&#x2F;code&gt; message, where X is an error code letter, and hangs:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;; Prints `ERR: ` and the given error code to screen and hangs.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;; parameter: error code (in ascii) in al
&lt;&#x2F;span&gt;&lt;span&gt;error:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;dword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f524f45
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;dword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8004&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f3a4f52
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;dword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8008&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f204f20
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;byte  [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb800a&lt;&#x2F;span&gt;&lt;span&gt;], al
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;At address &lt;code&gt;0xb8000&lt;&#x2F;code&gt; begins the so-called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;VGA-compatible_text_mode&quot;&gt;VGA text buffer&lt;&#x2F;a&gt;. It‚Äôs an array of screen characters that are displayed by the graphics card. A &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;printing-to-screen&#x2F;&quot;&gt;future post&lt;&#x2F;a&gt; will cover the VGA buffer in detail and create a Rust interface to it. But for now, manual bit-fiddling is the easiest option.&lt;&#x2F;p&gt;
&lt;p&gt;A screen character consists of a 8 bit color code and a 8 bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ASCII&quot;&gt;ASCII&lt;&#x2F;a&gt; character. We used the color code &lt;code&gt;4f&lt;&#x2F;code&gt; for all characters, which means white text on red background. &lt;code&gt;0x52&lt;&#x2F;code&gt; is an ASCII &lt;code&gt;R&lt;&#x2F;code&gt;, &lt;code&gt;0x45&lt;&#x2F;code&gt; is an &lt;code&gt;E&lt;&#x2F;code&gt;, &lt;code&gt;0x3a&lt;&#x2F;code&gt; is a &lt;code&gt;:&lt;&#x2F;code&gt;, and &lt;code&gt;0x20&lt;&#x2F;code&gt; is a space. The second space is overwritten by the given ASCII byte. Finally the CPU is stopped with the &lt;code&gt;hlt&lt;&#x2F;code&gt; instruction.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can add some check &lt;em&gt;functions&lt;&#x2F;em&gt;. A function is just a normal label with an &lt;code&gt;ret&lt;&#x2F;code&gt; (return) instruction at the end. The &lt;code&gt;call&lt;&#x2F;code&gt; instruction can be used to call it. Unlike the &lt;code&gt;jmp&lt;&#x2F;code&gt; instruction that just jumps to a memory address, the &lt;code&gt;call&lt;&#x2F;code&gt; instruction will push a return address to the stack (and the &lt;code&gt;ret&lt;&#x2F;code&gt; will jump to this address). But we don‚Äôt have a stack yet. The &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;1464052&#x2F;866447&quot;&gt;stack pointer&lt;&#x2F;a&gt; in the esp register could point to some important data or even invalid memory. So we need to update it and point it to some valid stack memory.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;creating-a-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-stack&quot; aria-label=&quot;Anchor link for: creating-a-stack&quot;&gt;üîó&lt;&#x2F;a&gt;Creating a Stack&lt;&#x2F;h3&gt;
&lt;p&gt;To create stack memory we reserve some bytes at the end of our &lt;code&gt;boot.asm&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;section .bss
&lt;&#x2F;span&gt;&lt;span&gt;stack_bottom:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;64
&lt;&#x2F;span&gt;&lt;span&gt;stack_top:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A stack doesn‚Äôt need to be initialized because we will &lt;code&gt;pop&lt;&#x2F;code&gt; only when we &lt;code&gt;pushed&lt;&#x2F;code&gt; before. So storing the stack memory in the executable file would make it unnecessary large. By using the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;.bss&quot;&gt;.bss&lt;&#x2F;a&gt; section and the &lt;code&gt;resb&lt;&#x2F;code&gt; (reserve byte) command, we just store the length of the uninitialized data (= 64). When loading the executable, GRUB will create the section of required size in memory.&lt;&#x2F;p&gt;
&lt;p&gt;To use the new stack, we update the stack pointer register right after &lt;code&gt;start&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;global start
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .text
&lt;&#x2F;span&gt;&lt;span&gt;bits 32
&lt;&#x2F;span&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;esp, stack_top
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OK` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use &lt;code&gt;stack_top&lt;&#x2F;code&gt; because the stack grows downwards: A &lt;code&gt;push eax&lt;&#x2F;code&gt; subtracts 4 from &lt;code&gt;esp&lt;&#x2F;code&gt; and does a &lt;code&gt;mov [esp], eax&lt;&#x2F;code&gt; afterwards (&lt;code&gt;eax&lt;&#x2F;code&gt; is a general purpose register).&lt;&#x2F;p&gt;
&lt;p&gt;Now we have a valid stack pointer and are able to call functions. The following check functions are just here for completeness and I won‚Äôt explain details. Basically they all work the same: They will check for a feature and jump to &lt;code&gt;error&lt;&#x2F;code&gt; if it‚Äôs not available.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;multiboot-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multiboot-check&quot; aria-label=&quot;Anchor link for: multiboot-check&quot;&gt;üîó&lt;&#x2F;a&gt;Multiboot check&lt;&#x2F;h3&gt;
&lt;p&gt;We rely on some Multiboot features in the next posts. To make sure the kernel was really loaded by a Multiboot compliant bootloader, we can check the &lt;code&gt;eax&lt;&#x2F;code&gt; register. According to the Multiboot specification (&lt;a href=&quot;https:&#x2F;&#x2F;nongnu.askapache.com&#x2F;grub&#x2F;phcoder&#x2F;multiboot.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;), the bootloader must write the magic value &lt;code&gt;0x36d76289&lt;&#x2F;code&gt; to it before loading a kernel. To verify that we can add a simple function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;check_multiboot:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x36d76289
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jne &lt;&#x2F;span&gt;&lt;span&gt;.no_multiboot
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span&gt;.no_multiboot:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;al, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span&gt;error
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use the &lt;code&gt;cmp&lt;&#x2F;code&gt; instruction to compare the value in &lt;code&gt;eax&lt;&#x2F;code&gt; to the magic value. If the values are equal, the &lt;code&gt;cmp&lt;&#x2F;code&gt; instruction sets the zero flag in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;FLAGS register&lt;&#x2F;a&gt;. The &lt;code&gt;jne&lt;&#x2F;code&gt; (‚Äújump if not equal‚Äù) instruction reads this zero flag and jumps to the given address if it‚Äôs not set. Thus we jump to the &lt;code&gt;.no_multiboot&lt;&#x2F;code&gt; label if &lt;code&gt;eax&lt;&#x2F;code&gt; does not contain the magic value.&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;code&gt;no_multiboot&lt;&#x2F;code&gt;, we use the &lt;code&gt;jmp&lt;&#x2F;code&gt; (‚Äújump‚Äù) instruction to jump to our error function. We could just as well use the &lt;code&gt;call&lt;&#x2F;code&gt; instruction, which additionally pushes the return address. But the return address is not needed because &lt;code&gt;error&lt;&#x2F;code&gt; never returns. To pass &lt;code&gt;0&lt;&#x2F;code&gt; as error code to the &lt;code&gt;error&lt;&#x2F;code&gt; function, we move it into &lt;code&gt;al&lt;&#x2F;code&gt; before the jump (&lt;code&gt;error&lt;&#x2F;code&gt; will read it from there).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cpuid-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cpuid-check&quot; aria-label=&quot;Anchor link for: cpuid-check&quot;&gt;üîó&lt;&#x2F;a&gt;CPUID check&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;CPUID&quot;&gt;CPUID&lt;&#x2F;a&gt; is a CPU instruction that can be used to get various information about the CPU. But not every processor supports it. CPUID detection is quite laborious, so we just copy a detection function from the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Setting_Up_Long_Mode#Detection_of_CPUID&quot;&gt;OSDev wiki&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;check_cpuid:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Check if CPUID is supported by attempting to flip the ID bit (bit 21)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; in the FLAGS register. If we can flip it, CPUID is available.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Copy FLAGS in to EAX via stack
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pushfd
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span&gt;eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Copy to ECX as well for comparing later on
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ecx, eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Flip the ID bit
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;xor &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;21
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Copy EAX to FLAGS via the stack
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span&gt;eax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;popfd
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Copy FLAGS back to EAX (with the flipped bit if CPUID is supported)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pushfd
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span&gt;eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Restore FLAGS from the old version stored in ECX (i.e. flipping the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; ID bit back if it was ever flipped).
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span&gt;ecx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;popfd
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; Compare EAX and ECX. If they are equal then that means the bit
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; wasn&amp;#39;t flipped, and CPUID isn&amp;#39;t supported.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span&gt;eax, ecx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;je &lt;&#x2F;span&gt;&lt;span&gt;.no_cpuid
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span&gt;.no_cpuid:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;al, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span&gt;error
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Basically, the &lt;code&gt;CPUID&lt;&#x2F;code&gt; instruction is supported if we can flip some bit in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FLAGS_register&quot;&gt;FLAGS register&lt;&#x2F;a&gt;. We can‚Äôt operate on the flags register directly, so we need to load it into some general purpose register such as &lt;code&gt;eax&lt;&#x2F;code&gt; first. The only way to do this is to push the &lt;code&gt;FLAGS&lt;&#x2F;code&gt; register on the stack through the &lt;code&gt;pushfd&lt;&#x2F;code&gt; instruction and then pop it into &lt;code&gt;eax&lt;&#x2F;code&gt;. Equally, we write it back through &lt;code&gt;push ecx&lt;&#x2F;code&gt; and &lt;code&gt;popfd&lt;&#x2F;code&gt;. To flip the bit we use the &lt;code&gt;xor&lt;&#x2F;code&gt; instruction to perform an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Exclusive_or&quot;&gt;exclusive OR&lt;&#x2F;a&gt;. Finally we compare the two values and jump to &lt;code&gt;.no_cpuid&lt;&#x2F;code&gt; if both are equal (&lt;code&gt;je&lt;&#x2F;code&gt; ‚Äì ‚Äújump if equal‚Äù). The &lt;code&gt;.no_cpuid&lt;&#x2F;code&gt; code just jumps to the &lt;code&gt;error&lt;&#x2F;code&gt; function with error code &lt;code&gt;1&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Don‚Äôt worry, you don‚Äôt need to understand the details.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;long-mode-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#long-mode-check&quot; aria-label=&quot;Anchor link for: long-mode-check&quot;&gt;üîó&lt;&#x2F;a&gt;Long Mode check&lt;&#x2F;h3&gt;
&lt;p&gt;Now we can use CPUID to detect whether long mode can be used. I use code from &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Setting_Up_Long_Mode#x86_or_x86-64&quot;&gt;OSDev&lt;&#x2F;a&gt; again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;check_long_mode:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; test if extended processor info in available
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; implicit argument for cpuid
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cpuid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                  ; get highest supported argument
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000001&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; it needs to be at least 0x80000001
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jb &lt;&#x2F;span&gt;&lt;span&gt;.no_long_mode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; if it&amp;#39;s less, the CPU is too old for long mode
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; use extended info to test if long mode is available
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000001&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; argument for extended processor info
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cpuid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                  ; returns various feature bits in ecx and edx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test &lt;&#x2F;span&gt;&lt;span&gt;edx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;29&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;      ; test if the LM-bit is set in the D-register
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jz &lt;&#x2F;span&gt;&lt;span&gt;.no_long_mode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; If it&amp;#39;s not set, there is no long mode
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span&gt;.no_long_mode:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;al, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;2&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span&gt;error
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like many low-level things, CPUID is a bit strange. Instead of taking a parameter, the &lt;code&gt;cpuid&lt;&#x2F;code&gt; instruction implicitly uses the &lt;code&gt;eax&lt;&#x2F;code&gt; register as argument. To test if long mode is available, we need to call &lt;code&gt;cpuid&lt;&#x2F;code&gt; with &lt;code&gt;0x80000001&lt;&#x2F;code&gt; in &lt;code&gt;eax&lt;&#x2F;code&gt;. This loads some information to the &lt;code&gt;ecx&lt;&#x2F;code&gt; and &lt;code&gt;edx&lt;&#x2F;code&gt; registers. Long mode is supported if the 29th bit in &lt;code&gt;edx&lt;&#x2F;code&gt; is set. &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;CPUID#EAX.3D80000001h:_Extended_Processor_Info_and_Feature_Bits&quot;&gt;Wikipedia&lt;&#x2F;a&gt; has detailed information.&lt;&#x2F;p&gt;
&lt;p&gt;If you look at the assembly above, you‚Äôll probably notice that we call &lt;code&gt;cpuid&lt;&#x2F;code&gt; twice. The reason is that the CPUID command started with only a few functions and was extended over time. So old processors may not know the &lt;code&gt;0x80000001&lt;&#x2F;code&gt; argument at all. To test if they do, we need to invoke &lt;code&gt;cpuid&lt;&#x2F;code&gt; with &lt;code&gt;0x80000000&lt;&#x2F;code&gt; in &lt;code&gt;eax&lt;&#x2F;code&gt; first. It returns the highest supported parameter value in &lt;code&gt;eax&lt;&#x2F;code&gt;. If it‚Äôs at least &lt;code&gt;0x80000001&lt;&#x2F;code&gt;, we can test for long mode as described above. Else the CPU is old and doesn‚Äôt know what long mode is either. In that case, we directly jump to &lt;code&gt;.no_long_mode&lt;&#x2F;code&gt; through the &lt;code&gt;jb&lt;&#x2F;code&gt; instruction (‚Äújump if below‚Äù).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;üîó&lt;&#x2F;a&gt;Putting it together&lt;&#x2F;h3&gt;
&lt;p&gt;We just call these check functions right after start:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;global start
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .text
&lt;&#x2F;span&gt;&lt;span&gt;bits 32
&lt;&#x2F;span&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;esp, stack_top
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_multiboot
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_cpuid
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_long_mode
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OK` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the CPU doesn‚Äôt support a needed feature, we get an error message with an unique error code. Now we can start the real work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;üîó&lt;&#x2F;a&gt;Paging&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Paging&lt;&#x2F;em&gt; is a memory management scheme that separates virtual and physical memory. The address space is split into equal sized &lt;em&gt;pages&lt;&#x2F;em&gt; and a &lt;em&gt;page table&lt;&#x2F;em&gt; specifies which virtual page points to which physical page. If you never heard of paging, you might want to look at the paging introduction (&lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;vm-paging.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) of the &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;&quot;&gt;Three Easy Pieces&lt;&#x2F;a&gt; OS book.&lt;&#x2F;p&gt;
&lt;p&gt;In long mode, x86 uses a page size of 4096 bytes and a 4 level page table that consists of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the Page-Map Level-4 Table (PML4),&lt;&#x2F;li&gt;
&lt;li&gt;the Page-Directory Pointer Table (PDP),&lt;&#x2F;li&gt;
&lt;li&gt;the Page-Directory Table (PD),&lt;&#x2F;li&gt;
&lt;li&gt;and the Page Table (PT).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As I don‚Äôt like these names, I will call them P4, P3, P2, and P1 from now on.&lt;&#x2F;p&gt;
&lt;p&gt;Each page table contains 512 entries and one entry is 8 bytes, so they fit exactly in one page (&lt;code&gt;512*8 = 4096&lt;&#x2F;code&gt;). To translate a virtual address to a physical address the CPU&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#hardware_lookup&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; will do the following&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#virtual_physical_translation_source&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;X86_Paging_64bit.svg&quot; alt=&quot;translation of virtual to physical addresses in 64 bit mode&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Get the address of the P4 table from the CR3 register&lt;&#x2F;li&gt;
&lt;li&gt;Use bits 39-47 (9 bits) as an index into P4 (&lt;code&gt;2^9 = 512 = number of entries&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P3&lt;&#x2F;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P2&lt;&#x2F;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P1&lt;&#x2F;li&gt;
&lt;li&gt;Use the last 12 bits as page offset (&lt;code&gt;2^12 = 4096 = page size&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;But what happens to bits 48-63 of the 64-bit virtual address? Well, they can‚Äôt be used. The ‚Äú64-bit‚Äù long mode is in fact just a 48-bit mode. The bits 48-63 must be copies of bit 47, so each valid virtual address is still unique. For more information see &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;X86-64#Virtual_address_space_details&quot;&gt;Wikipedia&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;An entry in the P4, P3, P2, and P1 tables consists of the page aligned 52-bit &lt;em&gt;physical&lt;&#x2F;em&gt; address of the frame or the next page table and the following bits that can be OR-ed in:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;present&lt;&#x2F;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;writable&lt;&#x2F;td&gt;&lt;td&gt;it‚Äôs allowed to write to this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;user accessible&lt;&#x2F;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;write through caching&lt;&#x2F;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;disable cache&lt;&#x2F;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;accessed&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;dirty&lt;&#x2F;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;huge page&#x2F;null&lt;&#x2F;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1GiB page in P3, creates a 2MiB page in P2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;global&lt;&#x2F;td&gt;&lt;td&gt;page isn‚Äôt flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62&lt;&#x2F;td&gt;&lt;td&gt;available&lt;&#x2F;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;63&lt;&#x2F;td&gt;&lt;td&gt;no execute&lt;&#x2F;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;set-up-identity-paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#set-up-identity-paging&quot; aria-label=&quot;Anchor link for: set-up-identity-paging&quot;&gt;üîó&lt;&#x2F;a&gt;Set Up Identity Paging&lt;&#x2F;h3&gt;
&lt;p&gt;When we switch to long mode, paging will be activated automatically. The CPU will then try to read the instruction at the following address, but this address is now a virtual address. So we need to do &lt;em&gt;identity mapping&lt;&#x2F;em&gt;, i.e. map a physical address to the same virtual address.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;huge page&lt;&#x2F;code&gt; bit is now very useful to us. It creates a 2MiB (when used in P2) or even a 1GiB page (when used in P3). So we could map the first &lt;em&gt;gigabytes&lt;&#x2F;em&gt; of the kernel with only one P4 and one P3 table by using 1GiB pages. Unfortunately 1GiB pages are relatively new feature, for example Intel introduced it 2010 in the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Westmere_(microarchitecture)#Technology&quot;&gt;Westmere architecture&lt;&#x2F;a&gt;. Therefore we will use 2MiB pages instead to make our kernel compatible to older computers, too.&lt;&#x2F;p&gt;
&lt;p&gt;To identity map the first gigabyte of our kernel with 512 2MiB pages, we need one P4, one P3, and one P2 table. Of course we will replace them with finer-grained tables later. But now that we‚Äôre stuck with assembly, we choose the easiest way.&lt;&#x2F;p&gt;
&lt;p&gt;We can add these two tables at the beginning&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#page_table_alignment&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; of the &lt;code&gt;.bss&lt;&#x2F;code&gt; section:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .bss
&lt;&#x2F;span&gt;&lt;span&gt;align &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p4_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p3_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;p2_table:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2F;span&gt;&lt;span&gt;stack_bottom:
&lt;&#x2F;span&gt;&lt;span&gt;    resb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;64
&lt;&#x2F;span&gt;&lt;span&gt;stack_top:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;resb&lt;&#x2F;code&gt; command reserves the specified amount of bytes without initializing them, so the 8KiB don‚Äôt need to be saved in the executable. The &lt;code&gt;align 4096&lt;&#x2F;code&gt; ensures that the page tables are page aligned.&lt;&#x2F;p&gt;
&lt;p&gt;When GRUB creates the &lt;code&gt;.bss&lt;&#x2F;code&gt; section in memory, it will initialize it to &lt;code&gt;0&lt;&#x2F;code&gt;. So the &lt;code&gt;p4_table&lt;&#x2F;code&gt; is already valid (it contains 512 non-present entries) but not very useful. To be able to map 2MiB pages, we need to link P4‚Äôs first entry to the &lt;code&gt;p3_table&lt;&#x2F;code&gt; and P3‚Äôs first entry to the the &lt;code&gt;p2_table&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;set_up_page_tables:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; map first P4 entry to P3 table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, p3_table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, 0b11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;[p4_table], eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; map first P3 entry to P2 table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, p2_table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, 0b11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;[p3_table], eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; TODO map each P2 entry to a huge 2MiB page
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We just set the present and writable bits (&lt;code&gt;0b11&lt;&#x2F;code&gt; is a binary number) in the aligned P3 table address and move it to the first 4 bytes of the P4 table. Then we do the same to link the first P3 entry to the &lt;code&gt;p2_table&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Now we need to map P2‚Äôs first entry to a huge page starting at 0, P2‚Äôs second entry to a huge page starting at 2MiB, P2‚Äôs third entry to a huge page starting at 4MiB, and so on. It‚Äôs time for our first (and only) assembly loop:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;set_up_page_tables:
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; map each P2 entry to a huge 2MiB page
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ecx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;         ; counter variable
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.map_p2_table:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; map ecx-th P2 entry to a huge page that starts at address 2MiB*ecx
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x200000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;  ; 2MiB
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mul &lt;&#x2F;span&gt;&lt;span&gt;ecx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;            ; start address of ecx-th page
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, 0b10000011&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable + huge
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;[p2_table + ecx * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; map ecx-th entry
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span&gt;ecx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;            ; increase counter
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span&gt;ecx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;512&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; if counter == 512, the whole P2 table is mapped
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jne &lt;&#x2F;span&gt;&lt;span&gt;.map_p2_table&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;  ; else map the next entry
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Maybe I should first explain how an assembly loop works. We use the &lt;code&gt;ecx&lt;&#x2F;code&gt; register as a counter variable, just like &lt;code&gt;i&lt;&#x2F;code&gt; in a for loop. After mapping the &lt;code&gt;ecx-th&lt;&#x2F;code&gt; entry, we increase &lt;code&gt;ecx&lt;&#x2F;code&gt; by one and jump to &lt;code&gt;.map_p2_table&lt;&#x2F;code&gt; again if it‚Äôs still smaller than 512.&lt;&#x2F;p&gt;
&lt;p&gt;To map a P2 entry we first calculate the start address of its page in &lt;code&gt;eax&lt;&#x2F;code&gt;: The &lt;code&gt;ecx-th&lt;&#x2F;code&gt; entry needs to be mapped to &lt;code&gt;ecx * 2MiB&lt;&#x2F;code&gt;. We use the &lt;code&gt;mul&lt;&#x2F;code&gt; operation for that, which multiplies &lt;code&gt;eax&lt;&#x2F;code&gt; with the given register and stores the result in &lt;code&gt;eax&lt;&#x2F;code&gt;. Then we set the &lt;code&gt;present&lt;&#x2F;code&gt;, &lt;code&gt;writable&lt;&#x2F;code&gt;, and &lt;code&gt;huge page&lt;&#x2F;code&gt; bits and write it to the P2 entry. The address of the &lt;code&gt;ecx-th&lt;&#x2F;code&gt; entry in P2 is &lt;code&gt;p2_table + ecx * 8&lt;&#x2F;code&gt;, because each entry is 8 bytes large.&lt;&#x2F;p&gt;
&lt;p&gt;Now the first gigabyte (512 * 2MiB) of our kernel is identity mapped and thus accessible through the same physical and virtual addresses.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;enable-paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#enable-paging&quot; aria-label=&quot;Anchor link for: enable-paging&quot;&gt;üîó&lt;&#x2F;a&gt;Enable Paging&lt;&#x2F;h3&gt;
&lt;p&gt;To enable paging and enter long mode, we need to do the following:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;write the address of the P4 table to the CR3 register (the CPU will look there, see the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;#paging&quot;&gt;paging section&lt;&#x2F;a&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;long mode is an extension of &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Physical_Address_Extension&quot;&gt;Physical Address Extension&lt;&#x2F;a&gt; (PAE), so we need to enable PAE first&lt;&#x2F;li&gt;
&lt;li&gt;Set the long mode bit in the EFER register&lt;&#x2F;li&gt;
&lt;li&gt;Enable Paging&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The assembly function looks like this (some boring bit-moving to various registers):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;enable_paging:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; load P4 to cr3 register (cpu uses this to access the P4 table)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, p4_table
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;cr3, eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; enable PAE-flag in cr4 (Physical Address Extension)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, cr4
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;cr4, eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; set the long mode bit in the EFER MSR (model specific register)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ecx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xC0000080
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rdmsr
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;wrmsr
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; enable paging in the cr0 register
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;eax, cr0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2F;span&gt;&lt;span&gt;eax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;31
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;cr0, eax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;or eax, 1 &amp;lt;&amp;lt; X&lt;&#x2F;code&gt; is a common pattern. It sets the bit &lt;code&gt;X&lt;&#x2F;code&gt; in the eax register (&lt;code&gt;&amp;lt;&amp;lt;&lt;&#x2F;code&gt; is a left shift). Through &lt;code&gt;rdmsr&lt;&#x2F;code&gt; and &lt;code&gt;wrmsr&lt;&#x2F;code&gt; it‚Äôs possible to read&#x2F;write to the so-called model specific registers at address &lt;code&gt;ecx&lt;&#x2F;code&gt; (in this case &lt;code&gt;ecx&lt;&#x2F;code&gt; points to the EFER register).&lt;&#x2F;p&gt;
&lt;p&gt;Finally we need to call our new functions in &lt;code&gt;start&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;esp, stack_top
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_multiboot
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_cpuid
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;check_long_mode
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;set_up_page_tables&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; new
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;enable_paging&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;     ; new
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OK` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;dword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f4b2f4f
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To test it we execute &lt;code&gt;make run&lt;&#x2F;code&gt;. If the green OK is still printed, we have successfully enabled paging!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-global-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table&quot;&gt;üîó&lt;&#x2F;a&gt;The Global Descriptor Table&lt;&#x2F;h2&gt;
&lt;p&gt;After enabling Paging, the processor is in long mode. So we can use 64-bit instructions now, right? Wrong. The processor is still in a 32-bit compatibility submode. To actually execute 64-bit code, we need to set up a new Global Descriptor Table.
The Global Descriptor Table (GDT) was used for &lt;em&gt;Segmentation&lt;&#x2F;em&gt; in old operating systems. I won‚Äôt explain Segmentation but the &lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;&quot;&gt;Three Easy Pieces&lt;&#x2F;a&gt; OS book has good introduction (&lt;a href=&quot;http:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F;vm-segmentation.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) again.&lt;&#x2F;p&gt;
&lt;p&gt;Today almost everyone uses Paging instead of Segmentation (and so do we). But on x86, a GDT is always required, even when you‚Äôre not using Segmentation. GRUB has set up a valid 32-bit GDT for us but now we need to switch to a long mode GDT.&lt;&#x2F;p&gt;
&lt;p&gt;A GDT always starts with a 0-entry and contains an arbitrary number of segment entries afterwards. A 64-bit entry has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)&lt;&#x2F;th&gt;&lt;th&gt;Name&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-41&lt;&#x2F;td&gt;&lt;td&gt;ignored&lt;&#x2F;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;42&lt;&#x2F;td&gt;&lt;td&gt;conforming&lt;&#x2F;td&gt;&lt;td&gt;the current privilege level can be higher than the specified level for code segments (else it must match exactly)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;43&lt;&#x2F;td&gt;&lt;td&gt;executable&lt;&#x2F;td&gt;&lt;td&gt;if set, it‚Äôs a code segment, else it‚Äôs a data segment&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;44&lt;&#x2F;td&gt;&lt;td&gt;descriptor type&lt;&#x2F;td&gt;&lt;td&gt;should be 1 for code and data segments&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;45-46&lt;&#x2F;td&gt;&lt;td&gt;privilege&lt;&#x2F;td&gt;&lt;td&gt;the &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Security#Rings&quot;&gt;ring level&lt;&#x2F;a&gt;: 0 for kernel, 3 for user&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;47&lt;&#x2F;td&gt;&lt;td&gt;present&lt;&#x2F;td&gt;&lt;td&gt;must be 1 for valid selectors&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;48-52&lt;&#x2F;td&gt;&lt;td&gt;ignored&lt;&#x2F;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;53&lt;&#x2F;td&gt;&lt;td&gt;64-bit&lt;&#x2F;td&gt;&lt;td&gt;should be set for 64-bit code segments&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;54&lt;&#x2F;td&gt;&lt;td&gt;32-bit&lt;&#x2F;td&gt;&lt;td&gt;must be 0 for 64-bit segments&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;55-63&lt;&#x2F;td&gt;&lt;td&gt;ignored&lt;&#x2F;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;We need one code segment, a data segment is not necessary in 64-bit mode. Code segments have the following bits set: &lt;em&gt;descriptor type&lt;&#x2F;em&gt;, &lt;em&gt;present&lt;&#x2F;em&gt;, &lt;em&gt;executable&lt;&#x2F;em&gt; and the &lt;em&gt;64-bit&lt;&#x2F;em&gt; flag. Translated to assembly the long mode GDT looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;section .rodata
&lt;&#x2F;span&gt;&lt;span&gt;gdt64:
&lt;&#x2F;span&gt;&lt;span&gt;    dq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
&lt;&#x2F;span&gt;&lt;span&gt;    dq (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We chose the &lt;code&gt;.rodata&lt;&#x2F;code&gt; section here because it‚Äôs initialized read-only data. The &lt;code&gt;dq&lt;&#x2F;code&gt; command stands for &lt;code&gt;define quad&lt;&#x2F;code&gt; and outputs a 64-bit constant (similar to &lt;code&gt;dw&lt;&#x2F;code&gt; and &lt;code&gt;dd&lt;&#x2F;code&gt;). And the &lt;code&gt;(1&amp;lt;&amp;lt;43)&lt;&#x2F;code&gt; is a bit shift that sets bit 43.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;üîó&lt;&#x2F;a&gt;Loading the GDT&lt;&#x2F;h3&gt;
&lt;p&gt;To load our new 64-bit GDT, we have to tell the CPU its address and length. We do this by passing the memory location of a special pointer structure to the &lt;code&gt;lgdt&lt;&#x2F;code&gt; (load GDT) instruction. The pointer structure looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;gdt64:
&lt;&#x2F;span&gt;&lt;span&gt;    dq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
&lt;&#x2F;span&gt;&lt;span&gt;    dq (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2F;span&gt;&lt;span&gt;.pointer:
&lt;&#x2F;span&gt;&lt;span&gt;    dw $ - gdt64 - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    dq gdt64
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first 2 bytes specify the (GDT length - 1). The &lt;code&gt;$&lt;&#x2F;code&gt; is a special symbol that is replaced with the current address (it‚Äôs equal to &lt;code&gt;.pointer&lt;&#x2F;code&gt; in our case). The following 8 bytes specify the GDT address. Labels that start with a point (such as &lt;code&gt;.pointer&lt;&#x2F;code&gt;) are sub-labels of the last label without point. To access them, they must be prefixed with the parent label (e.g., &lt;code&gt;gdt64.pointer&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Now we can load the GDT in &lt;code&gt;start&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span&gt;enable_paging
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; load the 64-bit GDT
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;lgdt &lt;&#x2F;span&gt;&lt;span&gt;[gdt64.pointer]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OK` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When you still see the green &lt;code&gt;OK&lt;&#x2F;code&gt;, everything went fine and the new GDT is loaded. But we still can‚Äôt execute 64-bit code: The code selector register &lt;code&gt;cs&lt;&#x2F;code&gt; still has the values from the old GDT. To update it, we need to load it with the GDT offset (in bytes) of the desired segment. In our case the code segment starts at byte 8 of the GDT, but we don‚Äôt want to hardcode that 8 (in case we modify our GDT later). Instead, we add a &lt;code&gt;.code&lt;&#x2F;code&gt; label to our GDT, that calculates the offset directly from the GDT:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;section .rodata
&lt;&#x2F;span&gt;&lt;span&gt;gdt64:
&lt;&#x2F;span&gt;&lt;span&gt;    dq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
&lt;&#x2F;span&gt;&lt;span&gt;.code: equ $ - gdt64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; new
&lt;&#x2F;span&gt;&lt;span&gt;    dq (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2F;span&gt;&lt;span&gt;) | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2F;span&gt;&lt;span&gt;.pointer:
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can‚Äôt just use a normal label here, since we need the table &lt;em&gt;offset&lt;&#x2F;em&gt;. We calculate this offset using the current address &lt;code&gt;$&lt;&#x2F;code&gt; and set the label to this value using &lt;a href=&quot;https:&#x2F;&#x2F;www.nasm.us&#x2F;doc&#x2F;nasmdoc3.html#section-3.2.4&quot;&gt;equ&lt;&#x2F;a&gt;. Now we can use &lt;code&gt;gdt64.code&lt;&#x2F;code&gt; instead of 8 and this label will still work if we modify the GDT.&lt;&#x2F;p&gt;
&lt;p&gt;In order to finally enter the true 64-bit mode, we need to load &lt;code&gt;cs&lt;&#x2F;code&gt; with &lt;code&gt;gdt64.code&lt;&#x2F;code&gt;. But we can‚Äôt do it through &lt;code&gt;mov&lt;&#x2F;code&gt;. The only way to reload the code selector is a &lt;em&gt;far jump&lt;&#x2F;em&gt; or a &lt;em&gt;far return&lt;&#x2F;em&gt;. These instructions work like a normal jump&#x2F;return but change the code selector. We use a far jump to a long mode label:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;global start
&lt;&#x2F;span&gt;&lt;span&gt;extern long_mode_start
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;lgdt &lt;&#x2F;span&gt;&lt;span&gt;[gdt64.pointer]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span&gt;gdt64.code:long_mode_start
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The actual &lt;code&gt;long_mode_start&lt;&#x2F;code&gt; label is defined as &lt;code&gt;extern&lt;&#x2F;code&gt;, so it‚Äôs part of another file. The &lt;code&gt;jmp gdt64.code:long_mode_start&lt;&#x2F;code&gt; is the mentioned far jump.&lt;&#x2F;p&gt;
&lt;p&gt;I put the 64-bit code into a new file to separate it from the 32-bit code, thereby we can‚Äôt call the (now invalid) 32-bit code accidentally. The new file (I named it &lt;code&gt;long_mode_init.asm&lt;&#x2F;code&gt;) looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;global long_mode_start
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .text
&lt;&#x2F;span&gt;&lt;span&gt;bits 64
&lt;&#x2F;span&gt;&lt;span&gt;long_mode_start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OKAY` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;rax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f592f412f4b2f4f
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;qword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;], rax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You should see a green &lt;code&gt;OKAY&lt;&#x2F;code&gt; on the screen. Some notes on this last step:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;As the CPU expects 64-bit instructions now, we use &lt;code&gt;bits 64&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;We can now use the extended registers. Instead of the 32-bit &lt;code&gt;eax&lt;&#x2F;code&gt;, &lt;code&gt;ebx&lt;&#x2F;code&gt;, etc. we now have the 64-bit &lt;code&gt;rax&lt;&#x2F;code&gt;, &lt;code&gt;rbx&lt;&#x2F;code&gt;, ‚Ä¶&lt;&#x2F;li&gt;
&lt;li&gt;and we can write these 64-bit registers directly to memory using &lt;code&gt;mov qword&lt;&#x2F;code&gt; (quad word)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;Congratulations&lt;&#x2F;em&gt;! You have successfully wrestled through this CPU configuration and compatibility mode mess :).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;one-last-thing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#one-last-thing&quot; aria-label=&quot;Anchor link for: one-last-thing&quot;&gt;üîó&lt;&#x2F;a&gt;One Last Thing&lt;&#x2F;h4&gt;
&lt;p&gt;Above, we reloaded the code segment register &lt;code&gt;cs&lt;&#x2F;code&gt; with the new GDT offset. However, the data segment registers &lt;code&gt;ss&lt;&#x2F;code&gt;, &lt;code&gt;ds&lt;&#x2F;code&gt;, &lt;code&gt;es&lt;&#x2F;code&gt;, &lt;code&gt;fs&lt;&#x2F;code&gt;, and &lt;code&gt;gs&lt;&#x2F;code&gt; still contain the data segment offsets of the old GDT. This isn‚Äôt necessarily bad, since they‚Äôre ignored by almost all instructions in 64-bit mode. However, there are a few instructions that expect a valid data segment descriptor &lt;em&gt;or the null descriptor&lt;&#x2F;em&gt; in those registers. An example is the the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;#the-iretq-instruction&quot;&gt;iretq&lt;&#x2F;a&gt; instruction that we‚Äôll need in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;returning-from-exceptions&#x2F;&quot;&gt;&lt;em&gt;Returning from Exceptions&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; post.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid future problems, we reload all data segment registers with null:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;long_mode_start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; load 0 into all data segment registers
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ax, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ss, ax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;ds, ax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;es, ax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;fs, ax
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;gs, ax
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OKAY` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;It‚Äôs time to finally leave assembly behind and switch to &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt;. Rust is a systems language without garbage collections that guarantees memory safety. Through a real type system and many abstractions it feels like a high-level language but can still be low-level enough for OS development. The &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;set-up-rust&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; describes the Rust setup.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;hardware_lookup&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;In the x86 architecture, the page tables are &lt;em&gt;hardware walked&lt;&#x2F;em&gt;, so the CPU will look at the table on its own when it needs a translation. Other architectures, for example MIPS, just throw an exception and let the OS translate the virtual address.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;virtual_physical_translation_source&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Image source: &lt;a href=&quot;https:&#x2F;&#x2F;commons.wikimedia.org&#x2F;wiki&#x2F;File:X86_Paging_64bit.svg&quot;&gt;Wikipedia&lt;&#x2F;a&gt;, with modified font size, page table naming, and removed sign extended bits. The modified file is licensed under the Creative Commons Attribution-Share Alike 3.0 Unported license.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;page_table_alignment&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;Page tables need to be page-aligned as the bits 0-11 are used for flags. By putting these tables at the beginning of &lt;code&gt;.bss&lt;&#x2F;code&gt;, the linker can just page align the whole section and we don‚Äôt have unused padding bytes in between.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
            <item>
                <title>A minimal Multiboot Kernel</title>
                <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/multiboot-kernel/</link>
                <guid>https://os.phil-opp.com/multiboot-kernel/</guid>
                <description>&lt;p&gt;This post explains how to create a minimal x86 operating system kernel using the Multiboot standard. In fact, it will just boot and print &lt;code&gt;OK&lt;&#x2F;code&gt; to the screen. In subsequent blog posts we will extend it using the &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; programming language.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;I tried to explain everything in detail and to keep the code as simple as possible. If you have any questions, suggestions or other issues, please leave a comment or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&quot;&gt;create an issue&lt;&#x2F;a&gt; on Github. The source code is available in a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;tree&#x2F;first_edition_post_1&#x2F;src&#x2F;arch&#x2F;x86_64&quot;&gt;repository&lt;&#x2F;a&gt;, too.&lt;&#x2F;p&gt;
&lt;p&gt;Note that this tutorial is written mainly for Linux. For some known problems on OS X see the comment section and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phil-opp&#x2F;blog_os&#x2F;issues&#x2F;55&quot;&gt;this issue&lt;&#x2F;a&gt;. If you want to use a virtual Linux machine, you can find instructions and a Vagrantfile in Ashley Willams‚Äôs &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ashleygwilliams&#x2F;x86-kernel&quot;&gt;x86-kernel repository&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;üîó&lt;&#x2F;a&gt;Overview&lt;&#x2F;h2&gt;
&lt;p&gt;When you turn on a computer, it loads the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;BIOS&quot;&gt;BIOS&lt;&#x2F;a&gt; from some special flash memory. The BIOS runs self test and initialization routines of the hardware, then it looks for bootable devices. If it finds one, the control is transferred to its &lt;em&gt;bootloader&lt;&#x2F;em&gt;, which is a small portion of executable code stored at the device‚Äôs beginning. The bootloader has to determine the location of the kernel image on the device and load it into memory. It also needs to switch the CPU to the so-called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protected_mode&quot;&gt;protected mode&lt;&#x2F;a&gt; because x86 CPUs start in the very limited &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Real_Mode&quot;&gt;real mode&lt;&#x2F;a&gt; by default (to be compatible to programs from 1978).&lt;&#x2F;p&gt;
&lt;p&gt;We won‚Äôt write a bootloader because that would be a complex project on its own (if you really want to do it, check out &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Rolling_Your_Own_Bootloader&quot;&gt;&lt;em&gt;Rolling Your Own Bootloader&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;). Instead we will use one of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Comparison_of_boot_loaders&quot;&gt;many well-tested bootloaders&lt;&#x2F;a&gt; out there to boot our kernel from a CD-ROM. But which one?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;multiboot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multiboot&quot; aria-label=&quot;Anchor link for: multiboot&quot;&gt;üîó&lt;&#x2F;a&gt;Multiboot&lt;&#x2F;h2&gt;
&lt;p&gt;Fortunately there is a bootloader standard: the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiboot_Specification&quot;&gt;Multiboot Specification&lt;&#x2F;a&gt;. Our kernel just needs to indicate that it supports Multiboot and every Multiboot-compliant bootloader can boot it. We will use the Multiboot 2 specification (&lt;a href=&quot;https:&#x2F;&#x2F;nongnu.askapache.com&#x2F;grub&#x2F;phcoder&#x2F;multiboot.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;) together with the well-known &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;GRUB_2&quot;&gt;GRUB 2&lt;&#x2F;a&gt; bootloader.&lt;&#x2F;p&gt;
&lt;p&gt;To indicate our Multiboot 2 support to the bootloader, our kernel must start with a &lt;em&gt;Multiboot Header&lt;&#x2F;em&gt;, which has the following format:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field&lt;&#x2F;th&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Value&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;magic number&lt;&#x2F;td&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0xE85250D6&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;architecture&lt;&#x2F;td&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;0&lt;&#x2F;code&gt; for i386, &lt;code&gt;4&lt;&#x2F;code&gt; for MIPS&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;header length&lt;&#x2F;td&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;total header size, including tags&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;checksum&lt;&#x2F;td&gt;&lt;td&gt;u32&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;-(magic + architecture + header_length)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;tags&lt;&#x2F;td&gt;&lt;td&gt;variable&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;end tag&lt;&#x2F;td&gt;&lt;td&gt;(u16, u16, u32)&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;(0, 0, 8)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Converted to a x86 assembly file it looks like this (Intel syntax):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;section .multiboot_header
&lt;&#x2F;span&gt;&lt;span&gt;header_start:
&lt;&#x2F;span&gt;&lt;span&gt;    dd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xe85250d6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                ; magic number (multiboot 2)
&lt;&#x2F;span&gt;&lt;span&gt;    dd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                         ; architecture 0 (protected mode i386)
&lt;&#x2F;span&gt;&lt;span&gt;    dd header_end - header_start&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; header length
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; checksum
&lt;&#x2F;span&gt;&lt;span&gt;    dd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x100000000 &lt;&#x2F;span&gt;&lt;span&gt;- (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xe85250d6 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;+ (header_end - header_start))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; insert optional multiboot tags here
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; required end tag
&lt;&#x2F;span&gt;&lt;span&gt;    dw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; type
&lt;&#x2F;span&gt;&lt;span&gt;    dw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; flags
&lt;&#x2F;span&gt;&lt;span&gt;    dd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; size
&lt;&#x2F;span&gt;&lt;span&gt;header_end:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you don‚Äôt know x86 assembly, here is some quick guide:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the header will be written to a section named &lt;code&gt;.multiboot_header&lt;&#x2F;code&gt; (we need this later)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;header_start&lt;&#x2F;code&gt; and &lt;code&gt;header_end&lt;&#x2F;code&gt; are &lt;em&gt;labels&lt;&#x2F;em&gt; that mark a memory location, we use them to calculate the header length easily&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;&#x2F;code&gt; stands for &lt;code&gt;define double&lt;&#x2F;code&gt; (32bit) and &lt;code&gt;dw&lt;&#x2F;code&gt; stands for &lt;code&gt;define word&lt;&#x2F;code&gt; (16bit). They just output the specified 32bit&#x2F;16bit constant.&lt;&#x2F;li&gt;
&lt;li&gt;the additional &lt;code&gt;0x100000000&lt;&#x2F;code&gt; in the checksum calculation is a small hack&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-checksum_hack&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; to avoid a compiler warning&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We can already &lt;em&gt;assemble&lt;&#x2F;em&gt; this file (which I called &lt;code&gt;multiboot_header.asm&lt;&#x2F;code&gt;) using &lt;code&gt;nasm&lt;&#x2F;code&gt;. It produces a flat binary by default, so the resulting file just contains our 24 bytes (in little endian if you work on a x86 machine):&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; nasm multiboot_header.asm
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; hexdump -x multiboot_header
&lt;&#x2F;span&gt;&lt;span&gt;0000000    50d6    e852    0000    0000    0018    0000    af12    17ad
&lt;&#x2F;span&gt;&lt;span&gt;0000010    0000    0000    0008    0000
&lt;&#x2F;span&gt;&lt;span&gt;0000018
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-boot-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-boot-code&quot; aria-label=&quot;Anchor link for: the-boot-code&quot;&gt;üîó&lt;&#x2F;a&gt;The Boot Code&lt;&#x2F;h2&gt;
&lt;p&gt;To boot our kernel, we must add some code that the bootloader can call. Let‚Äôs create a file named &lt;code&gt;boot.asm&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nasm&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-nasm &quot;&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span&gt;global start
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;section .text
&lt;&#x2F;span&gt;&lt;span&gt;bits 32
&lt;&#x2F;span&gt;&lt;span&gt;start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; print `OK` to screen
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span&gt;dword [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f4b2f4f
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are some new commands:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;global&lt;&#x2F;code&gt; exports a label (makes it public). As &lt;code&gt;start&lt;&#x2F;code&gt; will be the entry point of our kernel, it needs to be public.&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;code&gt;.text&lt;&#x2F;code&gt; section is the default section for executable code&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;bits 32&lt;&#x2F;code&gt; specifies that the following lines are 32-bit instructions. It‚Äôs needed because the CPU is still in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Protected_mode&quot;&gt;Protected mode&lt;&#x2F;a&gt; when GRUB starts our kernel. When we switch to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long_mode&quot;&gt;Long mode&lt;&#x2F;a&gt; in the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; we can use &lt;code&gt;bits 64&lt;&#x2F;code&gt; (64-bit instructions).&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;code&gt;mov dword&lt;&#x2F;code&gt; instruction moves the 32bit constant &lt;code&gt;0x2f4b2f4f&lt;&#x2F;code&gt; to the memory at address &lt;code&gt;b8000&lt;&#x2F;code&gt; (it prints &lt;code&gt;OK&lt;&#x2F;code&gt; to the screen, an explanation follows in the next posts)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;hlt&lt;&#x2F;code&gt; is the halt instruction and causes the CPU to stop&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Through assembling, viewing and disassembling we can see the CPU &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Opcode&quot;&gt;Opcodes&lt;&#x2F;a&gt; in action:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; nasm boot.asm
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; hexdump -x boot
&lt;&#x2F;span&gt;&lt;span&gt;0000000    05c7    8000    000b    2f4b    2f4f    00f4
&lt;&#x2F;span&gt;&lt;span&gt;000000b
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; ndisasm -b 32 boot
&lt;&#x2F;span&gt;&lt;span&gt;00000000  C70500800B004B2F  mov dword [dword 0xb8000],0x2f4b2f4f
&lt;&#x2F;span&gt;&lt;span&gt;         -4F2F
&lt;&#x2F;span&gt;&lt;span&gt;0000000A  F4                hlt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;building-the-executable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-executable&quot; aria-label=&quot;Anchor link for: building-the-executable&quot;&gt;üîó&lt;&#x2F;a&gt;Building the Executable&lt;&#x2F;h2&gt;
&lt;p&gt;To boot our executable later through GRUB, it should be an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Executable_and_Linkable_Format&quot;&gt;ELF&lt;&#x2F;a&gt; executable. So we want &lt;code&gt;nasm&lt;&#x2F;code&gt; to create ELF &lt;a href=&quot;https:&#x2F;&#x2F;wiki.osdev.org&#x2F;Object_Files&quot;&gt;object files&lt;&#x2F;a&gt; instead of plain binaries. To do that, we simply pass the &lt;code&gt;‚Äëf¬†elf64&lt;&#x2F;code&gt; argument to it.&lt;&#x2F;p&gt;
&lt;p&gt;To create the ELF &lt;em&gt;executable&lt;&#x2F;em&gt;, we need to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Linker_(computing)&quot;&gt;link&lt;&#x2F;a&gt; the object files together. We use a custom &lt;a href=&quot;https:&#x2F;&#x2F;sourceware.org&#x2F;binutils&#x2F;docs&#x2F;ld&#x2F;Scripts.html&quot;&gt;linker script&lt;&#x2F;a&gt; named &lt;code&gt;linker.ld&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ld&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-ld &quot;&gt;&lt;code class=&quot;language-ld&quot; data-lang=&quot;ld&quot;&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ENTRY&lt;&#x2F;span&gt;&lt;span&gt;(start)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;SECTIONS&lt;&#x2F;span&gt;&lt;span&gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    . = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1M&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .boot :
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;* ensure that the multiboot header is at the beginning *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;        *(.multiboot_header)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    .text :
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        *(.text)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let‚Äôs translate it:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start&lt;&#x2F;code&gt; is the entry point, the bootloader will jump to it after loading the kernel&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;. = 1M;&lt;&#x2F;code&gt; sets the load address of the first section to 1 MiB, which is a conventional place to load a kernel&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#Linker 1M&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the executable will have two sections: &lt;code&gt;.boot&lt;&#x2F;code&gt; at the beginning and &lt;code&gt;.text&lt;&#x2F;code&gt; afterwards&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;code&gt;.text&lt;&#x2F;code&gt; output section contains all input sections named &lt;code&gt;.text&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Sections named &lt;code&gt;.multiboot_header&lt;&#x2F;code&gt; are added to the first output section (&lt;code&gt;.boot&lt;&#x2F;code&gt;) to ensure they are at the beginning of the executable. This is necessary because GRUB expects to find the Multiboot header very early in the file.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So let‚Äôs create the ELF object files and link them using our new linker script:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; nasm -f elf64 multiboot_header.asm
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; nasm -f elf64 boot.asm
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It‚Äôs important to pass the &lt;code&gt;-n&lt;&#x2F;code&gt; (or &lt;code&gt;--nmagic&lt;&#x2F;code&gt;) flag to the linker, which disables the automatic section alignment in the executable. Otherwise the linker may page align the &lt;code&gt;.boot&lt;&#x2F;code&gt; section in the executable file. If that happens, GRUB isn‚Äôt able to find the Multiboot header because it isn‚Äôt at the beginning anymore.&lt;&#x2F;p&gt;
&lt;p&gt;We can use &lt;code&gt;objdump&lt;&#x2F;code&gt; to print the sections of the generated executable and verify that the &lt;code&gt;.boot&lt;&#x2F;code&gt; section has a low file offset:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt; objdump -h kernel.bin
&lt;&#x2F;span&gt;&lt;span&gt;kernel.bin:     file format elf64-x86-64
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Sections:
&lt;&#x2F;span&gt;&lt;span&gt;Idx Name      Size      VMA               LMA               File off  Algn
&lt;&#x2F;span&gt;&lt;span&gt;  0 .boot     00000018  0000000000100000  0000000000100000  00000080  2**0
&lt;&#x2F;span&gt;&lt;span&gt;              CONTENTS, ALLOC, LOAD, READONLY, DATA
&lt;&#x2F;span&gt;&lt;span&gt;  1 .text     0000000b  0000000000100020  0000000000100020  000000a0  2**4
&lt;&#x2F;span&gt;&lt;span&gt;              CONTENTS, ALLOC, LOAD, READONLY, CODE
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;&#x2F;em&gt;: The &lt;code&gt;ld&lt;&#x2F;code&gt; and &lt;code&gt;objdump&lt;&#x2F;code&gt; commands are platform specific. If you‚Äôre &lt;em&gt;not&lt;&#x2F;em&gt; working on x86_64 architecture, you will need to &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cross-compile-binutils&#x2F;&quot;&gt;cross compile binutils&lt;&#x2F;a&gt;. Then use &lt;code&gt;x86_64‚Äëelf‚Äëld&lt;&#x2F;code&gt; and &lt;code&gt;x86_64‚Äëelf‚Äëobjdump&lt;&#x2F;code&gt; instead of &lt;code&gt;ld&lt;&#x2F;code&gt; and &lt;code&gt;objdump&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;creating-the-iso&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-the-iso&quot; aria-label=&quot;Anchor link for: creating-the-iso&quot;&gt;üîó&lt;&#x2F;a&gt;Creating the ISO&lt;&#x2F;h2&gt;
&lt;p&gt;All PC BIOSes know how to boot from a CD-ROM, so we want to create a bootable CD-ROM image, containing our kernel and the GRUB bootloader‚Äôs files, in a single file called an &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ISO_image&quot;&gt;ISO&lt;&#x2F;a&gt;. Make the following directory structure and copy the &lt;code&gt;kernel.bin&lt;&#x2F;code&gt; to the right place:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;isofiles
&lt;&#x2F;span&gt;&lt;span&gt;‚îî‚îÄ‚îÄ boot
&lt;&#x2F;span&gt;&lt;span&gt;    ‚îú‚îÄ‚îÄ grub
&lt;&#x2F;span&gt;&lt;span&gt;    ‚îÇ   ‚îî‚îÄ‚îÄ grub.cfg
&lt;&#x2F;span&gt;&lt;span&gt;    ‚îî‚îÄ‚îÄ kernel.bin
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;grub.cfg&lt;&#x2F;code&gt; specifies the file name of our kernel and its Multiboot 2 compliance. It looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;set timeout=0
&lt;&#x2F;span&gt;&lt;span&gt;set default=0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;menuentry &amp;quot;my os&amp;quot; {
&lt;&#x2F;span&gt;&lt;span&gt;    multiboot2 &#x2F;boot&#x2F;kernel.bin
&lt;&#x2F;span&gt;&lt;span&gt;    boot
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can create a bootable image using the command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;grub-mkrescue -o os.iso isofiles
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;&#x2F;em&gt;: &lt;code&gt;grub-mkrescue&lt;&#x2F;code&gt; causes problems on some platforms. If it does not work for you, try the following steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;try to run it with &lt;code&gt;--verbose&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;make sure &lt;code&gt;xorriso&lt;&#x2F;code&gt; is installed (&lt;code&gt;xorriso&lt;&#x2F;code&gt; or &lt;code&gt;libisoburn&lt;&#x2F;code&gt; package)&lt;&#x2F;li&gt;
&lt;li&gt;If you‚Äôre using an EFI-system, &lt;code&gt;grub-mkrescue&lt;&#x2F;code&gt; tries to create an EFI image by default. You can either pass &lt;code&gt;-d &#x2F;usr&#x2F;lib&#x2F;grub&#x2F;i386-pc&lt;&#x2F;code&gt; to avoid EFI or install the &lt;code&gt;mtools&lt;&#x2F;code&gt; package to get a working EFI image&lt;&#x2F;li&gt;
&lt;li&gt;on some system the command is named &lt;code&gt;grub2-mkrescue&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;booting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#booting&quot; aria-label=&quot;Anchor link for: booting&quot;&gt;üîó&lt;&#x2F;a&gt;Booting&lt;&#x2F;h2&gt;
&lt;p&gt;Now it‚Äôs time to boot our OS. We will use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;QEMU&quot;&gt;QEMU&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;qemu-system-x86_64 -cdrom os.iso
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;multiboot-kernel&#x2F;qemu-ok.png&quot; alt=&quot;qemu output&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Notice the green &lt;code&gt;OK&lt;&#x2F;code&gt; in the upper left corner. If it does not work for you, take a look at the comment section.&lt;&#x2F;p&gt;
&lt;p&gt;Let‚Äôs summarize what happens:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;the BIOS loads the bootloader (GRUB) from the virtual CD-ROM (the ISO)&lt;&#x2F;li&gt;
&lt;li&gt;the bootloader reads the kernel executable and finds the Multiboot header&lt;&#x2F;li&gt;
&lt;li&gt;it copies the &lt;code&gt;.boot&lt;&#x2F;code&gt; and &lt;code&gt;.text&lt;&#x2F;code&gt; sections to memory (to addresses &lt;code&gt;0x100000&lt;&#x2F;code&gt; and &lt;code&gt;0x100020&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;it jumps to the entry point (&lt;code&gt;0x100020&lt;&#x2F;code&gt;, you can obtain it through &lt;code&gt;objdump -f&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;our kernel prints the green &lt;code&gt;OK&lt;&#x2F;code&gt; and stops the CPU&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;You can test it on real hardware, too. Just burn the ISO to a disk or USB stick and boot from it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;build-automation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#build-automation&quot; aria-label=&quot;Anchor link for: build-automation&quot;&gt;üîó&lt;&#x2F;a&gt;Build Automation&lt;&#x2F;h2&gt;
&lt;p&gt;Right now we need to execute 4 commands in the right order every time we change a file. That‚Äôs bad. So let‚Äôs automate the build using a &lt;code&gt;Makefile&lt;&#x2F;code&gt;. But first we should create some clean directory structure for our source files to separate the architecture specific files:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot;&gt;&lt;code&gt;&lt;span&gt;‚Ä¶
&lt;&#x2F;span&gt;&lt;span&gt;‚îú‚îÄ‚îÄ Makefile
&lt;&#x2F;span&gt;&lt;span&gt;‚îî‚îÄ‚îÄ src
&lt;&#x2F;span&gt;&lt;span&gt;    ‚îî‚îÄ‚îÄ arch
&lt;&#x2F;span&gt;&lt;span&gt;        ‚îî‚îÄ‚îÄ x86_64
&lt;&#x2F;span&gt;&lt;span&gt;            ‚îú‚îÄ‚îÄ multiboot_header.asm
&lt;&#x2F;span&gt;&lt;span&gt;            ‚îú‚îÄ‚îÄ boot.asm
&lt;&#x2F;span&gt;&lt;span&gt;            ‚îú‚îÄ‚îÄ linker.ld
&lt;&#x2F;span&gt;&lt;span&gt;            ‚îî‚îÄ‚îÄ grub.cfg
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Makefile looks like this (indented with tabs instead of spaces):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Makefile&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-Makefile &quot;&gt;&lt;code class=&quot;language-Makefile&quot; data-lang=&quot;Makefile&quot;&gt;&lt;span&gt;arch ?= &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;x86_64&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;kernel := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;build&#x2F;kernel-&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.bin&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;iso := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;build&#x2F;os-&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.iso&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;linker_script := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;linker.ld&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;grub_cfg := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;grub.cfg&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assembly_source_files := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;wildcard &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assembly_object_files := &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;patsubst &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm, \
&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;	build&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.o, &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_source_files&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;))&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;.PHONY: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;all clean run iso&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;all: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;clean:
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;rm -r build
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;run: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;iso&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;qemu-system-x86_64 -cdrom &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;iso&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;iso: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;iso&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;iso&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;grub_cfg&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;mkdir -p build&#x2F;isofiles&#x2F;boot&#x2F;grub
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;cp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; build&#x2F;isofiles&#x2F;boot&#x2F;kernel.bin
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;cp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;grub_cfg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; build&#x2F;isofiles&#x2F;boot&#x2F;grub
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;grub-mkrescue -o &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;iso&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; build&#x2F;isofiles &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &#x2F;dev&#x2F;null
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;rm -r build&#x2F;isofiles
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;ld -n -T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;linker_script&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt; -o &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span&gt;assembly_object_files&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# compile assembly files
&lt;&#x2F;span&gt;&lt;span&gt;build&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;%.o: &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2F;arch&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;mkdir -p &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span&gt;shell dirname $@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2F;span&gt;&lt;span&gt;nasm -felf64 $&amp;lt; -o $@
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Some comments (see the [Makefile tutorial] if you don‚Äôt know &lt;code&gt;make&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;$(wildcard src&#x2F;arch&#x2F;$(arch)&#x2F;*.asm)&lt;&#x2F;code&gt; chooses all assembly files in the src&#x2F;arch&#x2F;$(arch)` directory, so you don‚Äôt have to update the Makefile when you add a file&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;code&gt;patsubst&lt;&#x2F;code&gt; operation for &lt;code&gt;assembly_object_files&lt;&#x2F;code&gt; just translates &lt;code&gt;src&#x2F;arch&#x2F;$(arch)&#x2F;XYZ.asm&lt;&#x2F;code&gt; to &lt;code&gt;build&#x2F;arch&#x2F;$(arch)&#x2F;XYZ.o&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;the &lt;code&gt;$&amp;lt;&lt;&#x2F;code&gt; and &lt;code&gt;$@&lt;&#x2F;code&gt; in the assembly target are &lt;a href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;make&#x2F;manual&#x2F;html_node&#x2F;Automatic-Variables.html&quot;&gt;automatic variables&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;if you‚Äôre using &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;cross-compile-binutils&#x2F;&quot;&gt;cross-compiled binutils&lt;&#x2F;a&gt; just replace &lt;code&gt;ld&lt;&#x2F;code&gt; with &lt;code&gt;x86_64‚Äëelf‚Äëld&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Now we can invoke &lt;code&gt;make&lt;&#x2F;code&gt; and all updated assembly files are compiled and linked. The &lt;code&gt;make iso&lt;&#x2F;code&gt; command also creates the ISO image and &lt;code&gt;make run&lt;&#x2F;code&gt; will additionally start QEMU.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;üîó&lt;&#x2F;a&gt;What‚Äôs next?&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;os.phil-opp.com&#x2F;entering-longmode&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; we will create a page table and do some CPU configuration to switch to the 64-bit &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Long_mode&quot;&gt;long mode&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;üîó&lt;&#x2F;a&gt;Footnotes&lt;&#x2F;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-checksum_hack&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;The formula from the table, &lt;code&gt;-(magic + architecture + header_length)&lt;&#x2F;code&gt;, creates a negative value that doesn‚Äôt fit into 32bit. By subtracting from &lt;code&gt;0x100000000&lt;&#x2F;code&gt; (= 2^(32)) instead, we keep the value positive without changing its truncated value. Without the additional sign bit(s) the result fits into 32bit and the compiler is happy :).&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;Linker 1M&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;We don‚Äôt want to load the kernel to e.g. &lt;code&gt;0x0&lt;&#x2F;code&gt; because there are many special memory areas below the 1MB mark (for example the so-called VGA buffer at &lt;code&gt;0xb8000&lt;&#x2F;code&gt;, that we use to print &lt;code&gt;OK&lt;&#x2F;code&gt; to the screen).&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
            </item>
        
    </channel>
</rss>
