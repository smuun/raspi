<!doctype html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents …">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../js/edition-2/main.js"></script>

    <title>Heap Allocation | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="../index.html" title="All Posts">« All Posts</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="">
        <h2>Table of Contents</h2>
    <ol>
        <li>
            <a href="index.html#local-and-static-variables">Local and Static Variables</a>
            <ol>
                <li>
                    <a href="index.html#local-variables">Local Variables</a>
                </li><li>
                    <a href="index.html#static-variables">Static Variables</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#dynamic-memory">Dynamic Memory</a>
            <ol>
                <li>
                    <a href="index.html#common-errors">Common Errors</a>
                </li><li>
                    <a href="index.html#allocations-in-rust">Allocations in Rust</a>
                </li><li>
                    <a href="index.html#use-cases">Use Cases</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#the-allocator-interface">The Allocator Interface</a>
            <ol>
                <li>
                    <a href="index.html#the-globalalloc-trait">The GlobalAlloc Trait</a>
                </li><li>
                    <a href="index.html#a-dummyallocator">A DummyAllocator</a>
                </li><li>
                    <a href="index.html#the-global-allocator-attribute">The #[global_allocator] Attribute</a>
                </li><li>
                    <a href="index.html#the-alloc-error-handler-attribute">The #[alloc_error_handler] Attribute</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#creating-a-kernel-heap">Creating a Kernel Heap</a>
            
        </li><li>
            <a href="index.html#using-an-allocator-crate">Using an Allocator Crate</a>
            
        </li><li>
            <a href="index.html#adding-a-test">Adding a Test</a>
            
        </li><li>
            <a href="index.html#summary">Summary</a>
            
        </li><li>
            <a href="index.html#what-s-next">What’s next?</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">Comments</a></li>
    </ol>
</aside>

            <main>
    <div class="">
    <h1>Heap Allocation</h1>
    <time datetime="2019-06-26" class="post-date">
        Jun 26, 2019
        
    </time>
    </div>

    

    <div class="">
    <p>This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post, all the allocation and collection types of the built-in <code>alloc</code> crate will be available to our kernel.</p>
<span id="continue-reading"></span>
<p>This blog is openly developed on <a href="https://github.com/phil-opp/blog_os">GitHub</a>. If you have any problems or questions, please open an issue there. You can also leave comments <a href="index.html#comments">at the bottom</a>. The complete source code for this post can be found in the <a href="https://github.com/phil-opp/blog_os/tree/post-10"><code>post-10</code></a> branch.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>Table of Contents</b></summary>
        <ul>
            <li>
                <a href="index.html#local-and-static-variables">Local and Static Variables</a>
                <ul>
                    <li>
                        <a href="index.html#local-variables">Local Variables</a>
                    </li><li>
                        <a href="index.html#static-variables">Static Variables</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#dynamic-memory">Dynamic Memory</a>
                <ul>
                    <li>
                        <a href="index.html#common-errors">Common Errors</a>
                    </li><li>
                        <a href="index.html#allocations-in-rust">Allocations in Rust</a>
                    </li><li>
                        <a href="index.html#use-cases">Use Cases</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#the-allocator-interface">The Allocator Interface</a>
                <ul>
                    <li>
                        <a href="index.html#the-globalalloc-trait">The GlobalAlloc Trait</a>
                    </li><li>
                        <a href="index.html#a-dummyallocator">A DummyAllocator</a>
                    </li><li>
                        <a href="index.html#the-global-allocator-attribute">The #[global_allocator] Attribute</a>
                    </li><li>
                        <a href="index.html#the-alloc-error-handler-attribute">The #[alloc_error_handler] Attribute</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#creating-a-kernel-heap">Creating a Kernel Heap</a>
                
            </li><li>
                <a href="index.html#using-an-allocator-crate">Using an Allocator Crate</a>
                
            </li><li>
                <a href="index.html#adding-a-test">Adding a Test</a>
                
            </li><li>
                <a href="index.html#summary">Summary</a>
                
            </li><li>
                <a href="index.html#what-s-next">What’s next?</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">Comments</a></li>
        </ul>
    </details>

<h2 id="local-and-static-variables"><a class="zola-anchor" href="index.html#local-and-static-variables" aria-label="Anchor link for: local-and-static-variables">🔗</a>Local and Static Variables</h2>
<p>We currently use two types of variables in our kernel: local variables and <code>static</code> variables. Local variables are stored on the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a> and are only valid until the surrounding function returns. Static variables are stored at a fixed memory location and always live for the complete lifetime of the program.</p>
<h3 id="local-variables"><a class="zola-anchor" href="index.html#local-variables" aria-label="Anchor link for: local-variables">🔗</a>Local Variables</h3>
<p>Local variables are stored on the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack</a>, which is a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack data structure</a> that supports <code>push</code> and <code>pop</code> operations. On each function entry, the parameters, the return address, and the local variables of the called function are pushed by the compiler:</p>
<p><img src="call-stack.svg" alt="An outer() and an inner(i: usize) function, where outer calls inner(1). Both have some local variables. The call stack contains the following slots: the local variables of outer, then the argument i = 1, then the return address, then the local variables of inner." /></p>
<p>The above example shows the call stack after the <code>outer</code> function called the <code>inner</code> function. We see that the call stack contains the local variables of <code>outer</code> first. On the <code>inner</code> call, the parameter <code>1</code> and the return address for the function were pushed. Then control was transferred to <code>inner</code>, which pushed its local variables.</p>
<p>After the <code>inner</code> function returns, its part of the call stack is popped again and only the local variables of <code>outer</code> remain:</p>
<p><img src="call-stack-return.svg" alt="The call stack containing only the local variables of outer" /></p>
<p>We see that the local variables of <code>inner</code> only live until the function returns. The Rust compiler enforces these lifetimes and throws an error when we use a value for too long, for example when we try to return a reference to a local variable:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>inner(i: </span><span style="color:#569cd6;">usize</span><span>) -&gt; </span><span style="color:#569cd6;">&amp;&#39;static u32 </span><span>{
</span><span>    </span><span style="color:#569cd6;">let</span><span> z = [</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">2</span><span>, </span><span style="color:#b5cea8;">3</span><span>];
</span><span>    </span><span style="color:#569cd6;">&amp;</span><span>z[i]
</span><span>}
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6186a0f3a54f468e1de8894996d12819">run the example on the playground</a>)</p>
<p>While returning a reference makes no sense in this example, there are cases where we want a variable to live longer than the function. We already saw such a case in our kernel when we tried to <a href="../cpu-exceptions/index.html#loading-the-idt">load an interrupt descriptor table</a> and had to use a <code>static</code> variable to extend the lifetime.</p>
<h3 id="static-variables"><a class="zola-anchor" href="index.html#static-variables" aria-label="Anchor link for: static-variables">🔗</a>Static Variables</h3>
<p>Static variables are stored at a fixed memory location separate from the stack. This memory location is assigned at compile time by the linker and encoded in the executable. Statics live for the complete runtime of the program, so they have the <code>'static</code> lifetime and can always be referenced from local variables:</p>
<p><img src="call-stack-static.svg" alt="The same outer/inner example, except that inner has a static Z: [u32; 3] = [1,2,3]; and returns a &amp;Z[i] reference" /></p>
<p>When the <code>inner</code> function returns in the above example, its part of the call stack is destroyed. The static variables live in a separate memory range that is never destroyed, so the <code>&amp;Z[1]</code> reference is still valid after the return.</p>
<p>Apart from the <code>'static</code> lifetime, static variables also have the useful property that their location is known at compile time, so that no reference is needed for accessing them. We utilized that property for our <code>println</code> macro: By using a <a href="../vga-text-mode/index.html#a-global-interface">static <code>Writer</code></a> internally, there is no <code>&amp;mut Writer</code> reference needed to invoke the macro, which is very useful in <a href="../cpu-exceptions/index.html#implementation">exception handlers</a>, where we don’t have access to any additional variables.</p>
<p>However, this property of static variables brings a crucial drawback: they are read-only by default. Rust enforces this because a <a href="https://doc.rust-lang.org/nomicon/races.html">data race</a> would occur if, e.g., two threads modified a static variable at the same time. The only way to modify a static variable is to encapsulate it in a <a href="https://docs.rs/spin/0.5.2/spin/struct.Mutex.html"><code>Mutex</code></a> type, which ensures that only a single <code>&amp;mut</code> reference exists at any point in time. We already used a <code>Mutex</code> for our <a href="../vga-text-mode/index.html#spinlocks">static VGA buffer <code>Writer</code></a>.</p>
<h2 id="dynamic-memory"><a class="zola-anchor" href="index.html#dynamic-memory" aria-label="Anchor link for: dynamic-memory">🔗</a>Dynamic Memory</h2>
<p>Local and static variables are already very powerful together and enable most use cases. However, we saw that they both have their limitations:</p>
<ul>
<li>Local variables only live until the end of the surrounding function or block. This is because they live on the call stack and are destroyed after the surrounding function returns.</li>
<li>Static variables always live for the complete runtime of the program, so there is no way to reclaim and reuse their memory when they’re no longer needed. Also, they have unclear ownership semantics and are accessible from all functions, so they need to be protected by a <a href="https://docs.rs/spin/0.5.2/spin/struct.Mutex.html"><code>Mutex</code></a> when we want to modify them.</li>
</ul>
<p>Another limitation of local and static variables is that they have a fixed size. So they can’t store a collection that dynamically grows when more elements are added. (There are proposals for <a href="https://github.com/rust-lang/rust/issues/48055">unsized rvalues</a> in Rust that would allow dynamically sized local variables, but they only work in some specific cases.)</p>
<p>To circumvent these drawbacks, programming languages often support a third memory region for storing variables called the <strong>heap</strong>. The heap supports <em>dynamic memory allocation</em> at runtime through two functions called <code>allocate</code> and <code>deallocate</code>. It works in the following way: The <code>allocate</code> function returns a free chunk of memory of the specified size that can be used to store a variable. This variable then lives until it is freed by calling the <code>deallocate</code> function with a reference to the variable.</p>
<p>Let’s go through an example:</p>
<p><img src="call-stack-heap.svg" alt="The inner function calls allocate(size_of([u32; 3])), writes z.write([1,2,3]);, and returns (z as *mut u32).offset(i). On the returned value y, the outer function performs deallocate(y, size_of(u32))." /></p>
<p>Here the <code>inner</code> function uses heap memory instead of static variables for storing <code>z</code>. It first allocates a memory block of the required size, which returns a <code>*mut u32</code> <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">raw pointer</a>. It then uses the <a href="https://doc.rust-lang.org/core/ptr/fn.write.html"><code>ptr::write</code></a> method to write the array <code>[1,2,3]</code> to it. In the last step, it uses the <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a> function to calculate a pointer to the <code>i</code>-th element and then returns it. (Note that we omitted some required casts and unsafe blocks in this example function for brevity.)</p>
<p>The allocated memory lives until it is explicitly freed through a call to <code>deallocate</code>. Thus, the returned pointer is still valid even after <code>inner</code> returned and its part of the call stack was destroyed. The advantage of using heap memory compared to static memory is that the memory can be reused after it is freed, which we do through the <code>deallocate</code> call in <code>outer</code>. After that call, the situation looks like this:</p>
<p><img src="call-stack-heap-freed.svg" alt="The call stack contains the local variables of outer, the heap contains z[0] and z[2], but no longer z[1]." /></p>
<p>We see that the <code>z[1]</code> slot is free again and can be reused for the next <code>allocate</code> call. However, we also see that <code>z[0]</code> and <code>z[2]</code> are never freed because we never deallocate them. Such a bug is called a <em>memory leak</em> and is often the cause of excessive memory consumption of programs (just imagine what happens when we call <code>inner</code> repeatedly in a loop). This might seem bad, but there are much more dangerous types of bugs that can happen with dynamic allocation.</p>
<h3 id="common-errors"><a class="zola-anchor" href="index.html#common-errors" aria-label="Anchor link for: common-errors">🔗</a>Common Errors</h3>
<p>Apart from memory leaks, which are unfortunate but don’t make the program vulnerable to attackers, there are two common types of bugs with more severe consequences:</p>
<ul>
<li>When we accidentally continue to use a variable after calling <code>deallocate</code> on it, we have a so-called <strong>use-after-free</strong> vulnerability. Such a bug causes undefined behavior and can often be exploited by attackers to execute arbitrary code.</li>
<li>When we accidentally free a variable twice, we have a <strong>double-free</strong> vulnerability. This is problematic because it might free a different allocation that was allocated in the same spot after the first <code>deallocate</code> call. Thus, it can lead to a use-after-free vulnerability again.</li>
</ul>
<p>These types of vulnerabilities are commonly known, so one might expect that people have learned how to avoid them by now. But no, such vulnerabilities are still regularly found, for example this <a href="https://securityboulevard.com/2019/02/linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11/">use-after-free vulnerability in Linux</a> (2019), that allowed arbitrary code execution. A web search like <code>use-after-free linux {current year}</code> will probably always yield results. This shows that even the best programmers are not always able to correctly handle dynamic memory in complex projects.</p>
<p>To avoid these issues, many languages, such as Java or Python, manage dynamic memory automatically using a technique called <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><em>garbage collection</em></a>. The idea is that the programmer never invokes <code>deallocate</code> manually. Instead, the program is regularly paused and scanned for unused heap variables, which are then automatically deallocated. Thus, the above vulnerabilities can never occur. The drawbacks are the performance overhead of the regular scan and the probably long pause times.</p>
<p>Rust takes a different approach to the problem: It uses a concept called <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"><em>ownership</em></a> that is able to check the correctness of dynamic memory operations at compile time. Thus, no garbage collection is needed to avoid the mentioned vulnerabilities, which means that there is no performance overhead. Another advantage of this approach is that the programmer still has fine-grained control over the use of dynamic memory, just like with C or C++.</p>
<h3 id="allocations-in-rust"><a class="zola-anchor" href="index.html#allocations-in-rust" aria-label="Anchor link for: allocations-in-rust">🔗</a>Allocations in Rust</h3>
<p>Instead of letting the programmer manually call <code>allocate</code> and <code>deallocate</code>, the Rust standard library provides abstraction types that call these functions implicitly. The most important type is <a href="https://doc.rust-lang.org/std/boxed/index.html"><strong><code>Box</code></strong></a>, which is an abstraction for a heap-allocated value. It provides a <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.new"><code>Box::new</code></a> constructor function that takes a value, calls <code>allocate</code> with the size of the value, and then moves the value to the newly allocated slot on the heap. To free the heap memory again, the <code>Box</code> type implements the <a href="https://doc.rust-lang.org/book/ch15-03-drop.html"><code>Drop</code> trait</a> to call <code>deallocate</code> when it goes out of scope:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>{
</span><span>    </span><span style="color:#569cd6;">let</span><span> z = Box::new([</span><span style="color:#b5cea8;">1</span><span>,</span><span style="color:#b5cea8;">2</span><span>,</span><span style="color:#b5cea8;">3</span><span>]);
</span><span>    […]
</span><span>} </span><span style="color:#608b4e;">// z goes out of scope and `deallocate` is called
</span></code></pre>
<p>This pattern has the strange name <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"><em>resource acquisition is initialization</em></a> (or <em>RAII</em> for short). It originated in C++, where it is used to implement a similar abstraction type called <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>.</p>
<p>Such a type alone does not suffice to prevent all use-after-free bugs since programmers can still hold on to references after the <code>Box</code> goes out of scope and the corresponding heap memory slot is deallocated:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let</span><span> x = {
</span><span>    </span><span style="color:#569cd6;">let</span><span> z = Box::new([</span><span style="color:#b5cea8;">1</span><span>,</span><span style="color:#b5cea8;">2</span><span>,</span><span style="color:#b5cea8;">3</span><span>]);
</span><span>    </span><span style="color:#569cd6;">&amp;</span><span>z[</span><span style="color:#b5cea8;">1</span><span>]
</span><span>}; </span><span style="color:#608b4e;">// z goes out of scope and `deallocate` is called
</span><span>println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, x);
</span></code></pre>
<p>This is where Rust’s ownership comes in. It assigns an abstract <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">lifetime</a> to each reference, which is the scope in which the reference is valid. In the above example, the <code>x</code> reference is taken from the <code>z</code> array, so it becomes invalid after <code>z</code> goes out of scope. When you <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=28180d8de7b62c6b4a681a7b1f745a48">run the above example on the playground</a> you see that the Rust compiler indeed throws an error:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error[E0597]: `z[_]` does not live long enough
</span><span> --&gt; src/main.rs:4:9
</span><span>  |
</span><span>2 |     let x = {
</span><span>  |         - borrow later stored here
</span><span>3 |         let z = Box::new([1,2,3]);
</span><span>4 |         &amp;z[1]
</span><span>  |         ^^^^^ borrowed value does not live long enough
</span><span>5 |     }; // z goes out of scope and `deallocate` is called
</span><span>  |     - `z[_]` dropped here while still borrowed
</span></code></pre>
<p>The terminology can be a bit confusing at first. Taking a reference to a value is called <em>borrowing</em> the value since it’s similar to a borrow in real life: You have temporary access to an object but need to return it sometime, and you must not destroy it. By checking that all borrows end before an object is destroyed, the Rust compiler can guarantee that no use-after-free situation can occur.</p>
<p>Rust’s ownership system goes even further, preventing not only use-after-free bugs but also providing complete <a href="https://en.wikipedia.org/wiki/Memory_safety"><em>memory safety</em></a>, as garbage collected languages like Java or Python do. Additionally, it guarantees <a href="https://en.wikipedia.org/wiki/Thread_safety"><em>thread safety</em></a> and is thus even safer than those languages in multi-threaded code. And most importantly, all these checks happen at compile time, so there is no runtime overhead compared to hand-written memory management in C.</p>
<h3 id="use-cases"><a class="zola-anchor" href="index.html#use-cases" aria-label="Anchor link for: use-cases">🔗</a>Use Cases</h3>
<p>We now know the basics of dynamic memory allocation in Rust, but when should we use it? We’ve come really far with our kernel without dynamic memory allocation, so why do we need it now?</p>
<p>First, dynamic memory allocation always comes with a bit of performance overhead since we need to find a free slot on the heap for every allocation. For this reason, local variables are generally preferable, especially in performance-sensitive kernel code. However, there are cases where dynamic memory allocation is the best choice.</p>
<p>As a basic rule, dynamic memory is required for variables that have a dynamic lifetime or a variable size. The most important type with a dynamic lifetime is <a href="https://doc.rust-lang.org/alloc/rc/index.html"><strong><code>Rc</code></strong></a>, which counts the references to its wrapped value and deallocates it after all references have gone out of scope. Examples for types with a variable size are <a href="https://doc.rust-lang.org/alloc/vec/index.html"><strong><code>Vec</code></strong></a>, <a href="https://doc.rust-lang.org/alloc/string/index.html"><strong><code>String</code></strong></a>, and other <a href="https://doc.rust-lang.org/alloc/collections/index.html">collection types</a> that dynamically grow when more elements are added. These types work by allocating a larger amount of memory when they become full, copying all elements over, and then deallocating the old allocation.</p>
<p>For our kernel, we will mostly need the collection types, for example, to store a list of active tasks when implementing multitasking in future posts.</p>
<h2 id="the-allocator-interface"><a class="zola-anchor" href="index.html#the-allocator-interface" aria-label="Anchor link for: the-allocator-interface">🔗</a>The Allocator Interface</h2>
<p>The first step in implementing a heap allocator is to add a dependency on the built-in <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> crate. Like the <a href="https://doc.rust-lang.org/core/"><code>core</code></a> crate, it is a subset of the standard library that additionally contains the allocation and collection types. To add the dependency on <code>alloc</code>, we add the following to our <code>lib.rs</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">extern crate</span><span> alloc;
</span></code></pre>
<p>Contrary to normal dependencies, we don’t need to modify the <code>Cargo.toml</code>. The reason is that the <code>alloc</code> crate ships with the Rust compiler as part of the standard library, so the compiler already knows about the crate. By adding this <code>extern crate</code> statement, we specify that the compiler should try to include it. (Historically, all dependencies needed an <code>extern crate</code> statement, which is now optional).</p>
<p>Since we are compiling for a custom target, we can’t use the precompiled version of <code>alloc</code> that is shipped with the Rust installation. Instead, we have to tell cargo to recompile the crate from source. We can do that by adding it to the <code>unstable.build-std</code> array in our <code>.cargo/config.toml</code> file:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">unstable</span><span>]
</span><span style="color:#569cd6;">build-std </span><span>= [</span><span style="color:#d69d85;">&quot;core&quot;</span><span>, </span><span style="color:#d69d85;">&quot;compiler_builtins&quot;</span><span>, </span><span style="color:#d69d85;">&quot;alloc&quot;</span><span>]
</span></code></pre>
<p>Now the compiler will recompile and include the <code>alloc</code> crate in our kernel.</p>
<p>The reason that the <code>alloc</code> crate is disabled by default in <code>#[no_std]</code> crates is that it has additional requirements. When we try to compile our project now, we will see these requirements as errors:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: no global memory allocator found but one is required; link to std or add
</span><span>       #[global_allocator] to a static item that implements the GlobalAlloc trait.
</span><span>
</span><span>error: `#[alloc_error_handler]` function required, but not found
</span></code></pre>
<p>The first error occurs because the <code>alloc</code> crate requires a heap allocator, which is an object that provides the <code>allocate</code> and <code>deallocate</code> functions. In Rust, heap allocators are described by the <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> trait, which is mentioned in the error message. To set the heap allocator for the crate, the <code>#[global_allocator]</code> attribute must be applied to a <code>static</code> variable that implements the <code>GlobalAlloc</code> trait.</p>
<p>The second error occurs because calls to <code>allocate</code> can fail, most commonly when there is no more memory available. Our program must be able to react to this case, which is what the <code>#[alloc_error_handler]</code> function is for.</p>
<p>We will describe these traits and attributes in detail in the following sections.</p>
<h3 id="the-globalalloc-trait"><a class="zola-anchor" href="index.html#the-globalalloc-trait" aria-label="Anchor link for: the-globalalloc-trait">🔗</a>The <code>GlobalAlloc</code> Trait</h3>
<p>The <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> trait defines the functions that a heap allocator must provide. The trait is special because it is almost never used directly by the programmer. Instead, the compiler will automatically insert the appropriate calls to the trait methods when using the allocation and collection types of <code>alloc</code>.</p>
<p>Since we will need to implement the trait for all our allocator types, it is worth taking a closer look at its declaration:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">pub unsafe trait </span><span>GlobalAlloc {
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>alloc(</span><span style="color:#569cd6;">&amp;</span><span>self, layout: Layout) -&gt; </span><span style="color:#569cd6;">*mut u8</span><span>;
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>dealloc(</span><span style="color:#569cd6;">&amp;</span><span>self, ptr: </span><span style="color:#569cd6;">*mut u8</span><span>, layout: Layout);
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>alloc_zeroed(</span><span style="color:#569cd6;">&amp;</span><span>self, layout: Layout) -&gt; </span><span style="color:#569cd6;">*mut u8 </span><span>{ </span><span style="color:#569cd6;">... </span><span>}
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>realloc(
</span><span>        </span><span style="color:#569cd6;">&amp;</span><span>self,
</span><span>        ptr: </span><span style="color:#569cd6;">*mut u8</span><span>,
</span><span>        layout: Layout,
</span><span>        new_size: </span><span style="color:#569cd6;">usize
</span><span>    ) -&gt; </span><span style="color:#569cd6;">*mut u8 </span><span>{ </span><span style="color:#569cd6;">... </span><span>}
</span><span>}
</span></code></pre>
<p>It defines the two required methods <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> and <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a>, which correspond to the <code>allocate</code> and <code>deallocate</code> functions we used in our examples:</p>
<ul>
<li>The <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> method takes a <a href="https://doc.rust-lang.org/alloc/alloc/struct.Layout.html"><code>Layout</code></a> instance as an argument, which describes the desired size and alignment that the allocated memory should have. It returns a <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">raw pointer</a> to the first byte of the allocated memory block. Instead of an explicit error value, the <code>alloc</code> method returns a null pointer to signal an allocation error. This is a bit non-idiomatic, but it has the advantage that wrapping existing system allocators is easy since they use the same convention.</li>
<li>The <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>dealloc</code></a> method is the counterpart and is responsible for freeing a memory block again. It receives two arguments: the pointer returned by <code>alloc</code> and the <code>Layout</code> that was used for the allocation.</li>
</ul>
<p>The trait additionally defines the two methods <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.alloc_zeroed"><code>alloc_zeroed</code></a> and <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.realloc"><code>realloc</code></a> with default implementations:</p>
<ul>
<li>The <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.alloc_zeroed"><code>alloc_zeroed</code></a> method is equivalent to calling <code>alloc</code> and then setting the allocated memory block to zero, which is exactly what the provided default implementation does. An allocator implementation can override the default implementations with a more efficient custom implementation if possible.</li>
<li>The <a href="https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#method.realloc"><code>realloc</code></a> method allows to grow or shrink an allocation. The default implementation allocates a new memory block with the desired size and copies over all the content from the previous allocation. Again, an allocator implementation can probably provide a more efficient implementation of this method, for example by growing/shrinking the allocation in-place if possible.</li>
</ul>
<h4 id="unsafety"><a class="zola-anchor" href="index.html#unsafety" aria-label="Anchor link for: unsafety">🔗</a>Unsafety</h4>
<p>One thing to notice is that both the trait itself and all trait methods are declared as <code>unsafe</code>:</p>
<ul>
<li>The reason for declaring the trait as <code>unsafe</code> is that the programmer must guarantee that the trait implementation for an allocator type is correct. For example, the <code>alloc</code> method must never return a memory block that is already used somewhere else because this would cause undefined behavior.</li>
<li>Similarly, the reason that the methods are <code>unsafe</code> is that the caller must ensure various invariants when calling the methods, for example, that the <code>Layout</code> passed to <code>alloc</code> specifies a non-zero size. This is not really relevant in practice since the methods are normally called directly by the compiler, which ensures that the requirements are met.</li>
</ul>
<h3 id="a-dummyallocator"><a class="zola-anchor" href="index.html#a-dummyallocator" aria-label="Anchor link for: a-dummyallocator">🔗</a>A <code>DummyAllocator</code></h3>
<p>Now that we know what an allocator type should provide, we can create a simple dummy allocator. For that, we create a new <code>allocator</code> module:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span style="color:#569cd6;">pub mod </span><span>allocator;
</span></code></pre>
<p>Our dummy allocator does the absolute minimum to implement the trait and always returns an error when <code>alloc</code> is called. It looks like this:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>alloc::alloc::{GlobalAlloc, Layout};
</span><span style="color:#569cd6;">use </span><span>core::ptr::null_mut;
</span><span>
</span><span style="color:#569cd6;">pub struct </span><span>Dummy;
</span><span>
</span><span style="color:#569cd6;">unsafe impl </span><span>GlobalAlloc </span><span style="color:#569cd6;">for </span><span>Dummy {
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>alloc(</span><span style="color:#569cd6;">&amp;</span><span>self, _layout: Layout) -&gt; </span><span style="color:#569cd6;">*mut u8 </span><span>{
</span><span>        null_mut()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">unsafe fn </span><span>dealloc(</span><span style="color:#569cd6;">&amp;</span><span>self, _ptr: </span><span style="color:#569cd6;">*mut u8</span><span>, _layout: Layout) {
</span><span>        panic!(</span><span style="color:#d69d85;">&quot;dealloc should be never called&quot;</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<p>The struct does not need any fields, so we create it as a <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">zero-sized type</a>. As mentioned above, we always return the null pointer from <code>alloc</code>, which corresponds to an allocation error. Since the allocator never returns any memory, a call to <code>dealloc</code> should never occur. For this reason, we simply panic in the <code>dealloc</code> method. The <code>alloc_zeroed</code> and <code>realloc</code> methods have default implementations, so we don’t need to provide implementations for them.</p>
<p>We now have a simple allocator, but we still have to tell the Rust compiler that it should use this allocator. This is where the <code>#[global_allocator]</code> attribute comes in.</p>
<h3 id="the-global-allocator-attribute"><a class="zola-anchor" href="index.html#the-global-allocator-attribute" aria-label="Anchor link for: the-global-allocator-attribute">🔗</a>The <code>#[global_allocator]</code> Attribute</h3>
<p>The <code>#[global_allocator]</code> attribute tells the Rust compiler which allocator instance it should use as the global heap allocator. The attribute is only applicable to a <code>static</code> that implements the <code>GlobalAlloc</code> trait. Let’s register an instance of our <code>Dummy</code> allocator as the global allocator:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span>#[global_allocator]
</span><span style="color:#569cd6;">static </span><span style="color:#b4cea8;">ALLOCATOR</span><span>: Dummy = Dummy;
</span></code></pre>
<p>Since the <code>Dummy</code> allocator is a <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">zero-sized type</a>, we don’t need to specify any fields in the initialization expression.</p>
<p>When we now try to compile it, the first error should be gone. Let’s fix the remaining second error:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: `#[alloc_error_handler]` function required, but not found
</span></code></pre>
<h3 id="the-alloc-error-handler-attribute"><a class="zola-anchor" href="index.html#the-alloc-error-handler-attribute" aria-label="Anchor link for: the-alloc-error-handler-attribute">🔗</a>The <code>#[alloc_error_handler]</code> Attribute</h3>
<p>As we learned when discussing the <code>GlobalAlloc</code> trait, the <code>alloc</code> function can signal an allocation error by returning a null pointer. The question is: how should the Rust runtime react to such an allocation failure? This is where the <code>#[alloc_error_handler]</code> attribute comes in. It specifies a function that is called when an allocation error occurs, similar to how our panic handler is called when a panic occurs.</p>
<p>Let’s add such a function to fix the compilation error:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/lib.rs
</span><span>
</span><span>#![feature(alloc_error_handler)] </span><span style="color:#608b4e;">// at the top of the file
</span><span>
</span><span>#[alloc_error_handler]
</span><span style="color:#569cd6;">fn </span><span>alloc_error_handler(layout: alloc::alloc::Layout) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    panic!(</span><span style="color:#d69d85;">&quot;allocation error: {:?}&quot;</span><span>, layout)
</span><span>}
</span></code></pre>
<p>The <code>alloc_error_handler</code> function is still unstable, so we need a feature gate to enable it. The function receives a single argument: the <code>Layout</code> instance that was passed to <code>alloc</code> when the allocation failure occurred. There’s nothing we can do to resolve the failure, so we just panic with a message that contains the <code>Layout</code> instance.</p>
<p>With this function, the compilation errors should be fixed. Now we can use the allocation and collection types of <code>alloc</code>. For example, we can use a <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a> to allocate a value on the heap:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">extern crate</span><span> alloc;
</span><span>
</span><span style="color:#569cd6;">use </span><span>alloc::boxed::Box;
</span><span>
</span><span style="color:#569cd6;">fn </span><span>kernel_main(boot_info: </span><span style="color:#569cd6;">&amp;&#39;static</span><span> BootInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#608b4e;">// […] print &quot;Hello World!&quot;, call `init`, create `mapper` and `frame_allocator`
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> x = Box::new(</span><span style="color:#b5cea8;">41</span><span>);
</span><span>
</span><span>    </span><span style="color:#608b4e;">// […] call `test_main` in test mode
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    blog_os::hlt_loop();
</span><span>}
</span><span>
</span></code></pre>
<p>Note that we need to specify the <code>extern crate alloc</code> statement in our <code>main.rs</code> too. This is required because the <code>lib.rs</code> and <code>main.rs</code> parts are treated as separate crates. However, we don’t need to create another <code>#[global_allocator]</code> static because the global allocator applies to all crates in the project. In fact, specifying an additional allocator in another crate would be an error.</p>
<p>When we run the above code, we see that our <code>alloc_error_handler</code> function is called:</p>
<p><img src="qemu-dummy-output.png" alt="QEMU printing “panicked at `allocation error: Layout { size_: 4, align_: 4 }, src/lib.rs:89:5”" /></p>
<p>The error handler is called because the <code>Box::new</code> function implicitly calls the <code>alloc</code> function of the global allocator. Our dummy allocator always returns a null pointer, so every allocation fails. To fix this, we need to create an allocator that actually returns usable memory.</p>
<h2 id="creating-a-kernel-heap"><a class="zola-anchor" href="index.html#creating-a-kernel-heap" aria-label="Anchor link for: creating-a-kernel-heap">🔗</a>Creating a Kernel Heap</h2>
<p>Before we can create a proper allocator, we first need to create a heap memory region from which the allocator can allocate memory. To do this, we need to define a virtual memory range for the heap region and then map this region to physical frames. See the <a href="../paging-introduction/index.html"><em>“Introduction To Paging”</em></a> post for an overview of virtual memory and page tables.</p>
<p>The first step is to define a virtual memory region for the heap. We can choose any virtual address range that we like, as long as it is not already used for a different memory region. Let’s define it as the memory starting at address <code>0x_4444_4444_0000</code> so that we can easily recognize a heap pointer later:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">HEAP_START</span><span>: </span><span style="color:#569cd6;">usize </span><span>= </span><span style="color:#b5cea8;">0x_4444_4444_0000</span><span>;
</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">HEAP_SIZE</span><span>: </span><span style="color:#569cd6;">usize </span><span>= </span><span style="color:#b5cea8;">100 </span><span>* </span><span style="color:#b5cea8;">1024</span><span>; </span><span style="color:#608b4e;">// 100 KiB
</span></code></pre>
<p>We set the heap size to 100 KiB for now. If we need more space in the future, we can simply increase it.</p>
<p>If we tried to use this heap region now, a page fault would occur since the virtual memory region is not mapped to physical memory yet. To resolve this, we create an <code>init_heap</code> function that maps the heap pages using the <a href="../paging-implementation/index.html#using-offsetpagetable"><code>Mapper</code> API</a> that we introduced in the <a href="../paging-implementation/index.html"><em>“Paging Implementation”</em></a> post:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>x86_64::{
</span><span>    structures::paging::{
</span><span>        mapper::MapToError, FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB,
</span><span>    },
</span><span>    VirtAddr,
</span><span>};
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_heap(
</span><span>    mapper: </span><span style="color:#569cd6;">&amp;mut</span><span> impl Mapper&lt;Size4KiB&gt;,
</span><span>    frame_allocator: </span><span style="color:#569cd6;">&amp;mut</span><span> impl FrameAllocator&lt;Size4KiB&gt;,
</span><span>) -&gt; Result&lt;(), MapToError&lt;Size4KiB&gt;&gt; {
</span><span>    </span><span style="color:#569cd6;">let</span><span> page_range = {
</span><span>        </span><span style="color:#569cd6;">let</span><span> heap_start = VirtAddr::new(</span><span style="color:#b4cea8;">HEAP_START </span><span style="color:#569cd6;">as u64</span><span>);
</span><span>        </span><span style="color:#569cd6;">let</span><span> heap_end = heap_start + </span><span style="color:#b4cea8;">HEAP_SIZE </span><span>- </span><span style="color:#b5cea8;">1</span><span style="color:#569cd6;">u64</span><span>;
</span><span>        </span><span style="color:#569cd6;">let</span><span> heap_start_page = Page::containing_address(heap_start);
</span><span>        </span><span style="color:#569cd6;">let</span><span> heap_end_page = Page::containing_address(heap_end);
</span><span>        Page::range_inclusive(heap_start_page, heap_end_page)
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#569cd6;">for</span><span> page </span><span style="color:#569cd6;">in</span><span> page_range {
</span><span>        </span><span style="color:#569cd6;">let</span><span> frame = frame_allocator
</span><span>            .allocate_frame()
</span><span>            .ok_or(MapToError::FrameAllocationFailed)</span><span style="color:#569cd6;">?</span><span>;
</span><span>        </span><span style="color:#569cd6;">let</span><span> flags = PageTableFlags::</span><span style="color:#b4cea8;">PRESENT </span><span style="color:#569cd6;">| </span><span>PageTableFlags::</span><span style="color:#b4cea8;">WRITABLE</span><span>;
</span><span>        </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>            mapper.map_to(page, frame, flags, frame_allocator)</span><span style="color:#569cd6;">?</span><span>.flush()
</span><span>        };
</span><span>    }
</span><span>
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>The function takes mutable references to a <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/trait.Mapper.html"><code>Mapper</code></a> and a <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/trait.FrameAllocator.html"><code>FrameAllocator</code></a> instance, both limited to 4 KiB pages by using <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page/enum.Size4KiB.html"><code>Size4KiB</code></a> as the generic parameter. The return value of the function is a <a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a> with the unit type <code>()</code> as the success variant and a <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/enum.MapToError.html"><code>MapToError</code></a> as the error variant, which is the error type returned by the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>Mapper::map_to</code></a> method. Reusing the error type makes sense here because the <code>map_to</code> method is the main source of errors in this function.</p>
<p>The implementation can be broken down into two parts:</p>
<ul>
<li>
<p><strong>Creating the page range:</strong>: To create a range of the pages that we want to map, we convert the <code>HEAP_START</code> pointer to a <a href="https://docs.rs/x86_64/0.14.2/x86_64/addr/struct.VirtAddr.html"><code>VirtAddr</code></a> type. Then we calculate the heap end address from it by adding the <code>HEAP_SIZE</code>. We want an inclusive bound (the address of the last byte of the heap), so we subtract 1. Next, we convert the addresses into <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page/struct.Page.html"><code>Page</code></a> types using the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page/struct.Page.html#method.containing_address"><code>containing_address</code></a> function. Finally, we create a page range from the start and end pages using the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page/struct.Page.html#method.range_inclusive"><code>Page::range_inclusive</code></a> function.</p>
</li>
<li>
<p><strong>Mapping the pages:</strong> The second step is to map all pages of the page range we just created. For that, we iterate over these pages using a <code>for</code> loop. For each page, we do the following:</p>
<ul>
<li>
<p>We allocate a physical frame that the page should be mapped to using the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/trait.FrameAllocator.html#tymethod.allocate_frame"><code>FrameAllocator::allocate_frame</code></a> method. This method returns <a href="https://doc.rust-lang.org/core/option/enum.Option.html#variant.None"><code>None</code></a> when there are no more frames left. We deal with that case by mapping it to a <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/enum.MapToError.html#variant.FrameAllocationFailed"><code>MapToError::FrameAllocationFailed</code></a> error through the <a href="https://doc.rust-lang.org/core/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> method and then applying the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">question mark operator</a> to return early in the case of an error.</p>
</li>
<li>
<p>We set the required <code>PRESENT</code> flag and the <code>WRITABLE</code> flag for the page. With these flags, both read and write accesses are allowed, which makes sense for heap memory.</p>
</li>
<li>
<p>We use the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/trait.Mapper.html#method.map_to"><code>Mapper::map_to</code></a> method for creating the mapping in the active page table. The method can fail, so we use the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">question mark operator</a> again to forward the error to the caller. On success, the method returns a <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/struct.MapperFlush.html"><code>MapperFlush</code></a> instance that we can use to update the <a href="../paging-introduction/index.html#the-translation-lookaside-buffer"><em>translation lookaside buffer</em></a> using the <a href="https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/mapper/struct.MapperFlush.html#method.flush"><code>flush</code></a> method.</p>
</li>
</ul>
</li>
</ul>
<p>The final step is to call this function from our <code>kernel_main</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">fn </span><span>kernel_main(boot_info: </span><span style="color:#569cd6;">&amp;&#39;static</span><span> BootInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">use </span><span>blog_os::allocator; </span><span style="color:#608b4e;">// new import
</span><span>    </span><span style="color:#569cd6;">use </span><span>blog_os::memory::{self, BootInfoFrameAllocator};
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, </span><span style="color:#d69d85;">&quot;!&quot;</span><span>);
</span><span>    blog_os::init();
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> mapper = </span><span style="color:#569cd6;">unsafe </span><span>{ memory::init(phys_mem_offset) };
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> frame_allocator = </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        BootInfoFrameAllocator::init(</span><span style="color:#569cd6;">&amp;</span><span>boot_info.memory_map)
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#608b4e;">// new
</span><span>    allocator::init_heap(</span><span style="color:#569cd6;">&amp;mut</span><span> mapper, </span><span style="color:#569cd6;">&amp;mut</span><span> frame_allocator)
</span><span>        .expect(</span><span style="color:#d69d85;">&quot;heap initialization failed&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> x = Box::new(</span><span style="color:#b5cea8;">41</span><span>);
</span><span>
</span><span>    </span><span style="color:#608b4e;">// […] call `test_main` in test mode
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    blog_os::hlt_loop();
</span><span>}
</span></code></pre>
<p>We show the full function for context here. The only new lines are the <code>blog_os::allocator</code> import and the call to the <code>allocator::init_heap</code> function. In case the <code>init_heap</code> function returns an error, we panic using the <a href="https://doc.rust-lang.org/core/result/enum.Result.html#method.expect"><code>Result::expect</code></a> method since there is currently no sensible way for us to handle this error.</p>
<p>We now have a mapped heap memory region that is ready to be used. The <code>Box::new</code> call still uses our old <code>Dummy</code> allocator, so you will still see the “out of memory” error when you run it. Let’s fix this by using a proper allocator.</p>
<h2 id="using-an-allocator-crate"><a class="zola-anchor" href="index.html#using-an-allocator-crate" aria-label="Anchor link for: using-an-allocator-crate">🔗</a>Using an Allocator Crate</h2>
<p>Since implementing an allocator is somewhat complex, we start by using an external allocator crate. We will learn how to implement our own allocator in the next post.</p>
<p>A simple allocator crate for <code>no_std</code> applications is the <a href="https://github.com/phil-opp/linked-list-allocator/"><code>linked_list_allocator</code></a> crate. Its name comes from the fact that it uses a linked list data structure to keep track of deallocated memory regions. See the next post for a more detailed explanation of this approach.</p>
<p>To use the crate, we first need to add a dependency on it in our <code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># in Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">linked_list_allocator </span><span>= </span><span style="color:#d69d85;">&quot;0.9.0&quot;
</span></code></pre>
<p>Then we can replace our dummy allocator with the allocator provided by the crate:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>linked_list_allocator::LockedHeap;
</span><span>
</span><span>#[global_allocator]
</span><span style="color:#569cd6;">static </span><span style="color:#b4cea8;">ALLOCATOR</span><span>: LockedHeap = LockedHeap::empty();
</span></code></pre>
<p>The struct is named <code>LockedHeap</code> because it uses the <a href="https://docs.rs/spinning_top/0.1.0/spinning_top/type.Spinlock.html"><code>spinning_top::Spinlock</code></a> type for synchronization. This is required because multiple threads could access the <code>ALLOCATOR</code> static at the same time. As always, when using a spinlock or a mutex, we need to be careful to not accidentally cause a deadlock. This means that we shouldn’t perform any allocations in interrupt handlers, since they can run at an arbitrary time and might interrupt an in-progress allocation.</p>
<p>Setting the <code>LockedHeap</code> as global allocator is not enough. The reason is that we use the <a href="https://docs.rs/linked_list_allocator/0.9.0/linked_list_allocator/struct.LockedHeap.html#method.empty"><code>empty</code></a> constructor function, which creates an allocator without any backing memory. Like our dummy allocator, it always returns an error on <code>alloc</code>. To fix this, we need to initialize the allocator after creating the heap:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/allocator.rs
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>init_heap(
</span><span>    mapper: </span><span style="color:#569cd6;">&amp;mut</span><span> impl Mapper&lt;Size4KiB&gt;,
</span><span>    frame_allocator: </span><span style="color:#569cd6;">&amp;mut</span><span> impl FrameAllocator&lt;Size4KiB&gt;,
</span><span>) -&gt; Result&lt;(), MapToError&lt;Size4KiB&gt;&gt; {
</span><span>    </span><span style="color:#608b4e;">// […] map all heap pages to physical frames
</span><span>
</span><span>    </span><span style="color:#608b4e;">// new
</span><span>    </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        </span><span style="color:#b4cea8;">ALLOCATOR</span><span>.lock().init(</span><span style="color:#b4cea8;">HEAP_START</span><span>, </span><span style="color:#b4cea8;">HEAP_SIZE</span><span>);
</span><span>    }
</span><span>
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>We use the <a href="https://docs.rs/lock_api/0.3.3/lock_api/struct.Mutex.html#method.lock"><code>lock</code></a> method on the inner spinlock of the <code>LockedHeap</code> type to get an exclusive reference to the wrapped <a href="https://docs.rs/linked_list_allocator/0.9.0/linked_list_allocator/struct.Heap.html"><code>Heap</code></a> instance, on which we then call the <a href="https://docs.rs/linked_list_allocator/0.9.0/linked_list_allocator/struct.Heap.html#method.init"><code>init</code></a> method with the heap bounds as arguments. Because the <a href="https://docs.rs/linked_list_allocator/0.9.0/linked_list_allocator/struct.Heap.html#method.init"><code>init</code></a> function already tries to write to the heap memory, we must initialize the heap only <em>after</em> mapping the heap pages.</p>
<p>After initializing the heap, we can now use all allocation and collection types of the built-in <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a> crate without error:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in src/main.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>alloc::{boxed::Box, vec, vec::Vec, rc::Rc};
</span><span>
</span><span style="color:#569cd6;">fn </span><span>kernel_main(boot_info: </span><span style="color:#569cd6;">&amp;&#39;static</span><span> BootInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#608b4e;">// […] initialize interrupts, mapper, frame_allocator, heap
</span><span>
</span><span>    </span><span style="color:#608b4e;">// allocate a number on the heap
</span><span>    </span><span style="color:#569cd6;">let</span><span> heap_value = Box::new(</span><span style="color:#b5cea8;">41</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;heap_value at </span><span style="color:#b4cea8;">{:p}</span><span style="color:#d69d85;">&quot;</span><span>, heap_value);
</span><span>
</span><span>    </span><span style="color:#608b4e;">// create a dynamically sized vector
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> vec = Vec::new();
</span><span>    </span><span style="color:#569cd6;">for</span><span> i </span><span style="color:#569cd6;">in </span><span style="color:#b5cea8;">0</span><span style="color:#569cd6;">..</span><span style="color:#b5cea8;">500 </span><span>{
</span><span>        vec.push(i);
</span><span>    }
</span><span>    println!(</span><span style="color:#d69d85;">&quot;vec at </span><span style="color:#b4cea8;">{:p}</span><span style="color:#d69d85;">&quot;</span><span>, vec.as_slice());
</span><span>
</span><span>    </span><span style="color:#608b4e;">// create a reference counted vector -&gt; will be freed when count reaches 0
</span><span>    </span><span style="color:#569cd6;">let</span><span> reference_counted = Rc::new(vec![</span><span style="color:#b5cea8;">1</span><span>, </span><span style="color:#b5cea8;">2</span><span>, </span><span style="color:#b5cea8;">3</span><span>]);
</span><span>    </span><span style="color:#569cd6;">let</span><span> cloned_reference = reference_counted.clone();
</span><span>    println!(</span><span style="color:#d69d85;">&quot;current reference count is </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span>, Rc::strong_count(</span><span style="color:#569cd6;">&amp;</span><span>cloned_reference));
</span><span>    core::mem::drop(reference_counted);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;reference count is </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;"> now&quot;</span><span>, Rc::strong_count(</span><span style="color:#569cd6;">&amp;</span><span>cloned_reference));
</span><span>
</span><span>    </span><span style="color:#608b4e;">// […] call `test_main` in test context
</span><span>    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span>);
</span><span>    blog_os::hlt_loop();
</span><span>}
</span></code></pre>
<p>This code example shows some uses of the <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a>, <a href="https://doc.rust-lang.org/alloc/vec/"><code>Vec</code></a>, and <a href="https://doc.rust-lang.org/alloc/rc/"><code>Rc</code></a> types. For the <code>Box</code> and <code>Vec</code> types, we print the underlying heap pointers using the <a href="https://doc.rust-lang.org/core/fmt/trait.Pointer.html"><code>{:p}</code> formatting specifier</a>. To showcase <code>Rc</code>, we create a reference-counted heap value and use the <a href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.strong_count"><code>Rc::strong_count</code></a> function to print the current reference count before and after dropping an instance (using <a href="https://doc.rust-lang.org/core/mem/fn.drop.html"><code>core::mem::drop</code></a>).</p>
<p>When we run it, we see the following:</p>
<p><img src="qemu-alloc-showcase.png" alt="QEMU printing ` heap_value at 0x444444440000 vec at 0x4444444408000 current reference count is 2 reference count is 1 now " /></p>
<p>As expected, we see that the <code>Box</code> and <code>Vec</code> values live on the heap, as indicated by the pointer starting with the <code>0x_4444_4444_*</code> prefix. The reference counted value also behaves as expected, with the reference count being 2 after the <code>clone</code> call, and 1 again after one of the instances was dropped.</p>
<p>The reason that the vector starts at offset <code>0x800</code> is not that the boxed value is <code>0x800</code> bytes large, but the <a href="https://doc.rust-lang.org/alloc/vec/struct.Vec.html#capacity-and-reallocation">reallocations</a> that occur when the vector needs to increase its capacity. For example, when the vector’s capacity is 32 and we try to add the next element, the vector allocates a new backing array with a capacity of 64 behind the scenes and copies all elements over. Then it frees the old allocation.</p>
<p>Of course, there are many more allocation and collection types in the <code>alloc</code> crate that we can now all use in our kernel, including:</p>
<ul>
<li>the thread-safe reference counted pointer <a href="https://doc.rust-lang.org/alloc/sync/struct.Arc.html"><code>Arc</code></a></li>
<li>the owned string type <a href="https://doc.rust-lang.org/alloc/string/struct.String.html"><code>String</code></a> and the <a href="https://doc.rust-lang.org/alloc/macro.format.html"><code>format!</code></a> macro</li>
<li><a href="https://doc.rust-lang.org/alloc/collections/linked_list/struct.LinkedList.html"><code>LinkedList</code></a></li>
<li>the growable ring buffer <a href="https://doc.rust-lang.org/alloc/collections/vec_deque/struct.VecDeque.html"><code>VecDeque</code></a></li>
<li>the <a href="https://doc.rust-lang.org/alloc/collections/binary_heap/struct.BinaryHeap.html"><code>BinaryHeap</code></a> priority queue</li>
<li><a href="https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html"><code>BTreeMap</code></a> and <a href="https://doc.rust-lang.org/alloc/collections/btree_set/struct.BTreeSet.html"><code>BTreeSet</code></a></li>
</ul>
<p>These types will become very useful when we want to implement thread lists, scheduling queues, or support for async/await.</p>
<h2 id="adding-a-test"><a class="zola-anchor" href="index.html#adding-a-test" aria-label="Anchor link for: adding-a-test">🔗</a>Adding a Test</h2>
<p>To ensure that we don’t accidentally break our new allocation code, we should add an integration test for it. We start by creating a new <code>tests/heap_allocation.rs</code> file with the following content:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/heap_allocation.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style="color:#569cd6;">= </span><span style="color:#d69d85;">&quot;test_main&quot;</span><span>]
</span><span>
</span><span style="color:#569cd6;">extern crate</span><span> alloc;
</span><span>
</span><span style="color:#569cd6;">use </span><span>bootloader::{entry_point, BootInfo};
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>entry_point!(main);
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main(boot_info: </span><span style="color:#569cd6;">&amp;&#39;static</span><span> BootInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    unimplemented!();
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre>
<p>We reuse the <code>test_runner</code> and <code>test_panic_handler</code> functions from our <code>lib.rs</code>. Since we want to test allocations, we enable the <code>alloc</code> crate through the <code>extern crate alloc</code> statement. For more information about the test boilerplate, check out the <a href="../testing/index.html"><em>Testing</em></a> post.</p>
<p>The implementation of the <code>main</code> function looks like this:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/heap_allocation.rs
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main(boot_info: </span><span style="color:#569cd6;">&amp;&#39;static</span><span> BootInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">use </span><span>blog_os::allocator;
</span><span>    </span><span style="color:#569cd6;">use </span><span>blog_os::memory::{self, BootInfoFrameAllocator};
</span><span>    </span><span style="color:#569cd6;">use </span><span>x86_64::VirtAddr;
</span><span>
</span><span>    blog_os::init();
</span><span>    </span><span style="color:#569cd6;">let</span><span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> mapper = </span><span style="color:#569cd6;">unsafe </span><span>{ memory::init(phys_mem_offset) };
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> frame_allocator = </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>        BootInfoFrameAllocator::init(</span><span style="color:#569cd6;">&amp;</span><span>boot_info.memory_map)
</span><span>    };
</span><span>    allocator::init_heap(</span><span style="color:#569cd6;">&amp;mut</span><span> mapper, </span><span style="color:#569cd6;">&amp;mut</span><span> frame_allocator)
</span><span>        .expect(</span><span style="color:#d69d85;">&quot;heap initialization failed&quot;</span><span>);
</span><span>
</span><span>    test_main();
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>It is very similar to the <code>kernel_main</code> function in our <code>main.rs</code>, with the differences that we don’t invoke <code>println</code>, don’t include any example allocations, and call <code>test_main</code> unconditionally.</p>
<p>Now we’re ready to add a few test cases. First, we add a test that performs some simple allocations using <a href="https://doc.rust-lang.org/alloc/boxed/struct.Box.html"><code>Box</code></a> and checks the allocated values to ensure that basic allocations work:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/heap_allocation.rs
</span><span style="color:#569cd6;">use </span><span>alloc::boxed::Box;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>simple_allocation() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> heap_value_1 = Box::new(</span><span style="color:#b5cea8;">41</span><span>);
</span><span>    </span><span style="color:#569cd6;">let</span><span> heap_value_2 = Box::new(</span><span style="color:#b5cea8;">13</span><span>);
</span><span>    assert_eq!(*heap_value_1, </span><span style="color:#b5cea8;">41</span><span>);
</span><span>    assert_eq!(*heap_value_2, </span><span style="color:#b5cea8;">13</span><span>);
</span><span>}
</span></code></pre>
<p>Most importantly, this test verifies that no allocation error occurs.</p>
<p>Next, we iteratively build a large vector, to test both large allocations and multiple allocations (due to reallocations):</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/heap_allocation.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>alloc::vec::Vec;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>large_vec() {
</span><span>    </span><span style="color:#569cd6;">let</span><span> n = </span><span style="color:#b5cea8;">1000</span><span>;
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> vec = Vec::new();
</span><span>    </span><span style="color:#569cd6;">for</span><span> i </span><span style="color:#569cd6;">in </span><span style="color:#b5cea8;">0</span><span style="color:#569cd6;">..</span><span>n {
</span><span>        vec.push(i);
</span><span>    }
</span><span>    assert_eq!(vec.iter().sum::&lt;</span><span style="color:#569cd6;">u64</span><span>&gt;(), (n - </span><span style="color:#b5cea8;">1</span><span>) * n / </span><span style="color:#b5cea8;">2</span><span>);
</span><span>}
</span></code></pre>
<p>We verify the sum by comparing it with the formula for the <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums">n-th partial sum</a>. This gives us some confidence that the allocated values are all correct.</p>
<p>As a third test, we create ten thousand allocations after each other:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// in tests/heap_allocation.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>blog_os::allocator::</span><span style="color:#b4cea8;">HEAP_SIZE</span><span>;
</span><span>
</span><span>#[test_case]
</span><span style="color:#569cd6;">fn </span><span>many_boxes() {
</span><span>    </span><span style="color:#569cd6;">for</span><span> i </span><span style="color:#569cd6;">in </span><span style="color:#b5cea8;">0</span><span style="color:#569cd6;">..</span><span style="color:#b4cea8;">HEAP_SIZE </span><span>{
</span><span>        </span><span style="color:#569cd6;">let</span><span> x = Box::new(i);
</span><span>        assert_eq!(*x, i);
</span><span>    }
</span><span>}
</span></code></pre>
<p>This test ensures that the allocator reuses freed memory for subsequent allocations since it would run out of memory otherwise. This might seem like an obvious requirement for an allocator, but there are allocator designs that don’t do this. An example is the bump allocator design that will be explained in the next post.</p>
<p>Let’s run our new integration test:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo test --test heap_allocation
</span><span>[…]
</span><span>Running 3 tests
</span><span>simple_allocation... [ok]
</span><span>large_vec... [ok]
</span><span>many_boxes... [ok]
</span></code></pre>
<p>All three tests succeeded! You can also invoke <code>cargo test</code> (without the <code>--test</code> argument) to run all unit and integration tests.</p>
<h2 id="summary"><a class="zola-anchor" href="index.html#summary" aria-label="Anchor link for: summary">🔗</a>Summary</h2>
<p>This post gave an introduction to dynamic memory and explained why and where it is needed. We saw how Rust’s borrow checker prevents common vulnerabilities and learned how Rust’s allocation API works.</p>
<p>After creating a minimal implementation of Rust’s allocator interface using a dummy allocator, we created a proper heap memory region for our kernel. For that, we defined a virtual address range for the heap and then mapped all pages of that range to physical frames using the <code>Mapper</code> and <code>FrameAllocator</code> from the previous post.</p>
<p>Finally, we added a dependency on the <code>linked_list_allocator</code> crate to add a proper allocator to our kernel. With this allocator, we were able to use <code>Box</code>, <code>Vec</code>, and other allocation and collection types from the <code>alloc</code> crate.</p>
<h2 id="what-s-next"><a class="zola-anchor" href="index.html#what-s-next" aria-label="Anchor link for: what-s-next">🔗</a>What’s next?</h2>
<p>While we already added heap allocation support in this post, we left most of the work to the <code>linked_list_allocator</code> crate. The next post will show in detail how an allocator can be implemented from scratch. It will present multiple possible allocator designs, show how to implement simple versions of them, and explain their advantages and drawbacks.</p>

    </div>

    <div class="post-footer-support">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../paging-implementation/index.html">&laquo; Paging Implementation</a>
        
        
            <a class="next" href="../allocator-designs/index.html">Allocator Designs &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="">Comments</h2>

        
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q=%22Heap%20Allocation%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="Heap Allocation"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q=%22Heap%20Allocation%22"><em>on GitHub</em></a>.
    </p>

    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="ja" class=""><a href="../ja/heap-allocation/index.html">
                        Japanese
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
