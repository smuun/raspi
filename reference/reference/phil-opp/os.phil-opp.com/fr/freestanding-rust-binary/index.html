<!doctype html>

<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="La premiÃ¨re Ã©tape pour crÃ©er notre propre noyau de systÃ¨me dâ€™exploitation est de crÃ©er un exÃ©cutable Rust qui ne relie pas la bibliothÃ¨que standard. Câ€¦">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>Un binaire Rust autonome | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fr" title="All Posts">Â« Tous les articles</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="">
        <h2>Table des matiÃ¨res</h2>
    <ol>
        <li>
            <a href="index.html#introduction">Introduction</a>
            
        </li><li>
            <a href="index.html#desactiver-la-bibliotheque-standard">DÃ©sactiver la BibliothÃ¨que Standard</a>
            <ol>
                <li>
                    <a href="index.html#l-attribut-no-std">Lâ€™Attribut no_std</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#implementation-de-panic">ImplÃ©mentation de Panic</a>
            
        </li><li>
            <a href="index.html#l-objet-de-langage-eh-personality">Lâ€™Objet de Langage eh_personality</a>
            <ol>
                <li>
                    <a href="index.html#desactiver-le-deroulement">DÃ©sactiver le DÃ©roulement</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#l-attribut-start">Lâ€™attribut start</a>
            <ol>
                <li>
                    <a href="index.html#reecrire-le-point-d-entree">RÃ©Ã©crire le Point dâ€™EntrÃ©e</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#erreurs-de-linker">Erreurs de Linker</a>
            <ol>
                <li>
                    <a href="index.html#compiler-pour-une-cible-bare-metal">Compiler pour une Cible Bare Metal</a>
                </li><li>
                    <a href="index.html#arguments-du-linker">Arguments du Linker</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#resume">RÃ©sumÃ©</a>
            
        </li><li>
            <a href="index.html#et-ensuite">Et ensuite ?</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">Commentaires</a></li>
    </ol>
</aside>

            <main>
    <div class="">
    <h1>Un binaire Rust autonome</h1>
    <time datetime="2018-02-10" class="post-date">
        Feb 10, 2018
        
    </time>
    </div>

    
        <div class="warning">
            
            
            <p>
            <b>Contenu traduit : </b>
            Ceci est une traduction communautaire de l'article <strong><a href="../../freestanding-rust-binary/index.html">A Freestanding Rust Binary</a></strong>. Il peut Ãªtre incomplet, obsolÃ¨te ou contenir des erreurs. Veuillez signaler les quelconques problÃ¨mes !
            </p>
            <p>
                Traduit par :  <a href="https://github.com/AlexandreMarcq">@AlexandreMarcq</a> et <a href="https://github.com/alaincao">@alaincao</a>.</p>
            </div>
    

    <div class="">
    <p>La premiÃ¨re Ã©tape pour crÃ©er notre propre noyau de systÃ¨me dâ€™exploitation est de crÃ©er un exÃ©cutable Rust qui ne relie pas la bibliothÃ¨que standard. Cela rend possible lâ€™exÃ©cution du code Rust sur la <a href="https://en.wikipedia.org/wiki/Bare_machine">â€œbare machineâ€</a> sans systÃ¨me dâ€™exploitation sous-jacent.</p>
<span id="continue-reading"></span>
<p>Ce blog est dÃ©veloppÃ© sur <a href="https://github.com/phil-opp/blog_os">GitHub</a>. Si vous avez un problÃ¨me ou une question, veuillez ouvrir une issue. Vous pouvez aussi laisser un commentaire <a href="index.html#comments">en bas de page</a>. Le code source complet de cet article est disponible sur la branche <a href="https://github.com/phil-opp/blog_os/tree/post-01"><code>post-01</code></a>.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>Table des matiÃ¨res</b></summary>
        <ul>
            <li>
                <a href="index.html#introduction">Introduction</a>
                
            </li><li>
                <a href="index.html#desactiver-la-bibliotheque-standard">DÃ©sactiver la BibliothÃ¨que Standard</a>
                <ul>
                    <li>
                        <a href="index.html#l-attribut-no-std">Lâ€™Attribut no_std</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#implementation-de-panic">ImplÃ©mentation de Panic</a>
                
            </li><li>
                <a href="index.html#l-objet-de-langage-eh-personality">Lâ€™Objet de Langage eh_personality</a>
                <ul>
                    <li>
                        <a href="index.html#desactiver-le-deroulement">DÃ©sactiver le DÃ©roulement</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#l-attribut-start">Lâ€™attribut start</a>
                <ul>
                    <li>
                        <a href="index.html#reecrire-le-point-d-entree">RÃ©Ã©crire le Point dâ€™EntrÃ©e</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#erreurs-de-linker">Erreurs de Linker</a>
                <ul>
                    <li>
                        <a href="index.html#compiler-pour-une-cible-bare-metal">Compiler pour une Cible Bare Metal</a>
                    </li><li>
                        <a href="index.html#arguments-du-linker">Arguments du Linker</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#resume">RÃ©sumÃ©</a>
                
            </li><li>
                <a href="index.html#et-ensuite">Et ensuite ?</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">Commentaires</a></li>
        </ul>
    </details>

<h2 id="introduction"><a class="zola-anchor" href="index.html#introduction" aria-label="Anchor link for: introduction">ğŸ”—</a>Introduction</h2>
<p>Pour Ã©crire un noyau de systÃ¨me dâ€™exploitation, nous avons besoin dâ€™un code qui ne dÃ©pend pas de fonctionnalitÃ©s de systÃ¨me dâ€™exploitation. Cela signifie que nous ne pouvons pas utiliser les fils dâ€™exÃ©cution, les fichiers, la mÃ©moire sur le tas, le rÃ©seau, les nombres alÃ©atoires, la sortie standard ou tout autre fonctionnalitÃ© nÃ©cessitant une abstraction du systÃ¨me dâ€™exploitation ou un matÃ©riel spÃ©cifique. Cela a du sens, Ã©tant donnÃ© que nous essayons dâ€™Ã©crire notre propre OS et nos propres pilotes.
Cela signifie que nous ne pouvons pas utiliser la majeure partie de la <a href="https://doc.rust-lang.org/std/">bibliothÃ¨que standard de Rust</a>. Il y a nÃ©anmoins beaucoup de fonctionnalitÃ©s de Rust que nous <em>pouvons</em> utiliser. Par exemple, nous pouvons utiliser les <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">iterators</a>, les <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">closures</a>, le <a href="https://doc.rust-lang.org/book/ch06-00-enums.html">pattern matching</a>, lâ€™<a href="https://doc.rust-lang.org/core/option/">option</a> et le <a href="https://doc.rust-lang.org/core/result/">result</a>, le <a href="https://doc.rust-lang.org/core/macro.write.html">string formatting</a>, et bien-sÃ»r lâ€™<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership system</a>. Ces fonctionnalitÃ©s permettent lâ€™Ã©criture dâ€™un noyau dâ€™une faÃ§on expressive et haut-niveau sans se soucier des [comportements indÃ©finis] ou de la <a href="https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention">sÃ©curitÃ© de la mÃ©moire</a>.</p>
<p>Pour crÃ©er un noyau dâ€™OS en Rust, nous devons crÃ©er un exÃ©cutable qui peut tourner sans systÃ¨me dâ€™exploitation sous-jacent. Un tel exÃ©cutable est appelÃ© â€œfreestandingâ€ (autoportÃ©) ou â€œbare-metalâ€.
Cet article dÃ©crit les Ã©tapes nÃ©cessaires pour crÃ©er un exÃ©cutable Rust autoportÃ© et explique pourquoi ces Ã©tapes sont importantes. Si vous nâ€™Ãªtes intÃ©ressÃ© que par un exemple minimal, vous pouvez <strong><a href="index.html#resume">aller au rÃ©sumÃ©</a></strong>.</p>
<h2 id="desactiver-la-bibliotheque-standard"><a class="zola-anchor" href="index.html#desactiver-la-bibliotheque-standard" aria-label="Anchor link for: desactiver-la-bibliotheque-standard">ğŸ”—</a>DÃ©sactiver la BibliothÃ¨que Standard</h2>
<p>Par dÃ©faut, tous les crates Rust relient la <a href="https://doc.rust-lang.org/std/">bibliothÃ¨que standard</a>, qui dÃ©pend du systÃ¨me dâ€™exploitation pour les fonctionnalitÃ©s telles que les fils dâ€™exÃ©cution, les fichiers ou le rÃ©seau. Elle dÃ©pend aussi de la bibliothÃ¨que standard de C <code>libc</code>, qui intÃ©ragit de prÃ¨s avec les services de lâ€™OS. Comme notre plan est dâ€™Ã©crire un systÃ¨me dâ€™exploitation, nous ne pouvons pas utiliser des bibliothÃ¨ques dÃ©pendant de lâ€™OS. Nous devons donc dÃ©sactiver lâ€™inclusion automatique de la bibliothÃ¨que standard en utilisant lâ€™<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html">attribut <code>no std</code></a>.</p>
<p>Nous commencons par crÃ©er un nouveau projet dâ€™application cargo. La maniÃ¨re la plus simple de faire est avec la ligne de commande : </p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo new blog_os --bin --edition 2018
</span></code></pre>
<p>Jâ€™ai nommÃ© le projet <code>blog_os</code>, mais vous pouvez bien-sÃ»r choisir le nom quâ€™il vous convient. Le flag <code>--bin</code> indique que nous voulons crÃ©er un exÃ©cutable (contrairement Ã  une bibliothÃ¨que) et le flag <code>--edition 2018</code> indique que nous voulons utiliser lâ€™<a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/index.html">Ã©dition 2018</a> de Rust pour notre crate. Quand nous lanÃ§ons la commande, cargo crÃ©e la structure de rÃ©pertoire suivante pour nous :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>blog_os
</span><span>â”œâ”€â”€ Cargo.toml
</span><span>â””â”€â”€ src
</span><span>    â””â”€â”€ main.rs
</span></code></pre>
<p>Le fichier <code>Cargo.toml</code> contient la configuration de la crate, par exemple le nom de la crate, lâ€™auteur, le numÃ©ro de <a href="https://semver.org/">versionnage sÃ©mantique</a> et les dÃ©pendances. Le fichier <code>src/main.rs</code> contient le module racine de notre crate et notre fonction <code>main</code>. Vous pouvez compiler votre crate avec <code>cargo build</code> et ensuite exÃ©cuter lâ€™exÃ©cutable compilÃ© <code>blog_os</code> dans le sous-dossier <code>target/debug</code>.</p>
<h3 id="l-attribut-no-std"><a class="zola-anchor" href="index.html#l-attribut-no-std" aria-label="Anchor link for: l-attribut-no-std">ğŸ”—</a>Lâ€™Attribut <code>no_std</code></h3>
<p>Pour lâ€™instant, notre crate relie la bilbiothÃ¨que standard implicitement. DÃ©sactivons cela en ajoutant lâ€™<a href="https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html">attribut <code>no std</code></a> : </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// main.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Hello, world!&quot;</span><span>);
</span><span>}
</span></code></pre>
<p>Quand nous essayons maintenant de compiler (avec <code>cargo build)</code>, lâ€™erreur suivante se produit :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: cannot find macro `println!` in this scope
</span><span> --&gt; src/main.rs:4:5
</span><span>  |
</span><span>4 |     println!(&quot;Hello, world!&quot;);
</span><span>  |     ^^^^^^^
</span></code></pre>
<p>La raison est que la <a href="https://doc.rust-lang.org/std/macro.println.html">macro <code>println</code></a> fait partie de la bibliothÃ¨que standard, que nous ne pouvons plus utiliser. Nous ne pouvons donc plus afficher de texte avec. Cela est logique, car <code>println</code> Ã©crit dans la <a href="https://fr.wikipedia.org/wiki/Flux_standard#Sortie_standard">sortie standard</a>, qui est un descripteur de fichier spÃ©cial fourni par le systÃ¨me dâ€™eploitation.</p>
<p>Supprimons lâ€™affichage et essayons Ã  nouveau avec une fonction main vide :</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// main.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {}
</span></code></pre>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build
</span><span>error: `#[panic_handler]` function required, but not found
</span><span>error: language item required, but not found: `eh_personality`
</span></code></pre>
<p>Maintenant le compilateur a besoin dâ€™une fonction <code>#[panic_handler]</code> et dâ€™un <em>objet de langage</em>.</p>
<h2 id="implementation-de-panic"><a class="zola-anchor" href="index.html#implementation-de-panic" aria-label="Anchor link for: implementation-de-panic">ğŸ”—</a>ImplÃ©mentation de Panic</h2>
<p>Lâ€™attribut <code>panic_handler</code> dÃ©finit la fonction que le compilateur doit appeler lorsquâ€™un <a href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">panic</a> arrive. La bibliothÃ¨que standard fournit sa propre fonction de gestion de panic mais dans un environnement <code>no_std</code>, nous avons besoin de le dÃ©finir nous-mÃªmes : </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// dans main.rs
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#608b4e;">/// Cette fonction est appelÃ©e Ã  chaque panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>Le <a href="https://doc.rust-lang.org/nightly/core/panic/struct.PanicInfo.html">paramÃ¨tre <code>PanicInfo</code></a> contient le fichier et la ligne oÃ¹ le panic a eu lieu et le message optionnel de panic. La fonction ne devrait jamais retourner quoi que ce soit, elle est donc marquÃ©e comme <a href="https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions">fonction divergente</a> en retournant le <a href="https://doc.rust-lang.org/nightly/std/primitive.never.html">type â€œneverâ€</a> <code>!</code>. Nous ne pouvons pas faire grand chose dans cette fonction pour le moment, nous bouclons donc indÃ©finiment.</p>
<h2 id="l-objet-de-langage-eh-personality"><a class="zola-anchor" href="index.html#l-objet-de-langage-eh-personality" aria-label="Anchor link for: l-objet-de-langage-eh-personality">ğŸ”—</a>Lâ€™Objet de Langage <code>eh_personality</code></h2>
<p>Les objets de langage sont des fonctions et des types spÃ©ciaux qui sont requis par le compilateur de maniÃ¨re interne. Par exemple, le trait <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html"><code>Copy</code></a> est un objet de langage qui indique au compilateur quels types possÃ¨dent la <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html">sÃ©mantique copy</a>. Quand nous regardons lâ€™<a href="https://github.com/rust-lang/rust/blob/485397e49a02a3b7ff77c17e4a3f16c653925cb3/src/libcore/marker.rs#L296-L299">implÃ©mentation</a> du code, nous pouvons voir quâ€™il possÃ¨de lâ€™attribut spÃ©cial <code>#[lang = copy]</code> qui le dÃ©finit comme Ã©tant un objet de langage.</p>
<p>Bien quâ€™il soit possible de fournir des implÃ©mentations personnalisÃ©es des objets de langage, cela ne devrait Ãªtre fait quâ€™en dernier recours. La raison est que les objets de langages sont des dÃ©tails dâ€™implÃ©mentation trÃ¨s instables et qui ne sont mÃªme pas vÃ©rifiÃ©s au niveau de leur type (donc le compilateur ne vÃ©rifie mÃªme pas quâ€™une fonction possÃ¨de les bons types dâ€™arguments). Heureusement, il y a une maniÃ¨re plus robuste de corriger lâ€™erreur dâ€™objet de langage ci-dessus.</p>
<p>Lâ€™<a href="https://github.com/rust-lang/rust/blob/edb368491551a77d77a48446d4ee88b35490c565/src/libpanic_unwind/gcc.rs#L11-L45">objet de langage <code>eh_personality</code></a> marque une fonction qui est utilisÃ©e pour lâ€™implÃ©mentation du <a href="https://docs.microsoft.com/fr-fr/cpp/cpp/exceptions-and-stack-unwinding-in-cpp?view=msvc-160">dÃ©roulement de pile</a>. Par dÃ©faut, Rust utilise le dÃ©roulement de pile pour exÃ©cuter les destructeurs de chaque variable vivante sur la pile en cas de <a href="https://doc.rust-lang.org/stable/book/ch09-01-unrecoverable-errors-with-panic.html">panic</a>. Cela assure que toute la mÃ©moire utilisÃ©e est libÃ©rÃ©e et permet au fil dâ€™exÃ©cution parent dâ€™attraper la panic et de continuer lâ€™exÃ©cution. Le dÃ©roulement toutefois est un processus compliquÃ© et nÃ©cessite des bibliothÃ¨ques spÃ©cifiques Ã  lâ€™OS (<a href="https://www.nongnu.org/libunwind/">libunwind</a> pour Linux ou <a href="https://docs.microsoft.com/fr-fr/windows/win32/debug/structured-exception-handling">gestion structurÃ©e des erreurs</a> pour Windows), nous ne voulons donc pas lâ€™utiliser pour notre systÃ¨me dâ€™exploitation.</p>
<h3 id="desactiver-le-deroulement"><a class="zola-anchor" href="index.html#desactiver-le-deroulement" aria-label="Anchor link for: desactiver-le-deroulement">ğŸ”—</a>DÃ©sactiver le DÃ©roulement</h3>
<p>Il y a dâ€™autres cas dâ€™utilisation pour lesquels le dÃ©roulement nâ€™est pas souhaitÃ©. Rust offre donc une option pour <a href="https://github.com/rust-lang/rust/pull/32900">interrompre aprÃ¨s un panic</a>. Cela dÃ©sactive la gÃ©nÃ©ration de symboles de dÃ©roulement et ainsi rÃ©duit considÃ©rablement la taille de lâ€™exÃ©cutable. Il y a de multiples endroit oÃ¹ nous pouvons dÃ©sactiver le dÃ©roulement. Le plus simple est dâ€™ajouter les lignes suivantes dans notre <code>Cargo.toml</code> :</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">profile.dev</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot;
</span><span>
</span><span>[</span><span style="color:#808080;">profile.release</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot;
</span></code></pre>
<p>Cela configure la stratÃ©gie de panic Ã  <code>abort</code> pour le profil <code>dev</code> (utilisÃ© pour <code>cargo build</code>) et le profil <code>release</code> (utilisÃ© pour <code>cargo build --release</code>). Maintenant lâ€™objet de langage <code>eh_personality</code> ne devrait plus Ãªtre requis. </p>
<p>Nous avons dorÃ©navant corrigÃ© les deux erreurs ci-dessus. Toutefois, si nous essayons de compiler, une autre erreur apparaÃ®t :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build
</span><span>error: requires `start` lang_item
</span></code></pre>
<p>Lâ€™objet de langage <code>start</code> manque Ã  notre programme. Il dÃ©finit le point dâ€™entrÃ©e.</p>
<h2 id="l-attribut-start"><a class="zola-anchor" href="index.html#l-attribut-start" aria-label="Anchor link for: l-attribut-start">ğŸ”—</a>Lâ€™attribut <code>start</code></h2>
<p>On pourrait penser que la fonction <code>main</code> est la premiÃ¨re fonction appelÃ©e lorsquâ€™un programme est exÃ©cutÃ©. Toutefois, la plupart des langages ont un <a href="https://fr.wikipedia.org/wiki/Environnement_d%27ex%C3%A9cution">environnement dâ€™exÃ©cution</a> qui est responsable des tÃ¢ches telles que le ramassage des miettes (ex: dans Java) ou les fils dâ€™exÃ©cution logiciel (ex: les goroutines dans Go). Cet environnement doit Ãªtre appelÃ© avant <code>main</code> puisquâ€™il a besoin de sâ€™initialiser.</p>
<p>Dans un exÃ©cutable Rust classique qui relie la bibliothÃ¨que standard, lâ€™exÃ©cution commence dans une bibliothÃ¨que dâ€™environnement dâ€™exÃ©cution C appelÃ© <code>crt0</code> (â€œC runtime zeroâ€). Elle configure lâ€™environnement pour une application C. Cela comprend la crÃ©ation dâ€™une pile et le placement des arguments dans les bons registres. Lâ€™environnement dâ€™exÃ©cution C appelle ensuite <a href="https://github.com/rust-lang/rust/blob/bb4d1491466d8239a7a5fd68bd605e3276e97afb/src/libstd/rt.rs#L32-L73">le point dâ€™entrÃ©e de lâ€™environnement dâ€™exÃ©cution de Rust</a>, qui est marquÃ© par lâ€™objet de langage <code>start</code>. Rust possÃ¨de un environnement dâ€™exÃ©cution trÃ¨s minime, qui se charge de petites tÃ¢ches telles que la configuration des guardes de dÃ©passement de pile ou lâ€™affichage de la trace dâ€™appels lors dâ€™un panic. Lâ€™environnement dâ€™exÃ©cution finit par appeler la fonction <code>main</code>.</p>
<p>Notre exÃ©cutable autoportÃ© nâ€™a pas accÃ¨s Ã  lâ€™environnement dâ€™exÃ©cution de Rust ni Ã  <code>crt0</code>. Nous avons donc besoin de dÃ©finir notre propre point dâ€™entrÃ©e. ImplÃ©menter lâ€™objet de langage <code>start</code> nâ€™aiderait pas car nous aurions toujours besoin de <code>crt0</code>. Nous avons plutÃ´t besoin de rÃ©Ã©crire le point dâ€™entrÃ©e de <code>crt0</code> directement.</p>
<h3 id="reecrire-le-point-d-entree"><a class="zola-anchor" href="index.html#reecrire-le-point-d-entree" aria-label="Anchor link for: reecrire-le-point-d-entree">ğŸ”—</a>RÃ©Ã©crire le Point dâ€™EntrÃ©e</h3>
<p>Pour indiquer au compilateur que nous ne voulons pas utiliser la chaÃ®ne de point dâ€™entrÃ©e normale, nous ajoutons lâ€™attribut <code>#![no_main]</code>. </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#608b4e;">/// Cette fonction est appelÃ©e Ã  chaque panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>Vous remarquerez peut-Ãªtre que nous avons retirÃ© la fonction <code>main</code>. La raison est que la prÃ©sence de cette fonction nâ€™a pas de sens sans un environnement dâ€™exÃ©cution sous-jacent qui lâ€™appelle. Ã€ la place, nous rÃ©Ã©crivons le point dâ€™entrÃ©e du systÃ¨me dâ€™exploitation avec notre propre fonction <code>_start</code> :</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>En utilisant lâ€™attribut <code>#[no_mangle]</code>, nous dÃ©sactivons la <a href="https://fr.wikipedia.org/wiki/D%C3%A9coration_de_nom">dÃ©coration de nom</a> pour assurer que le compilateur Rust crÃ©e une fonction avec le nom <code>_start</code>. Sans cet attribut, le compilateur gÃ©nÃ¨rerait un symbol obscure <code>_ZN3blog_os4_start7hb173fedf945531caE</code> pour donner un nom unique Ã  chaque fonction. Lâ€™attribut est nÃ©cessaire car nous avons besoin dâ€™indiquer le nom de la fonction de point dâ€™entrÃ©e Ã  lâ€™Ã©diteur de lien (<em>linker</em>) dans lâ€™Ã©tape suivante.</p>
<p>Nous devons aussi marquer la fonction avec <code>extern C</code> pour indiquer au compilateur quâ€™il devrait utiliser la <a href="https://fr.wikipedia.org/wiki/Convention_de_nommage">convention de nommage</a> de C pour cette fonction (au lieu de la convention de nommage de Rust non-spÃ©cifiÃ©e). Cette fonction se nomme <code>_start</code> car câ€™est le nom par dÃ©faut des points dâ€™entrÃ©e pour la plupart des systÃ¨mes.</p>
<p>Le type de retour <code>!</code> signifie que la fonction est divergente, c-Ã -d quâ€™elle nâ€™a pas le droit de retourner quoi que ce soit. Cela est nÃ©cessaire car le point dâ€™entrÃ©e nâ€™est pas appelÃ© par une fonction, mais invoquÃ© directement par le systÃ¨me dâ€™exploitation ou par le chargeur dâ€™amorÃ§age. Donc au lieu de retourner une valeur, le point dâ€™entrÃ©e doit invoquer lâ€™<a href="https://fr.wikipedia.org/wiki/Appel_syst%C3%A8me">appel systÃ¨me <code>exit</code></a> du systÃ¨me dâ€™exploitation. Dans notre cas, arrÃªter la machine pourrait Ãªtre une action convenable, puisquâ€™il ne reste rien dâ€™autre Ã  faire si un exÃ©cutable autoportÃ© sâ€™arrÃªte. Pour lâ€™instant, nous remplissons la condition en bouclant indÃ©finiement.</p>
<p>Quand nous lanÃ§ons <code>cargo build</code>, nous obtenons une erreur de <em>linker</em>.</p>
<h2 id="erreurs-de-linker"><a class="zola-anchor" href="index.html#erreurs-de-linker" aria-label="Anchor link for: erreurs-de-linker">ğŸ”—</a>Erreurs de Linker</h2>
<p>Le linker est un programme qui va transformer le code gÃ©nÃ©rÃ© en exÃ©cutable. Comme le format de lâ€™exÃ©cutable differt entre Linux, Windows et macOS, chaque systÃ¨me possÃ¨de son propre linker qui lÃ¨ve une erreur diffÃ©rente. La cause fondamentale de cette erreur est la mÃªme : la configuration par dÃ©faut du linker part du principe que notre programme dÃ©pend de lâ€™environnement dâ€™exÃ©cution de C, ce qui nâ€™est pas le cas.</p>
<p>Pour rÃ©soudre les erreurs, nous devons indiquer au linker quâ€™il ne doit pas inclure lâ€™environnement dâ€™exÃ©cution de C. Nous pouvons faire cela soit en passant un ensemble prÃ©cis dâ€™arguments, soit en compilant pour une cible bare metal.</p>
<h3 id="compiler-pour-une-cible-bare-metal"><a class="zola-anchor" href="index.html#compiler-pour-une-cible-bare-metal" aria-label="Anchor link for: compiler-pour-une-cible-bare-metal">ğŸ”—</a>Compiler pour une Cible Bare Metal</h3>
<p>Par dÃ©faut Rust essaie de compiler un exÃ©cutable qui est compatible avec lâ€™environnment du systÃ¨me actuel. Par exemple, si vous utilisez Windows avec <code>x86_64</code>, Rust essaie de compiler un exÃ©cutable Windows <code>.exe</code> qui utilises des instructions <code>x86_64</code>. Cet environnement est appelÃ© systÃ¨me â€œhÃ´teâ€.</p>
<p>Pour dÃ©crire plusieurs environnements, Rust utilise une chaÃ®ne de caractÃ¨res appelÃ©e <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple"><em>triplÃ© cible</em></a>. Vous pouvez voir le triplÃ© cible de votre systÃ¨me hÃ´te en lanÃ§ant la commande <code>rustc --version --verbose</code> :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>rustc 1.35.0-nightly (474e7a648 2019-04-07)
</span><span>binary: rustc
</span><span>commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
</span><span>commit-date: 2019-04-07
</span><span>host: x86_64-unknown-linux-gnu
</span><span>release: 1.35.0-nightly
</span><span>LLVM version: 8.0
</span></code></pre>
<p>La sortie ci-dessus provient dâ€™un systÃ¨me Linux <code>x86_64</code>. Nous pouvons voir que le triplÃ© <code>host</code> est <code>x86_64-unknown-linux-gnu</code>, qui inclut lâ€™architecture du CPU (<code>x86_64</code>), le vendeur (<code>unknown</code>), le systÃ¨me dâ€™exploitation (<code>linux</code>) et lâ€™<a href="https://fr.wikipedia.org/wiki/Application_binary_interface">ABI</a> (<code>gnu</code>).</p>
<p>En compilant pour notre triplÃ© hÃ´te, le compilateur Rust ainsi que le linker supposent quâ€™il y a un systÃ¨me dâ€™exploitation sous-jacent comme Linux ou Windows qui utilise lâ€™environnement dâ€™exÃ©cution C par dÃ©faut, ce qui cause les erreurs de linker. Donc pour Ã©viter ces erreurs, nous pouvons compiler pour un environnement diffÃ©rent sans systÃ¨me dâ€™exploitation sous-jacent.</p>
<p>Un exemple dâ€™un tel envrironnement est le triplÃ© cible <code>thumbv7em-none-eabihf</code>, qui dÃ©crit un systÃ¨me <a href="https://fr.wikipedia.org/wiki/Architecture_ARM">ARM</a> <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_embarqu%C3%A9">embarquÃ©</a>. Les dÃ©tails ne sont pas importants, tout ce qui compte est que le triplÃ© cible nâ€™a pas de systÃ¨me dâ€™exploitation sous-jacent, ce qui est indiquÃ© par le <code>none</code> dans le triplÃ© cible. Pour pouvoir compiler pour cette cible, nous avons besoin de lâ€™ajouter dans rustup :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>rustup target add thumbv7em-none-eabihf
</span></code></pre>
<p>Cela tÃ©lÃ©charge une copie de la bibliothÃ¨que standard (et core) pour le systÃ¨me. Maintenant nous pouvons compiler notre exÃ©cutable autoportÃ© pour cette cible :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo build --target thumbv7em-none-eabihf
</span></code></pre>
<p>En donnant un argument <code>--target</code>, nous effectuons une [compilation croisÃ©e][cross_compile] de notre exÃ©cutable pour un systÃ¨me bare metal. Comme le systÃ¨me cible nâ€™a pas de systÃ¨me dâ€™exploitation, le linker nâ€™essaie pas de lier lâ€™environnement dâ€™exÃ©cution C et notre compilation rÃ©ussit sans erreur de linker.</p>
<p>Câ€™est lâ€™approche que nous allons utiliser pour construire notre noyau dâ€™OS. PlutÃ´t que <code>thumbv7em-none-eabihf</code>, nous allons utiliser une <a href="https://doc.rust-lang.org/rustc/targets/custom.html">cible personnalisÃ©e</a> qui dÃ©crit un environnement bare metal <code>x86_64</code>. Les dÃ©tails seront expliquÃ©s dans le prochain article.</p>
<h3 id="arguments-du-linker"><a class="zola-anchor" href="index.html#arguments-du-linker" aria-label="Anchor link for: arguments-du-linker">ğŸ”—</a>Arguments du Linker</h3>
<p>Au lieu de compiler pour un systÃ¨me bare metal, il est aussi possible de rÃ©soudre les erreurs de linker en passant un ensemble prÃ©cis dâ€™arguments au linker. Ce nâ€™est pas lâ€™approche que nous allons utiliser pour notre noyau. Cette section est donc optionnelle et fournis uniquement Ã  titre de complÃ©tude. Cliquez sur <em>â€œArguments du Linkerâ€</em> ci-dessous pour montrer le contenu optionel.</p>
<details>
<summary>Arguments du Linker</summary>
<p>Dans cette section nous allons parler des erreurs de linker qui se produisent sur Linux, Windows et macOS. Nous allons aussi apprendre Ã  rÃ©soudre ces erreurs en passant des arguments complÃ©mentaires au linker. Ã€ noter que le format de lâ€™exÃ©cutable et le linker diffÃ¨rent entre les systÃ¨mes dâ€™exploitation. Il faut donc un ensemble dâ€™arguments diffÃ©rent pour chaque systÃ¨me.</p>
<h4 id="linux"><a class="zola-anchor" href="index.html#linux" aria-label="Anchor link for: linux">ğŸ”—</a>Linux</h4>
<p>Sur Linux, voici lâ€™erreur de linker qui se produit (raccourcie) :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; [â€¦]
</span><span>  = note: /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x12): undefined reference to `__libc_csu_fini&#39;
</span><span>          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x19): undefined reference to `__libc_csu_init&#39;
</span><span>          /usr/lib/gcc/../x86_64-linux-gnu/Scrt1.o: In function `_start&#39;:
</span><span>          (.text+0x25): undefined reference to `__libc_start_main&#39;
</span><span>          collect2: error: ld returned 1 exit status
</span></code></pre>
<p>Le problÃ¨me est que le linker inclut par dÃ©faut la routine de dÃ©marrage de lâ€™environnement dâ€™exÃ©cution de C, qui est aussi appelÃ©e <code>_start</code>. Elle requiert des symboles de la bibliothÃ¨que standard de C <code>libc</code> que nous nâ€™incluons pas Ã  cause de lâ€™attribut <code>no_std</code>. Le linker ne peut donc pas rÃ©soudre ces rÃ©fÃ©rences. Pour rÃ©soudre cela, nous pouvons indiquer au linker quâ€™il ne devrait pas lier la routine de dÃ©marrage de C en passant lâ€™argument <code>-nostartfiles</code>.</p>
<p>Une faÃ§on de passer des attributs au linker via cargo est la commande <code>cargo rustc</code>. Cette commande se comporte exactement comme <code>cargo build</code>, mais permet aussi de donner des options Ã  <code>rustc</code>, le compilateur Rust sous-jacent. <code>rustc</code> possÃ¨de le flag <code>-C link-arg</code>, qui donne un argument au linker. CombinÃ©s, notre nouvelle commande ressemble Ã  ceci :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-arg=-nostartfiles
</span></code></pre>
<p>DorÃ©navant notre crate compile en tant quâ€™exÃ©cutable Linux autoportÃ© !</p>
<p>Nous nâ€™avions pas besoin de spÃ©cifier le nom de notre point dâ€™entrÃ©e de faÃ§on explicite car le linker cherche par dÃ©faut une fonction nommÃ©e <code>_start</code>. </p>
<h4 id="windows"><a class="zola-anchor" href="index.html#windows" aria-label="Anchor link for: windows">ğŸ”—</a>Windows</h4>
<p>Sur Windows, une erreur de linker diffÃ©rente se produit (raccourcie) :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `link.exe` failed: exit code: 1561
</span><span>  |
</span><span>  = note: &quot;C:\\Program Files (x86)\\â€¦\\link.exe&quot; [â€¦]
</span><span>  = note: LINK : fatal error LNK1561: entry point must be defined
</span></code></pre>
<p>Cette erreur signifie que le linker ne peut pas trouver le point dâ€™entrÃ©e. Sur Windows, le nom par dÃ©faut du point dâ€™entrÃ©e <a href="https://docs.microsoft.com/fr-fr/cpp/build/reference/entry-entry-point-symbol?view=msvc-160">dÃ©pend du sous-systÃ¨me utilisÃ©</a>. Pour le sous-systÃ¨me <code>CONSOLE</code>, le linker cherche une fonction nommÃ©e <code>mainCRTStartup</code> et pour le sous-systÃ¨me <code>WINDOWS</code>, il cherche une fonction nomÃ©e <code>WinMainCRTStartup</code>. Pour rÃ©Ã©crire la valeur par dÃ©faut et indiquer au linker de chercher notre fonction <code>_start</code> Ã  la place, nous pouvons donner lâ€™argument <code>/ENTRY</code> au linker :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-arg=/ENTRY:_start
</span></code></pre>
<p>Vu le format dâ€™argument diffÃ©rent nous pouvons clairement voir que le linker Windows est un programme totalement diffÃ©rent du linker Linux.</p>
<p>Maintenant une erreur de linker diffÃ©rente se produit :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `link.exe` failed: exit code: 1221
</span><span>  |
</span><span>  = note: &quot;C:\\Program Files (x86)\\â€¦\\link.exe&quot; [â€¦]
</span><span>  = note: LINK : fatal error LNK1221: a subsystem can&#39;t be inferred and must be
</span><span>          defined
</span></code></pre>
<p>Cette erreur se produit car les exÃ©cutables Windows peuvent utiliser diffÃ©rents <a href="https://docs.microsoft.com/fr-fr/cpp/build/reference/entry-entry-point-symbol?view=msvc-160">sous-systÃ¨mes</a>. Pour les programmes normaux, ils sont infÃ©rÃ©s en fonction du nom du point dâ€™entrÃ©e : sâ€™il est nommÃ© <code>main</code>, le sous-systÃ¨me <code>CONSOLE</code> est utilisÃ©. Si le point dâ€™entrÃ©e est nommÃ© <code>WinMain</code>, alors le sous-sytÃ¨me <code>WINDOWS</code> est utilisÃ©.  Comme notre fonction <code>_start</code> possÃ¨de un nom diffÃ©rent, nous devons prÃ©ciser le sous-systÃ¨me explicitement :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;/ENTRY:_start /SUBSYSTEM:console&quot;
</span></code></pre>
<p>Ici nous utilisons le sous-systÃ¨me <code>CONSOLE</code>, mais le sous-systÃ¨me <code>WINDOWS</code> pourrait fonctionner aussi. Au lieu de donner <code>-C link-arg</code> plusieurs fois, nous utilisons <code>-C link-args</code> qui utilise des arguments sÃ©parÃ©s par des espaces.</p>
<p>Avec cette commande, notre exÃ©cutable devrait compiler avec succÃ¨s sous Windows.</p>
<h4 id="macos"><a class="zola-anchor" href="index.html#macos" aria-label="Anchor link for: macos">ğŸ”—</a>macOS</h4>
<p>Sur macOS, voici lâ€™erreur de linker qui se produit (raccourcie) :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; [â€¦]
</span><span>  = note: ld: entry point (_main) undefined. for architecture x86_64
</span><span>          clang: error: linker command failed with exit code 1 [â€¦]
</span></code></pre>
<p>Cette erreur nous indique que le linker ne peut pas trouver une fonction de point dâ€™entrÃ©e avec le nom par dÃ©faut <code>main</code> (pour une quelconque raison, toutes les fonctions sur macOS sont prÃ©cÃ©dÃ©es de <code>_</code>). Pour configurer le point dâ€™entrÃ©e sur notre fonction <code>_start</code>, nous donnons lâ€™argument <code>-e</code> au linker :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start&quot;
</span></code></pre>
<p>Lâ€™argument <code>-e</code> spÃ©cifie le nom de la fonction de point dâ€™entrÃ©e. Comme toutes les fonctions ont un prÃ©fixe supplÃ©mentaire <code>_</code> sur macOS, nous devons configurer le point dâ€™entrÃ©e comme Ã©tant <code>__start</code> au lieu de <code>_start</code>.</p>
<p>Maintenant lâ€™erreur de linker suivante se produit :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; [â€¦]
</span><span>  = note: ld: dynamic main executables must link with libSystem.dylib
</span><span>          for architecture x86_64
</span><span>          clang: error: linker command failed with exit code 1 [â€¦]
</span></code></pre>
<p>macOS <a href="https://developer.apple.com/library/archive/qa/qa1118/_index.html">ne supporte pas officiellement les bibliothÃ¨ques liÃ©es de faÃ§on statique</a> et necÃ©essite que les programmes lient la bibliothÃ¨que <code>libSystem</code> par dÃ©faut. Pour rÃ©Ã©crire ceci et lier une bibliothÃ¨que statique, nous donnons lâ€™argument <code>-static</code> au linker :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start -static&quot;
</span></code></pre>
<p>Cela ne suffit toujours pas, une troisiÃ¨me erreur de linker se produit :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>error: linking with `cc` failed: exit code: 1
</span><span>  |
</span><span>  = note: &quot;cc&quot; [â€¦]
</span><span>  = note: ld: library not found for -lcrt0.o
</span><span>          clang: error: linker command failed with exit code 1 [â€¦]
</span></code></pre>
<p>Cette erreur se produit car les programmes sous macOS lient <code>crt0</code> (â€œC runtime zeroâ€) par dÃ©faut. Ceci est similaire Ã  lâ€™erreur que nous avions eu sous Linux et peut aussi Ãªtre rÃ©solue en ajoutant lâ€™argument <code>-nostartfiles</code> au linker :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo rustc -- -C link-args=&quot;-e __start -static -nostartfiles&quot;
</span></code></pre>
<p>Maintenant notre programme compile avec succÃ¨s sous macOS.</p>
<h4 id="unifier-les-commandes-de-compilation"><a class="zola-anchor" href="index.html#unifier-les-commandes-de-compilation" aria-label="Anchor link for: unifier-les-commandes-de-compilation">ğŸ”—</a>Unifier les Commandes de Compilation</h4>
<p>Ã€ cet instant nous avons diffÃ©rentes commandes de compilation en fonction de la plateforme hÃ´te, ce qui nâ€™est pas idÃ©al. Pour Ã©viter cela, nous pouvons crÃ©er un ficher nommÃ© <code>.cargo/config.toml</code> qui contient les arguments spÃ©cifiques aux plateformes :</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;linux&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-arg=-nostartfiles&quot;</span><span>]
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;windows&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-args=/ENTRY:_start /SUBSYSTEM:console&quot;</span><span>]
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;macos&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">rustflags </span><span>= [</span><span style="color:#d69d85;">&quot;-C&quot;</span><span>, </span><span style="color:#d69d85;">&quot;link-args=-e __start -static -nostartfiles&quot;</span><span>]
</span></code></pre>
<p>La clÃ© <code>rustflags</code> contient des arguments qui sont automatiquement ajoutÃ©s Ã  chaque appel de <code>rustc</code>. Pour plus dâ€™informations sur le fichier <code>.cargo/config.toml</code>, allez voir la <a href="https://doc.rust-lang.org/cargo/reference/config.html">documentation officielle</a></p>
<p>Maintenant notre programme devrait Ãªtre compilable sur les trois plateformes avec un simple <code>cargo build</code>.</p>
<h4 id="devriez-vous-faire-ca"><a class="zola-anchor" href="index.html#devriez-vous-faire-ca" aria-label="Anchor link for: devriez-vous-faire-ca">ğŸ”—</a>Devriez-vous Faire Ã‡a ?</h4>
<p>Bien quâ€™il soit possible de compiler un exÃ©cutable autoportÃ© pour Linux, Windows et macOS, ce nâ€™est probablement pas une bonne idÃ©e. La raison est que notre exÃ©cutable sâ€™attend toujours Ã  trouver certaines choses, par exemple une pile initialisÃ©e lorsque la fonction <code>_start</code> est appelÃ©e. Sans lâ€™environnement dâ€™exÃ©cution C, certaines de ces conditions peuvent ne pas Ãªtre remplies, ce qui pourrait faire planter notre programme, avec par exemple une erreur de segmentation.</p>
<p>Si vous voulez crÃ©er un exÃ©cutable minimal qui tourne sur un systÃ¨me dâ€™exploitation existant, include <code>libc</code> et mettre lâ€™attribut <code>#[start]</code> come dÃ©crit <a href="https://doc.rust-lang.org/1.16.0/book/no-stdlib.html">ici</a> semble Ãªtre une meilleure idÃ©e.</p>
</details>
<h2 id="resume"><a class="zola-anchor" href="index.html#resume" aria-label="Anchor link for: resume">ğŸ”—</a>RÃ©sumÃ©</h2>
<p>Un exÃ©cutable Rust autoportÃ© minimal ressemble Ã  ceci :</p>
<p><code>src/main.rs</code>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![no_std] </span><span style="color:#608b4e;">// ne pas lier la bibliothÃ¨que standard Rust
</span><span>#![no_main] </span><span style="color:#608b4e;">// dÃ©sactiver tous les points d&#39;entrÃ©e au niveau de Rust
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// ne pas dÃ©corer le nom de cette fonction
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#608b4e;">// cette fonction est le point d&#39;entrÃ©e, comme le linker cherche une fonction
</span><span>    </span><span style="color:#608b4e;">// nomÃ©e `_start` par dÃ©faut
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#608b4e;">/// Cette fonction est appelÃ©e Ã  chaque panic.
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p><code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[</span><span style="color:#808080;">package</span><span>]
</span><span style="color:#569cd6;">name </span><span>= </span><span style="color:#d69d85;">&quot;crate_name&quot;
</span><span style="color:#569cd6;">version </span><span>= </span><span style="color:#d69d85;">&quot;0.1.0&quot;
</span><span style="color:#569cd6;">authors </span><span>= [</span><span style="color:#d69d85;">&quot;Author Name &lt;author@example.com&gt;&quot;</span><span>]
</span><span>
</span><span style="color:#608b4e;"># le profile utilisÃ© pour `cargo build`
</span><span>[</span><span style="color:#808080;">profile.dev</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot; </span><span style="color:#608b4e;"># dÃ©sactive le dÃ©roulement de la pile lors d&#39;un panic
</span><span>
</span><span style="color:#608b4e;"># le profile utilisÃ© pour `cargo build --release`
</span><span>[</span><span style="color:#808080;">profile.release</span><span>]
</span><span style="color:#569cd6;">panic </span><span>= </span><span style="color:#d69d85;">&quot;abort&quot; </span><span style="color:#608b4e;"># dÃ©sactive le dÃ©roulement de la pile lors d&#39;un panic
</span></code></pre>
<p>Pour compiler cet exÃ©cutable, nous devons compiler pour une cible bare metal telle que <code>thumbv7em-none-eabihf</code> :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo build --target thumbv7em-none-eabihf
</span></code></pre>
<p>Sinon, nous pouvons aussi compiler pour le systÃ¨me hÃ´te en donnant des arguments supplÃ©mentaires pour le linker :</p>
<pre data-lang="bash" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#608b4e;"># Linux
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-arg=-nostartfiles
</span><span style="color:#608b4e;"># Windows
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-args=</span><span style="color:#d69d85;">&quot;/ENTRY:_start /SUBSYSTEM:console&quot;
</span><span style="color:#608b4e;"># macOS
</span><span>cargo rustc</span><span style="color:#569cd6;"> --</span><span> -C link-args=</span><span style="color:#d69d85;">&quot;-e __start -static -nostartfiles&quot;
</span></code></pre>
<p>Ã€ noter que ceci est juste un exemple minimal dâ€™un exÃ©cutable Rust autoportÃ©. Cet exÃ©cutable sâ€™attend Ã  de nombreuses choses, comme par exemple le fait quâ€™une pile soit initialisÃ©e lorsque la fonction <code>_start</code> est appelÃ©e. <strong>Donc pour une rÃ©elle utilisation dâ€™un tel exÃ©cutable, davantages dâ€™Ã©tapes sont requises.</strong></p>
<h2 id="et-ensuite"><a class="zola-anchor" href="index.html#et-ensuite" aria-label="Anchor link for: et-ensuite">ğŸ”—</a>Et ensuite ?</h2>
<p>Le <a href="../../minimal-rust-kernel/index.html">poste suivant</a> explique les Ã©tapes nÃ©cessaires pour transformer notre exÃ©cutable autoportÃ© minimal en noyau de systÃ¨me dâ€™opÃ©ration. Cela comprend la crÃ©ation dâ€™une cible personnalisÃ©e, lâ€™intÃ©gration de notre exÃ©cutable avec un chargeur dâ€™amorÃ§age et lâ€™apprentissage de comment imprimer quelque chose sur lâ€™Ã©cran.</p>

    </div>

    <div class="post-footer-support">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
        
            <a class="next" href="../minimal-rust-kernel/index.html">Un noyau Rust minimal &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="">Commentaires</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Freestanding%20Rust%20Binary%20%28fr%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="A Freestanding Rust Binary (fr)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fr"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Freestanding%20Rust%20Binary%20%28fr%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="">
            Veuillez commenter en Anglais si possible.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../freestanding-rust-binary/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/freestanding-rust-binary/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="zh-TW" class=""><a href="../../zh-TW/freestanding-rust-binary/index.html">
                        Chinese (traditional)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/freestanding-rust-binary/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="fa" class=""><a href="../../fa/freestanding-rust-binary/index.html">
                        Persian
                    </a></li><li data-lang-switch-to="ru" class=""><a href="../../ru/freestanding-rust-binary/index.html">
                        Russian
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/freestanding-rust-binary/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
