<!doctype html>

<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <meta name="description" content="Dans cet article, nous cr√©ons un noyau Rust 64-bit minimal pour l‚Äôarchitecture x86. Nous continuons le travail fait dans l‚Äôarticle pr√©c√©dent ‚ÄúUn binai‚Ä¶">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="index.html" />
    
    <link href="../../css/edition-2/main.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="RSS feed for os.phil-opp.com" href="../../rss.xml" />

    <script>
        let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }
    </script>

    <script async src="../../js/edition-2/main.js"></script>

    <title>Un noyau Rust minimal | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h2 class="masthead-title">
                    <a href="../../index.html" title="Home">Writing an OS in Rust</a>
                </h2>
                <p><small>Philipp&nbsp;Oppermann's&nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https://os.phil-opp.com/fr" title="All Posts">¬´ Tous les articles</a></aside>

            </div>
        </header>

        <div class="theme-switch">
            <div class="light-switch" onclick="toggle_lights()" title="Switch between light and dark theme"></div>
            <div class="light-switch-reset" onclick="clear_theme_override()" title="Clear the theme override and go back to the system theme"></div>
        </div>

        <div>
            
<aside id="toc-aside" class="">
        <h2>Table des mati√®res</h2>
    <ol>
        <li>
            <a href="index.html#le-processus-d-amorcage">Le processus d‚Äôamor√ßage</a>
            <ol>
                <li>
                    <a href="index.html#amorcage-bios">Amor√ßage BIOS</a>
                </li><li>
                    <a href="index.html#uefi">UEFI</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#un-noyau-minimal">Un noyau minimal</a>
            <ol>
                <li>
                    <a href="index.html#installer-une-version-nocturne-de-rust">Installer une version nocturne de Rust</a>
                </li><li>
                    <a href="index.html#specification-de-la-cible">Sp√©cification de la cible</a>
                </li><li>
                    <a href="index.html#construction-de-notre-noyau">Construction de notre noyau</a>
                </li><li>
                    <a href="index.html#afficher-a-l-ecran">Afficher √† l‚Äô√©cran</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#executer-notre-noyau">Ex√©cuter notre noyau</a>
            <ol>
                <li>
                    <a href="index.html#creer-une-image-d-amorcage">Cr√©er une image d‚Äôamor√ßage</a>
                </li><li>
                    <a href="index.html#amorcage-dans-qemu">Amor√ßage dans QEMU</a>
                </li><li>
                    <a href="index.html#veritable-ordinateur">V√©ritable ordinateur</a>
                </li><li>
                    <a href="index.html#utilisation-de-cargo-run">Utilisation de cargo run</a>
                </li>
            </ol>
        </li><li>
            <a href="index.html#et-ensuite">Et ensuite?</a>
            
        </li>
        <li class="toc-comments-link"><a href="index.html#comments">Commentaires</a></li>
    </ol>
</aside>

            <main>
    <div class="">
    <h1>Un noyau Rust minimal</h1>
    <time datetime="2018-02-10" class="post-date">
        Feb 10, 2018
        
    </time>
    </div>

    
        <div class="warning">
            
            
            <p>
            <b>Contenu traduit : </b>
            Ceci est une traduction communautaire de l'article <strong><a href="../../minimal-rust-kernel/index.html">A Minimal Rust Kernel</a></strong>. Il peut √™tre incomplet, obsol√®te ou contenir des erreurs. Veuillez signaler les quelconques probl√®mes !
            </p>
            <p>
                Traduit par :  <a href="https://github.com/TheMimiCodes">@TheMimiCodes</a> et <a href="https://github.com/maximevaillancourt">@maximevaillancourt</a>.
                <span class="translation_contributors">
                    With contributions from <a href="https://github.com/alaincao">@alaincao</a>.
                </span>
                </p>
            </div>
    

    <div class="">
    <p>Dans cet article, nous cr√©ons un noyau Rust 64-bit minimal pour l‚Äôarchitecture x86. Nous continuons le travail fait dans l‚Äôarticle pr√©c√©dent ‚Äú<a href="../freestanding-rust-binary/index.html">Un binaire Rust autonome</a>‚Äù pour cr√©er une image de disque amor√ßable qui affiche quelque chose √† l‚Äô√©cran. </p>
<span id="continue-reading"></span>
<p>Cet article est d√©velopp√© de mani√®re ouverte sur <a href="https://github.com/phil-opp/blog_os">GitHub</a>. Si vous avez des probl√®mes ou des questions, veuillez ouvrir une <em>Issue</em> sur GitHub. Vous pouvez aussi laisser un commentaire <a href="index.html#comments">au bas de la page</a>. Le code source complet pour cet article se trouve dans la branche <a href="https://github.com/phil-opp/blog_os/tree/post-02"><code>post-02</code></a>.</p>
<!-- fix for zola anchor checker (target is in template): <a id="comments"> -->

    <details id = "toc-inline">
        <summary><b>Table des mati√®res</b></summary>
        <ul>
            <li>
                <a href="index.html#le-processus-d-amorcage">Le processus d‚Äôamor√ßage</a>
                <ul>
                    <li>
                        <a href="index.html#amorcage-bios">Amor√ßage BIOS</a>
                    </li><li>
                        <a href="index.html#uefi">UEFI</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#un-noyau-minimal">Un noyau minimal</a>
                <ul>
                    <li>
                        <a href="index.html#installer-une-version-nocturne-de-rust">Installer une version nocturne de Rust</a>
                    </li><li>
                        <a href="index.html#specification-de-la-cible">Sp√©cification de la cible</a>
                    </li><li>
                        <a href="index.html#construction-de-notre-noyau">Construction de notre noyau</a>
                    </li><li>
                        <a href="index.html#afficher-a-l-ecran">Afficher √† l‚Äô√©cran</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#executer-notre-noyau">Ex√©cuter notre noyau</a>
                <ul>
                    <li>
                        <a href="index.html#creer-une-image-d-amorcage">Cr√©er une image d‚Äôamor√ßage</a>
                    </li><li>
                        <a href="index.html#amorcage-dans-qemu">Amor√ßage dans QEMU</a>
                    </li><li>
                        <a href="index.html#veritable-ordinateur">V√©ritable ordinateur</a>
                    </li><li>
                        <a href="index.html#utilisation-de-cargo-run">Utilisation de cargo run</a>
                    </li>
                </ul>
            </li><li>
                <a href="index.html#et-ensuite">Et ensuite?</a>
                
            </li>
            <li class="toc-comments-link"><a href="index.html#comments">Commentaires</a></li>
        </ul>
    </details>

<h2 id="le-processus-d-amorcage"><a class="zola-anchor" href="index.html#le-processus-d-amorcage" aria-label="Anchor link for: le-processus-d-amorcage">üîó</a>Le processus d‚Äôamor√ßage</h2>
<p>Quand vous allumez un ordinateur, il commence par ex√©cuter le code du micrologiciel qui est enregistr√© dans la carte m√®re (<a href="https://fr.wikipedia.org/wiki/M%C3%A9moire_morte">ROM</a>). Ce code performe un <a href="https://fr.wikipedia.org/wiki/Power-on_self-test_(informatique)">test d‚Äôauto-diagnostic de d√©marrage</a>, d√©tecte la m√©moire volatile disponible, et pr√©-initialise le processeur et le mat√©riel. Par la suite, il recherche un disque amor√ßable et commence le processus d‚Äôamor√ßage du noyau du syst√®me d‚Äôexploitation.</p>
<p>Sur x86, il existe deux standards pour les micrologiciels : le ‚ÄúBasic Input/Output System‚Äú (<strong><a href="https://fr.wikipedia.org/wiki/BIOS_(informatique)">BIOS</a></strong>) et le nouvel ‚ÄúUnified Extensible Firmware Interface‚Äù (<strong><a href="https://fr.wikipedia.org/wiki/UEFI">UEFI</a></strong>). Le BIOS standard est vieux et d√©pass√©, mais il est simple et bien support√© sur toutes les machines x86 depuis les ann√©es 1980. Au contraire, l‚ÄôUEFI est moderne et offre davantage de fonctionnalit√©s. Cependant, il est plus complexe √† installer (du moins, selon moi).</p>
<p>Actuellement, nous offrons seulement un support BIOS, mais nous planifions aussi du support pour l‚ÄôUEFI. Si vous aimeriez nous aider avec cela, consultez l‚Äô<a href="https://github.com/phil-opp/blog_os/issues/349"><em>issue</em> sur GitHub</a>.</p>
<h3 id="amorcage-bios"><a class="zola-anchor" href="index.html#amorcage-bios" aria-label="Anchor link for: amorcage-bios">üîó</a>Amor√ßage BIOS</h3>
<p>Presque tous les syst√®mes x86 peuvent amorcer le BIOS, y compris les nouvelles machines UEFI qui utilisent un BIOS √©mul√©. C‚Äôest une bonne chose car cela permet d‚Äôutiliser la m√™me logique d‚Äôamor√ßage sur toutes les machines du dernier si√®cle. Cependant, cette grande compatibilit√© est aussi le plus grand inconv√©nient de l‚Äôamor√ßage BIOS, car cela signifie que le CPU est mis dans un mode de compatibilit√© 16-bit appel√© <em><a href="https://fr.wikipedia.org/wiki/Mode_r%C3%A9el">real mode</a></em> avant l‚Äôamor√ßage afin que les bootloaders archa√Øques des ann√©es 1980 puissent encore fonctionner. </p>
<p>Mais commen√ßons par le commencement :</p>
<p>Quand vous allumez votre ordinateur, il charge le BIOS provenant d‚Äôun emplacement de m√©moire flash sp√©ciale localis√©e sur la carte m√®re. Le BIOS ex√©cute des tests d‚Äôauto-diagnostic et des routines d‚Äôinitialisation du mat√©riel, puis il cherche des disques amor√ßables. S‚Äôil en trouve un, le contr√¥le est transf√©r√© √† son <em>bootloader</em>, qui est une portion de 512 octets de code ex√©cutable enregistr√© au d√©but du disque. Vu que la plupart des bootloaders d√©passent 512 octets, ils sont g√©n√©ralement divis√©s en deux phases: la premi√®re, plus petite, tient dans ces 512 octets, tandis que la seconde phase est charg√©e subs√©quemment.</p>
<p>Le bootloader doit d√©terminer l‚Äôemplacement de l‚Äôimage de noyau sur le disque et la charger en m√©moire. Il doit aussi passer le processeur de 16-bit (<a href="https://fr.wikipedia.org/wiki/Mode_r%C3%A9el">real mode</a>) √† 32-bit (<a href="https://fr.wikipedia.org/wiki/Mode_prot%C3%A9g%C3%A9">protected mode</a>), puis √† 64-bit (<a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a>), dans lequel les registres 64-bit et la totalit√© de la m√©moire principale sont disponibles. Sa troisi√®me responsabilit√© est de r√©cup√©rer certaines informations (telle que les associations m√©moires) du BIOS et de les transf√©rer au noyau du syst√®me d‚Äôexploitation. </p>
<p>Impl√©menter un bootloader est fastidieux car cela requiert l‚Äô√©criture en language assembleur ainsi que plusieurs autres √©tapes particuli√®res comme ‚Äú√©crire une valeur magique dans un registre du processeur‚Äú. Par cons√©quent, nous ne couvrons pas la cr√©ation d‚Äôun bootloader dans cet article et fournissons plut√¥t un outil appel√© <a href="https://github.com/rust-osdev/bootimage">bootimage</a> qui ajoute automatiquement un bootloader au noyau.</p>
<p>Si vous √™tes int√©ress√© par la cr√©ation de votre propre booloader : restez dans le coin, plusieurs articles sur ce sujet sont d√©j√† pr√©vus √† ce sujet! <!-- , jetez un coup d'oeil √† nos articles ‚Äú_[Writing a Bootloader]_‚Äù, o√π nous expliquons en d√©tails comment √©crire un bootloader. --></p>
<h4 id="le-standard-multiboot"><a class="zola-anchor" href="index.html#le-standard-multiboot" aria-label="Anchor link for: le-standard-multiboot">üîó</a>Le standard Multiboot</h4>
<p>Pour √©viter que chaque syst√®me d‚Äôexploitation impl√©mente son propre bootloader, qui est seulement compatible avec un seul syst√®me d‚Äôexploitation, la <a href="https://fr.wikipedia.org/wiki/Free_Software_Foundation">Free Software Foundation</a> a cr√©√© en 1995 un bootloader standard public appel√© <a href="https://wiki.osdev.org/Multiboot">Multiboot</a>. Le standard d√©finit une interface entre le bootloader et le syst√®me d‚Äôexploitation afin que n‚Äôimporte quel bootloader compatible Multiboot puisse charger n‚Äôimporte quel syst√®me d‚Äôexploitation compatible Multiboot. L‚Äôimpl√©mentation de r√©f√©rence est <a href="https://fr.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>, qui est le bootloader le plus populaire pour les syst√®mes Linux. </p>
<p>Pour cr√©er un noyau compatible Multiboot, il suffit d‚Äôins√©rer une <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#OS-image-format">en-t√™te Multiboot</a> au d√©but du fichier du noyau. Cela rend tr√®s simple l‚Äôamor√ßage d‚Äôun syst√®me d‚Äôexploitation depuis GRUB. Cependant, GRUB et le standard Multiboot pr√©sentent aussi quelques probl√®mes : </p>
<ul>
<li>Ils supportent seulement le ‚Äúprotected mode‚Äù 32-bit. Cela signifie que vous devez encore effectuer la configuration du processeur pour passer au ‚Äúlong mode‚Äù 64-bit.</li>
<li>Ils sont con√ßus pour simplifier le bootloader plut√¥t que le noyau. Par exemple, le noyau doit √™tre li√© avec une <a href="https://wiki.osdev.org/Multiboot#Multiboot_2">taille de page pr√©d√©finie</a>, √©tant donn√© que GRUB ne peut pas trouver les ent√™tes Multiboot autrement. Un autre exemple est que l‚Äô<a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format">information de boot</a>, qui est fournies au noyau, contient plusieurs structures sp√©cifiques √† l‚Äôarchitecture au lieu de fournir des abstractions pures. </li>
<li>GRUB et le standard Multiboot sont peu document√©s.</li>
<li>GRUB doit √™tre install√© sur un syst√®me h√¥te pour cr√©er une image de disque amor√ßable depuis le fichier du noyau. Cela rend le d√©veloppement sur Windows ou sur Mac plus difficile.</li>
</ul>
<p>En raison de ces d√©savantages, nous avons d√©cid√© de ne pas utiliser GRUB ou le standard Multiboot. Cependant, nous avons l‚Äôintention d‚Äôajouter le support Multiboot √† notre outil <a href="https://github.com/rust-osdev/bootimage">bootimage</a>, afin qu‚Äôil soit aussi possible de charger le noyau sur un syst√®me GRUB. Si vous √™tes interess√© par l‚Äô√©criture d‚Äôun noyau Multiboot conforme, consultez la <a href="../../edition-1">premi√®re √©dition</a> de cette s√©rie d‚Äôarticles. </p>
<h3 id="uefi"><a class="zola-anchor" href="index.html#uefi" aria-label="Anchor link for: uefi">üîó</a>UEFI</h3>
<p>(Nous ne fournissons pas le support UEFI √† l‚Äôheure actuelle, mais nous aimerions bien! Si vous voulez aider, dites-le nous dans cette <a href="https://github.com/phil-opp/blog_os/issues/349"><em>issue</em> GitHub</a>.)</p>
<h2 id="un-noyau-minimal"><a class="zola-anchor" href="index.html#un-noyau-minimal" aria-label="Anchor link for: un-noyau-minimal">üîó</a>Un noyau minimal</h2>
<p>Maintenant que nous savons √† peu pr√®s comment un ordinateur d√©marre, il est temps de cr√©er notre propre noyau minimal. Notre objectif est de cr√©er une image de disque qui affiche ‚ÄúHello World!‚Äù √† l‚Äô√©cran lorsqu‚Äôil d√©marre. Nous ferons ceci en am√©liorant le <a href="../freestanding-rust-binary/index.html">binaire Rust autonome</a> du dernier article.</p>
<p>Comme vous vous en rappelez peut-√™tre, nous avons cr√©√© un binaire autonome gr√¢ce √† <code>cargo</code>, mais selon le syst√®me d‚Äôexploitation, nous avions besoin de diff√©rents points d‚Äôentr√©e et d‚Äôoptions de compilation. C‚Äôest d√ª au fait que <code>cargo</code> construit pour <em>syst√®me h√¥te</em> par d√©faut, c‚Äôest-√†-dire le syst√®me que vous utilisez. Ce n‚Äôest pas ce que nous voulons pour notre noyau, car un noyau qui s‚Äôex√©cute, par exemple, sur Windows n‚Äôa pas de sens. Nous voulons plut√¥t compiler pour un <em>syst√®me cible</em> bien d√©fini.</p>
<h3 id="installer-une-version-nocturne-de-rust"><a class="zola-anchor" href="index.html#installer-une-version-nocturne-de-rust" aria-label="Anchor link for: installer-une-version-nocturne-de-rust">üîó</a>Installer une version nocturne de Rust</h3>
<p>Rust a trois canaux de distribution : <em>stable</em>, <em>beta</em>, et <em>nightly</em>. Le Livre de Rust explique bien les diff√©rences entre ces canaux, alors prenez une minute et <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains">jetez y un coup d‚Äôoeil</a>. Pour construire un syst√®me d‚Äôexploitation, nous aurons besoin de fonctionalit√©s exp√©rimentales qui sont disponibles uniquement sur le canal de distribution nocturne. Donc nous devons installer une version nocturne de Rust.</p>
<p>Pour g√©rer l‚Äôinstallation de Rust, je recommande fortement <a href="https://www.rustup.rs/">rustup</a>. Il vous permet d‚Äôinstaller les versions nocturne, beta et stable du compilateur c√¥te-√†-c√¥te et facilite leurs mises √† jour. Avec rustup, vous pouvez utiliser un canal de distribution nocturne pour le dossier actuel en ex√©cutant <code>rustup override set nightly</code>. Par ailleurs, vous pouvez ajouter un fichier appel√© <code>rust-toolchain</code> avec le contenu <code>nightly</code> au dossier racine du projet. Vous pouvez v√©rifier que vous avez une version nocturne install√©e en ex√©cutant <code>rustc --version</code>: Le num√©ro de la version devrait comprendre <code>-nightly</code> √† la fin.</p>
<p>La version nocturne du compilateur nous permet d‚Äôactiver certaines fonctionnalit√©s exp√©rimentales en utilisant certains <em>drapeaux de fonctionalit√©</em> dans le haut de notre fichier. Par exemple, nous pourrions activer <a href="https://doc.rust-lang.org/stable/reference/inline-assembly.html">macro exp√©rimentale <code>asm!</code></a> pour √©crire du code assembleur int√©gr√© en ajoutant <code>#![feature(asm)]</code> au haut de notre <code>main.rs</code>. Notez que ces fonctionnalit√©s exp√©rimentales sont tout √† fait instables, ce qui veut dire que des versions futures de Rust pourraient les changer ou les retirer sans pr√©avis. Pour cette raison, nous les utiliserons seulement lorsque strictement n√©cessaire.</p>
<h3 id="specification-de-la-cible"><a class="zola-anchor" href="index.html#specification-de-la-cible" aria-label="Anchor link for: specification-de-la-cible">üîó</a>Sp√©cification de la cible</h3>
<p>Cargo supporte diff√©rent syst√®mes cibles avec le param√®tre <code>--target</code>. La cible est d√©finie par un soi-disant <em><a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">triplet de cible</a></em>, qui d√©crit l‚Äôarchitecteur du processeur, le fabricant, le syst√®me d‚Äôexploitation, et l‚Äôinterface binaire d‚Äôapplication (<a href="https://stackoverflow.com/a/2456882">ABI</a>). Par exemple, le triplet <code>x86_64-unknown-linux-gnu</code> d√©crit un syst√®me avec un processeur <code>x86_64</code>, sans fabricant d√©fini, et un syst√®me d‚Äôexploitation Linux avec l‚Äôinterface binaire d‚Äôapplication GNU. Rust supporte <a href="https://forge.rust-lang.org/release/platform-support.html">plusieurs diff√©rents triplets de cible</a>, incluant <code>arm-linux-androideabi</code> pour Android ou <a href="https://www.hellorust.com/setup/wasm-target/"><code>wasm32-unknown-unknown</code> pour WebAssembly</a>.</p>
<p>Pour notre syst√®me cible toutefois, nous avons besoin de param√®tres de configuration sp√©ciaux (par exemple, pas de syst√®me d‚Äôexplotation sous-jacent), donc aucun des <a href="https://forge.rust-lang.org/release/platform-support.html">triplets de cible existants</a> ne convient. Heureusement, Rust nous permet de d√©finir <a href="https://doc.rust-lang.org/nightly/rustc/targets/custom.html">notre propre cible</a> par l‚Äôentremise d‚Äôun fichier JSON. Par exemple, un fichier JSON qui d√©crit une cible <code>x86_64-unknown-linux-gnu</code> ressemble √† ceci:</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>    </span><span style="color:#d69d85;">&quot;llvm-target&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64-unknown-linux-gnu&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;data-layout&quot;</span><span>: </span><span style="color:#d69d85;">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;arch&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-endian&quot;</span><span>: </span><span style="color:#d69d85;">&quot;little&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-pointer-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-c-int-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;32&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;os&quot;</span><span>: </span><span style="color:#d69d85;">&quot;linux&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;executables&quot;</span><span>: </span><span style="color:#569cd6;">true</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;linker-flavor&quot;</span><span>: </span><span style="color:#d69d85;">&quot;gcc&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;pre-link-args&quot;</span><span>: [</span><span style="color:#d69d85;">&quot;-m64&quot;</span><span>],
</span><span>    </span><span style="color:#d69d85;">&quot;morestack&quot;</span><span>: </span><span style="color:#569cd6;">false
</span><span>}
</span></code></pre>
<p>La plupart des champs sont requis par LLVM pour g√©n√©rer le code pour cette plateforme. Par exemple, le champ <a href="https://llvm.org/docs/LangRef.html#data-layout"><code>data-layout</code></a> d√©finit la taille de divers types d‚Äôentiers, de nombres √† virgule flottante, et de pointeurs. Puis, il y a des champs que Rust utilise pour de la compilation conditionelle, comme <code>target-pointer-width</code>. Le troisi√®me type de champ d√©finit comment la crate doit √™tre construite. Par exemple, le champ <code>pre-link-args</code> sp√©cifie les arguments fournis au <a href="https://en.wikipedia.org/wiki/Linker_(computing)">lieur</a>.</p>
<p>Nous pouvons aussi cibler les syst√®mes <code>x86_64</code> avec notre noyau, donc notre sp√©cification de cible ressemblera beaucoup √† celle plus haut. Commen√ßons par cr√©er un fichier <code>x86_64-blog_os.json</code> (utilisez le nom de votre choix) avec ce contenu commun:</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>    </span><span style="color:#d69d85;">&quot;llvm-target&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64-unknown-none&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;data-layout&quot;</span><span>: </span><span style="color:#d69d85;">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;arch&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-endian&quot;</span><span>: </span><span style="color:#d69d85;">&quot;little&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-pointer-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-c-int-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;32&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;os&quot;</span><span>: </span><span style="color:#d69d85;">&quot;none&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;executables&quot;</span><span>: </span><span style="color:#569cd6;">true
</span><span>}
</span></code></pre>
<p>Notez que nous avons chang√© le syst√®me d‚Äôexploitation dans le champs <code>llvm-target</code> et <code>os</code> en <code>none</code>, puisque nous ferons l‚Äôex√©cution sur du ‚Äúbare metal‚Äù (donc, sans syst√®me d‚Äôexploitation sous-jacent).</p>
<p>Nous ajoutons ensuite les champs suivants reli√©s √† la construction:</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#d69d85;">&quot;linker-flavor&quot;</span><span>: </span><span style="color:#d69d85;">&quot;ld.lld&quot;</span><span>,
</span><span style="color:#d69d85;">&quot;linker&quot;</span><span>: </span><span style="color:#d69d85;">&quot;rust-lld&quot;</span><span>,
</span></code></pre>
<p>Plut√¥t que d‚Äôutiliser le lieur par d√©faut de la plateforme (qui pourrait ne pas supporter les cibles Linux), nous utilisons le lieur multi-plateforme <a href="https://lld.llvm.org/">LLD</a> qui est inclut avec Rust pour lier notre noyau.</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#d69d85;">&quot;panic-strategy&quot;</span><span>: </span><span style="color:#d69d85;">&quot;abort&quot;</span><span>,
</span></code></pre>
<p>Ce param√®tre sp√©cifie que la cible ne permet pas le <a href="https://www.bogotobogo.com/cplusplus/stackunwinding.php">d√©roulement de la pile</a> lorsque le noyau panique, alors le syst√®me devrait plut√¥t s‚Äôarr√™ter directement. Ceci m√®ne au m√™me r√©sultat que l‚Äôoption <code>panic = &quot;abort&quot;</code> dans notre Cargo.toml, alors nous pouvons la retirer de ce fichier. (Notez que, contrairement √† l‚Äôoption Cargo.toml, cette option de cible s‚Äôapplique aussi quand nous recompilerons la biblioth√®que <code>core</code> plus loin dans cet article. Ainsi, m√™me si vous pr√©f√©rez garder l‚Äôoption Cargo.toml, gardez cette option.)</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#d69d85;">&quot;disable-redzone&quot;</span><span>: </span><span style="color:#569cd6;">true</span><span>,
</span></code></pre>
<p>Nous √©crivons un noyau, donc nous devrons √©ventuellement g√©rer les interruptions. Pour ce faire en toute s√©curit√©, nous devons d√©sactiver une optimisation de pointeur de pile nomm√©e la <em>‚Äúzone rouge‚Äú</em>, puisqu‚Äôelle causerait une corruption de la pile autrement. Pour plus d‚Äôinformations, lire notre article s√©par√© √† propos de la <a href="../../red-zone/index.html">d√©sactivation de la zone rouge</a>.</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#d69d85;">&quot;features&quot;</span><span>: </span><span style="color:#d69d85;">&quot;-mmx,-sse,+soft-float&quot;</span><span>,
</span></code></pre>
<p>Le champ <code>features</code> active/d√©sactive des fonctionalit√©s de la cible. Nous d√©sactivons les fonctionalit√©s <code>mmx</code> et <code>sse</code> en les pr√©c√©dant d‚Äôun signe ‚Äúmoins‚Äù et activons la fonctionnalit√© <code>soft-float</code> en la pr√©c√©dant d‚Äôun signe ‚Äúplus‚Äù. Notez qu‚Äôil ne doit pas y avoir d‚Äôespace entre les diff√©rentes fonctionnalit√©s, sinon LLVM n‚Äôarrive pas √† analyser la cha√Æne de caract√®res des fonctionnalit√©s.</p>
<p>Les fonctionnalit√©s <code>mmx</code> et <code>sse</code> d√©terminent le support les instructions <a href="https://fr.wikipedia.org/wiki/Single_instruction_multiple_data">Single Instruction Multiple Data (SIMD)</a>, qui peuvent souvent significativement acc√©l√©rer les programmes. Toutefois, utiliser les grands registres SIMD dans les noyaux des syst√®mes d‚Äôexploitation m√®ne √† des probl√®mes de performance. Ceci parce que le noyau a besoin de restaurer tous les registres √† leur √©tat original avant de continuer un programme interrompu. Cela signifie que le noyau doit enregistrer l‚Äô√©tat SIMD complet dans la m√©moire principale √† chaque appel syst√®me ou interruption mat√©rielle. Puisque l‚Äô√©tat SIMD est tr√®s grand (512‚Äì1600 octets) et que les interruptions peuvent survenir tr√®s fr√©quemment, ces op√©rations d‚Äôenregistrement/restauration additionnelles nuisent consid√©rablement √† la performance. Pour pr√©venir cela, nous d√©sactivons SIMD pour notre noyau (pas pour les applications qui s‚Äôex√©cutent dessus!).</p>
<p>Un probl√®me avec la d√©sactivation de SIMD est que les op√©rations sur les nombres √† virgule flottante sur <code>x86_64</code> n√©cessitent les registres SIMD par d√©faut. Pour r√©soudre ce probl√®me, nous ajoutons la fonctionnalit√© <code>soft-float</code>, qui √©mule toutes les op√©rations √† virgule flottante avec des fonctions logicielles utilisant des entiers normaux.</p>
<p>Pour plus d‚Äôinformations, voir notre article sur la <a href="../../disable-simd/index.html">d√©sactivation de SIMD</a>.</p>
<h4 id="assembler-le-tout"><a class="zola-anchor" href="index.html#assembler-le-tout" aria-label="Anchor link for: assembler-le-tout">üîó</a>Assembler le tout</h4>
<p>Notre fichier de sp√©cification de cible ressemble maintenant √† ceci :</p>
<pre data-lang="json" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>    </span><span style="color:#d69d85;">&quot;llvm-target&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64-unknown-none&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;data-layout&quot;</span><span>: </span><span style="color:#d69d85;">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;arch&quot;</span><span>: </span><span style="color:#d69d85;">&quot;x86_64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-endian&quot;</span><span>: </span><span style="color:#d69d85;">&quot;little&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-pointer-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;64&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;target-c-int-width&quot;</span><span>: </span><span style="color:#d69d85;">&quot;32&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;os&quot;</span><span>: </span><span style="color:#d69d85;">&quot;none&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;executables&quot;</span><span>: </span><span style="color:#569cd6;">true</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;linker-flavor&quot;</span><span>: </span><span style="color:#d69d85;">&quot;ld.lld&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;linker&quot;</span><span>: </span><span style="color:#d69d85;">&quot;rust-lld&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;panic-strategy&quot;</span><span>: </span><span style="color:#d69d85;">&quot;abort&quot;</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;disable-redzone&quot;</span><span>: </span><span style="color:#569cd6;">true</span><span>,
</span><span>    </span><span style="color:#d69d85;">&quot;features&quot;</span><span>: </span><span style="color:#d69d85;">&quot;-mmx,-sse,+soft-float&quot;
</span><span>}
</span></code></pre>
<h3 id="construction-de-notre-noyau"><a class="zola-anchor" href="index.html#construction-de-notre-noyau" aria-label="Anchor link for: construction-de-notre-noyau">üîó</a>Construction de notre noyau</h3>
<p>Compiler pour notre nouvelle cible utilisera les conventions Linux (je ne suis pas trop certain pourquoi; j‚Äôassume que c‚Äôest simplement le comportement par d√©faut de LLVM). Cela signifie que nos avons besoin d‚Äôun point d‚Äôentr√©e nomm√© <code>_start</code> comme d√©crit dans <a href="../freestanding-rust-binary/index.html">l‚Äôarticle pr√©c√©dent</a>:</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// src/main.rs
</span><span>
</span><span>#![no_std] </span><span style="color:#608b4e;">// ne pas lier la biblioth√®que standard Rust
</span><span>#![no_main] </span><span style="color:#608b4e;">// d√©sactiver tous les points d&#39;entr√©e Rust
</span><span>
</span><span style="color:#569cd6;">use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style="color:#608b4e;">/// Cette fonction est invoqu√©e lorsque le syst√®me panique
</span><span>#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span>panic(_info: </span><span style="color:#569cd6;">&amp;</span><span>PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[no_mangle] </span><span style="color:#608b4e;">// ne pas massacrer le nom de cette fonction
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#608b4e;">// cette fonction est le point d&#39;entr√©e, puisque le lieur cherche une fonction
</span><span>    </span><span style="color:#608b4e;">// nomm√©e `_start` par d√©faut
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>Notez que le point d‚Äôentr√©e doit √™tre appel√© <code>_start</code> ind√©pendamment du syst√®me d‚Äôexploitation h√¥te.</p>
<p>Nous pouvons maintenant construire le noyau pour notre nouvelle cible en fournissant le nom du fichier JSON comme <code>--target</code>:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build --target x86_64-blog_os.json
</span><span>
</span><span>error[E0463]: can&#39;t find crate for `core`
</span></code></pre>
<p>Cela √©choue! L‚Äôerreur nous dit que le compilateur ne trouve plus la <a href="https://doc.rust-lang.org/nightly/core/index.html">biblioth√®que <code>core</code></a>. Cette biblioth√®que contient les types de base Rust comme <code>Result</code>, <code>Option</code>, les it√©rateurs, et est implicitement li√©e √† toutes les crates <code>no_std</code>.</p>
<p>Le probl√®me est que la biblioth√®que <code>core</code> est distribu√©e avec le compilateur Rust comme bilioth√®que <em>precompil√©e</em>. Donc, elle est seulement valide pour les triplets d‚Äôh√¥tes support√©s (par exemple, <code>x86_64-unknown-linux-gnu</code>) mais pas pour notre cible personnalis√©e. Si nous voulons compiler du code pour d‚Äôautres cibles, nous devons d‚Äôabord recompiler <code>core</code> pour ces cibles.</p>
<h4 id="l-option-build-std"><a class="zola-anchor" href="index.html#l-option-build-std" aria-label="Anchor link for: l-option-build-std">üîó</a>L‚Äôoption <code>build-std</code></h4>
<p>C‚Äôest ici que la <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std">fonctionnalit√© <code>build-std</code></a> de cargo entre en jeu. Elle permet de recompiler <code>core</code> et d‚Äôautres crates de la biblioth√®que standard sur demande, plut√¥t que d‚Äôutiliser des versions pr√©compil√©es incluses avec l‚Äôinstallation de Rust. Cette fonctionnalit√© est tr√®s r√©cente et n‚Äôest pas encore compl√®te, donc elle est d√©finie comme instable et est seulement disponible avec les <a href="index.html#installer-une-version-nocturne-de-rust">versions nocturnes du compilateur Rust</a>.</p>
<p>Pour utiliser cette fonctionnalit√©, nous devons cr√©er un fichier de <a href="https://doc.rust-lang.org/cargo/reference/config.html">configuration cargo</a> dans <code>.cargo/config.toml</code> avec le contenu suivant:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">unstable</span><span>]
</span><span style="color:#569cd6;">build-std </span><span>= [</span><span style="color:#d69d85;">&quot;core&quot;</span><span>, </span><span style="color:#d69d85;">&quot;compiler_builtins&quot;</span><span>]
</span></code></pre>
<p>Ceci indique √† cargo qu‚Äôil doit recompiler les biblioth√®ques <code>core</code> et <code>compiler_builtins</code>. Celle-ci est n√©cessaire pour qu‚Äôelle ait une d√©pendance de <code>core</code>. Afin de recompiler ces biblioth√®ques, cargo doit avoir acc√®s au code source de Rust, que nous pouvons installer avec <code>rustup component add rust-src</code>.</p>
<div class="note">
<p><strong>Note:</strong> La cl√© de configuration <code>unstable.build-std</code> n√©cessite une version nocturne de Rust plus r√©cente que 2020-07-15.</p>
</div>
<p>Apr√®s avoir d√©fini la cl√© de configuration <code>unstable.build-std</code> et install√© la composante <code>rust-src</code>, nous pouvons ex√©cuter notre commande de construction √† nouveau:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo build --target x86_64-blog_os.json
</span><span>   Compiling core v0.0.0 (/‚Ä¶/rust/src/libcore)
</span><span>   Compiling rustc-std-workspace-core v1.99.0 (/‚Ä¶/rust/src/tools/rustc-std-workspace-core)
</span><span>   Compiling compiler_builtins v0.1.32
</span><span>   Compiling blog_os v0.1.0 (/‚Ä¶/blog_os)
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
</span></code></pre>
<p>Nous voyons que <code>cargo build</code> recompile maintenant les biblioth√®ques <code>core</code>, <code>rustc-std-workspace-core</code> (une d√©pendance de <code>compiler_builtins</code>), et <code>compiler_builtins</code> pour notre cible personnalis√©e.</p>
<h4 id="details-relies-a-la-memoire"><a class="zola-anchor" href="index.html#details-relies-a-la-memoire" aria-label="Anchor link for: details-relies-a-la-memoire">üîó</a>D√©tails reli√©s √† la m√©moire</h4>
<p>Le compilateur Rust assume qu‚Äôun certain ensemble de fonctions int√©gr√©es sont disponibles pour tous les syst√®mes. La plupart de ces fonctions sont fournies par la crate <code>compiler_builtins</code> que nous venons de recompiler. Toutefois, certaines fonctions li√©es √† la m√©moire dans cette crate ne sont pas activ√©es par d√©faut puisqu‚Äôelles sont normalement fournies par la biblioth√®que C sur le syst√®me. Parmi ces fonctions, on retrouve <code>memset</code>, qui d√©finit tous les octets dans un bloc m√©moire √† une certaine valeur, <code>memcpy</code>, qui copie un bloc m√©moire vers un autre, et <code>memcmp</code>, qui compare deux blocs m√©moire. Alors que nous n‚Äôavions pas besoin de ces fonctions pour compiler notre noyau maintenant, elles seront n√©cessaires aussit√¥t que nous lui ajouterons plus de code (par exemple, lorsque nous copierons des <code>struct</code>).</p>
<p>Puisque nous ne pouvons pas lier avec la biblioth√®que C du syst√®me d‚Äôexploitation, nous avons besoin d‚Äôune m√©thode alternative de fournir ces fonctions au compilateur. Une approche possible pour ce faire serait d‚Äôimpl√©menter nos propre fonctions <code>memset</code>, etc. et de leur appliquer l‚Äôattribut <code>#[no_mangle]</code> (pour pr√©venir le changement de nom automatique pendant la compilation). Or, ceci est dangereux puisque toute erreur dans l‚Äôimpl√©mentation pourrait mener √† un comportement ind√©termin√©. Par exemple, impl√©menter <code>memcpy</code> avec une boucle <code>for</code> pourrait mener √† une recursion infinie puisque les boucles <code>for</code> invoquent implicitement la m√©thode <em>trait</em> <a href="https://doc.rust-lang.org/stable/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>IntoIterator::into_iter</code></a>, qui pourrait invoquer <code>memcpy</code> de nouveau. C‚Äôest donc une bonne id√©e de plut√¥t r√©utiliser des impl√©mentations existantes et √©prouv√©es.</p>
<p>Heureusement, la crate <code>compiler_builtins</code> contient d√©j√† des impl√©mentations pour toutes les fonctions n√©cessaires, elles sont seulement d√©sactiv√©es par d√©faut pour ne pas interf√©rer avec les impl√©mentations de la biblioth√®que C. Nous pouvons les activer en d√©finissant le drapeau <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std-features"><code>build-std-features</code></a> de cargo √† <code>[&quot;compiler-builtins-mem&quot;]</code>. Comme pour le drapeau <code>build-std</code>, ce drapeau peut √™tre soit fourni en ligne de commande avec <code>-Z</code> ou configur√© dans la table <code>unstable</code> du fichier <code>.cargo/config.toml</code>. Puisque nous voulons toujours construire avec ce drapeau, l‚Äôoption du fichier de configuration fait plus de sens pour nous:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">unstable</span><span>]
</span><span style="color:#569cd6;">build-std-features </span><span>= [</span><span style="color:#d69d85;">&quot;compiler-builtins-mem&quot;</span><span>]
</span><span style="color:#569cd6;">build-std </span><span>= [</span><span style="color:#d69d85;">&quot;core&quot;</span><span>, </span><span style="color:#d69d85;">&quot;compiler_builtins&quot;</span><span>]
</span></code></pre>
<p>(Le support pour la fonctionnalit√© <code>compiler-builtins-mem</code> a <a href="https://github.com/rust-lang/rust/pull/77284">√©t√© ajout√© assez r√©cemment</a>, donc vous aurez besoin de la version nocturne <code>2020-09-30</code> de Rust ou plus r√©cent pour l‚Äôutiliser.)</p>
<p>Dans les coulisses, ce drapeau active la <a href="https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/Cargo.toml#L54-L55">fonctionnalit√© <code>mem</code></a> de la crate <code>compiler_builtins</code>. Le r√©sultat est que l‚Äôattribut <code>#[no_mangle]</code> est appliqu√© aux <a href="https://github.com/rust-lang/compiler-builtins/blob/eff506cd49b637f1ab5931625a33cef7e91fbbf6/src/mem.rs#L12-L69">impl√©mentations <code>memcpy</code> et autres</a> de la caise, ce qui les rend disponible au lieur.</p>
<p>Avec ce changement, notre noyau a des impl√©mentations valides pour toutes les fonctions requises par le compilateur, donc il peut continuer √† compiler m√™me si notre code devient plus complexe.</p>
<h4 id="definir-une-cible-par-defaut"><a class="zola-anchor" href="index.html#definir-une-cible-par-defaut" aria-label="Anchor link for: definir-une-cible-par-defaut">üîó</a>D√©finir une cible par d√©faut</h4>
<p>Pour ne pas avoir √† fournir le param√®tre <code>--target</code> √† chaque invocation de <code>cargo build</code>, nous pouvons d√©finir la cible par d√©faut. Pour ce faire, nous ajoutons le code suivant √† notre fichier de <a href="https://doc.rust-lang.org/cargo/reference/config.html">configuration Cargo</a> dans <code>.cargo/config.toml</code>:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">build</span><span>]
</span><span style="color:#569cd6;">target </span><span>= </span><span style="color:#d69d85;">&quot;x86_64-blog_os.json&quot;
</span></code></pre>
<p>Ceci indique √† <code>cargo</code> d‚Äôutiliser notre cible <code>x86_64-blog_os.json</code> quand il n‚Äôy a pas d‚Äôargument de cible <code>--target</code> explicitement fourni. Ceci veut dire que nous pouvons maintenant construire notre noyau avec un simple <code>cargo build</code>. Pour plus d‚Äôinformations sur les options de configuration cargo, jetez un coup d‚Äôoeil √† la <a href="https://doc.rust-lang.org/cargo/reference/config.html">documentation officielle de cargo</a>.</p>
<p>Nous pouvons maintenant construire notre noyau pour une cible ‚Äúbare metal‚Äù avec un simple <code>cargo build</code>. Toutefois, notre point d‚Äôentr√©e <code>_start</code>, qui sera appel√© par le bootloader, est encore vide. Il est temps de lui faire afficher quelque chose √† l‚Äô√©cran.</p>
<h3 id="afficher-a-l-ecran"><a class="zola-anchor" href="index.html#afficher-a-l-ecran" aria-label="Anchor link for: afficher-a-l-ecran">üîó</a>Afficher √† l‚Äô√©cran</h3>
<p>La fa√ßon la plus facile d‚Äôafficher √† l‚Äô√©cran √† ce stade est gr√¢ce au tampon texte VGA. C‚Äôest un emplacement m√©moire sp√©cial associ√© au mat√©riel VGA qui contient le contenu affich√© √† l‚Äô√©cran. Il consiste normalement en 25 lines qui contiennent chacune 80 cellules de caract√®re. Chaque cellule de caract√®re affiche un caract√®re ASCII avec des couleurs d‚Äôavant-plan et d‚Äôarri√®re-plan. Le r√©sultat √† l‚Äô√©cran ressemble √† ceci:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Codepage-437.png" alt="sortie √† l‚Äô√©cran pour des caract√®res ASCII ordinaires" /></p>
<p>Nous discuterons de la disposition exacte du tampon VGA dans le prochain article, o√π nous lui √©crirons un premier petit pilote. Pour afficher ‚ÄúHello World!‚Äù, nous devons seulement savoir que le tampon est situ√© √† l‚Äôadresse <code>0xb8000</code> et que chaque cellule de caract√®re consiste en un octet ASCII et un octet de couleur.</p>
<p>L‚Äôimpl√©mentation ressemble √† ceci :</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">static </span><span style="color:#b4cea8;">HELLO</span><span>: </span><span style="color:#569cd6;">&amp;</span><span>[</span><span style="color:#569cd6;">u8</span><span>] = </span><span style="color:#569cd6;">b</span><span style="color:#d69d85;">&quot;Hello World!&quot;</span><span>;
</span><span>
</span><span>#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span>_start() -&gt; </span><span style="color:#569cd6;">! </span><span>{
</span><span>    </span><span style="color:#569cd6;">let</span><span> vga_buffer = </span><span style="color:#b5cea8;">0xb8000 </span><span style="color:#569cd6;">as *mut u8</span><span>;
</span><span>
</span><span>    </span><span style="color:#569cd6;">for </span><span>(i, </span><span style="color:#569cd6;">&amp;</span><span>byte) </span><span style="color:#569cd6;">in </span><span style="color:#b4cea8;">HELLO</span><span>.iter().enumerate() {
</span><span>        </span><span style="color:#569cd6;">unsafe </span><span>{
</span><span>            *vga_buffer.offset(i </span><span style="color:#569cd6;">as isize </span><span>* </span><span style="color:#b5cea8;">2</span><span>) = byte;
</span><span>            *vga_buffer.offset(i </span><span style="color:#569cd6;">as isize </span><span>* </span><span style="color:#b5cea8;">2 </span><span>+ </span><span style="color:#b5cea8;">1</span><span>) = </span><span style="color:#b5cea8;">0xb</span><span>;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">loop </span><span>{}
</span><span>}
</span></code></pre>
<p>D‚Äôabord, nous transformons l‚Äôentier <code>0xb8000</code> en un <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">pointeur brut</a>. Puis nous <a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">parcourons</a> les octets de la <a href="https://doc.rust-lang.org/reference/tokens.html#byte-string-literals">cha√Æne d‚Äôoctets</a> <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime">statique</a> <code>HELLO</code>. Nous utilisons la m√©thode <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a> pour aussi obtenir une variable <code>i</code>. Dans le corps de la boucle <code>for</code>, nous utilisons la m√©thode <a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a> pour √©crire la cha√Æne d‚Äôoctets et l‚Äôoctet de couleur correspondant(<code>0xb</code> est un cyan p√¢le).</p>
<p>Notez qu‚Äôil y a un bloc <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html"><code>unsafe</code></a> qui enveloppe les √©critures m√©moire. La raison en est que le compilateur Rust ne peut pas prouver que les pointeurs bruts que nous cr√©ons sont valides. Ils pourraient pointer n‚Äôimporte o√π et mener √† une corruption de donn√©es. En les mettant dans un bloc <code>unsafe</code>, nous disons fondamentalement au compilateur que nous sommes absolument certains que les op√©rations sont valides. Notez qu‚Äôun bloc <code>unsafe</code> ne d√©sactive pas les contr√¥les de s√©curit√© de Rust. Il permet seulement de faire <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html#unsafe-superpowers">cinq choses suppl√©mentaires</a>.</p>
<p>Je veux souligner que <strong>ce n‚Äôest pas comme cela que les choses se font en Rust!</strong> Il est tr√®s facile de faire des erreurs en travaillant avec des pointeurs bruts √† l‚Äôint√©rieur de blocs <code>unsafe</code>. Par exemple, nous pourrions facilement √©crire au-del√† de la fin du tampon si nous ne sommes pas prudents.</p>
<p>Alors nous voulons minimiser l‚Äôutilisation de <code>unsafe</code> autant que possible. Rust nous offre la possibilit√© de le faire en cr√©ant des abstractions de s√©curit√©. Par exemple, nous pourrions cr√©er un type tampon VGA qui encapsule les risques et qui s‚Äôassure qu‚Äôil est impossible de faire quoi que ce soit d‚Äôincorrect √† l‚Äôext√©rieur de ce type. Ainsi, nous aurions besoin de tr√®s peu de code <code>unsafe</code> et nous serions certains que nous ne violons pas la <a href="https://en.wikipedia.org/wiki/Memory_safety">s√©curit√© de m√©moire</a>. Nous allons cr√©er une telle abstraction de tampon VGA buffer dans le prochain article.</p>
<h2 id="executer-notre-noyau"><a class="zola-anchor" href="index.html#executer-notre-noyau" aria-label="Anchor link for: executer-notre-noyau">üîó</a>Ex√©cuter notre noyau</h2>
<p>Maintenant que nous avons un ex√©cutable qui fait quelque chose de perceptible, il est temps de l‚Äôex√©cuter. D‚Äôabord, nous devons transformer notre noyau compil√© en une image de disque amor√ßable en le liant √† un bootloader. Ensuite, nous pourrons ex√©cuter l‚Äôimage de disque dans une machine virtuelle <a href="https://www.qemu.org/">QEMU</a> ou l‚Äôamorcer sur du v√©ritable mat√©riel en utilisant une cl√© USB.</p>
<h3 id="creer-une-image-d-amorcage"><a class="zola-anchor" href="index.html#creer-une-image-d-amorcage" aria-label="Anchor link for: creer-une-image-d-amorcage">üîó</a>Cr√©er une image d‚Äôamor√ßage</h3>
<p>Pour transformer notre noyau compil√© en image de disque amor√ßable, nous devons le lier avec un bootloader. Comme nous l‚Äôavons appris dans la <a href="index.html#le-processus-d-amorcage">section √† propos du lancement</a>, le bootloader est responsable de l‚Äôinitialisation du processeur et du chargement de notre noyau.</p>
<p>Plut√¥t que d‚Äô√©crire notre propre bootloader, ce qui est un projet en soi, nous utilisons la crate <a href="https://crates.io/crates/bootloader"><code>bootloader</code></a>. Cette crate propose un bootloader BIOS de base sans d√©pendance C. Seulement du code Rust et de l‚Äôassembleur int√©gr√©. Pour l‚Äôutiliser afin de lancer notre noyau, nous devons ajouter une d√©pendance √† cette crate:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans Cargo.toml
</span><span>
</span><span>[</span><span style="color:#808080;">dependencies</span><span>]
</span><span style="color:#569cd6;">bootloader </span><span>= </span><span style="color:#d69d85;">&quot;0.9.8&quot;
</span></code></pre>
<p>Ajouter le bootloader comme d√©pendance n‚Äôest pas suffisant pour r√©ellement cr√©er une image de disque amor√ßable. Le probl√®me est que nous devons lier notre noyau avec le bootloader apr√®s la compilation, mais cargo ne supporte pas les <a href="https://github.com/rust-lang/cargo/issues/545">scripts post-build</a>.</p>
<p>Pour r√©soudre ce probl√®me, nous avons cr√©√© un outil nomm√© <code>bootimage</code> qui compile d‚Äôabord le noyau et le bootloader, et les lie ensuite ensemble pour cr√©er une image de disque amor√ßable. Pour installer cet outil, ex√©cutez la commande suivante dans votre terminal:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>cargo install bootimage
</span></code></pre>
<p>Pour ex√©cuter <code>bootimage</code> et construire le bootloader, vous devez avoir la composante rustup <code>llvm-tools-preview</code> install√©e. Vous pouvez l‚Äôinstaller en ex√©cutant <code>rustup component add llvm-tools-preview</code>.</p>
<p>Apr√®s avoir install√© <code>bootimage</code> et ajout√© la composante <code>llvm-tools-preview</code>, nous pouvons cr√©er une image de disque amor√ßable en ex√©cutant:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; cargo bootimage
</span></code></pre>
<p>Nous voyons que l‚Äôoutil recompile notre noyau en utilisant <code>cargo build</code>, donc il utilisera automatiquement tout changements que vous faites. Ensuite, il compile le bootloader, ce qui peut prendre un certain temps. Comme toutes les d√©pendances de crates, il est seulement construit une fois puis il est mis en cache, donc les builds subs√©quentes seront beaucoup plus rapides. Enfin, <code>bootimage</code> combine le bootloader et le noyau en une image de disque amor√ßable.</p>
<p>Apr√®s avoir ex√©cut√© la commande, vous devriez voir une image de disque amor√ßable nomm√©e <code>bootimage-blog_os.bin</code> dans votre dossier <code>target/x86_64-blog_os/debug</code>. Vous pouvez la lancer dans une machine virtuelle ou la copier sur une cl√© USB pour la lancer sur du v√©ritable mat√©riel. (Notez que ceci n‚Äôest pas une image CD, qui est un format diff√©rent, donc la graver sur un CD ne fonctionne pas).</p>
<h4 id="comment-cela-fonctionne-t-il"><a class="zola-anchor" href="index.html#comment-cela-fonctionne-t-il" aria-label="Anchor link for: comment-cela-fonctionne-t-il">üîó</a>Comment cela fonctionne-t-il?</h4>
<p>L‚Äôoutil <code>bootimage</code> effectue les √©tapes suivantes en arri√®re-plan:</p>
<ul>
<li>Il compile notre noyau en un fichier <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>.</li>
<li>Il compile notre d√©pendance bootloader en ex√©cutable autonome.</li>
<li>Il lie les octets du fichier ELF noyau au bootloader.</li>
</ul>
<p>Lorsque lanc√©, le bootloader lit et analyse le fichier ELF ajout√©. Il associe ensuite les segments du programme aux adresses virtuelles dans les tables de pages, r√©initialise la section <code>.bss</code>, puis met en place une pile. Finalement, il lit le point d‚Äôentr√©e (notre fonction <code>_start</code>) et s‚Äôy rend.</p>
<h3 id="amorcage-dans-qemu"><a class="zola-anchor" href="index.html#amorcage-dans-qemu" aria-label="Anchor link for: amorcage-dans-qemu">üîó</a>Amor√ßage dans QEMU</h3>
<p>Nous pouvons maintenant lancer l‚Äôimage disque dans une machine virtuelle. Pour la d√©marrer dans <a href="https://www.qemu.org/">QEMU</a>, ex√©cutez la commande suivante :</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os/debug/bootimage-blog_os.bin
</span><span>warning: TCG doesn&#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
</span></code></pre>
<p>Ceci ouvre une fen√™tre s√©par√©e qui devrait ressembler √† cela:</p>
<p><img src="qemu.png" alt="QEMU showing ‚ÄúHello World!‚Äù" /></p>
<p>Nous voyoons que notre ‚ÄúHello World!‚Äù est visible √† l‚Äô√©cran.</p>
<h3 id="veritable-ordinateur"><a class="zola-anchor" href="index.html#veritable-ordinateur" aria-label="Anchor link for: veritable-ordinateur">üîó</a>V√©ritable ordinateur</h3>
<p>Il est aussi possible d‚Äô√©crire l‚Äôimage disque sur une cl√© USB et de le lancer sur un v√©ritable ordinateur, <strong>mais soyez prudent</strong> et choisissez le bon nom de p√©riph√©rique, parce que <strong>tout sur ce p√©riph√©rique sera √©cras√©</strong>:</p>
<pre style="background-color:#1e1e1e;color:#dcdcdc;"><code><span>&gt; dd if=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX &amp;&amp; sync
</span></code></pre>
<p>O√π <code>sdX</code> est le nom du p√©riph√©rique de votre cl√© USB.</p>
<p>Apr√®s l‚Äô√©criture de l‚Äôimage sur votre cl√© USB, vous pouvez l‚Äôex√©cuter sur du v√©ritable mat√©riel en l‚Äôamor√ßant √† partir de la cl√© USB. Vous devrez probablement utiliser un menu d‚Äôamor√ßage sp√©cial ou changer l‚Äôordre d‚Äôamor√ßage dans votre configuration BIOS pour amorcer √† partir de la cl√© USB. Notez que cela ne fonctionne actuellement pas avec des ordinateurs UEFI, puisque la crate <code>bootloader</code> ne supporte pas encore UEFI.</p>
<h3 id="utilisation-de-cargo-run"><a class="zola-anchor" href="index.html#utilisation-de-cargo-run" aria-label="Anchor link for: utilisation-de-cargo-run">üîó</a>Utilisation de <code>cargo run</code></h3>
<p>Pour faciliter l‚Äôex√©cution de notre noyau dans QEMU, nous pouvons d√©finir la cl√© de configuration <code>runner</code> pour cargo:</p>
<pre data-lang="toml" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#608b4e;"># dans .cargo/config.toml
</span><span>
</span><span>[</span><span style="color:#808080;">target.</span><span style="color:#d69d85;">&#39;cfg(target_os = &quot;none&quot;)&#39;</span><span>]
</span><span style="color:#569cd6;">runner </span><span>= </span><span style="color:#d69d85;">&quot;bootimage runner&quot;
</span></code></pre>
<p>La table <code>target.'cfg(target_os = &quot;none&quot;)'</code> s‚Äôapplique √† toutes les cibles dont le champ <code>&quot;os&quot;</code> dans le fichier de configuration est d√©fini √† <code>&quot;none&quot;</code>. Ceci inclut notre cible <code>x86_64-blog_os.json</code>. La cl√© <code>runner</code> key sp√©cifie la commande qui doit √™tre invoqu√©e pour <code>cargo run</code>. La commande est ex√©cut√©e apr√®s une build r√©ussie avec le chemin de l‚Äôex√©cutable comme premier argument. Voir la <a href="https://doc.rust-lang.org/cargo/reference/config.html">configuration cargo</a> pour plus de d√©tails.</p>
<p>La commande <code>bootimage runner</code> est sp√©cifiquement con√ßue pour √™tre utilisable comme un ex√©cutable <code>runner</code>. Elle lie l‚Äôex√©cutable fourni avec le bootloader duquel d√©pend le projet et lance ensuite QEMU. Voir le <a href="https://github.com/rust-osdev/bootimage">README de <code>bootimage</code></a> pour plus de d√©tails et les options de configuration possibles.</p>
<p>Nous pouvons maintenant utiliser <code>cargo run</code> pour compiler notre noyau et le lancer dans QEMU.</p>
<h2 id="et-ensuite"><a class="zola-anchor" href="index.html#et-ensuite" aria-label="Anchor link for: et-ensuite">üîó</a>Et ensuite?</h2>
<p>Dans le prochain article, nous explorerons le tampon texte VGA plus en d√©tails et nous √©crirons une interface s√©curitaire pour l‚Äôutiliser. Nous allons aussi mettre en place la macro <code>println</code>.</p>

    </div>

    <div class="post-footer-support">
        <h2>Support Me</h2>
        
<p>
    Creating and <a href="../../status-update/index.html">maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.
</p>
<p>
    The best way to support me is to <a href="https://github.com/sponsors/phil-opp"><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href="https://www.patreon.com/phil_opp"><em>Patreon</em></a> and <a href="https://donorbox.org/phil-opp"><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.
</p>
<p>
    Thank you!
</p>

    </div>

    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="../freestanding-rust-binary/index.html">&laquo; Un binaire Rust autonome</a>
        
        
    </div>

    <hr>
    <section>
        <h2 id="comments" class="">Commentaires</h2>

        
            
            
            
        
        
    
        
        
    

    
        
        
    

    <p class="comment-note">
        Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href="https://www.rust-lang.org/policies/code-of-conduct">code of conduct</a>. This comment thread directly maps to a <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Minimal%20Rust%20Kernel%20%28fr%29%22"><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.
    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="phil-opp/blog_os"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ=="
        data-category="Post Comments (translated)"
        data-category-id="MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1"
    
        data-mapping="specific"
    
        data-term="A Minimal Rust Kernel (fr)"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="fr"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/phil-opp/blog_os/discussions/categories/post-comments-translated?discussions_q=%22A%20Minimal%20Rust%20Kernel%20%28fr%29%22"><em>on GitHub</em></a>.
    </p>

        <p class="">
            Veuillez commenter en Anglais si possible.
        </p>
        
    </section>

    <aside class="page-aside-right">
        <div class="block" id="language-selector">
            <h2>Other Languages</h2>
            
            <ul><li data-lang-switch-to="en" class=""><a href="../../minimal-rust-kernel/index.html">
                        English (original)
                    </a></li><li data-lang-switch-to="zh-CN" class=""><a href="../../zh-CN/minimal-rust-kernel/index.html">
                        Chinese (simplified)
                    </a></li><li data-lang-switch-to="ja" class=""><a href="../../ja/minimal-rust-kernel/index.html">
                        Japanese
                    </a></li><li data-lang-switch-to="fa" class=""><a href="../../fa/minimal-rust-kernel/index.html">
                        Persian
                    </a></li><li data-lang-switch-to="ru" class=""><a href="../../ru/minimal-rust-kernel/index.html">
                        Russian
                    </a></li><li data-lang-switch-to="ko" class=""><a href="../../ko/minimal-rust-kernel/index.html">
                        Korean
                    </a></li></ul>
        </div>
    </aside>

</main>
        </div>

        <div></div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2022">2022</time>. All rights reserved.
                <a class="spaced" href="https://github.com/phil-opp/blog_os#license">License</a>
                <a class="spaced" href="../../contact/index.html">Contact</a>
            </small>
        </footer>
    </div>
</body>

</html>
